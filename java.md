# 语法

## 理论与使用

### 前置知识

#### 常识

代码文件后缀是 `.java`

基本特点：

- 编写一次代码，在不同环境(机器)运行
- 语法更简洁，可靠，安全
- 既是编译型又是解释型 代码$\to$字节码（`.class`）$\overset{JVM}{\to}$解释运行
- 用接口取代多重继承
- 取消指针
- 垃圾自动收集
- 纯面向对象(万物皆对象)
- 支持分布式；支持多线程

> JVM：Java虚拟机

Sun ONE(Open Net Environment)体系，按应用范围划分的3个Java版本：Java SE, Java EE, Java ME

- Java SE 标准版 主要用于桌面应用程序开发 含语言基础、JDBC(Java 数据库连接性)操作，I/O，网络通信，多线程
- Java EE 企业版 企业级分布式网络程序开发 如电子商务网站、ERP(企业资源规划)系统 核心是EJB(企业Java组件模型)
- Java ME 嵌入式系统开发(手机等)

> 设计模式，把握项目整体结构，使其有调试、维护、升级的价值

> API application programming interface  官网可以找到说明书

使用`/** */`注释，使得鼠标放到这个类/方法前面时能够弹出对应的提示，其中@提示项名 信息都会被一一渲染。如：

```java
/**
 * @说明 单例程 饱汉模式
 * @author lr580
 */
```

> 过时的方法能用，因为IDK底层本来就是用这些的；不建议用的原因是有包装





#### 语法糖

Syntactic sugar ，糖衣语法。指对语言功能无影响，但更方便程序员使用的语法。使得程序更加简洁和可读性更高

语法糖只存在于编译期，编译器编辑 .java 源文件为 .class 字节码时就会解语法糖。

> 语法糖包括：条件编译、断言、Switch语句与枚举及字符串结合、可变参数、自动装箱/拆箱、枚举、内部类、泛型擦除、增强for循环、lambda表达式、try-with-resources语句、JDK10的局部变量类型推断等等



### 安装和首个程序

官网找JDK8 (或其他稳定版)安装 然后参考[这里](https://www.zhihu.com/question/278838022/answer/1709832515) 配置vscode环境(ctrl+shift+p找那个插件配置)(搜索java home可以找到配置，然后此时上方会有setting.json可以找)

版本号里$x$与$1.x$相同，如JDK8就是JDK1.8，是目前最主流版本。前者是Oracle收购Sun前版本号，后者是收购后。

JDK 包括 JRE。需要安装 JDK 而不是 JRE。如果安装后 shell 不能运行 javac 就是 JRE。检测：`java -version`, `javac -version`。

注意不要跟C语言项目setting冲突(F5冲突)，建议单开一个新的项目跑java代码。

一个hello world代码如下：

```java
//注意s1是文件名，即该文件必须是s1.java (所以文件名不要用数字开头)
public class s1 {
    public static void main(String[] args) {//main+tab补全
        System.out.println("wdnmd."); //注意是小写L 不是大写I; 自动补全代码是syso
    }
}
```

> 输入main可以tab补全

按F5运行代码，会像python在vscode一样在下方输出。

> 另一个带输入的例子如下：(oj1029)
>
> ```java
> import java.util.Scanner; //导入一个API的类
>
> public class Main {
>  public static void main(String[] args) {
>      Scanner sc = new Scanner(System.in);
>      int k = sc.nextInt();
>      int a = sc.nextInt();//不能用逗号运算符链接
>      int b = sc.nextInt();//就算不是赋值初始化也不行
>      System.out.println(gcd(k, b) == 1 ? "Yes" : "No");
>      sc.close();//防warning用，不搞也行
>  }
>
>  static int gcd(int a, int b) {
>      return a % b == 0 ? b : gcd(b, a % b);
>  }
> }
> ```

> 查看 java 路径：`where java`

一个虫子的按钮是debug模式启动

> 可以通过,某个工程打包的jar在同一个服务器,不同的端口启动
>
> `java -jar **.jar --server.port=8091`

### 项目建立

> 不需要建什么maven, spring。

[参考视频教程](https://www.bilibili.com/video/av415231494/)

ctrl+shift+p ：选择 java create java project 然后选路径和输项目名

此时新建完毕。

> 可能会加载debugger很久，需要网络(可以想办法禁用？)

`src`文件夹的 `App.java`是项目里唯一的主函数，运行一定要靠它。

如果需要其他代码文件，在 `src`文件夹里创建。假设在 `src`里创建了文件夹 `c1`，里面有代码文件 `c101.java`，代码如下：

```java
package c1; //包名约定英文全小写

public class c101 {
    public int test(int n) {
        return n * n;
    }//有main也行，那么在这里F5会跑这里的main
}
```

那么在 `App.java`里调用的参考格式如下：

```java
import c1.c101; //加载这个代码文件
public class App {
    public static void main(String[] args) throws Exception {
        c101 c = new c101(); //创建实例
        System.out.println(c.test(114514)); //运行
    }
}
```

### Eclipse

#### 初始配置

安装：有一个我的安装包在百度云，[链接](https://pan.baidu.com/s/1bOsueP4fMcUjEKlRDthJsw)，密码java，绿色版，下载解压即可。建议放非中文路径。然后下一个JDK8装好并建议弄好path全局变量。

更改用户配置的存储路径：先打开一次eclipse。可能会在D盘看到一个eclipse-workspace文件夹，关闭eclipse，剪切到你想要的位置，再次打开eclipse，File-Switch Workspace 选择自己改的路径。如果要换用户配置相似的操作。

字体修改：Window-Preferences-General-Appearance，找到不同部分字体然后修改

开启自动补全：Window-Preferences-Java-Editor-Content Assist，找到Auto Activation的Auto activation triggers for Java，加上26个英文小写字母。只允许回车时键入自动补全：同页勾选 disable insertion triggers except 'Enter' [参考](https://www.pianshen.com/article/39692498050/)

热键修改：Window-Preferences-Keys，如：

- 代码格式化 format

#### 使用

注意事项：

1. 默认中文编码是GBK，而vscode是UTF-8，所以会乱码。vscode可以点击下方的UTF-8重新选择编码。
2. 自动生成的 `*// TODO Auto-generated method stub*`这行东西会产生vscode的warning

##### 项目新建

打开eclipse的资源管理器：右击左边小窗打开。

File - New - project - 选General下的Project - 输入名字 - Finish

新建包(文件夹)：src下右击new package (一个 `.`代表实际路径的一个目录分割，如 `cn.edu.scnu`是从外到内三层文件夹存储，但包不会这么显示三层)

新建类(代码文件)：包下new class，建议勾选public static void main，会帮你写一个main，然后跑即可。

导入项目：资源管理器右击import，选general-existing projects into workspace，找到项目路径，选择，Finish

取消加载项目(不是删除)：右击项目，delete

更改项目配置：若项目的JDK和自己的版本JDK不匹配，可以修改项目JDK，右击项目，Build path-Configure build path-右边上菜单Libraries，Remove掉JRE System Library，然后Add Library-JRE System Library-Finish

支持assert：右击项目-Run as-Run configurations-Arguments-VM arguments加上一行 `-ea`，即enable assert，关闭即 `-da`，然后apply即可

外部库加入：一般先将外部库放到项目文件下，如 `/lib` 目录，然后右击项目， build path - configure build path - java build path - libraries ，点 add external JARs ，选中库 `.jar` ，确认应用。此时能够看到有项目内的 Referenced Libraries 。使用则用 `Class.forName(库内包名)` 加载。

编码：windows-preferences-general-workspace-text file encoding 的 other 里输入即可。编码出现问题的时候，可以不断原地转换，可以解决bugs。

tab用四个空格而不是\t：首先 window-general-editor-text editor-勾选 insert spaces for tabs ；然后 window-java-code style-formatter-new - edit - indentation - tab policy - space only - apply

如果在 `vscode` 等其他地方新建了文件，而这里没加载出来，可以刷新一下就就出来了 

如果出现版本错误(如什么60.0 55.0数字出现的报错)，可以把vscode版本和eclipse版本调到一样，即eclipse的jre删掉，然后add library加一个jre11(具体为add library - JRE System Library - Environments...按钮 - JavaSE - 11 (可以勾选右边的jre)，应用)

如果报错，说诸如版本过低无法编译1.7,1.5语法之类的，在build path-configure build path - java compiler - 看到 Compiler compliance level，修改为对应版本即可(如11)

修改jar版本：右击项目property-java build path-libraries-jre system library-edit/remove-对应改版本即可

修改默认jar版本：preference-java-install jres-add-找到本地java根目录确认

项目重命名：右击refactor-rename即可。

右击项目，选team-share。可以点create一键造分支。在windows-show view-others-git-git staging可以打开图形化下方面板，就是一个普通的图形化git。

限制格式化行宽：preferences-java-code style-formatter-edit-lien wrapping-maximum line width选一个自己喜欢的如60

##### 快捷

右击菜单找source，能够依据提示看到许多快速生成，如构造函数、get和set。

查看源码，ctrl+单击 (也可`jdk`安装目录下src.zip查看所有`jdk`源码)

alt+shift+f 自动格式化

alt+shift+y 自动拆行(即超过行宽自动换行，再按一次取消)

##### 插件

源：windows-preference-install/update-available software sites 或 help-install new software-add

安装:help-install new software / eclipse marketplace

离线安装：下载 jar，拖到 `eclipse/plugins`，重启软件

##### 视图

恢复默认 window-perspective-reset perspective

##### 编译

右击 export , jar, 一路点，选好导出路径和主类即可。导出一个 `.jar`。

查看当前 java 本机版本，用 `java -version` 在 1.8 或以下，否则用 `java --version`

假设已有 `build.xml`，如果 java 版本不对，改改如：

```xml
<property name="sourceversion" value="8"/>
```

windows - show view - ant, 点 + add build files, 加了之后右击 run as ant build



### vscode

#### 问题解决

##### 总是启动同一文件

找到 `.vscode` 的 `launch.json` ，把诸如下面的东西全删了：

```json
{
    "configurations": [
        {
            "type": "java",
            "name": "Launch c1325",
            "request": "launch",
            "mainClass": "c1325"
        }
    ]
}
```



##### 未解决

vscode暂时未知如何设置启用assert，可以尝试在setting.json里加参数，具体怎么加未知



### 理论

#### JVM

##### 组成

Java Virtual Machine，执行 Java 程序的虚拟计算机系统。

JVM是用C/C++开发的软件，不同平台下需要安装不同版本的JVM

JVM 主要由四大部分组成：ClassLoader（类加载器），Runtime Data Area（运行时数据区，内存分区），Execution Engine（执行引擎），Native Interface（本地库接口），下图可以大致描述 JVM 的结构。

<img src="img/9602C6323C6B86C4EDA164DB052D8420.jpeg" alt="img" style="zoom:50%;" />

JNI (Java Native Interface) 

有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。

> 若没有程序计数器，Java程序中的流程控制将无法得到正确的控制，多线程也无法正确的轮换

1. 程序计数器

   程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

   由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

   如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

2. Java虚拟机栈

   与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

   局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。

   在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

3. 本地方法栈

   本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

   《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。

4. Java堆

   对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配”，而这里笔者写的“几乎”是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。

   根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。

   Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。

5. 方法区

   方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据(类放在这里)。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。

   根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

6. 运行时常量池

   运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

   既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

7. 直接内存

   直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。

   显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。



##### 执行

###### 概述

准备好编译好的 Java 字节码文件（即class文件），计算机要运行程序需要先通过一定方式（类加载器）将 class 文件加载到内存中（运行时数据区），但是字节码文件是JVM定义的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解释器（执行引擎）将字节码翻译成特定的操作系统指令集交给 CPU 去执行，这个过程中会需要调用到一些不同语言为 Java 提供的接口（例如驱动、地图制作等），这就用到了本地 Native 接口（本地库接口）。

- ClassLoader：负责加载字节码文件即 class 文件，class 文件在文件开头有特定的文件标示，并且 ClassLoader 只负责class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。
- Runtime Data Area：是存放数据的，分为五部分：Stack（虚拟机栈），Heap（堆），Method Area（方法区），PC Register（程序计数器），Native Method Stack（本地方法栈）。几乎所有的关于 Java 内存方面的问题，都是集中在这块。
- Execution Engine：执行引擎，也叫 Interpreter。Class 文件被加载后，会把指令和数据信息放入内存中，Execution Engine 则负责把这些命令解释给操作系统，即将 JVM 指令集翻译为操作系统指令集。
- Native Interface：负责调用本地接口的。他的作用是调用不同语言的接口给 JAVA 用，他会在 Native Method Stack 中记录对应的本地方法，然后调用该方法时就通过 Execution Engine 加载对应的本地 lib。原本多用于一些专业领域，如JAVA驱动，地图制作引擎等，现在关于这种本地方法接口的调用已经被类似于Socket通信，WebService等方式取代。



###### JVM启动

JVM的启动过程分为如下四个步骤：

1. JVM的装入环境和配置

   java.exe负责查找JRE，并且它会按照如下的顺序来选择JRE：

   - 自己目录下的JRE；
   - 父级目录下的JRE；
   - 查注册表中注册的JRE。

2. 装载JVM

   通过第一步找到JVM的路径后，Java.exe通过LoadJavaVM来装入JVM文件。LoadLibrary装载JVM动态连接库，然后把JVM中的到处函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMIntArgs 挂接到InvocationFunction 变量的CreateJavaVM和GetDafaultJavaVMInitArgs 函数指针变量上。JVM的装载工作完成。

3. 初始化JVM，获得本地调用接口

   调用InvocationFunction -> CreateJavaVM，也就是JVM中JNI_CreateJavaVM方法获得JNIEnv结构的实例。

4. 运行Java程序

   JVM运行Java程序的方式有两种：jar包 与 class。

   运行jar 的时候，java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例然后调用JarFileJNIEnv类中getManifest()，从其返回的Manifest对象中取getAttrebutes("Main-Class")的值，即jar 包中文件：META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类。之后main函数会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。

   运行Class的时候，main函数直接调用Java.c中的LoadClass方法装载该类。



###### java程序运行

概括来说，写好的 Java 源代码文件经过 Java 编译器编译成字节码文件后，通过类加载器加载到内存中，才能被实例化，然后到 Java 虚拟机中解释执行，最后通过操作系统操作 CPU 执行获取结果。如下图

![img](img/2B33427D8F51F7F8EADC74E0034C5FC7.jpeg)

JIT (Just-In-Time) 



###### 编译

![img](img/D5A5CF19C86BD497E892012DFFC26B0E.jpeg)

从Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3个处理过程，它们分别如下所示。

1. 准备过程：初始化插入式注解处理器。

2. 解析与填充符号表过程，包括：

   - 词法、语法分析，将源代码的字符流转变为标记集合，构造出抽象语法树。
   - 填充符号表，产生符号地址和符号信息。

3. 插入式注解处理器的注解处理过程：

   在Javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，而它的执行过程则是在processAnnotations()方法中完成。这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。

4. 分析与字节码生成过程，包括：

   - 标注检查，对语法的静态信息进行检查。
   - 数据流及控制流分析，对程序动态运行过程进行检查。
   - 解语法糖，将简化代码编写的语法糖还原为原有的形式。
   - 字节码生成，将前面各个步骤所生成的信息转化成字节码。

上述3个处理过程里，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号，从总体来看，三者之间的关系与交互顺序如图所示。



###### 类加载

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。这七个阶段的发生顺序如下图所示。

![img](img/2F1143CD0902210BA8783DBC8CB76D0A.jpeg)

在上述七个阶段中，包括了类加载的全过程，即加载、验证、准备、解析和初始化这五个阶段。

一、加载

“加载”（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段，在加载阶段，Java虚拟机需要完成以下三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。

二、验证

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。

1. 文件格式验证：

   第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。

2. 元数据验证：

   第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。

3. 字节码验证：

   第三阶段是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。

4. 符号引用验证：

   符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

三、准备

准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的。而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。

四、解析

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在Class文件中以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？

符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。

直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

五、初始化

类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。

进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：初始化阶段就是执行类构造器`<clinit>()`方法的过程。`<clinit>()`并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。

> Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。
>
> 类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等

###### 对象实例化

对象实例化过程，就是执行类构造函数对应在字节码文件中的<init>()方法(实例构造器)，<init>()方法由非静态变量、非静态代码块以及对应的构造器组成。

- `<init>()`方法可以重载多个，类有几个构造器就有几个<init>()方法；
- `<init>()`方法中的代码执行顺序为：父类变量初始化、父类代码块、父类构造器、子类变量初始化、子类代码块、子类构造器。

静态变量、静态代码块、普通变量、普通代码块、构造器的执行顺序如下图：

<img src="img/9285BA6FB2D1E24A711E876B40F6E978.png" alt="img" style="zoom:67%;" />

有父类的类的构造过程：(简单来说就是前两个、后三个记为 AB，则 FA, SA, FB, SB)

<img src="img/7F511C22AD3C8FA49BFA8D92452E6CB3.png" alt="img" style="zoom:67%;" />



> Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？
>
> 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
>
> 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。
>
> 除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。
>
> 内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。
>
> 接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
>
> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的`<init>()`方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行`<init>()`方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。
>
> CMS算法是JVM中老年代常用的垃圾回收算法,全称是Concurrent Mark Sweep算法,即并发标记-清除算法

##### GC

垃圾回收 Garbage Collection

###### 概述

在Java内存运行时区域的各个部分中，堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理，我们平时所说的内存分配与回收也仅仅特指这一部分内存

回收垃圾有若干算法，下面分标题细述。

###### 垃圾定义

引用计数方法：

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

但是，在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。

举个简单的例子：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。



可达性分析算法：

当前主流的商用程序语言的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

如下图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。

![img](img/530050F0D7F21C01B1E53B69A34DE34C.jpeg)

在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。



方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。回收废弃常量与回收Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。

判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。



###### 分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（GenerationalCollection）的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用

分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会存在跨代引用。假如要现在进行一次只局限于新生代区域内的收集，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：

1. 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（称为“记忆集”，RememberedSet），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。



###### 标记清除算法

最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

它的主要缺点有两个：第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记-清除算法的执行过程如下图所示。

<img src="img/8DA0B21274031BD21A8D167C402CD686.jpeg" alt="img" style="zoom:67%;" />



###### 标记复制算法

为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969年Fenichel提出了一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费多。标记-复制算法的执行过程如下图所示。

![img](img/18A9C9A68A9BD232DC976B48EA7132FE.jpeg)

老年代保留的对象都是难以消亡的，而标记复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低，所以在老年代一般不能直接选用这种算法

> 现在的商用Java虚拟机大多都优先采用了“标记-复制算法”去回收新生代，该算法早期采用“半区复制”的机制进行垃圾回收。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。
>
> 实际上，新生代中的对象有98%熬不过第一轮收集，因此并不需要按照1∶1的比例来划分新生代的内存空间。在1989年，Andrew Appel提出了一种更优化的半区复制分代策略，现在称为“Appel式回收”。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。
>
> HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。
>
> 设置两个 Survivor 区最大的好处就是解决内存碎片化。
>
> 我们先假设一下，Survivor 只有一个区域会怎样。Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 Survivor 有 2 个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。
>
> 这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案



###### 标记整理算法

标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

针对<u>老年代</u>对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，“标记-整理”算法的示意图如下图所示。

![img](img/23CE6001C14F968ADB095C66E832DEE1.jpeg)



###### 完整流程

新创建的对象一般会被分配在新生代中，常用的新生代的垃圾回收器是 ParNew 垃圾回收器，它按照 8:1:1 将新生代分成 Eden 区，以及两个 Survivor 区。某一时刻，我们创建的对象将 Eden 区全部挤满，这个对象就是挤满新生代的最后一个对象。此时，Minor GC 就触发了。

在正式 Minor GC 前，JVM 会先检查新生代中对象，是比老年代中剩余空间大还是小。为什么要做这样的检查呢？原因很简单，假如 Minor GC 之后 Survivor 区放不下剩余对象，这些对象就要进入到老年代，所以要提前检查老年代是不是够用。这样就有两种情况：

1. 老年代剩余空间大于新生代中的对象大小，那就直接Minor GC，GC完survivor不够放，老年代也绝对够放；

2. 老年代剩余空间小于新生代中的对象大小，这个时候就要查看是否启用了“老年代空间分配担保规则”，具体来说就是看 -XX:-HandlePromotionFailure 参数是否设置了。

   老年代空间分配担保规则是这样的，如果老年代中剩余空间大小，大于历次 Minor GC 之后剩余对象的大小，那就允许进行 Minor GC。因为从概率上来说，以前的放的下，这次的也应该放的下。那就有两种情况：

   老年代中剩余空间大小，大于历次Minor GC之后剩余对象的大小，进行 Minor GC；

   老年代中剩余空间大小，小于历次Minor GC之后剩余对象的大小，进行Full GC，把老年代空出来再检查。

开启老年代空间分配担保规则只能说是大概率上来说，Minor GC 剩余后的对象够放到老年代，所以当然也会有万一，Minor GC 后会有这样三种情况：

1. Minor GC 之后的对象足够放到 Survivor 区，皆大欢喜，GC 结束；
2. Minor GC 之后的对象不够放到 Survivor 区，接着进入到老年代，老年代能放下，那也可以，GC 结束；
3. Minor GC 之后的对象不够放到 Survivor 区，老年代也放不下，那就只能 Full GC。

前面都是成功 GC 的例子，还有 3 中情况，会导致 GC 失败，报 OOM：

1. 紧接上一节 Full GC 之后，老年代任然放不下剩余对象，就只能 OOM；
2. 未开启老年代分配担保机制，且一次 Full GC 后，老年代任然放不下剩余对象，也只能 OOM；
3. 开启老年代分配担保机制，但是担保不通过，一次 Full GC 后，老年代任然放不下剩余对象，也是能 OOM。

Full GC会“Stop The World”，即在GC期间全程暂停用户的应用程序。

虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置

> 当 Eden 区的空间耗尽时 Java 虚拟机便会触发一次 Minor GC 来收集新生代的垃圾，存活下来的对象，则会被送到 Survivor 区，简单说就是当新生代的Eden区满的时候触发 Minor GC。
>
> serial GC 中，老年代内存剩余已经小于之前年轻代晋升老年代的平均大小，则进行 Full GC。而在 CMS 等并发收集器中则是每隔一段时间检查一下老年代内存的使用量，超过一定比例时进行 Full GC 回收。
>
> 可以采用以下措施来减少Full GC的次数：
>
> 1. 增加方法区的空间；
> 2. 增加老年代的空间；
> 3. 减少新生代的空间；
> 4. 禁止使用System.gc()方法；
> 5. 使用标记-整理算法，尽量保持较大的连续内存空间；
> 6. 排查代码中无用的大对象



###### G1垃圾收集器

G1（Garbage First）是一款主要面向服务端应用的垃圾收集器，JDK 9发布之日，G1宣告取代ParallelScavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器。G1收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。

虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数 -XX：G1HeapRegionSize 设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region 之中，G1的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待，如下图所示。

![img](img/247F7CD9892EB01A7A3ECBC7193FA032.jpeg)

虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。



###### CMS垃圾收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。从名字上就可以看出CMS收集器是基于标记-清除算法实现的，它的运作过程分为四个步骤，包括：

1. 初始标记（CMS initial mark）；
2. 并发标记（CMS concurrent mark）；
3. 重新标记（CMS remark）；
4. 并发清除（CMS concurrent sweep）。

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的阶段。

![img](img/139DF2625D59EBF58A1FA8BBC0D38988.jpeg)

CMS收集器还远达不到完美的程度，它至少有以下三个明显的缺点：

首先，CMS收集器对处理器资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。

然后，由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop TheWorld”的Full GC的产生。

> 重新标记（Remark） 的作用在于：之前在并发标记时，因为是 GC 和用户程序是并发执行的，可能导致一部分已经标记为 从 GC Roots 不可达 的对象，因为用户程序的（并发）运行，又可达 了，Remark 的作用就是将这部分对象又标记为 可达对象。 至于 “浮动垃圾”，因为 CMS 在 并发标记 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（即浮动垃圾）没有被标记到；而 重新标记 的作用只是修改之前 并发标记 所获得的不可达对象，所以是没有办法处理 “浮动垃圾” 的 [参考](https://blog.csdn.net/weichi7549/article/details/113507623)

还有最后一个缺点，CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。



###### 内存泄漏

内存泄漏（memory leak）：内存泄漏指程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。

内存泄漏的根本原因是长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象已经不再需要，但由于长生命周期对象持有它的引用而导致不能被回收。以发生的方式来分类，内存泄漏可以分为4类：

1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。
4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。

避免内存泄漏的几点建议：

1. 尽早释放无用对象的引用。
2. 避免在循环中创建对象。
3. 使用字符串处理时避免使用String，应使用StringBuffer。
4. 尽量少使用静态变量，因为静态变量存放在永久代，基本不参与垃圾回收。



###### 内存溢出

内存溢出（out of memory OOM）：简单地说内存溢出就是指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。

引起内存溢出的原因有很多种，常见的有以下几种：

1. 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
2. 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
3. 代码中存在死循环或循环产生过多重复的对象实体；
4. 使用的第三方软件中的BUG；
5. 启动参数内存值设定的过小。

内存溢出的解决方案：

- 第一步，修改JVM启动参数，直接增加内存。
- 第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。
- 第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
- 第四步，使用内存查看工具动态查看内存使用情况。

除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。

1. Java堆溢出

   Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。

2. 虚拟机栈和本地方法栈溢出

   HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。

3. 方法区和运行时常量池溢出

   方法区溢出也是一种常见的内存溢出异常，在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。这类场景常见的包括：程序使用了CGLib字节码增强和动态语言、大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。

   在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，即常量池是方法去的一部分，所以上述问题在常量池中也同样会出现。而HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代，所以上述问题在JDK 8中会得到避免。

4. 本地直接内存溢出

   直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致。如果直接通过反射获取Unsafe实例进行内存分配，并超出了上述的限制时，将会引发OOM异常



##### 其他

###### 双亲委派

自JDK1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。对于这个时期的Java应用，绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载。

- 启动类加载器（Bootstrap Class Loader）：这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。
- 扩展类加载器（Extension Class Loader）：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK 9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。
- 应用程序类加载器（Application Class Loader）：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

这些类加载器之间的协作关系“通常”会如下图所示，图中展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents Delegation Model）”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。

<img src="img/8E2E9DCFA8BD05816F2C6E5041254667.jpeg" alt="img" style="zoom:67%;" />

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。

loadClass具体实现：先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。

> 双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。
>
> 双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。
>
> 双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？
>
> 这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？
>
> 为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。
>
> 有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。
>
> 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（HotSwap）、模块热部署（Hot Deployment）等。说白了就是希望Java应用程序能像我们的电脑外设那样，接上鼠标、U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用关机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是大型系统或企业级软件开发者具有很大的吸引力。
>
> 早在2008年，在Java社区关于模块化规范的第一场战役里，由Sun/Oracle公司所提出的JSR-294、JSR-277规范提案就曾败给以IBM公司主导的JSR-291（即OSGi R4.2）提案。尽管Sun/Oracle并不甘心就此失去Java模块化的主导权，随即又再拿出Jigsaw项目迎战，但此时OSGi已经站稳脚跟，成为业界“事实上”的Java模块化标准。曾经在很长一段时间内，IBM凭借着OSGi广泛应用基础让Jigsaw吃尽苦头，其影响一直持续到Jigsaw随JDK 9面世才算告一段落。而且即使Jigsaw现在已经是Java的标准功能了，它仍需小心翼翼地避开OSGi运行期动态热部署上的优势，仅局限于静态地解决模块间封装隔离和访问控制的问题，现在我们先来简单看一看OSGi是如何通过类加载器实现热部署的。
>
> OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：
>
> 1. 将以java.*开头的类，委派给父类加载器加载。
> 2. 否则，将委派列表名单内的类，委派给父类加载器加载。
> 3. 否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。
> 4. 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
> 5. 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
> 6. 否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
> 7. 否则，类查找失败。
>
> 上面的查找顺序中只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的。



###### 元空间

在栈外，元空间占用的是本地内存。

> 许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代“，或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机实现，譬如BEAJRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。
>
> 现在回头来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法（例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。
>
> 当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。







### 其他

#### 反编译

JDK 自带 javap 工具。

jad 工具。可以用 CFR 。



## 语言基础

代码注释同C。

> 特别注意有文档注释，即 `/** */`，出现在声明之前，会被读取作为文档内容。

### 主类结构

主类：含有main方法的类

> 项目item 有若干个包package，一个包有若干个类
>
> 语句 `package 包名;`声明单签类属于哪个包(在代码第一行)

类的属性(成员属性)是全局变量；方法的属性是局部变量

> 例如：
>
> ```java
> public class Main {
>     static String x = "greg.fhetgfg"; // 属性
>
>     public static void main(String[] args) {
>         String y = "中文字符";
>         System.out.println(x + y); // 自带换行符
>         System.out.println(y);
>     }
> }
> ```

> `public` 权限修饰符   `static` 静态修饰符

main方法必须声明为 `public static void`

### 数据

#### 基本数据类型

不存在 unsigned

##### 整数类型

十进制、八进制、十六进制表示同C (八进制即带前导0如 `0123`$\to83_{(10)}$)

分为byte(8位)、short(16)、int(32)、long(64)  数据范围同C，即byte等于C的char($[-128,127]$)

将超出int范围的字面量赋值给long，需要加后缀 `l`或 `L`。默认值依次是 `0,0,0,0L`

如：

```java
long x = 123456789012L;
System.out.println(x << 1);
```



##### 浮点类型

有32位的float($[1.4\times10^{-45},3.4028253\times10^{38}]$)   (精度7位)和

64位的double($[4.9\times10^{-324},1.7976931348623157\times10^{308}]$)  (精度16位)

float后缀为 `F`/`f`    double为 `D`/`d`   声明float时建议加后缀 (默认小数为double)。默认值 `0.0F` 和 `0.0`

##### 字符类型

char存单个字符，占16位(65536个字符)，所以可以处理单个中文等字符转int可输出看ascii码。字符类型采用的是Unicode编码方案。默认值 `\u0000`

```java
char a = '萨', b = '日', c = '朗';
System.out.println(a);
System.out.println((int)a);
```

转义符 `\ddd` $1\sim3$位八进制表示的字符 如 `\123`

`\uxxxx` $4$位十六进制数据表示字符 如 `\u2605`

中文的主要范围 `[\u4e00]~[\u9fa5]`，判定方法举例：

```java
char a = '囸';
if (a >= '\u4e00' && a <= '\u9fa5') {
    System.out.println("fuck");
}//注：不完全准确，还有中文特殊符号
```

##### 布尔类型

boolean 值为 `true`/`false`。默认 false

Java规范没有明确的规定占内存多少字节，不同的JVM有不同的实现机制

##### null

[参考](https://blog.csdn.net/chinus_yan/article/details/120583287)

null 是关键字，不是数据类型。是引用类型的默认值。不能强转基本数据类型。

##### 类型转换

###### 隐式

有整数、浮点之间有隐式类型转换：$byte<short<int<long<float<double$

具体而言 `byte,short,char`是第一类，然后 `int`,`long`,`float`,`double`是其他四类，低类操作数转成高类的。

> byte可以传入'a'，但是不可以传入char变量赋值；其他整数浮点数类型可以;byte也不能赋值传整型变量。

负数浮点数强转整数也会只剩略小数点部分，即 `(int)-1.9=-1`

###### 显式

同C语法。(boolean不行，其他都可以) ，如：

```java
double x = 3.1, y = -10.9;
System.out.println((long) x + (int) y);
```

#### 变量

##### 声明

标识符可以由字母数字和 `_$`组成，开头不能是数字 (还可以包含中文等其他语言(不支持tab补全))

声明语法同C。

> 系统内存分为系统(OS)区、程序区和数据区。运行时代码暂存程序区，数据暂存数据区。但定义在方法体的变量暂存在程序区。

局部变量(方法里定义的变量)没有初始值，未赋值只声明就输出会报错。存储在栈内存，作用范围结束自动释放变量空间。

成员变量都有初始值。其中类变量存在方法区生命周期与当前类相同。实例变量存在对象所在堆内存，生命周期与对象相同。

java 没有真正的全局变量。

##### 常量

常量声明关键字是 `final`，只能进行一次赋值(在初始化时也行不在也行)

> 常量一般用大写字母和下划线。

举例：

```java
static final double pi = 3.1415926531; //可以final static
public static void main(String[] args) {
    final int k = 114514;//但不可以int final
    System.out.println(k * pi);
}
```

特别注意一个变量如果没有赋值过就调用来输出或参与运算就会报错。

若对对象(即引用)(如数组)使用final，只能恒定指向一个对象，不能重指向别的对象。final数组等效于final对象，元素可以改，但不能重新整体赋值(如再new)。

static final的对象可以实现不能修改。如：

```java
import java.util.Random;

class st {
    private static Random rand = new Random();// 常数优化
    public final int a1 = rand.nextInt(10);
    public final static int a2 = rand.nextInt(10);
}

//...
st a = new st(), b = new st();
System.out.println(a.a1 + "??" + a.a2);
System.out.println(b.a1 + "??" + b.a2);
```

方法定义为final，可防止子类修改定义和实现(即重写)。且final方法效率更高。private方法自动是final的。

final类不可以被继承，且所有方法被自动设置为final(成员属性不会)。如：

```java
class par {
    private final void f() { // 若protected/public/不写，子类不可重写
        System.out.println("aaa");
    }
}

class sub extends par {
    public final void f() { // 二者仅仅重名，而没有任何关系；不代表重写
        // 因为sub没有继承par的f
        //若sub实例向上转型后则f表示父类的，且private
        System.out.println("bbb");
    }
}
```

final作为函数参数时，该参数不可改变(对象不可重引用)。

final 不能修饰构造方法。

常数组可以使用unmodifiableList。

##### 有效范围

变量的生存期 分为成员变量和局部变量；成员变量分为静态变量和实例变量。在方法内可以用自建代码块约束生存范围。

例如：

```java
public class Main {
    public static void main(String[] args) {
        System.out.println(v.y + 1);
    }

    //如果没有static ，main里获取的v.y将会获取失败(得到0)
    //如果放在了public class main的外面那么无法调用v.y
    static class v { // 放public class main里或外都行
        int x = 580; // 实例变量
        static int y = 998244353; // 静态变量(类变量)
    }
}
```

#### 字符串

java.lang包含String类，不需要import可以直接用。

字符串字面量包含在双引号内。

是final类，不可继承。

> final 的原因：安全、性能
>
> - 如果字符串可变，可以被篡改，如出现 SQL 注入、访问危险文件等
> - 多线程里不变的对象和值是线程安全的，可以在多个线程共享变量。一个线程若修改了字符串值，会产生新字符串对象
> - `hashCode` 属性(int hash)不会变更，保证唯一性，集合类等可以缓存。避免重复计算哈希值，提高性能。
> - 字符串不变使得可以做字符串常量池，减少创建相同字面量字符串。否则 `String.intern()` 失效，每次创建新字符串开辟新空间
>
> 假设可变，为 String 子类重写方法，绕过正常途径修改字符串值

##### 创建

声明直接 `String`关键字。

可以直接用字面量赋值。如：

```java
String a="lr580";
System.out.println(a);
```

也可以用new String构造字符串，创建方法有：

1. 可以传入字面量，如：

   ```java
   String a = new String("lr580");
   ```
2. 可以用字符数组构造String对象，如：

   ```java
   char a[] = { 'g', 'o', 'o', 'd' };
   String b = new String(a);
   System.out.println(b);
   ```
3. 附上第二第三个参数，代表起始下标和长度。(越界会报错)

   ```java
   String b = new String(a, 2, 2); //"od"
   ```

   这个传入的第一个参数也可以是字符数组/字节数组

##### 运算

###### 链接

`+`运算符链接，可以是字符串、字符和数值(其他类型自动调用toString方法)，如：

```java
String a = "lorem ipsum dolor sit " + 'a';
char b = 109;
String c = "et.";
double r = 1.0 / 3;
System.out.println(a + b + c + r);
```

字符串指向一个字面量，不可以对字符串直接修改。每次对String的修改都是一次直接全字符串的覆盖。

##### 方法

###### 长度

length，无参数

###### 查找

indexOf，加char或字符串，用法同js，第二个参数是起始位置(对lastIndexOf 是结束)

同理有lastIndexOf方法

> lastIndexOf空字符串是长度，indexOf是0

复杂度是$\Omicron(n)$

如：

```java
System.out.println("aoboco".lastIndexOf('o', 3));//3
```



###### 取元素

charAt(x)方法，即下标为x的字符，越界会报错

###### 取子串

substring(x,y)方法，返回下标范围在$[x,y)$的子串(y可缺省)，越界会报错

###### 转为字符数组

toCharArray()方法

###### 去空白字符

trim()方法 ，去除首尾空白字符(ascii 小于等于空格)，类似python的strip

###### 替换

replace(原内容,新内容)方法，参数可以是char或String，两个参数类型一致。全部替换

replaceFirst, replaceAll

###### 前后缀检测

startsWith(字符串) (字符不行) 返回boolean (空字符恒true)

endsWith(字符串)

###### 相等

equals(x)或equalsIgnoreCase(x)

###### 字典序比较

compareTo(x) 若相等返回$0$，大于返回正整数，小于返回负整数。数字大小是ascii码的差值，即首个不同的位置的自己的ascii\-x\.ascii。null 不可比较。

###### 大小写转换

toLowerCase(),toUpperCase() ，将英文、希腊字母等转换大小写

###### 分割

split(分割符,匹配次数)  分割符集是正则表达式，匹配次数不填就一直匹配(是多少就返回至多长度为多少的数组)

如：

```java
String x = "1.2=345 6";
String[] y = x.split("\\.|=");// 转义使得不是正则表达式的.
for (String k : y) {
    System.out.println(k);
}
```

###### 格式化

String.format方法，第一个参数是格式字符串，后面的参数依次是代表的变量(多出的部分忽略)

一般的转换符，有：

- %b %B 格式化为布尔类型(区别在于大小写，可以传非布尔值)
- %h %H 转化为十六进制哈希值
- %s %S 转化为字符串(S转大写,s不转小写)
- %c %C 转化为字符
- %d 十进制整数
- %o 八进制整数(正) (不含前导)
- %x %X 十六进制整数(正) (不含前导)
- %f 浮点数
- %e %E 指数形式
- %a 带有效位数和指数的十六进制浮点值
- %n 分割符(本机为换行符)
- %% %

如：

```java
System.out.println(String.format("%B", 13));
System.out.println(String.format("%H", 1.2));
System.out.println(String.format("%.6s", 31.0 / 3));// 总长为6，不是6位小数
System.out.println(String.format("%.6f", 1.0 / 3));// 没有%F
System.out.println(String.format("%s", "AbC"));
System.out.println(String.format("%S", 1e9));
System.out.println(String.format("%s", 1e9));// 都是1.0E9
System.out.println(String.format("%f", 1e9));// 都是1.0E9
System.out.println(String.format("%e", 1e9));// 唯独是1.0e9
System.out.println(String.format("%E", 1e9));// 都是1.0E9
System.out.println(String.format("%c", 'A'));// "A"会报错
System.out.println(String.format("%C", 'a'));// 同%S理
System.out.println(String.format("%d", 1));// 1.9会报错
System.out.println(String.format("%d", -1));
System.out.println(String.format("%o", -1));
System.out.println(String.format("%x", -1));
System.out.println(String.format("%a", 6.1));// 输入整数报错
System.out.println(String.format("1%n2%%"));
System.out.println(String.format("%6s", "lr580"));
System.out.println(String.format("%4s", "lr580"));
System.out.println(String.format("%-6sabc", "lr580"));
System.out.println(String.format("%15.0f", 2.0 / 3));// 输入整数报错
```

对日期的转换符，有：

- %te 天($[1,31]$)
- %tb 月份简称(根据环境不同输出英文或中文，中文如 `9月`)
- %tB 月份全称，如 `九月`
- %ta 星期简称，如 `周一`
- %tA 星期全称，如 `星期一`
- %tc 日期全部信息，如 `周一 9月 13 09:04:40 CST 2021`
- %ty 长为二的后缀年份数字
- %tY 年份数字
- %tm 月份数字(含前导0)($[1,12]$)
- %td 一个月的第几天($[1,31]$)(含前导0)
- %tj 一年中的第几天($[1,366]$)
- %tH 2位24时制小时(含前导0) ($[0,23]$)
- %tI 2位12时制小时(含前导0)  (t+大写i)  ($[1,12]$)
- %tk 2位24时制小时(不含前导0)
- %tl 2位12时制小时(不含前导0)  (t+小写L)
- %tM 2位数字分钟(含前导0) ($[0,59]$)
- %tS 2位数字秒钟(含前导0) ($[0,60]$)
- %tL 3位数字毫秒(含前导0) ($[0,999]$)
- %tN 9位数字微秒(含前导0) (实测时后六位都是$0$)
- %tp 上午或下午标记，如 `上午`
- %tz 相对于GMT RFC 82 格式的数字时区偏移量 如 `+0800`
- %tZ 时区缩写形式字符串，如 `CST`
- %ts 1970-1-1 00:00:00 到现在的秒数 如 `1631496677`
- %tQ 1970-1-1 00:00:00 到现在的毫秒数 如 `1631496727812`
- %tF 年-月-日 (四位，两位，两位)
- %tD 月/日/年 (都两位)
- %tr 时:分:秒 %tp(12时制) 如 `09:36:47 上午`
- %tT 时:分:秒(24时制) 如 `09:37:58`
- %tR 时:分(24时制) 如 `09:37`

如：

```java
System.out.println(String.format("hahaha%tB", new Date()));
```

```java
String.format("%tF-%tT", new Date(), new Date())//年月日时分秒
```



###### 转字符数组

`getBytes()`，如：

```java
byte b[] = "按个v1".getBytes();
for (byte i : b) {
    System.out.print(i + " ");
}
```

###### 拼接

concat。见下文常量池



##### 正则表达式

###### 语法

- .

- ? 0次或1次

- \* 0次或多次

- \+ 1次或多次

- {n}

- {n,}

- {n,m} $[n,m]$次之间都可以

- () 作为一个整体

- [abc] 里面的任一字符

- [^abc]

- [a-r]

- [a-rA-R]

- [a-e[g-z]] 等效于上面的写法 并运算

- [a-o&&[def]] 交运算

- [a-d&&[\^def]] 差运算

- \d \D

- \s \S 空白字符和非空白字符

- \w \W 可用作标识符的字符(不包括\$) 和不可

- \p{Lower} a-z

- \p{Upper}

- \p{ASCII} ascii

- \p{Alpha} a-zA-Z

- \p{Digit} 0-9

- \p{Alnum} a-zA-Z0-9

- \p{Punct} `!#$%&'{}*+.-/:;<=>?@[\]^_\{|}~`

- \p{Graph} 可见字符 即Alnum+Punct

- \p{Print} 可打印字符 Graph+\x20(空格)

- \p{Blank} \t

- \p{Cntrl} 控制字符 `[\x00-\x1F\x7F]`

- \^ 设置了 `RegExp` 对象的 `Multiline` 属性时会与 \n \r 后的位置匹配

- \$ 设置了 `RegExp` 对象的 `Multiline` 属性时会与 \n \r 前的位置匹配

- (pattern) 分组，使用 \$0..\$9 属性从结果匹配该组

- (?:pattern) 非捕获匹配 

  如：`industr(?:y|ies)` 匹配单复数

- (?=pattern) 非捕获匹配，括号内内容不匹配而作为条件

  如：`id(?=x|y)` 匹配 `idx` 的 `id` ，不匹配 `ida` 的 `id`

- (?!pattern) 非捕获匹配，括号内容是不能包含的内容(与上一条相反)

- \b 字边界

- \B 非字边界

  如：`er\B` 匹配 `verb` 不匹配 `never`

- \cx x是控制字符，x是大小写字母；否则无意义(\\c=c)

- \xn 十六进制转义码，n 正好两位长

  如：`\x41` 是 `'A'`

- \num num是正整数

  如：`(.)\1` 匹配两个连续相同字符

- \n 若至少有 n 个捕获子表达式是\num ，否则是八进制转移码(八进制数 0-7)

- \nm 是数字 nm (有 nm 个子表达式) 或 \n + 字符 m (n 个子表达式) 或八进制码

- \nml $n\in[0,3],m,l\in[0,7]$ 是八进制转移码

- \un n是四位十六进制 Unicode字符

  如：`\u00A9` 是 `©`

如：

```java
System.out.println("int".matches("\\w*"));//匹配了一个单词
System.out.println("ss".matches("\\w"));// 单个不匹配多个
System.out.println("lr580? slowa!".matches("\\w*\\?\\W\\w*\\!"));// 标点符号不算
System.out.println("abcde".matches("\\p{Lower}+"));
System.out.println("abcde".matches("\\p{Lower}"));
System.out.println("tw.k".matches("[a-z]+(\\([a-z]*\\))*\\.[a-z]+"));
System.out.println("tw(adf).k".matches("[a-z]+(\\([a-z]*\\))*\\.[a-z]+"));
```

常用方法：

###### split

> 见字符串-方法-分割

###### matches

布尔值，返回字符串是否与正则表达式匹配，如：

##### 字符串生成器

StringBuffer、StringBuilder都代表可变的字符串对象，它们有共同的父类 AbstractStringBuilder，并且两个类的构造方法和成员方法也基本相同。不同的是，StringBuffer是线程安全的，而StringBuilder是非线程安全的，所以StringBuilder性能略高。一般情况下，要创建一个内容可变的字符串，建议优先考虑StringBuilder类

StringBuilder对象，如果频繁附加字符串，速度快于String

> 这是因为 String 的属性是不可变的，每次修改本质是用新的替换

> 新建的初始容量是16字符(多出部分用append加)，每次扩容加倍。如果长度可知，可以构造时传进去，避免频繁扩容

方法：

###### length

取长度 (注意不是属性s)

###### toString

返回字符串

###### append

增加int,boolean,char,String,double或字符串生成器到末尾

###### insert

第一个参数offset是插入起始后被插入字符串首字符所在的下标，大于等于0，小于等于序列长度

第二个参数是插入的内容

###### delete

删除$[start,end)$下标范围的字符，若end大于长度，end取长度

如：

```java
StringBuilder sb = new StringBuilder("0123456789ABCDEFG");
System.out.println(sb.toString());
sb.insert(1, 1.0 / 3);
System.out.println(sb.toString());
sb.delete(5, 114514);
System.out.println(sb.toString());
sb.append(sb);
System.out.println(sb.toString());
```

效率对比：

```java
long st10 = System.currentTimeMillis(); //取当前毫秒时间戳
String s1 = "";
for (int i = 0; i < 100000; ++i) {
    s1 += (char) i;
}
long st11 = System.currentTimeMillis();

long st20 = System.currentTimeMillis();
StringBuilder s2 = new StringBuilder();
for (int i = 0; i < 100000; ++i) {
    s2.append((char) i);
}
long st21 = System.currentTimeMillis();

System.out.println(s1.length() + " " + s2.length());
System.out.println((st11 - st10) + " " + (st21 - st20));
//String消耗2.2s StringBuilder几乎不消耗时间
```

###### reverse

返回自己的转置。(之后自己也转置了)

```java
StringBuilder sb = new StringBuilder("abcdef0123456789=");
System.out.println(sb.reverse().toString());
System.out.println(sb);
```

###### trimToSize

自调整，类似于 `std::vector`



> 没有 `toCharArray` 方法



###### 线程安全分析

StringBuilder 不安全的例子：

```java
public static void g() throws InterruptedException {
    // 期望：运行中途大概率会报错，且运行结束后长度偏小
    StringBuilder s = new StringBuilder();
    for (int i = 0; i < 10; ++i) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int j = 0; j < 1000; ++j) {
                    s.append('a');
                }
            }
        }).start();
    }
    Thread.sleep(100);
    System.out.println(s.toString().length());
}
```

理由：在父类 `AbstractStringBuilder` 里，有 char value 数组和 int count。然后在 append 方法直接调用父类的 append，内含 `count += len` 这一个非原子操作，所以导致 count 与 `value.length` 实际上不一致。

之所以会报错是因为，假设两个线程同时检查完了扩容后时间片完，且当前剩下的位置只有一个字符，然后下一轮时，两个线程分别向 value 数组塞值，导致其中一个越界，所以会报错。

而换成 StringBuffer，结果正确，因为它的 append 函数是 synchronized 关键字的。



##### 常量池

[参考](https://blog.csdn.net/tianyuzui6/article/details/124417267) , intern 方法

具体而言每次有一个常量时，会自动添加到常量池，下次取常量赋值时自动把地址返回。

```java
String s1 = "白茶";
String s2 = "白茶";
String s3 = "白" + "茶";// 编译优化
System.out.println(s1 == s2);// true
System.out.println(s1 == s3);// true
final String fs1 = "白";
final String fs2 = "茶";
String s4 = fs1 + fs2;
System.out.println(s1 == s4);// strue
String s5 = new String("白茶");// 不走常量池
System.out.println(s1 == s5);// false
String s6 = fs1.concat(fs2);
System.out.println(s1 == s6);// false
```

JDK6 会把首次遇到的字符串实例复制到常量池中，并返回此引用

JDK7及之后 会把首次遇到的字符串实例的引用添加到常量池中，并返回此引用

注意到 new 时本身也用到了一个常量传进去，这代表实际上会多创建一个对象。(String 对象的数组指向常量池)

字符串拼接的四种方法：

- `+`。如果左右是直接量(如上例)，可以编译优化

  如果是变量编译器用 `Builder` 优化。但拼接在循环时，每次循环编译器都创建实例再拼接即 `new StringBuilder().append(str)`

- `StringBuilder`

- `StringBuffer`

- `concat`。先创建一个足以容纳两部分的字节数组，然后先后将其拼到数组，然后转字符串。大量拼接效率低于 Builder。只拼接两个优于。



##### StringTokenizer

用于将一个字符串按照指定的分隔符分割成多个子字符串。在Java中，StringTokenizer类位于java.util包中

```java
String str = "apple,banana,orange";
StringTokenizer tokenizer = new StringTokenizer(str, ",");
while (tokenizer.hasMoreTokens()) {
  String token = tokenizer.nextToken();
  System.out.println(token);
}
```

输出三个水果。



#### 数组

静态数组。

##### 创建

###### 一维

声明格式：

```java
数据元素类型 数组名字[];
数据元素类型[] 数组名字; //不要写数字
```

创建并初始化：(默认值全0)

```java
变量名 = new 类型名[长度];
变量名 = new 类型名[]{值, ...};//这时候不可以写长度，初始化或赋值
变量名 = {值, ...};//只可以用在初始化
```

声明和创建可以合在一起。

例如：

```java
int[] a, b;
a = new int[10];
b = new int[15];
System.out.println(a.length + b.length);
String c[], d[];
c = new String[5];
d = new String[8];
System.out.println(c.length + d.length);
```

```java
int a[] = new int[4];
int[] b = new int[4];
System.out.println(a[3] + b[3]);
```

```java
int a[] = new int[] { 1, 2 };
int[] b = new int[] { 3, -4 };
System.out.println(a[1] * b[1]);
```

```java
int[] c; //或int c[];
c = new int[] { 1, 2, 6 };
System.out.println(c[1] | c[2] | c[0]);
```

###### 二维

声明格式：

```java
数据元素类型 数组名字[][];
数据元素类型[][] 数组名字;
```

创建：

```java
数组名字 = new 类型[长度][长度];
数组名字 = new 类型[长度][];
数组名字[下标] = new 类型[长度];
```

一步到位：

```java
数据元素类型 数组名字[][] = {{},{},...,{}};
数据元素类型 数组名字[][] = new 类型[][]{{},{},...,{}}; 
//或数据元素类型[][] 数组名字 但有{}时不能填数字 不能有其他类型值
```

例如：

```java
int a[][], b[][][];
a = new int[5][6];
b = new int[2][3][4];
System.out.println(a.length * b[1][1].length);
```

```java
int[][][][] c, d;
c = new int[2][4][2][];
c[0][0][0] = new int[13];
c[0][0][1] = new int[14];
d = new int[20][3][4][2];
System.out.println(c[0][0][0].length + c[0][0][1].length + d.length);
```

```java
int x[][] = { { -1, -2 }, { 3, 4 } };
System.out.println(x[0][1] * x[1][0]);
x[0] = new int[]{5,-6};
```

##### 方法

加载：`import java.util.Arrays;`

###### length

长度(当前维的) (不需要用Arrays)

###### fill

`Arrays.fill(数组, 值)`  即memset

`Arrays.fill(数组, a, b, c)` 对下标子段$[a,b)$填充 $c$，越界会报错

如：

```java
import java.util.Arrays;
//...
int a[] = new int[5];
Arrays.fill(a, 2, 5, 998244353);
System.out.println(a[4]);
```

###### sort

`Arrays.sort(数组)`升序排序一个数组(数值和字符串排序依据不一样)

可以自定义排序依据。

如：

```java
int x[] = { 15, 8, 666 };
Arrays.sort(x);
String y[] = { "15", "8", "666" };
Arrays.sort(y);
for (int i = 0; i < x.length; ++i) {
    System.out.print(x[i]);
    System.out.println(" " + y[i]);
}
```

```java
int[][] a = {{3, 2, 1}, {1, 4, 2}, {2, 3, 5}, {4, 1, 3}};
Arrays.sort(a, new Comparator<int[]>() {
    @Override
    public int compare(int[] o1, int[] o2) {
        return o1[0] - o2[0];
    }
});
```

java8 箭头表达式简写：

```java
Arrays.sort(rs, (a,b)->{
    if (a[0] != b[0]) return a[0] - b[0];
    return a[1] - b[1];
});
```



###### copyOf

复制 `Arrays.copyOf(原数组, 新长度)`

新长度与原数组长度不需要一致，可以大于或小于

###### copyOfRange

`Arrays.copyOf(原数组, a, b)` 取原数组子段$[a,b)$ 长度就是$b-a$

可以强转类型，加参数 `原类型[].class` ，如：

```java
Integer xx[] = Arrays.copyOfRange(a2.toArray(), 0, a2.size(), Integer[].class); // Object[]转Integer[]
```

###### toString

`Arrays.toString`

```java
System.out.println(Arrays.toString(new int[] {1,1,4,5,1,4}));
//[1, 1, 4, 5, 1, 4]
```



###### stream

是静态方法。传入一个数组参数，获得流。对流，可以使用方法 `mapToInt(方法)` ，方法是原流的方法，如 `Integer::valueOf` ，然后得到的值使用 `toArray()` 方法，可以将类数组转基本数据类型数组，如：

```java
int dest[] = Arrays.stream(xx).mapToInt(Integer::valueOf).toArray();// Integer[]转int[]
```

> java 8 新特性

###### binarySearch

`Arrays.binarySearch(数组, v)` 若包含在升序数组内，返回下标，否则返回插入$v$后，$v$所应在下标的相反数。

若 `(数组,a,b,v)`  在子段$[a,b)$搜索

##### 排序

结构体：以 height 逆序为例

```java
import java.util.Arrays;

class Solution {
    class Node implements Comparable<Node> {
        public String name;
        public int height;

        public Node(String name, int height) {
            this.name = name;
            this.height = height;
        }

        @Override
        public int compareTo(Node o) {
            return o.height - this.height;
        }

    }

    public String[] sortPeople(String[] names, int[] heights) {
        int n = names.length;
        Node[] a = new Node[n];
        for (int i = 0; i < n; ++i) {
            a[i] = new Node(names[i], heights[i]);
        }
        Arrays.sort(a);
        String res[] = new String[n];
        for (int i = 0; i < n; ++i) {
            res[i] = a[i].name;
        }
        return res;
    }
}
```

```java
class Solution {
    public String[] sortPeople(String[] names, int[] heights) {
        int n = names.length;
        Integer[] indices = new Integer[n];
        for (int i = 0; i < n; i++) {
            indices[i] = i;
        }
        Arrays.sort(indices, (a, b) -> heights[b] - heights[a]);
        String[] res = new String[n];
        for (int i = 0; i < n; i++) {
            res[i] = names[indices[i]];
        }
        return res;
    }
}
```



### 运算

#### 基本运算

##### 运算符

可以连等号赋值。

```java
int x, y, z;
x = y = z = 8;
System.out.println(x * y * z);
```

普通算术运算大体同C (同理有整数除法)

```java
int x = 7, y = 2;
double z = x / y;
System.out.println(z);
```

> 零除会报错 `ArithmeticException`

有实数取模。模数是负数时好像同正数对待。

```java
double x = 7.1, y = 7.0;
System.out.println(-x % y);//-0.1
System.out.println(x % -y);//0.1
System.out.println(-x % -y);//-0.1
```

关系运算符、逻辑运算符、自增自减运算符同C。&&和||也是短路运算符。短路是会有dead code的warning

> 不能脱离赋值或判断单独调用一段表达式，不然会报错。

注意&& ||两边必须是布尔值，不能直接放int上去。如：

```java
public class Main {
    public static void main(String[] args) {
        int x = 0;
        boolean y = false && ++x != 0;
        boolean z = false || ++x != 0;
        System.out.println(x);
    }
}
```

位运算符同C。新增无符号右移 `>>>`，对普通右移，若最高位是0，空位填$0$，否则$1$。对无符号右移，都填0。实际上即把负数转化后转成正数。正数则一般处理，如：

```java
int x = 4, y = -4;
System.out.println(x >> 1); //2
System.out.println(x >>> 1); //2
System.out.println(y >> 1); //-2
System.out.println(y >>> 1); //2147483646
System.out.println(x >> 2); //1
System.out.println(x >>> 2); //1
System.out.println(y >> 2); //-1
System.out.println(y >>> 2); //1073741823
```

##### 优先级

整体优先级：

1. 自增自减
2. 算术运算
3. 比较运算
4. 逻辑运算
5. 赋值运算

详细：

1. `()`
2. `+,-` 正负号
3. `++,--,!`
4. `* / %`
5. `+ -` 二元运算
6. `>> >>> <<`
7. `< <= > >=`
8. `== !=`
9. `&`
10. `^`
11. `|`
12. `&&`
13. `||`
14. `?:`
15. `=` 和各种赋值如 `+=`

如：

```java
int a = 4, b = 6, c = 8;
System.out.println(++a * b-- - c); //30-8=22
```





### 输入输出

#### 标准I/O

##### 输出

###### System.out

`System.out.println`，简写为syso，只能传一个参数，可以不传(输出单个空行)。功能类似python的print。`ln`的意思是 `line`，所以是小写LN。可以输出 null(显示

null)。

`System.out.print`，区别在于不输出换行。

`System.out.printf` ，用法大体同 C/C++。

##### 输入

使用Scanner，需要事先载入：

`import java.util.Scanner; `

创建一个新的对象用于读标准输入：(也可以读字符串)

`Scanner sc = new Scanner(System.in);`

读整数(作为返回值返回)：

`sc.nextInt()`

> 同理有：
>
> - next()  读字符串
> - nextLine()
> - nextDouble()
> - nextLong()
> - …… (具体看tab补全列表)

> 建议不要 `sc.close()`，否则将不能再次new。即忽略warning信息。

> 输入异常会报错 `InputMismatchException`

### 流程控制

#### 复合语句

复合语句(大括号)可以直接出现在任何地方(不需要if等关键字也行)。复合语句会确定一个作用域。这为局部变量的生存期设置提供了便利。

#### 条件语句

特别注意逻辑表达式一定要是boolean，不可以出现 `if(1)`等语法。

if的语法同C

switch的case可以是字符串(JDK1.7)。仍不可以是实数。

如：

```java
String x = "lr580";
if (true) {
    switch (x) {
        case "lr":
            System.out.println("蛤蛤大笑");
            break;
        case "lr580":
            System.out.println("That's me.");
            break;
    }
}
```

```java
int a = 0;
out: while (a < 5) {
    switch (a) {
        case 0:
        case 3:
            a += 2;
        case 2:
            break out;
        default:
            a += 5;
    }
}
System.out.println(a); //2
```



特别注意 `?:` 会带来类型一致性转换，如：

```java
System.out.println("a=" + ((5 < 5) ? 5.1 : 4));//4.0
```



#### 循环语句

同理有while,do-while,for。语法同C。C++11的foreach方法也有，如：

```java
int arr[] = { 6, 4, 1 };
for (int x : arr) { //但是不可以不int(即不能预先定义x)
    System.out.println(-x);
}
```

可以用 `标签:`建立一个标签点(命名规则同标识符)，在break或continue后加标签来跳出多层循环。

```c++
loop1: for (int i = 1; i < 10; ++i) {
    for (int j = 1; j < 10; ++j) {
        if (i * i + j * j > 83)
            break loop1; //改成continue也行，等效于直接break
        System.out.println(i * 10 + j);
    }
}
```

### 对象

#### 基本概念

> 面向对象的三个基本特征：封装、继承、多态。

##### 类成员

对象是类的实例，类是对象的抽象。类是同一事物的统称。类是组成java程序的最小的单位

有类成员：类成员方法和类成员变量。成员变量有默认初始值。

类成员方法不支持默认参数和可变参数。

> 创建对象时必须先声明对象，为对象分配内存空间，对对象初始化，然后才能使用对象

类成员默认值是 0 。

举例：

```java
public class c701 {
    private String name = "";// 类成员变量

    public String getname() {
        int id = 0;
        if (name.equals("")) { //name.length==0说没有length，因为是方法
            setname("yyy");
        }
        return name + "qwq" + id;
    }

    public void setname(String v) {// 当然也可以弄私有private方法
        name = v;// 若参数与成员函数重名，可以用this.name区分
    }

    public c701 itself() {
        return this;// this是引用
    }
}
```

```java
//同一文件夹下的另一个代码文件
import c701;

public class c702 {
    public static void main(String[] args) {
        c701 obj = new c701();
        System.out.println(obj.getname());
        c701 o2 = obj.itself();// 指针作用
        o2.setname("lr580");
        System.out.println(o2.getname());
    }
}
```

> 当然实际上合在一起也可以的，就是不需要用public了，把c701改成一个跟文件名无关的类名

```java
public class c2506 {
    public int x;
    public static void main(String[] args) {
        System.out.println(new c2506().x);
    }
}
```



##### 修饰符权限

修饰符权限：

| 访问包位置       | private | protected | public |
| ---------------- | ------- | --------- | ------ |
| 本类             | 可见    | 可见      | 可见   |
| 同包其他类或子类 | 不可见  | 可见      | 可见   |
| 其他包的类或子类 | 不可见  | 不可见    | 可见   |

若不声明，那么这个类预设为包存取范围，即只有一个包中的类可以调用这个类。方法和类都可以不声明。

类不能声明为 `private`或 `protected`，否则无法被调用。(内部类除外)

##### 构造函数

`public 类名(参数)`

同C++，无返回值。但可以不定义构造函数。定义一个 private 的构造函数可以禁止创造该对象的实例。

构造方法不能被继承，所以不能被重写。通常而言，构造函数放 `public init` 为将来功能扩展重写准备。

无参构造让继承不报错(默认调用父类无参构造)。

> 构造函数可以设置默认参数 (实际会报错)。

举例：

```java
class circle {
    final private static double pi = Math.acos(-1);

    private double r = 0;

    circle() {
    } // 若允许不写参数则必须要有，如下面的c

    circle(double x) {
        r = x;
    }

    protected double getArea() {
        return pi * r * r;
    }
}

public class c802 {
    public static void main(String[] args) {
        circle c = new circle();
        System.out.println(c.getArea());
        circle d = new circle(2);
    }
}

```

默认构造函数在java可以省略，如：

```java
class obj {
    private String v;

    public obj(String u) {
        v = u;
    }

    public void out() {
        System.out.println(v);
    }
}

//...

obj a[] = new obj[10];
// obj b = new obj; 但是非数组不能使用空构造
// a[0].out();// 未定义值不能用
obj c = new obj("www");
c.out();
```

复用构造函数用this，如：

```java
package plugin;

import javax.swing.JLabel;

public class FsLabel extends JLabel {
    private final static int default_size = 14;
    
    public static String font_size(String s, int siz) {
        return "<html><div style='font-size=" + siz + "'>" + s + "</div></html>";
    }

    public FsLabel(String s, int siz) {
        super(font_size(s, siz));
    }

    public FsLabel(String s) {
        this(s, default_size);// 不能写FsLabel
    }

    public FsLabel() {
        this("", default_size);
    }
}

```





##### static

由static修饰的变量、常量、方法称为静态变量、常量、方法。静态方法不能被重写。又称类变量，与实例变量区分。类变量可以通过类名/对象名访问。

> 静态方法存在方法区，跟类信息一起。对象存堆区。
>
> 类变量应在声明/静态块指定初始值。

意义同C++。声明了static的是静态成员。可以用类名.静态成员调用(也可以不用，但是会扔警告)

同样遵循修饰符权限(同C++，关键字顺序无关)

> 在 JVM 生命周期里，每个类只被加载一次，时机为：
>
> - 第一次创建对象 / 调用静态方法/属性 / 加载子类
>
>   访问静态常量，如果编译器可以计算出常量的值不加载 ，例如 final 不触发
>
> - 创建对象引用不加载类
>
> - 子类调用父类静态方法，若当子类没有覆盖父类的静态方法时，只加载父类，不加载子类；否则父子都加载

有静态代码块，可以放在类的任何位置，可以有多个，在类初次被加载的时候执行且仅会被执行一次，一般用来初始化静态变量和调用静态方法。如：

```java
class stt {
    public static final double y = Math.PI; //final不触发static
    public static int x = 3;
    static {
        System.out.println("awa");
        x = 10;
    }
}

public class ce08 {

    public static void main(String[] args) {
        System.out.println("a");
        System.out.println(stt.y);
        System.out.println(stt.x);
    }
}

```



##### 主方法

`public static void main(String[] args)`

静态方法，所以如果主方法需要调用类的其他方法，被调用方法必须是静态的(原因见C++)

> 在Eclipse可以设置参数args
>
> 右击项目名字-run as - run configuration- 找到arguments(参数换行或空格隔开)，然后点run即可，就可以设置args来运行主方法
>

事实上，由于主方法的静态性，可以在主方法建立一大堆本类的对象实例，调用它们自己的非静态成员。

##### public类

对一个代码文件只能有一个public类且必须与文件名(不含后缀)同名。其他类只能不要加权限修饰关键字，如直接 `class obj{...}`

> 这个与文件同名的类也可以不声明public，但是即使这样也不能给别的类public



##### 可变参数

语法是 `类型...变量名` ，使用方法和限制类似 `python` 即：必须是最后一个参数且只能有一个可变参数

```java
public class c1603 {
    public static void main(String[] args) {
        System.out.println(powsum(1, 2, 3));
        System.out.println(powsum());
        System.out.println(apowsum(3, 4, 5));
    }

    public static int powsum(int... a) {
        int r = 0;
        for (int i = 0; i < a.length; ++i) {
            r += a[i] * a[i];
        }
        return r;
    }

    public static int apowsum(int p, int... a) {
        int r = 0;
        for (int i = 0; i < a.length; ++i) {
            int k = 1;
            for (int j = 0; j < p; ++j) {
                k *= a[i];
            }
            r += k;
        }
        return r;
    }
}

```



##### 对象

###### 基本

不用析构函数，java会自动清理。

创建方法：`类名 实例名= new 类名(构造函数参数)`

真正的操作标识符的实质是引用，即上面的实例名其实是一个引用。通常可以认为引用就是对象，虽然事实上是对象包含它的一个引用

若两个对象是同一个对象的引用，`==`运算符会返回true。而equals方法才是比较内容是否相等。(未定义时即便每个成员变量都相等也不false)

将一个引用赋值为null(根据上述分析，可知等于直接把对象设置为null)，会自动清理该对象，析构销毁(使用finalize方法，是一个protected方法，可以自定义)。

`System.gc()`方法强制启动清理。

多态：需要使用基类对象的任何地方都可以用派生类对象来替代

如：

```java
Object obj = new Date();
System.out.println(((Date)obj).getDate()); //使用派生类方法
System.out.println(obj.getClass());
System.out.println(obj.getClass().getClass());
System.out.println(obj.getClass().getClass().getClass());
```

应用：编写一个函数时，使用对象参数时，往往使用基类作为对象(或Object)。

###### 对象数组

new一个对象数组时，只分配内存，不调用默认构造函数。

所以new一个对象数组时，还要对每一个要用到的元素new一下调用构造函数。

不可以用Arrays.fill来填充全部new，如 `Arrays.fill(arr, new obj());`，这样是浅复制，即它们是同一个对象。

如：

Object类(对象类)是所有类的基类

具有equals,getClass,hashCode,toString方法

> mvc   redis高可用   nginx



#### 包装类

将基本类型(非对象)封装成类。其中Integer类、Long类、Short类是Number的子类。

JDK1.5 后，提供：自动装箱(基本数据类型直接赋值给对应包装类)、自动拆箱(反过来)

##### Integer

###### 基本

构造可以new+Integer，参数是int或String（报错说JDK9后抛弃了该方法），也可以直接赋值。如：

```java
Integer v = new Integer(580);
Integer w = new Integer("581");
Integer x = 3, y = 4;
System.out.println(x + y + v + w);
```

> 若String参数不是整数数值，报错 `NumberFormatException`。因为装箱不可以隐式类型装换。

###### 常用方法

1. byteValue()  转byte
2. shortValue() 转short
3. compareTo()  返回$1,0,-1$的一个(严格是正数零负数)，代表大小关系
4. equals() 返回Boolean
5. toString() 转String
6. toBinaryString() 转二进制文本(不含前导符号)
7. toHexString() 转十六进制文本(不含前导符号)
8. toOctalString() 转八进制文本(不含前导符号)
9. valueOf(String str) 返回Integer
10. parseInt(String str) 返回int

位运算内置(静态方法)：

1. bitCount(x) 统计 1 的个数
2. lowestOneBit(x) lowbit

如：

```java
String str[] = { "89", "23", "580" };
for (String s : str) {
    System.out.println(Integer.parseInt(s));
}
```

```java
Integer v = 580;
System.out.println(Integer.toHexString(v));
System.out.println(String.format("%x", v));
System.out.println(Integer.toOctalString(v));
System.out.println(String.format("%o", v));
System.out.println(Integer.toBinaryString(v));// 无format
System.out.println(v.toString());// 其他toString不能这样
System.out.println(Integer.toString(v));
```

> 特别注意\=\=运算符和equals类成员方法的差别，对\=\=：
>
> 1. 无论如何，Integer与new Integer不会相等。不会经历拆箱过程，因为它们存放内存的位置不一样。
> 2. 两个都是非new出来的Integer，如果数在$[-128,127]$，则是true,否则为false。
> 3. 两个都是new出来的,则为false。
> 4. int和integer(new或非new)比较，都为true，因为会把Integer自动拆箱为int，其实就是相当于两个int类型比较。
>
> 具体而言，对 Object ，所有 `==` 比较的是两个对象地址是否相等。因为采用了缓存，所以所有 `[-128,127]` 的值的地址都是相等的，而在这之外的值没有缓存，会新建，故地址不一样。(整型字面量的值这之间，那么不会 new 新的 Integer 对象，而是直接引用常量池中的 Integer 对象)点进源码可以看 `IntegerCache` 方法。127 可以调更高。同理，Short, Byte, Long 也做了一样区间的缓存，但不可调。
>
> 如：
>
> ```java
> Integer n = 13, m = new Integer(13);
> System.out.println(n == m);
> Integer x = 580, y = 580;
> System.out.println(x == y);
> System.out.println(x.equals(y));
> Integer a = -128, b = -128;
> System.out.println(a == b);
> Integer p = new Integer(1), q = new Integer(1);
> System.out.println(p == q);
> System.out.println(x == 580);
> ```
>
> 特别注意，如果要比较不同的 Number 类的值， equals 是不行的，要转，如：
>
> ```java
> Integer i = 100;
> Double d = 100.0;
> System.out.println(i.doubleValue() == d.doubleValue());
> ```



###### 常量

MAX_VALUE $2^{31}-1$

MIN_VALUE $-2^{31}$

SIZE 二进制位数 32

TYPE  输出int

##### Boolean

###### 基本

构造函数可以传boolean或字符串，当不分大小写字符串内容为true时返回true。也可以直接赋值布尔值，如：

```java
Boolean b = new Boolean("TrUe");
System.out.println(b);
Boolean a = true, c = false;
System.out.println(a && c);
```

###### 常用方法

1. booleanValue() 返回boolean
2. equals(obj) 当表示同一个值的boolean对象时返回true
3. parseBoolean(String s) 返回boolean
4. toString() 返回string
5. valueOf() 返回boolean

```java
Boolean x = true, y = true, z = false;
System.out.println(x.equals(y));
System.out.println(z.equals(0));
System.out.println(Boolean.parseBoolean("y")); //false
```

###### 常量

TRUE FALSE TYPE

##### byte

基本类似Integer，有新的方法：

1. doubleValue()

##### character

###### 基本

```java
Character a = 'c', b = new Character('d');
System.out.println(a + b - 97 * 2);
```

###### 常用方法

1. charValue()  返回char
2. compareTo(v) 返回int
3. equals(obj)  返回Boolean
4. toUpperCase(char ch) 返回char
5. toLowerCase(char ch) 返回char
6. toString() 返回String
7. charValue()
8. isUpperCase(char ch)  返回boolean
9. isLowerCase(char ch)  返回boolean

###### 常量

CONNECTOR_PUNCTUATION 返回byte，表示Unicode规范常规类别"Pc"

UNASSIGNED byte "Cn"

TITLECASE_LETTER byte "Lt"

##### Double

还有Float类。跟Integer类似，有别的方法：

1. isNaN()  boolean
2. byteValue()
3. intValue()

常量：

MAX_EXPONENT  int，表示有限double变量可能具有的最大指数

MIN_EXPONENT  int，表示标准化double变量可能具有的最小指数

NEGATIVE_INFINITY double，负无穷大常量

POSITIVE_INFINITY double，正无穷大常量

##### Number

上述的以及BigDecimal, BigInteger的父类 (除了Character, Boolean)

有byteValue(),intValue(),floatValue(),shortValue(),longValue(),doubleValue()

#### 数字处理类

##### 数字格式化

对double和float，主要使用 `java.text.DecimalFormat`

未格式化的数据的表示原则：

- 若$|x|\ge0.001\cap|x|<10^7$，用常规小数
- 否则用科学计数法(e大写)

如：

```java
System.out.println(0.001);
System.out.println(0.0001);
System.out.println(1e7-1);
System.out.println(1e7);
```

`DecimalFormat`是 `NumberFormal`的一个子类。

初始化方法：

```java
DecimalFormat mf = new DecimalFormat(模式);
```

或

```java
DecimalFormat mf = new DecimalFormat();
mf.applyPattren(模式);
```

创造格式化的字符串：

```java
mf.format(值);
```

模式有：

1. `0` 表示一位十进制数字，没有则代表前导0 (整数部分超出会显示)
2. `#` 表示一位十进制数字，没有则留空  (整数部分超出会显示)
3. `.` 小数点
4. `,` 分组分隔符
5. `E` 科学计数法分割符
6. `%` 放在数字前缀或后缀，将数字乘以100显示百分数(会显示%)
7. `\u2030` 放在数字前缀或后缀，将数字乘以1000显示千分数
8. `\u00A4` 放在数字前缀或后缀，作为货币符号 即 `￥`(本机)
9. `'` 单引号，转义上述特殊字符

> `-` 负号(无论本来是不是负数)

举例：

```java
DecimalFormat mf = new DecimalFormat("-000.0");
System.out.println(mf.format(-2.0 / 3));
mf.applyPattern("##.##%\u00A4'0'");
System.out.println(mf.format(0.4527));
mf.applyPattern("#.#E0");  //后面不可以是#
System.out.println(mf.format(1e11 + 2e10));
mf.applyPattern("##E0");
System.out.println(mf.format(1e11 + 2e10));
mf.applyPattern("#");
System.out.println(mf.format(1e11));
mf.applyPattern("0");
System.out.println(mf.format(1e11));
```

还支持将一个数字按整数位每$k$个位分组(逗号分隔)的功能，从小位到大，类似于英文的大数字表示法，使用：

```java
mf.setGroupSize(k);
```

关闭：

```java
mf.setGroupingUsed(false);
```

如：

```java
DecimalFormat mf = new DecimalFormat();
mf.setGroupingSize(3);
System.out.println(mf.format(1234567.131));
System.out.println(mf.format(123456.131));
mf.setGroupingUsed(false);
System.out.println(mf.format(114514));
```

##### 数学运算

Math类，内建。类方法是static的。

有常数：`Math.PI`,`Math.E`

###### 三角函数

有方法 `sin,cos,tan,asin,acos,atan,toRadians,toDegrees`

单位均为弧度制。注意会有误差。

```java
System.out.println(Math.toDegrees(Math.asin(1.0 / 2)));
System.out.println(Math.sin(Math.toRadians(30)));
```

###### 指数函数

`exp,log,log10,sqrt,cbrt,pow`，其中$\log=\ln$,`cbrt`是立方根

###### 取整函数

`ceil,floor,rint,round`

其中 `rint`返回与参数最接近的整数，若同样接近取偶数

$round(x)=\lfloor x+0.5\rfloor$ (即+0.5后强转)

如：

```java
System.out.println(Math.rint(1.5)); //2.0
System.out.println(Math.rint(2.5)); //2.0
System.out.println(Math.rint(-1.5)); //-2.0
//-2.5也是0； -0.5是0
System.out.println(Math.round(1.5)); //2 ,返回long
```

```java
System.out.println(Math.round(0.5)); //1
System.out.println(Math.round(-0.5)); //0
System.out.println(Math.round(-1.5)); //-1
System.err.println(Math.round(-0.001)); //0
System.err.println(Math.round(-0)); //0
```

```java
System.out.println(Math.floor(-0.9)); //-1.0
System.out.println(Math.floor(-1.9)); //-2.0
System.out.println(Math.floor(1.9)); //double, 1.0
```

```java
System.out.println(Math.floor(-0.0)); //-0.0
System.out.println(Math.floor(0.0));  //0.0
System.out.println(Math.floor(0.1));  //0.0
System.out.println(Math.ceil(0.0));  //0.0
System.out.println(Math.ceil(-0.0));  //-0.0
System.out.println(Math.ceil(-0.1));  //-0.0
System.out.println(Math.ceil(-1.1));  //-1.0
```





###### 其他函数

`max,min,abs,signum`

`signum`是$sgn$函数(但返回double)。

##### 随机数

###### Math.random

产生$[0,1)$的随机数

可以通过 `(int)(n*Math.random())`获取$[0,n)$的随机整数，可以再通过偏移得到任意区间如 `a+(int)((b-a)*Math.random())`

如：生成随机密码代码

```java
public static String ranpsw(int len) {
    StringBuilder res = new StringBuilder();
    for (int i = 0; i < len; ++i) {
        int c = (int) (3 * Math.random());
        if (c == 0) {
            res.append((char) ('a' + Math.random() * ('z' - 'a' + 1)));
        } else if (c == 1) {
            res.append((char) ('A' + Math.random() * ('z' - 'a' + 1)));
        } else {
            res.append((char) ('0' + 10 * Math.random()));
        }
    }
    return res.toString();
}
```

###### Random类

`import java.util.Random;`

构造函数可以传入一个种子参数(可以不传，那么会随便造一个)。常用方法：

- nextInt() 随机整数(int范围内)
- nextInt(n) 随机整数$[0,n)$
- nextLong()
- nextBoolean()
- nextFloat()
- nextDouble()
- nextGaussian() 概率密度为高斯分布的双精度值

###### UUID

连字符分割的 32 个 16 进制数。

```java
import java.util.UUID;
UUID.randomUUID().toString()
```

将 128 位的数字划分为 5 个部分，其中第 1 部分为 8 个字符，第 2、3 部分各为 4 个字符，第 4、5 部分各为 12 个字符。这些部分之间使用连字符 "-" 连接起来，形成一个长度为 36 的字符串

- 第 1 部分是时间戳的高位部分。
- 第 2 部分是时间戳的中间部分。
- 第 3 部分是时间戳的低位部分。
- 第 4 部分是节点 ID 的高位部分。
- 第 5 部分是节点 ID 的低位部分和随机数部分的组合。

--GPT

##### 大数字运算

`java.math.BigInteger`,`java.math.BigDecimal` 高精度运算

###### BigInteger

构造函数只能传字符串。可以直接输出。

方法：(注意不会改变lhs本身)

- add, subtract, multiply, divide
- remainder 取模
- divideAndRemainder 返回数组，第一个是商，第二个是余
- pow(指数是int不是BigInteger) (应该不是快速幂)
- negate 相反数
- shiftLeft 左移<<(负数右移) 参数是int
- shiftRight 右移>>(负数左移) 参数是int
- and or 位运算
- compareTo
- equals 参数rhs是Ojbect
- min,max
- isProbablePrime(值) 值越大，得到的结果越准确
- toString(进制) 可以返回16进制字符串

如：

```java
BigInteger x = new BigInteger("580");
x = x.add(new BigInteger("1"));
System.out.println(x);
x = new BigInteger("1");
x = x.pow(10000000);
System.out.println(x);
System.out.println(x.isProbablePrime(10));
x = new BigInteger("998244353");
System.out.println(x.isProbablePrime(10));
System.out.println(x.isProbablePrime(2));
System.out.println(x.isProbablePrime(10000));
x = new BigInteger("7");
x = x.shiftLeft(1);
System.out.println(x);
System.out.println(x.and(new BigInteger("2")));
```

###### BigDecimal

方法：

- add subtract multiply divide

divide的设置方法处理小数位：

- ROUND_UP 商的最后一位大于0时向前进位，正负号均如此
- ROUND_DOWN 商的最后一位忽略
- ROUND_CEILING 正up负down 故近似值$\ge$实际值
- ROUND_FLOOR 负up正down 故近似值$\le$实际值
- ROUND_HALF_DOWN 商四舍五入$\le5$舍弃否则进位
- ROUND_HALF_UP $<$5舍弃否则进位
- ROUND_HALF_EVEN 商倒数第二位奇数halfup否则halfdown

要调用，三个参数，第一个是rhs,第二个是商小数点保留位数，第三个是处理方式，如 `BigDecimal.ROUND_UP`

### 内建函数

#### 系统相关

##### 计时计内存

###### 时间

计时用 `System.currentTimeMillis()`返回当前时间戳(单位毫秒，数据类型 `long`)，在开始计时和结束计时，然后相减即可得到这一段时间的毫秒数。

其他函数：`System.nanoTime()`

###### 内存

计内存用：

```java
Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()
```

返回一个 `long`，单位是字节。



###### 外存

```java
package test2;

import java.io.File;
import java.lang.management.ManagementFactory;
import java.lang.management.OperatingSystemMXBean;
import java.lang.reflect.Method;
import java.util.Date;

public class sysInfo {
    private final static int gbunit = 1024 * 1024 * 1024;

    private void getDiskInfo() {
        System.out.println("硬盘使用状态：");
        File[] disks = File.listRoots();
        for (File disk : disks) {
            double free = 1.0 * disk.getFreeSpace() / gbunit;
            double total = 1.0 * disk.getTotalSpace() / gbunit;
            double used = total - free;
            System.out.print(disk.getPath() + " ");// 如C:\
            System.out.print("未使用" + String.format("%.2f", free) + "GB ");
            System.out.print("已使用" + String.format("%.2f", used) + "GB ");
            System.out.println("总容量" + String.format("%.2f", total) + "GB");
        }
    }

    private void getMemInfo() {
        System.out.println("分配给服务器的内存信息：");
        System.out.print("空闲内存大小:"
                + String.format("%.2f", 1.0 * Runtime.getRuntime().freeMemory() / gbunit) + "GB ");
        System.out.println("总内存大小:"
                + String.format("%.2f", 1.0 * Runtime.getRuntime().totalMemory() / gbunit) + "GB");
    }

    private void getSysMemInfo() {
        System.out.println("服务器总内存信息：");
        boolean ibmVendor = System.getProperty("java.vendor").contains("IBM");
        int totalMb = 0;
        int freeMb = 0;
        Class<?> beanClass;
        OperatingSystemMXBean bean = ManagementFactory.getOperatingSystemMXBean();
        try {

            if (ibmVendor) {
                beanClass = Class.forName("com.ibm.lang.management.OperatingSystemMXBean");
            } else {
                beanClass = Class.forName("com.sun.management.OperatingSystemMXBean");
            }
            Method getTotalPhysicalMemorySize = beanClass
                    .getDeclaredMethod("getTotalPhysicalMemorySize");
            Method getFreePhysicalMemorySize = beanClass
                    .getDeclaredMethod("getFreePhysicalMemorySize");
            totalMb = (int) (Long.valueOf(getTotalPhysicalMemorySize.invoke(bean).toString()) / 1024
                    / 1024);
            freeMb = (int) (Long.valueOf(getFreePhysicalMemorySize.invoke(bean).toString()) / 1024
                    / 1024);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.print(String.format("总内存：%dMB ", totalMb));
        System.out.print(String.format("剩余内存：%dMB ", freeMb));

        int cores = Runtime.getRuntime().availableProcessors();
        System.out.println(String.format("总核数：%d", cores));
    }

    public void printNow() {
        Date now = new Date();
        System.out.println(
                String.format("现在时间是: %tY年%tm月%td日 %tH:%tM:%tS", now, now, now, now, now, now));
    }

    public void printSysInfo() {

        System.out.println("服务器运行状态：");
        getDiskInfo();
        getMemInfo();
        getSysMemInfo();
    }

    public static void main(String[] args) {
        sysInfo ths = new sysInfo();
        ths.printSysInfo();
    }
}
```





##### 执行 cmd

使用 `try..except` 。方法是：`Runtime.getRuntime().exec(指令字符串)`

例如：

```java
String cmd1 = "mysqladmin -h 127.0.0.1 -u root -p1 create test";
String cmd2 = "cmd /c mysql -h 127.0.0.1 -u root -p1 test < tb_thu.sql";
try {
    Runtime.getRuntime().exec(cmd1);
}catch(Exception e){
    System.out.println("Database \"test\" already exists.");
}
try{
    Runtime.getRuntime().exec(cmd2);
    System.out.println("Import database \"test\" successfully.");
} catch (Exception e) {
    e.printStackTrace();
}
```



### 其他

#### native

[参考](https://blog.csdn.net/funneies/article/details/8949660?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-8949660-blog-125702170.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-8949660-blog-125702170.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=2)

修饰方法的关键字，表示该方法的实现不在当前文件，而使用 C/C++ 等实现的文件。

JNI 是 Java native interface，是 JDK 的一部分，允许 java 代码使用其他语言的代码。



#### 二级考试

杂项知识点补充：

##### 杂项

文档注释： `/** */` ，可以写各种特殊内容，如HTML， `@` 在注释里，每行都有 `*`

Timer 是定时器，在 `java.util.Timer` ，对应执行任务类 `TimerTask` ，有 `run` 方法， `cancel` 方法。定时器本身有 `schedule` 方法。

`Long d = (Long) (long) 3;` 正确，省去 `(long)` 会报错。

变量命名可以用 `$` 。

##### Applet

[Applet](https://www.runoob.com/java/java-applet-basics.html) 是 Java 程序的一种，一般运行在支持 Java 的浏览器，有完整 Java API (Application Programming Interface，应用程序接口) 支持：

- Java 中 Applet 类继承了 java.applet.Applet 类。
- Applet 类没有定义 main()，所以一个 Applet 程序不会调用 main() 方法。
- Applet 被设计为嵌入在一个 HTML 页面。
- 当用户浏览包含 Applet 的 HTML 页面，Applet 的代码就被下载到用户的机器上。
- 要查看一个 Applet 需要 JVM。 JVM 可以是 Web 浏览器的一个插件，或一个独立的运行时环境。
- 用户机器上的 JVM 创建一个 Applet 类的实例，并调用 Applet 生命周期过程中的各种方法。
- Applet 有 Web 浏览器强制执行的严格的安全规则，Applet 的安全机制被称为沙箱安全。
- Applet 需要的其他类可以用 Java 归档（JAR Java Archive）文件的形式下载下来。

Applet 类中的四个方法给我们提供了一个框架，你可以在该框架上开发小程序：

- **init:** 该方法的目的是为你的 Applet 提供所需的任何初始化。在 Applet 标记内的 param 标签被处理后调用该方法。
- **start:** 浏览器调用 init 方法后，该方法被自动调用。每当用户从其他页面返回到包含 Applet 的页面时，则调用该方法。
- **stop:** 当用户从包含 Applet 的页面移除的时候，该方法自动被调用。因此，可以在相同的 Applet 中反复调用该方法。
- **destroy:** 此方法仅当浏览器正常关闭时调用。因为 Applet 只有在 HTML 网页上有效，所以你不应该在用户离开包含 Applet 的页面后遗漏任何资源。
- **paint:** 该方法在 start() 方法之后立即被调用，或者在 Applet 需要重绘在浏览器的时候调用。paint() 方法实际上继承于 java.awt。

如：

```java
import java.applet.*;
import java.awt.*;
 
public class HelloWorldApplet extends Applet
{
   public void paint (Graphics g)
   {
      g.drawString ("Hello World", 25, 50);
   }
}
```

Applet 是一种 Java 程序。它一般运行在支持 Java 的 Web 浏览器内。因为它有完整的 Java API 支持,所以 Applet 是一个全功能的 Java 应用程序。

`<applet>` 标签是在HTML文件中嵌入 Applet 的基础。以下是一个调用"Hello World"applet的例子；

```java
<html>
<title>The Hello, World Applet</title>
<hr>
<applet code="HelloWorldApplet.class" width="320" height="120">
If your browser was Java-enabled, a "Hello, World"
message would appear here.
</applet>
<hr>
</html>
```



通常情况下，Applet 不能进行文件的 I/O 操作，必须嵌入在 HTML 页面中才能解释、执行，生命周期四个状态为初始态、运行态、停止态和消亡态

Applet 能执行任何本地计算机上的程序是错的。Applet 的 `init` 方法在生存周期只能调用一次。



##### swing

`ComponentEvent` 的子类有 `InputEvent` , `FocusEvent` , `WindowEvent` 等。 `ItemEvent` 不是它的子类。`TextField` 组件不能添加 `ItemEvent` 监听器，而 `Choice, Checkbox, List` 可以。

Choice 下拉列表框，像 `JCombobox` 。是 `awt` 的，不需要加载 `swing` 。[参考 ](https://qwert.blog.csdn.net/article/details/104744483?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.highlightwordscore&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.highlightwordscore) Choice 制作用于单选的下拉列表

Graphics 的 `clearRect` 是通过使用当前绘图表面的背景色进行填充来清除指定的矩形

`TextField` 组件的 `setChar(char c)` 设置回显字符

颜色定义 Color ，可以传 `0x`十六进制数字， 三个整数参数，三个 `x.xf` 浮点参数。不可以传 Color 常量即 `Color.全大/全小写单词` 到构造函数

错误表述： Panel 类可以作为容器容纳其他组件也可以独立存在 (需要依赖 Frame ?) 

与菜单相关的类主要有三个， `MenuBar, Menu, MenuItem`

Canvas 代表屏幕上一块空白矩形区域

`CardLayout` 是多个重叠在一起的布局管理器(一次只能看到一张卡片，容器则充当卡片的堆栈，默认显示第一张卡片)，方法有 `first, last, next, previous, show, add` ，参数是 Container 。



## 核心技术

### 类

#### 继承

继承使用extends+父类。不允许多重继承。

子类中，可以用super表示父类，则可以用super()调用父类构造方法,super.成员调用父类成员。可以调用的有public和protected方法、属性。

继承可以重写(覆盖)父类成员方法，即同名函数，但修改实现内容、存储权限或返回值类型(后者基于J2SE5.0或以上编译器)。若只有实现内容不一样，称为重构。

声明了final的函数不可以被子类重写。声明了final的类不可以被继承。

重写时修饰权限只能从小的范围到大的范围改变。如protected可以改为public，但不能改为private。重写方法名、参数序列、返回值必须跟父类一致(或小于等于(子类))。重写抛出的异常不可以比父类更宽泛。且 private 方法无法重写(即不能加 @override, 声明出来认为是新的方法)。(区别重载，见下文)。构造方法不能重写。

实例化子类对象时，父类无参构造函数将会被自动调用。有参构造函数只能使用super显式调用。

若使用finalize清理，需要保证子类最后一个动作是调用父类的finalize。

如：

```java
class obj1 {
    int v1, v2;

    obj1() {
        v1 = v2 = 0;
    }

    obj1(int a, int b) {
        v1 = a;
        v2 = b;
    }

    public void f() {
        System.out.println(v1 + v2);
    }

    public void set(int a, int b) {
        v1 = a;
        v2 = b;
    }
}

class obj2 extends obj1 {
    obj2() {
    }

    obj2(int a, int b) {
        super(a, b);
    }

    public void f() {
        System.out.println(v1 * v2);
    }

    public void g() {
        super.f();
    }
}

//main
obj2 v = new obj2();
v.g();
v.set(3, 4);
v.f();
v.g();
obj2 u = new obj2(5, -5);
u.f();
```

#### Object类

`java.lang.Object `内建 是所有类的父类(即省略extends Object时也是其子类)

Object类的 `getClass, notify, notifyAll, wait`方法是fianl类

> 还有 finalize 方法，认为是析构函数，GC 调用该方法清理该对象。对一个对象只能调用一次。何时和是否调用不确定，不推荐主动调用。

##### 常用方法

###### getClass

返回类为Class的实例，Class有getName()方法，取类名。

输出上的区别是不用getName有 `class `。类名就是 `java.xxx.yyy...`

如：

```java
BigInteger x = new BigInteger("3");
System.out.println(x.getClass());
System.out.println(x.getClass().getName());
System.out.println(x.getClass().getName().getClass());
```

更多方法参见下文 `Class` 类。

> `实例.getClass()` 等效于 `类名.class`

###### toString

默认返回 `运行时类名@十六进制hashcode值`。如 `test3.t04_2@15db9742`，哈希值转十进制为 `366712642`

标准输出时等效于先调用toString方法。可以重写该方法，tab补全可以很快获得参数，如：

```java
class obj3 {
    int v;

    obj3(int x) {
        v = x;
    }

    @Override
    public String toString() {
        return Integer.toString(v);
    }
}

//...
System.out.println(new obj3(114514));
```

###### equals

没有重写时，Object默认以 == 来实现，即比较两个对象的内存地址是否相同(基本数据类型才是值)

同样是常用于重写的方法，如：

```java
// @Override 有会报错
public boolean equals(obj3 rhs) {
    return v == rhs.v;
}

//...
System.out.println((new obj3(13)).equals(new obj3(13)));
```

###### hashCode

返回 int。默认根据地址计算。一般如果重写 equals 也要重写 hashCode

###### clone

protected。只能被子类重写/调用。

###### wait

wait, notify, notifyAll 方法控制线程暂停和运行。

#### 类型转换

##### instanceof

操作符(关键字)，`实例 instanceof 类`，返回boolean

> 关键字都是小写的

如果实例是类或者类的父类，返回true，如果实例是类的子类，返回false，否则报错。

如：

```c++
obj2 v = new obj2();
System.out.println(v instanceof obj2); //obj2 extends obj1
System.out.println(v instanceof obj1);
System.out.println(v instanceof obj4); //obj4 extends obj2
// System.out.println(v instanceof String); //报错
```

##### 向上转型

将子类对象看作是父类对象被称为是向上转型。Java 允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，向上转型由系统自动完成。

子类可以作父类使用，在参数或别的地方。如：

```java
class obj10 { //加public会炸，且小心跟同package下类同名
    public int v;
  
    obj10(int x) {
        v = x;
    }
}

class obj20 extends obj10 { //加public会炸
    obj20(int x) {
        super(x);
    }
}

public class c1003 {
    public static void f(obj10 x) {
        System.out.println(x.v);
    }

    public static void main(String[] args) {
        obj20 a = new obj20(2);
        f(a);
        obj10 b = a;
    }
}
```

当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，即多态。

```java
class t04_1 {
    public void f() {
        System.out.println("This is t041");
    }
}

class t04_2 extends t04_1 {
    @Override
    public void f() {
        System.out.println("This is t042");
    }
}

public class t04 {
    public static void main(String[] args) {
        t04_2 obj = new t04_2();
        obj.f();
        t04_1 objf = obj;
        objf.f();//都输出 t042
    }
}
```

将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。



##### 向下转型

将父类看作是子类。通常需要强转。如：

```java
class obj10 {
    public int v;

    obj10(int x) {
        v = x;
    }
}

class obj20 extends obj10 {
    obj20(int x) {
        super(x);
    }
}

public class c1003 {
    public static void f(obj10 x) {
        System.out.println(x.v);
    }

    public static void g(obj20 x) {
        System.out.println(x.v + 10);
    }

    public static void main(String[] args) {
        obj10 c = new obj20(1); // 注意new obj10的话不可以转obj20
        if (c instanceof obj20) {
            obj20 d = (obj20) c; // 拆包
            g(d);
        }
    }
}
```

通常配合instanceof使用，符合才执行向下转型，避免报错。

#### 重载

参数不同(数目或类型或类型顺序)构成重载。

> 方法的参数类型、个数、顺序至少有一项不同，返回类型不一定相同，修饰符要相同

多态就是多个子类共用父类的方法。

#### 抽象类

abstract关键字。

有一个抽象方法的类称为抽象类，抽象方法只能出现在抽象类(有abstract关键字的类)中。抽象类不可以建立实例。抽象类不可以是 final 类。

使用举例：

```java
abstract class abt {
    int v;

    abt(int k) {
        v = k;
    }

    abstract public void f();

    public void g() {
        System.out.println(v);
    }
}

class c2 extends abt {
    c2(int k) {
        super(k);
    }

    public void f() {
        System.out.println(v * v);
    }
}

//main
c2 a = new c2(-4);
a.g();
a.f();
```

#### 接口

抽象类如果每个子类都要重写抽象方法，会造成代码冗余。且某些不需要使用抽象方法的子类也不得不重写抽象方法。因此有了接口。

接口可以看成纯虚类。所有方法都没有方法体(都抽象)。

接口关键字是interface(而不是class+xxx)。接口中，方法必须定义public或abstract (其他都报错)。属性只能被public final static 修饰。缺省使用默认修饰。其他权限修饰也会被强制认为是public。接口定义的任何字段都自动是static和final的。(且public)

一个类使用接口，在后面加上implements关键字加若干个接口名。可以有零(不加关键字)到若干个接口，逗号分开。

类调用接口的方法时，会首先将类向上转型成接口形式。

接口名可以认为是有这个接口的类的父类。

接口不可以有构造方法。方法可以是任意访问权限(会报错)。

> 接口表示一种约定，一种能力，体现了约定和实现分离的原则
>
> 接口可以定义一堆常量当枚举类来用

接口内方法添加 default 关键字可以定义方法。

> 接口与抽象类的区别：
>
> - 接口体现规范，规定向外提供的服务。接口是多个模块的耦合标准，多个程序的通信标准
>
>   抽象类是模版式设计，实现的中间产品，未完善部分有多种实现方式
>
> - 接口只能有抽象、静态、默认、私有方法，不为普通方法提供方法实现。抽象类可以包含普通方法
>
> - 接口只能定义静态常量，不能定义普通成员变量 (默认 final)
>
> - 接口不包含构造器，抽象类的构造器不用于创建对象而是让子类调用
>
> - 接口不能包含初始化块
>
> - 一个类可以实现多个接口，只能实现一个抽象类
>
> - 抽象类和接口都不能被实例化，都可以包含抽象方法
>
> 接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这种原则，很多软件架构设计理论都倡导“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合

代码举例：

```java
class sth {
    public int v = 0;

    sth(int x) {
        v = x;
    }
}

interface ro {
    public void f();
}

class sa extends sth implements ro {
    sa(int x) {
        super(x);
    }

    public void f() {
        System.out.println(v * v);
    }
}

class sb extends sth implements ro {
    sb(int x) {
        super(x);
    }

    public void f() {
        System.out.println(v + 580);
    }
}

class sc extends sth { //不使用接口
    sc(int x) {
        super(x);
    }
}

public class c1005 {
    public static void main(String[] args) {
        ro[] arr = { new sa(7), new sb(-80) };
        for (int i = 0; i < arr.length; ++i) {
            arr[i].f();
        }
    }
}
```

接口可以继承另一个或多个接口。如：

```java
interface i1 {
    public void h();
}

interface i2 extends i1 {
}

class sd implements i2 {
    public int v = 7;

    public void h() {
        System.out.println(v * 2);
    }
}
//...
sd w = new sd(); //或i1 w = 或i2 w = 都可以的
w.h();
```

> ```java
> interface a {
>     void f();
> }
> 
> interface b {
>     void g();
> }
> 
> interface c extends a, b {
> }
> 
> class dd implements c {
>     public void f() {
>     }
> 
>     public void g() {
>     }
> }
> ```

#### 类包

类的路径可以是相对路径或完整类路径，以避免重名冲突。完整路径示例如下：

```java
java.util.Date d = new java.util.Date(); //无需import即可使用
java.sql.Date e = new java.sql.Date(234);
```

> 其中 `java.util`是包名，`Date`是类名。

> 定义好的java类通过java编译后会产生 `.class`文件。

> 同一包的类不必放在同一位置，如 `com.lr.class1`和 `com.lr.class2`可以放在不同盘符(如C和D盘)，将 `CLASSPATH`分别指向这两个位置即可。(da ho ro)

在类中指定包名：(一般就是父文件夹名字)

```java
package 包名;
```

该语句放在第一行非注释文本。包命名规则是全部小写。

java定义包名通常使用创建者 `Intenet`域名的反序。如 `com.edu.scnu`。

导入包：

```java
import 路径;
```

导入时会以 `CLASSPATH`为相对路径，找路径下有无编译完成的 `.class`文件。注：导入一个包的类时，不会导入它的子包的类。

可以用通配符 `*`，如：

```java
import java.util.*;
import java.sql.date;
```

可以设置编译后类文件产生的位置：

```shell
javac -d ./bin ./位置
```

可以添加环境变量：

```shell
set path=路径;%path% #如C:\java\jdk123\bin;%path%
```

也可以导入静态成员：(JDK5.0+)

```java
import static 成员名;
```

如：

```java
import static java.lang.Math.max; //之后可以直接max(1,4);
import static java.lang.System.out; //但是不能再继续.println了
```



#### 内部类

分为成员内部类、局部内部类、匿名类。

##### 成员内部类

在外部类中可以直接照常使用，同一般使用类的语法。

内部类对象一定要依赖于外部类实例而存在。

> 内部类的目的通常是不让类外代码单独使用这个类(而是往往给外部类自己使用)。所以通常设置内部类为 `private`
>
> 内部类可以加 `public`

> 内部类 `this`是自己，用 `外部类名.this`是外部类自己。冲突时可以区分。

在外部类外，实例化一个内部类方法：

```java
外部类名.内部类名 实例名 = new 外部类名(构造函数参数).new 内部类名(构造函数参数);
外部类名.内部类名 实例名 = 外部类实例.new 内部类名(构造函数参数); //推荐
外部类名.内部类名 实例名 = 外部类实例.返回内部类的公有方法(参数);
```

如：

```java
class c1 {
    c2 obj = new c2(0); // 外部类内创建

    class c2 {
        public int x = 0;

        c2(int y) {
            x = y;
        }
    }

    public c2 f(int x) {
        return new c2(x); // 外部类方法内创建
    }
}

public class c1103 {
    public static void main(String[] args) {
        c1 a = new c1();
        c1.c2 b = a.f(5);
        c1.c2 c = a.new c2(6); //c1.new 会炸
        System.out.println(b.x + "|" + c.x); //'|'会转int
    }
}

```

内部类可以任意调用外部类的成员和方法，包括私有的。但外部类不可以访问内部类的私有成员。

若把private的内部类向上转型为父类或接口，可以定义多个内部类实现同一个接口的方法，可以在一个类做出多个不同响应事件。

这是隐藏实现细节的一种方法。因为 `c01`自己或它的子类可以用 `f`，但是无法改。

如：

```java
interface it {
    public void f();
}

class c01 {
    private class c02 implements it {
        public void f() {
            System.out.println("ro sth");
        }
    }

    private class c03 implements it {
        public void f() {
            System.out.println("ro nth");
        }
    }

    public it g(int x) {
        if (x == 1) {
            return new c02();
        } else {
            return new c03();
        }
    }
}

public class c1104 {
    public static void main(String[] args) {
        c01 c = new c01();
        c.g(1).f();
        c.g(0).f();
    }
}
```

##### 局部内部类

用的很少。在一个成员函数里定义的类。如果希望作为返回值，在函数外可以调用，需要设置为接口，返回值类型也是接口。如：

```java
interface people {
    public int introduce(int times);
}

public class c1106 {
    static people f(String x, int y) {
        class spe implements people {
            String v;
            int a;

            public spe(String x, int y) {
                v = x;
                a = y;
            }

            public int introduce(int t) {
                System.out.println(t + " " + v + " " + a);
                return t * t;
            }
        }
        return new spe(x, y);
    }

    public static void main(String[] args) {
        people a = f("jl", 1);
        a.introduce(5);
        people b = f("sz", 2);
        b.introduce(80);

    }
}

```

> (idk wa hi mean)在方法体用要使用局部变量，需要设置为final；即内部类只能访问final局部变量，因为这个类的生命周期大于局部变量的生命周期。

即使内部类作为某个类的父类，

##### 匿名内部类

一般也是作为接口。语法为：

```java
修饰符 接口名 函数名(参数){
    return new 接口名(){
        类的各种定义，如方法、成员函数
    }; //分号！
}
```

> 在swing很常用。

如：

```java
interface human {
    public void itd();
}

interface num {
    public int cal();
}

public class c1107 {
    static human f(String name) {
        return new human() {
            private String v = name; // 绕开了构造函数也行

            public void itd() {
                System.out.println("my name is " + v);
            }
        };
    }

    static num g(int x) {
        return new num() { //甚至可以绕开私有成员
            public int cal() {
                return x * x;
            }
        };
    }

    public static void main(String[] args) {
        human a = f("gd");
        a.itd();
        human b = f("hf");
        b.itd();

        num c = g(-2);
        System.out.println(c.cal());
    }
}
```

可以使用匿名内部类实现自定义排序，如：

```java
import java.util.Arrays;
import java.util.Comparator;

class point {
    double x, y;

    point(double a, double b) {
        x = a;
        y = b;
    }
}

public class c1205 {
    public static int sgn(double x, double y) {
        return x > y ? 1 : (x == y ? 0 : -1);
    }

    public static void main(String[] args) {
        point[] x = new point[3];
        x[0] = new point(1, 1);
        x[1] = new point(3, 0);
        x[2] = new point(2, 3);
        Arrays.sort(x, new Comparator<point>() {
            @Override
            public int compare(point o1, point o2) {
                if (o1.x != o2.x) {
                    return sgn(o1.x, o2.x);
                }
                return sgn(o1.y, o2.y);
            }
        });
        for (point a : x) {
            System.out.println(a.x + "," + a.y);
        }
    }
}

```

由于不存在名字，没有构造函数，升降按变量指令时可以建立一个返回自己的成员函数，然后参数处调用一下这个方法，如：

```java
import java.util.Arrays;
import java.util.Comparator;

class point {
    double x, y;

    point(double a, double b) {
        x = a;
        y = b;
    }
}

public class c1206 {
    public static int sgn(double x, double y) {
        return x > y ? 1 : (x == y ? 0 : -1);
    }

    public static void main(String[] args) {
        point[] x = new point[3];
        x[0] = new point(1, 1);
        x[1] = new point(2, 0);
        x[2] = new point(2, 3);
        Arrays.sort(x, new Comparator<point>() {
            boolean asc;

            public Comparator<point> getorder(boolean a) {
                this.asc = a;
                return this;
            }

            @Override
            public int compare(point o1, point o2) {
                if (o1.x != o2.x) {
                    return asc ? sgn(o1.x, o2.x) : sgn(o2.x, o1.x);
                }
                return asc ? sgn(o1.y, o2.y) : sgn(o2.y, o1.y);
            }
        }.getorder(false));
        for (point a : x) {
            System.out.println(a.x + "," + a.y);
        }
    }
}

```

##### 静态内部类

静态内部类(类内部类)可以声明static成员。非静态内部类不可以。静态内部类不可以使用外部类的非静态成员。

> static关键字的作用是把类的成员变成类相关，而不是实例相关，即static修饰的成员属于整个类，而不属于单个对象。外部类的上一级程序单元是包，所以不可使用static修饰

如果创建静态内部类对象，不需要其外部类对象。

不能从静态内部类的对象中访问非静态外部类的对象。

静态内部类可以包含静态或非静态成员。

```java
class ntmv {
    static class sta {
        void f() {
            System.out.println("awa");
        }
    }
}

public class c1202 {
    public static void main(String[] args) {
        ntmv.sta x = new ntmv.sta();
        x.f();
    }
}
```

特别地，如果每个java文件都有一个main，会出现很多main的内容在编译后产生；如果不希望有或希望可以删了，可以将main放到静态内部类里，那么main的内容在 `外部public类名$内部类名`独立类里。

可以被继承。

##### 继承

继承时 `extends` 为 `外部类名.内部类名` ，构造函数传入一个参数为外部类实例，必须用 `外部类参数.super()`。父类应该有无参构造函数。创造直接 `继承类名 变量=new 继承类名(外部类实例);`如：

```java
class repro {
    int x = 1;

    repro() {
    }

    repro(int y) {
        y = x;
    }

    class sub {
    }
}

class repros extends repro.sub {
    repros(repro a) {
        a.super();
    }

    public void f() {
        System.out.println("abc");
    }
}

public class c1203 {
    public static void main(String[] args) {
        repros x = new repros(new repro());
        x.f();
    }
}

```



#### 泛型

即 C++ 的模板类。

粗暴的实现方法是设为 Object 类，然后用向上向下强转实现。缺点是麻烦和不安全(放的跟调用的不一样报错 `ClassCastException` )。所以考虑使用泛型。

##### 基本用法

定义泛型：在类名后加上`<模板名>` ，之后要用的地方同一替换即可。使用泛型时声明为：

```java
类名<具体数据类型> 变量名 = new 类名<具体数据类型>();
```

多个模板用逗号隔开。

> 模板名一般用 `T` ，容器一般用 `E` ，键值用 `K` 。

不能定义泛型数组，但是可以声明、传入和返回。

类型不能是基本数据类型如 `int` ， 但可以是 `Integer` 。

例如：

```java
import java.util.Arrays;

public class c1704 {
    private class fk<t1, t2> {
        public int n = 0;
        public t1 x[] = null;
        public t2 y;

        public fk(t1 a[], t2 b, int n) {
            x = Arrays.copyOf(a, n);
            // x = new t1[n]; 错
            // for (int i = 0; i < n; ++i) {
            // x[i] = a[i];
            // }
            this.n = n;
            // x = a; 软复制
            y = b;
        }

        public void prt() {
            System.out.print(y + ": ");
            for (int i = 0; i < n; ++i) {
                System.out.print(x[i] + " ");
            }
            System.err.println();
        }
    }

    public c1704() {
        Double a1[] = new Double[] { 4.4, -4.44, 44.444 };
        fk<Double, String> x1 = new fk<Double, String>(a1, "dy", 3);
        a1[1] = 6.0;
        x1.prt();
    }

    public static void main(String[] args) {
        new c1704();
    }
}

```



##### 拓展用法

可以在定义模板处写 `<T extends 类型>` 表示必须实现或继承了这个接口/类。

同理在创建时也可以用类型通配符，如 `<? extends 类型>`。普通方法参数也可以这么定义。甚至可以直接`<?>` 。但是使用了通配符的对象不能再次新建/改变成员(如`LinkedList`)，只能查询和删除。

也可以向上限制，用`<? super 类>` ，那么只接受该类或其父类。

泛型类/接口可以被继承和实现。如果保留父类的泛型类型，继承的时候要指明，否则 extends 后面不加泛型符号`<>`，且子类所有模板自动变成 Object 。

> java 早期允许把 Integer 数组赋值给 Number，但是 Double 对象保存进去编译能过而运行报错。之后不再允许 `List<Integer>` 赋值给 `List<Number>`
>
> 若 Foo 是 Bar 子类型(子类/子接口)，则 Foo 数组仍然是 Bar 子类型，而 `G<Foo>` 不是`G<Bar>` 子类型。Foo 数组自动向上转型为 Bar 数组是型变。而 Java 集合不支持型变。
>
> 泛型设计原则：代码编译不警告，则运行不会遇到 `ClassCastException`

如：

```java
public class c1706 {
    class c1 {
        public int x;
    }

    class c2 extends c1 {
        public int y;
    }

    class c3<T extends c1> {
        public T z;
    }

    class c4<T> {
        public T w;
    }

    public c1706() {
        c3<c2> x = new c3<>();
        x.z = new c2();
        x.z.x = 1;
        c4<? extends c1> y = new c4<c2>();
        // y.w = new c2(); //不可实例化
        System.out.println(y.getClass().getName());
        c4<? super c2> z = new c4<c1>();
        System.out.println(z.getClass().getName());
        c4<?> w = new c4<String>();
        // w.w = new String("awa");//不可实例化
        System.out.println(w.w);
    }

    public static void main(String[] args) {
        new c1706();
    }
}

```

```java
public class c1707 {
    private class c1<T1, T2> {
        public T1 a;
        public T2 b;

        public c1() { // 必须要有，不然报错说无明确构造方法
        }

        public c1(T1 x, T2 y) {
            a = x;
            b = y;
        }
    }

    private class c2<T1, T2, T3> extends c1<T1, T2> {
        public T3 c;

        public c2() {
        }

        public c2(T1 x, T2 y, T3 z) {
            super(x, y);
            c = z;
        }
    }

    public c1707() {
        c1<?, ?> x = new c1<Integer, String>(6, "awa");
        System.out.println(x.a + " " + x.b);
        Thread thr = new Thread(new Runnable() {
            public void run() {
                System.out.println("Hey!");
            }
        });
        c2<String, Integer, Thread> y = new c2<String, Integer, Thread>("lr580", 580, thr);
        y.c.start();
        System.out.println(y.b + " " + y.a);
    }

    public static void main(String[] args) {
        new c1707();
    }
}

```



##### 泛型数组

Java 不支持泛型数组，会报 warning ，除非写 `<?>` ，如： 

```java
LinkedList<?> x[] = new LinkedList[n];
```

那么在后面使用时也需要注意要用 Object

可以使用 `@SuppressWarnings("unchecked")` 无视警告，如：

```java
public TreeSet<Pair> sons[] = null;
@SuppressWarnings("unchecked")
public String stat_sum() {
    sons = new TreeSet[top + 1];
    for (int i = 1; i <= top; ++i) {
        sons[i] = new TreeSet<Pair>();
    }
}
```



##### 泛型擦除

严格泛型代码，带泛型声明的类总应该带类型参数，为了与老 Java 一致，也允许不指定，此时称为原始类型 raw type，默认是声明该泛型形参时指定的第一个上限类型。

将一个具有泛型信息的对象赋给没有信息的变量时，尖括号内容1扔掉，且转换后检查类型变成了上限 Object。

而如果返过来，将一个没写类型的变量给泛型对象，会报警报未经检查的转换(泛型转换)。

```java
@SuppressWarnings("unchecked")
public static void main(String[] args) {
    List<String> x = new ArrayList<>();
    x.add("禾枫");
    @SuppressWarnings("rawtypes")
    List y = x;//引用
    y.add(1437580);
    System.out.println(x.size());
    //String s = x.get(1); (报错
    Integer s = (Integer) y.get(1);
    System.out.println(s);
}
```

```java
@SuppressWarnings("unchecked")
private static void f() {
    @SuppressWarnings("rawtypes")
    List x = new ArrayList<>();
    List<String> y = x;
    y.add("弥明");
    x.add("云烟");
    String s = y.get(1);
    System.out.println(s);
}
```





#### 反射

> Java 对象运行时表现为两种类型，编译时类型和运行时类型。如：`List<Integer> a = new ArrayList<>()`，则编译时类型前者，运行时类型后者。
>
> 程序需要调用运行时类型的方法时，若假设已知可能是什么类，可以加 `instanceof` 判断+强转。如果无法预知，则靠运行时信息发现真实信息，使用反射。先获取一个类的 Class 对象，查询类信息，然后通过反射创建任意一个类实例，并访问成员。生成类的动态代理类/对象。
>
> 用 JDBC 时，通过反射加载数据库驱动程序。框架的 注解/XML配置解析的类字符串利用反射机制实例化。AOP 实现是程序运行时创建目标对象代理类。

主要依据为 `Class` 。

功能为：以前的代码可以调用未来的代码。

Class---代表字节码的类---代表类的类
Field---代表属性的类
Method---代表方法的类
Constructor---代表构造方法的类
Package---代表包的类
Annotation---代表注解的类

##### Class

Java有两种对象：实例对象和Class对象。每个类运行时的类型信息就是用Class对象表示的。它包含了与类有关的信息，实例对象就通过Class对象来创建的

每一个类都有一个Class对象，编译一个新类就产生一个Class对象。Class类没有公共的构造方法，因此不能显式地声明一个Class对象。不允许手动的去new一个Class对象

获取一个类的 Class 对象：

- `类名.class` 如 `Class clz = String.class;`
- 对象的 `getClass()` 方法 如 `Integer i = 9; Class clz2 = i.getClass();`
- `Class.forName("类的全限定名")` 即路径名 如 `Class clz3 = Class.forName("java.util.List");`

可以直接输出 Class 对象，显示结果如 `class java.lang.String`。

可以描述一个类的基本信息。常用方法：

- `getPackage()` 返回 `Package` 对象，得到类的存放路径

- `getName()` String

- `getSuperclass()` 返回 `Class` 对象

- `getInterfaces()` `Class` 数组

- `getConstructors()` `Constructor` 数组 所有权限为 public 的构造方法

- `getConstructor(Class<?>...parameterTypes)` `Constructor` 对象 指定构造方法

- `getDeclaredConstructors()` 按声明顺序返回所有构造方法

- `getDeclaredConstructors(Class<?>...)` 

- `getMethods()` 得到`Methods` 型数组 同理是 public 的

- `getMethod(String name, Class<?>..paraTy)` 同理有 declared 的

- `getFields()` 同理有其他三个方法

- `getClasses()` 所有权限为 public 的内部类

- `getDeclaredClasses()` 所有内部类

- `getDeclaringClass()` 如果是内部类，返回它的成员类，否则返回 null

- `getResource(String path)`  返回 URL ，代表路径

  path不以'/'开头时，默认是从此类所在的包下取资源；

  path以'/'开头时，则是从项目的ClassPath根下获取资源

通过 `getFields` 和 `getMethods` 获得时，将包含从超类中继承到的成员变量和方法；而 `Declared` 获得本类中定义的所有成员变量和方法

##### Construcor

`import java.lang.reflect.Constructor`

> 几种使用的例子：
>
> ```java
> package refl;
> 
> import java.lang.reflect.Constructor;
> import java.lang.reflect.InvocationTargetException;
> 
> class Person {
>     public String name, chats;
> 
>     public Person() {
>     }
> 
>     public Person(String name, String chats) {
>         this.name = name;
>         this.chats = chats;
>     }
> }
> 
> public class Try1 {
>     @SuppressWarnings("deprecation")
>     public static void main(String[] args) {
>         @SuppressWarnings("rawtypes")
>         Class cls0 = String.class;
>         try {
>             String s0 = (String) cls0.newInstance();
>             System.out.println("QwQ" + s0);
>         } catch (InstantiationException e) {
>             e.printStackTrace();
>         } catch (IllegalAccessException e) {
>             e.printStackTrace();
>         }
> 
>         Class<String> cls = String.class;
>         try {
>             String s1 = cls.newInstance();// 不能填参数
>             System.out.println("awa" + s1);
>         } catch (InstantiationException | IllegalAccessException e) {
>             e.printStackTrace();
>         }
> 
>         Class<Integer> inc = Integer.class;
>         Constructor<Integer> c = null;// 否则in=那里报错
>         try {
>             c = inc.getConstructor(int.class);
>         } catch (NoSuchMethodException | SecurityException e) {
>             // TODO Auto-generated catch block
>             e.printStackTrace();
>         }
>         Integer in = 0;// 同理否则syso报错
>         try {
>             in = c.newInstance(5);
>         } catch (InstantiationException | IllegalAccessException | IllegalArgumentException
>                 | InvocationTargetException e) {
>             // TODO Auto-generated catch block
>             e.printStackTrace();
>         }
>         System.out.println(in);
> 
>         Class<Person> pc = Person.class;
>         try {
>             Constructor<Person> cst = pc.getConstructor(String.class, String.class);
>             Person baicha = cst.newInstance("白茶", "在摸鱼");
>             System.out.println(baicha.name + baicha.chats);
>         } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException
>                 | IllegalArgumentException | InvocationTargetException e) {
>             // TODO Auto-generated catch block
>             e.printStackTrace();
>         }
>     }
> }
> ```

若要访问指定的构造方法，需要根据该构造方法的入口参数类型来访问，例如访问入口参数依次为 `String` , `int` 的，可以通过如下方法实现：

```java
xx.getDeclaredConstructor(String.class, int.class);
xx.getDeclaredConstructor(new Class[]{String.class, int.class});
```

Constructor 类常用方法有：

- `isVarArgs()` 查看该构造方法是否允许带有可变数量参数
- `getParameterTypes()` 按声明顺序以 Class 数组的形式获得该构造方法的各个参数的类型
- `getExceptionTypes()` 以 Class 数组形式获得该构造方法的各个参数类型
- `newInstance(Object...initargs)` 通过该构造方法利用指定参数创建一个该类的对象，若未设置参数表示采用默认无参数的构造方法；返回 Object ，需要强转类型
- `setAccessible(boolean flag)` 若构造方法权限为 private ，默认不允许用过反射创建对象，可以设 true 来允许创建
- `getModifiers()` 获得可以解析出该构造方法所采用修饰符的整数

通过 `java.lang.reflect.Modifier` 类可以解析出信息，静态方法如下：

- `isPublic(int mod)` 
- `isPrivate(int mod)`
- `isProtected(int mod)`
- `isStatic(int mod)`
- `isFinal(int mod)`
- `toString(int mod)`

例如：

```java
import java.lang.reflect.Constructor;

public class c1602 {
    private class ezm {
        String s;
        int i1, i2;

        private ezm(String ss, int ii) {
            s = ss;
            i1 = ii;
        }

        public ezm(String... str) throws NumberFormatException {
            s = "awa";
            if (str.length > 0) {
                i1 = Integer.valueOf(str[0]);
            }
            if (str.length > 1) {
                i2 = Integer.valueOf(str[1]);
            }
        }

        public void prt() {
            System.out.println(s + " " + i1 + " " + i2);
        }
    }

    public c1602() {
        ezm x = new ezm("580", "1437");
        Class<? extends ezm> cx = x.getClass();
        Constructor[] dcons = cx.getDeclaredConstructors();
        for (int i = 0; i < dcons.length; ++i) {
            Constructor<?> con = dcons[i];
            System.out.println("isVarArgs: " + con.isVarArgs());
            Class[] paraTy = con.getParameterTypes();
            System.out.print(paraTy.length + " params: ");
            for (int j = 0; j < paraTy.length; ++j) {
                System.out.print(paraTy[j] + ", ");
            }
            System.out.println();
            System.out.print("Exceptions: ");
            Class[] excepTy = con.getExceptionTypes();
            for (int j = 0; j < excepTy.length; ++j) {
                System.out.print(excepTy[j] + ", ");
            }
            System.out.println();
            ezm y = null;
            while (y == null) {
                try {
                    // 事实上无法遍历出默认构造函数
                    if (paraTy.length == 1) {// 默认构造(参数有父类)
                        y = (ezm) con.newInstance(this);
                    } else if (paraTy.length == 3) {// private构造
                        y = (ezm) con.newInstance(this, "666", 580);
                    } else {
                        Object[] params = new Object[] { this, new String[] { "11", "4514" } };
                        y = (ezm) con.newInstance(params);
                    }
                } catch (Exception e) {
                    con.setAccessible(true);
                }
            }
            y.prt();
        }
    }

    public static void main(String[] args) {
        new c1602();
        // main 直接跑内部类会 No enclosing instance of type is accessible
    }
}

```



##### Field

`import java.lang.reflect.Field`

常用方法：

- `getName()`
- `getType()` 返回 Class
- `get(Object obj)` 获得指定对象的成员变量值返回 Object
- `set(Object obj, Object value)` 对象成员变量赋值
- `getInt(Object obj)` 获取类型为 int 的变量值；其他类型同理
- `setInt(Object obj, int i)` 赋值
- `setAccessible(boolean flag)` 此方法可以设置是否忽略权限限制直接访问 private 等私有权限的成员变量
- `getModifires()` 

如：

```java
import java.lang.reflect.Field;

class ezm2 {
    int i, j;
    public float f;
    protected boolean b;
    private String s = "fudge";
}

public class c1604 {
    public static void main(String[] args) {
        ezm2 x = new ezm2();
        Class c = x.getClass();
        Field[] fs = c.getDeclaredFields();
        for (int i = 0; i < fs.length; ++i) {
            Field f = fs[i];
            Class ty = f.getType();
            System.out.print(ty + " " + f.getName());
            spj: while (true) {
                try {
                    System.out.print(" = " + f.get(x) + " -> ");
                    if (ty.equals(int.class)) {// f.equals暴毙
                        f.setInt(x, 1437);
                    } else if (ty.equals(float.class)) {
                        f.setFloat(x, 5.8F);
                    } else if (ty.equals(boolean.class)) {
                        f.setBoolean(x, true);
                    } else if (ty.equals(String.class)) {
                        f.set(x, "awa");
                    }

                    System.out.println(f.get(x));
                    break spj;
                } catch (Exception e) {
                    f.setAccessible(true);
                }
            }

        }

    }
}

```

> ```java
> package refl;
> 
> import java.lang.reflect.Constructor;
> import java.lang.reflect.Field;
> 
> public class Try2 {
>     @SuppressWarnings("rawtypes")
>     public static void main(String[] args) {
>         Class<String> clz = String.class;
>         Constructor[] cs = clz.getDeclaredConstructors();
>         for (Constructor con : cs) { // 查看所有构造方法
>             System.out.println(con);
>         }
>         Field f = null;
>         try {
>             f = clz.getDeclaredField("hash");// 获取一个属性
>         } catch (NoSuchFieldException | SecurityException e) {
>             e.printStackTrace();
>         }
> //        f.setAccessible(true);// 开权限(高版本可能会挂)
> //        try {
> //            f.set("abc", 45);
> //        } catch (IllegalArgumentException | IllegalAccessException e) {
> //            e.printStackTrace();
> //        } // 设置值
> //        try {
> //            System.out.println(f.get("abc"));
> //        } catch (IllegalArgumentException | IllegalAccessException e) {
> //            e.printStackTrace();
> //        }
>         System.out.println(clz.getName());// 取路径
>         System.out.println(clz.getSimpleName());
>         System.out.println(clz.getSuperclass());
>         System.out.println(clz.isArray());
>         System.out.println(clz.isPrimitive());// 判是否基本类型
>         System.out.println(double.class.isPrimitive());
>         System.out.println(Double.class.isPrimitive());// false
>     }
> }
> ```
>
> ```java
> package cn.scnu.book;
> public class Book extends SuperBook implements BookInterface1,BookInterface2{
> 	private String bname;
> 	private Integer price;
> 	private String author;
> 	public Book() {	}
> 
> 	public Book(String bname,Integer price,String author){
> 		this.bname=bname;
> 		this.price=price;
> 		this.author=author;
> 	}
> 	
> 	Book(String bname){
> 		this.bname=bname;
> 	}
> 	@Override
> 	public String save(String bname){
> 		return bname+"被保存！";
> 	}
> 	
> 	private void modify(String bname){
> 		System.out.println(bname+"被修改！");
> 		
> 	}
> 	@Override
> 	public void delete(String bname){
> 		System.out.println(bname+"删除！");
> 	}
> 	
> 	@Override
> 	public String toString() {
> 		return "Book [bname=" + bname + ", price=" + price + ", author=" + author + "]";
> 	}
> 
> 	public String getBname() {
> 		return bname;
> 	}
> 
> 	public void setBname(String bname) {
> 		this.bname = bname;
> 	}
> 
> 	public Integer getPrice() {
> 		return price;
> 	}
> 
> 	public void setPrice(Integer price) {
> 		this.price = price;
> 	}
> 
> 	public String getAuthor() {
> 		return author;
> 	}
> 
> 	public void setAuthor(String author) {
> 		this.author = author;
> 	}
> }
> ```
>
> ```java
> package cn.scnu.reflect;
> import java.lang.reflect.Constructor;
> import java.lang.reflect.Field;
> import cn.scnu.book.Book;
> public class ClassDemo44 {
> 	//告诉编译器忽略指定的警告，不用在编译完成后出现警告信息。
> 		@SuppressWarnings("rawtypes")
> 		public static void main(String[] args) throws Exception {
> 			Class<Book> clz = Book.class;
> 			// 获取String类中的所有的构造方法
> 			Constructor[] cs = clz.getDeclaredConstructors();
> 			for (Constructor constructor : cs) {
> 				System.out.println(constructor);
> 			}
> 			
> 			Book b=(Book)clz.newInstance();
> 			
> 			// 获取指定的属性对象
> 			Field f = clz.getDeclaredField("bname");
> 			f.setAccessible(true);			
> 			System.out.println(f);
> 			
> 			// 在指定对象身上给指定的属性设置值		
> 			f.set(b, "PHP web"); //b.setBname("PHP web");
> 			// 从指定的对象身上获取指定的属性值
> 			System.out.println(f.get(b));//b.getBname()
> 						
> 			// 获取实现的所有的接口
> 			Class[] cls = clz.getInterfaces();
> 			for (Class c : cls) {
> 				System.out.println(c);
> 			}
> 			// 获取类的全路径名
> 			System.out.println(clz.getName());
> 			System.out.println(clz.getSimpleName());
> 			
> 
> 			// 获取父类
> 			System.out.println(clz.getSuperclass());
> 			
> 			// 判断是否是一个数组
> 			System.out.println(clz.isArray());
> 			// 判断是否是一个基本类型
> 			System.out.println(clz.isPrimitive());
> 			System.out.println(double.class.isPrimitive());
> 			
> 		}
> }
> ```



##### Method

`import java.lang.reflect.Method`

访问指定方法需要通过方法名和入口参数来访问，如：(私有；公有不需要 declared)

```java
x.getDeclaredMethod("f", String.class, int.class);
x.getDeclaredMethod("f", new Class[] {String.class, int.class});
```

方法：

- `getName()`
- `getParameterTypes()`
- `getReturnType()`
- `getExceptionTypes()`
- `invoke(Object obj, Object...args)` 执行该方法 返回 Object
- `isVarArgs()` 该构造方法是否有可变参数
- `getModifiers()`

 举例：

```java
import java.lang.reflect.Method;

class ezm3 {
    static void f1() {
        System.out.println("f1 done.");
    }

    public int f2(int x) {
        System.out.println("f2 done.");
        return x * x;
    }

    protected void f3(String s, int x) throws NumberFormatException {
        System.out.println(s + ", " + x);
    }

    private String f4(String... x) {
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < x.length; ++i) {
            res.append(x[i] + " ");
        }
        return res.toString();
    }
}

public class c1605 {
    public static void main(String[] args) {
        ezm3 x = new ezm3();
        Class c = x.getClass();
        Method[] fs = c.getDeclaredMethods();
        for (int i = 0; i < fs.length; ++i) {
            Method f = fs[i];
            String nam = f.getName();
            System.out.print(f.getReturnType() + " ");
            System.out.print(nam + "(");
            Class[] paraTy = f.getParameterTypes();
            for (int j = 0; j < paraTy.length; ++j) {
                System.out.print(paraTy[j] + (j + 1 != paraTy.length ? ", " : ""));
            }
            System.out.print(")");
            Class[] excepTy = f.getExceptionTypes();
            if (excepTy.length > 0) {
                System.out.print(" throws ");
                for (int j = 0; j < excepTy.length; ++j) {
                    System.out.print(excepTy[j] + (j + 1 != excepTy.length ? ", " : ""));
                }
            }
            if (f.isVarArgs()) {
                System.out.print(" (varArgs)");
            }
            System.out.println();
            while (true) {
                try {
                    if ("f1".equals(nam)) {
                        f.invoke(x);
                    } else if ("f2".equals(nam)) {
                        System.out.println("Return: " + f.invoke(x, 25));
                    } else if ("f3".equals(nam)) {
                        f.invoke(x, ">_<", 233);
                    } else if ("f4".equals(nam)) {
                        // Object[] params = new Object[] { new String[] { "num", "hen", "hen",
                        // "aaaaaaaaa" } };
                        // System.out.println("Return: " + f.invoke(x,params));
                        // 不明报错，有待查错
                    }
                    break;
                } catch (Exception e) {
                    // e.printStackTrace();
                    f.setAccessible(true);
                }
            }
        }
    }
}

```

> ```java
> package refl;
> 
> import java.lang.reflect.Constructor;
> import java.lang.reflect.InvocationTargetException;
> import java.lang.reflect.Method;
> 
> public class Try3 {
>     public static void main(String[] args) {
>         Class<String> clz = String.class;
>         String s1 = null;
>         try {
>             Constructor<String> c1 = clz.getConstructor(clz);
>             s1 = c1.newInstance("baicha");
>             System.out.println(s1);
>         } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException
>                 | IllegalArgumentException | InvocationTargetException e) {
>             e.printStackTrace();
>         }
> //        try {
> //            Constructor<String> c2 = clz.getDeclaredConstructor(new char[0].getClass(), boolean.class);
> //            c2.setAccessible(true);
> //            String s2 = c2.newInstance(new char[] { 'a', 'b', 'c' }, true);
> //            System.out.println(s2);
> //        } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
> //            e.printStackTrace();
> //        }
> 
>         try {
>             Method m = clz.getMethod("charAt", int.class);
>             char ch = (char) m.invoke(s1, 1);
>             System.out.println(ch);
> //            Method m2 = clz.getDeclaredMethod("indexOfSupplementary", int.class, int.class);
> //            m2.setAccessible(true);
> //            System.out.println(m2.invoke(s1, 0, 1));
>         } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException
>                 | InvocationTargetException e) {
>             e.printStackTrace();
>         }
>     }
> }
> 
> ```
>
> ```java
> package cn.scnu.book;
> public class Book{
> 	private String bname;
> 	private Integer price;
> 	private String author;
> 	public Book() {	}
> 	public Book(String bname,Integer price,String author){
> 		this.bname=bname;
> 		this.price=price;
> 		this.author=author;
> 	}
> 	Book(String bname){
> 		this.bname=bname;
> 	}
> 	public String save(String bname){
> 		return bname+"被保存！";
> 	}
> 	private void modify(String bname){
> 		System.out.println(bname+"被修改！");
> 	}
> 	public void delete(String bname){
> 		System.out.println(bname+"删除！");
> 	}
> 	@Override
> 	public String toString() {
> 		return "Book [bname=" + bname + ", price=" + price + ", author=" + author + "]";
> 	}
> }
> ```
>
> ```java
> package cn.scnu.reflect;
> import java.lang.reflect.Constructor;
> import java.lang.reflect.Method;
> import cn.scnu.book.Book;
> public class ClassDemo33 {
> 	public static void main(String[] args) throws Exception {
> 		Class<Book> clz = Book.class;
> 		// 获取指定的公有的构造方法
> 		Constructor<Book> ccc = clz.getConstructor(String.class, Integer.class,String.class);
> 		Book book1 = ccc.newInstance("Java web",48,"李四");
> 		System.out.println(book1);
> 
> 		// 获取指定的构造方法
> 		Constructor<Book> c = clz.getDeclaredConstructor(String.class);
> 		// 暴力破解,获取非公有的有参构造方法
> 		c.setAccessible(true);
> 		Book book2 = c.newInstance("Java从入门到精通");
> 		System.out.println(book2);
> 
> 		// save(String bname)
> 		// 获取了指定的公有的方法
> 		Method m = clz.getMethod("save",String.class);
> 		// 第一个参数表示方法要作用的对象
> 		// 第二个参数表示这个方法执行所需要的参数
> 		// 在指定对象身上执行了指定的方法
> 		String message=(String)m.invoke(book1, "PHP web");//book1.save("PHP web")
> 		System.out.println(message);		
> 		//private void modify(String bname)
> 		// 获取指定的方法 
> 		Method m2 = clz.getDeclaredMethod("modify",String.class);
> 		// 暴力拆除
> 		m2.setAccessible(true);		
> 		m2.invoke(book1, "PHP web123");//book1.modify("PHP web123")
> 	}
> }
> 
> ```



##### Property

创建：

```java
Properties pro = new Properties();
```

读取配置文件，格式每行为 `属性键=属性值`。

先使用加载器读取路径(根目录是`bin/`)，如：

```java
String mapName = "com/tedu/text/"+mapId+".map";//在包里
ClassLoader classLoader = GameLoad.class.getClassLoader();
InputStream maps = classLoader.getResourceAsStream(mapName);
```

读取键值对，如：

```java
//pro.clear(); //清理上次读取
try {
    pro.load(maps);
    Enumeration<?> names = pro.propertyNames();
    while(names.hasMoreElements()) {
        String key=names.nextElement().toString();
        String value=pro.getProperty(key);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

作用：解耦 (基于抽象的程序设计)

> 使用举例：
>
> ```java
> Class<?> class1 = objMap.get("play");
> ElementObj obj=null;
> try {
>     @SuppressWarnings("deprecation")
>     Object newInstance = class1.newInstance();
>     if(newInstance instanceof ElementObj) {
>         obj=(ElementObj)newInstance;
>     }
>     obj.creatElement("param");
> } catch (InstantiationException | IllegalAccessException e) {
>     e.printStackTrace();
> }
> ```



#### 其他

##### 单例模式

java单例模式是一种常见的设计模式，单例模式分三种：懒汉式单例、饿汉式单例、登记式单例三种。

1、单例类只能有一个实例。
2、单例类必须自己创建自己的唯一实例。
3、单例类必须给所有其他对象提供这一实例。

恶(饿)汉模式：一开始就创建实例 (static块)

饱汉模式：需要用时才创建。如

```java
private static ElementManager EM = null;
public static synchronized ElementManager getManager() {
    if(EM == null) {
        EM = new ElementManager();
    }
    return EM;
}
```





##### POJO

POJO（Plain Ordinary Java Object）简单的Java对象 作用是方便程序员使用数据库中的数据表

PO －Persistent Object ，即＂持久化对象＂

VO是指值对象或者View对象（Value Object、View Object）

DTO Data Transform object就是作为数据使用的对象

只要是VO类，都要为属性生成get,set



#### 垃圾回收

GC

```java
String str = new String("abcd");
```

上文产生了三个对象

- `abcd` 字面量，在常量池
- `new String` 在堆
- `String str` 

根据 java 的 CHM 手册(JAVA + API 官方文档中文版)，`java-lang-ref-Reference` 和 `ReferenceQueue`

但内存没有任何一个引用指向时，会被GC回收。

- 强引用。程序创建对象，赋值给引用变量。通过引用操作实际变量。对象被一个或以上引用变量引用时处于可达状态，不能被 GC。
- 软引用。可能被 GC。足够时一般不回收。
- 弱引用。级别比软引用更低，不管内存够不够都会 GC 运行就回收
- 虚引用。和没有引用差不多，主要用于跟踪对象 GC 状态。不能单独使用必须和引用队列联合使用。





### 异常

默认的指令流是遇到异常前一直输出，一遇到异常在异常处马上停止然后抛出信息，如：

```java
System.out.println("a"); //会输出
int b = 1 / 0; //输出报错
System.out.println("b"); //不输出
```

> 注意错误的输出不是一般的输出流，所以某些编译环境可能会跟其他输出流之间不保证严格的I/O顺序。

> 异常是java提供的用于处理程序中错误的一种机制；异常产生时，不会自动跳转到异常处理程序
>
> `RuntimeException` 异常是程序运行过程中产生的异常， Java 类库每个包都定义了异常类，都是 `Throwable` 类的子类。分为 `Exception` 和 `Error` 类。 `Error` 类及其子类用来描述 Java 运行系统中的内部错误以及资源耗尽的错误，比较严重(致命错误)，如 `LinkageError, IOError` 等，不应捕获。 `Exception` 是非致命性错误，可以通过捕捉处理使得程序继续执行，分为 `RuntimeException` 和其他异常。前者可以细分为 `ClassCastException` , `ArraySizeException` 等。有空指针，越界，算术异常，数组包含不兼容值，非法参数，安全性和负数组长度。

#### try

##### 常规

格式为(try必须有，catch或finally可以没有)：

```java
try { //里面的代码如果发生异常则依次查找catch
// 如果异常符合其中一个catch就执行这个catch，其他catch不再执行
} catch (Exception e) {
// 有一个到多个，通常是从小到大的顺序
} finally {
// 无论异常与否都会执行的语句
}
```

如：

```java
try {
    int a = 1 / 0;
} catch (Exception e) {
    e.printStackTrace(); //按平时看到的报错格式输出这个报错
} finally {
    System.out.println("done");
}
```

支持嵌套。除try外出现别的异常还是会报错。

> 从小到大如：
>
> ```java
> try {
>  System.out.println(1 / 0);
> } catch (ArithmeticException e) {
>  System.out.println("不行哦");//do
> } catch (Exception e) {
>  e.printStackTrace();//not do
> }
> ```
>
> 多个错误一个 catch 如：
>
> ```java
> catch (InterruptedException | ExecutionException e)
> ```

##### resources

JDK >= 1.7

语法格式

```java
try ( 变量1定义初始化; 变量2定义初始化; .. ; 变量n) {
} //其他同上
```

如：

```java
ConnectionFactory factory = new ConnectionFactory();
try (
    Connecton connection = factory.newConnection();
    Channel channel = connection.createChannel()
) {
    //...
} catch (Exception e) {
    e.printStackTrace();
}
```

采用try-with-resources写法，当try中代码执行结束（正常结束/异常结束）之后就会调用try()括号中对象的close()方法来关闭资源，本质是 finally 语法糖，要求有 AutoCloseable 接口

支持赋值，如 `Connection c2 = c1` 传入 try，其中 `c1` 在 try 前初始化好

对 JDK9，可以直接对 try 前初始化的对象，只传变量名，如 `try (c1; c2)`

#### throw

抛出的格式为 `throw new 异常类名(异常信息参数)`。参数可以不填。

如果throw在try内，则不用任何特别处理。如果在try外，throw的方法需要在方法的参数后加上 `throws 错误类名`，这个类名是能够覆盖方法内所有throw的总父类。如：

```java
try {
    throw new ArithmeticException("hahaha");
} catch (Exception e) {
    e.printStackTrace();
}
```

```java
public static void main(String[] args) throws Exception {
     throw new EOFException("qwq");
 }
```

```java
public static void main(String[] args) throws Exception {
    double x = Math.random();
    if (x < 0.5) {
        throw new ClassCastException("123");
    } else {
        throw new SQLException();
    }
}
```

#### finally

不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。在通常情况下，不要在finally块中使用return、throw等导致方法终止的语句，一旦在finally块中使用了return、throw语句，将会导致try块、catch块中的return、throw语句失效。

```java
private static int f() {
    try {
        System.out.println(1 / 0);
    }  catch (Exception e) {
        System.out.println("awa");//先输出
        return 1;//返回这个
    }finally {
        System.out.println("QwQ");//后输出
        //return 2; 有的话报错
    }
    return 0;
}
```

```java
private static int f() {
    try {
        System.out.println(1 / 0);
    }  catch (Exception e) {//有的话也先输出awa
        return 1;
    }finally {
        System.out.println("QwQ");
        return 2;
    }
    //return 0;有的话报错
}
```





#### 异常类

##### Exception

Exception(异常)是Throwable类的子类。

> Error(错误)是另一个Throwable子类。一般是运行系统内部错误、资源耗尽等致命错误，比Exception这类非致命错误严重。

Exception是异常，它被分为两大类，分别是Checked异常和Runtime异常。所有的RuntimeException类及其子类的实例被称为Runtime异常；不是RuntimeException类及其子类的异常实例则被称为Checked异常。Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try...catch块来实现。

三个常用方法为：

###### printStackTrace

无参数，输出一段报错信息，即平时所看到的报错：报错类名+报错信息+报错行递归追溯

###### toString

返回报错：报错类名+报错信息

###### getMessage

返回报错信息

如：

```java
try {
    int a = 1 / 0;
} catch (Exception e) {
    System.out.println("------");
    e.printStackTrace();
    System.out.println("------");
    System.out.println(e.toString()); 
    System.out.println("------");
    System.out.println(e.getMessage());
}
```

##### 常见异常

> Exception可以分为RuntimeException和其他错误。
>
> 暂略，具体遇到可查。例如 Scanner 的报错是 `java.io.IOException`

##### 自定义异常

一般继承Exception类。构造函数传字符串代表错误信息，然后 `super(错误信息);`即可。抛出则跟Exception一样throw即可，如：

```java
class speerr extends Exception {
    public speerr(String msg) {
        super(msg);
    }
}

public class c1204 {
    public static void main(String[] args) {
        try {
            throw new speerr("awa");
        } catch (speerr e) {
            System.out.println("---");
            e.printStackTrace();
        } catch (Exception e) { //若无上面就执行这个，输出内容与上面一模一样
            e.printStackTrace();
        }
    }
}

```

#### assert

可以直接用，跟 py 差不多

### Swing

java基础类AWT(Abstract Window Toolkit)，抽象窗口工具包的一种，即窗口化，是AWT的增强，支持不同平台统一显示(AWT的GUI不支持)。

> AWT提供了基本的java程序的GUI设计工具，主要包括下述三个概念：组件、容器、布局管理器。

Swing组件是**轻量级**组件：完全由java编写，不依赖操作系统，可以在任何平台运行；而依赖本地平台的组件是**重量级**组件，如AWT。

从父往子的类关系分别是 `java.lang.Object` , `Java.awt.Component` , `Java.awt.Container` , `Javax.swing.JComponent` 。Swing大多数GUI组件是 Component 的直接/间接子类。 JComponent 是 Swing组件各种特性的存放位置，如设定组件边界、GUI组件自动滚动。

Container 有 `java.awt.Window` , `java.awt.Frame` 子类。

通常导入：

```java
import java.awt.*;
import javax.swing.*;
```

创建组件：`组件名 实例=new 组件名(参数)`

> 匿名内部类可能无法访问外面的控件，如果设为 `final`则可以访问。

#### 窗体

##### JFrame

承载Swing组件的容器(窗口框架)。

创建：在某个类继承 `JFrame` 类，在某个方法(如构造函数)里：

```java
JFrame jf = new JFrame(标题字符串);
//创建初始不可见，有标题的窗体(不传参数就无)
```

之后在 `main` 里：`new 主类名().该方法()`

使窗体可见：`setVisible(true)`

设置宽高：`setSize(int x, int y) `  (不然为$0,0$)
用户可以自己拖放更改宽高

`setLocationRelativeTo(null)` 屏幕居中

是否可以拖放更改宽高 `setResizable()` 在 `setVisible` 之前设置

> 获取用 `getWidth(),  getHeight()`

设置拖放的最小大小： `setMinimumSize(new Dimension(宽,高))`

设置关闭方式：`setDefaultCloseOperation(关闭方式)`

关闭方式有：(`WindowConstants.关闭方式常量`)

- `DO_NOTHING_ON_CLOSE`什么也不做就直接关闭
- `DISPOSE_ON_CLOSE`任何注册监听程序对象后会自动隐藏并释放窗体
- `HIDE_ON_CLOSE`隐藏窗口的默认窗口关闭
- `EXIT_ON_CLOSE`退出应用程序默认窗口关闭

设置背景颜色：`setBackground(颜色)`

颜色如 `Color.小写单词`

返回承载组件的容器：`Container ct = getContentPane()`

之后每一个组件可 `ct.add(组件实例)`

每一个控件

如：(这是个假继承，真继承见 `JDialog` 例子)

```java
import java.awt.*;
import javax.swing.*;

public class c1302 {
    public void create() {
        JFrame jf = new JFrame("这是一个标题");
        Container ct = jf.getContentPane();
        JLabel jl = new JLabel("这是一个标签");
        jl.setHorizontalAlignment(SwingConstants.CENTER);

        ct.add(jl);
        ct.setBackground(Color.white);
        jf.setVisible(true);
        jf.setSize(200, 150); //注意代码顺序
        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    public static void main(String[] args) {
        new c1302().create();
    }
}
```

validate 方法可以刷新页面。`init` 方法也可以。

dispose 方法销毁页面。

setIconImage(Image) 可以通过 ImageIcon的getImage方法获得Image



##### JDialog

对话框，继承自 `java.awt.Dialog` ，也是窗体的一种。用法类似于 JFrame

构造方法：

- `JDialog()` 无标题和父窗体
- `JDialog(Frame f)` 有父窗体无标题
- `JDialog(Frame f, boolean model)` 指定类型
- `JDialog(Frame f, String title, [boolean model])`

  model为true是模态窗口，只能弹出一个窗口且父窗口不会被锁定(不关闭主窗口就不能动)

  否则是非模态，可以创建多个，主窗口还是能动

如：

```java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

class dialog extends JDialog {
    public dialog(c1303 frame) {
        super(frame, "窗体qwq", true);
        Container ct = getContentPane();
        ct.add(new JLabel("这是一个对话框"));
        setBounds(120, 120, 100, 100);
    }
}

public class c1303 extends JFrame {
    public static void main(String[] args) {
        new c1303();
    }

    public c1303() {
        Container ct = getContentPane();

        JButton jb = new JButton("there's no button");
        jb.setBounds(10, 10, 100, 21);
        //报错的话需要这一行：import java.awt.event.*;
        jb.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                new dialog(c1303.this).setVisible(true);
            }
        });
        ct.add(jb);

        setSize(200, 100);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}
```



#### 组件

##### Icon

图标可以用 java 支持的图片文件类型进行创建，也可以使用 `java.awt.Graphics` 类提供的功能方法来创建

通过 `Icon` 接口创建图标，必须实现接口的三个方法：

- `public int getIconHeight()`
- `public int getIconWidth()`
- `public void paintIcon(Component arg0, Graphics arg1, int arg2, int arg3)`  在指定坐标位置画图

通常有构造函数，以确认宽高。

绘制一个实心圆形，如：

```java
import java.awt.*;
import javax.swing.*;

class circleicon implements Icon {
    private int w, h;

    public circleicon(int a, int b) {
        w = a;
        h = b;
    }

    public int getIconHeight() {
        return h;
    }

    public int getIconWidth() {
        return w;
    }

    public void paintIcon(Component arg0, Graphics arg1, int x, int y) {
        arg1.fillOval(x, y, w, h);//drawOval空心
    }
}

public class c1304 extends JFrame {
    public static void main(String[] args) {
        new c1304();
    }

    public c1304() {
        Container ct = getContentPane();
        circleicon ic = new circleicon(15, 15);
        JLabel jl = new JLabel("awa", ic, SwingConstants.CENTER);
        ct.add(jl);
        setSize(80, 80);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```

##### ImageIcon

图片图标。根据 `javax.swing.ImageIcon` 创建。该类实现了 `Icon` 接口，支持多种图片格式。

构造方法：

- `ImageIcon()`

  然后再用 `setImage(Image img)` 公有方法设置图片
  
- `ImageIcon(Image img, [String description])`

- `ImageIcon(URL url)`

  URL需要用 `import java.net.URL`
  
- `ImageIcon(String 路径)`

  有可能不行，此时建议使用URL ，这个是运行路径下找
  
- `getImage()` 返回 Image 对象

图片大小的修改：

- `实例.setImage(该实例.getImage().getScaledInstance(新宽px, 新高px, Image.SCALE_DEFAULT))`
- `实例 = new imageIcon(参数同上)`

如：

```java
import java.awt.*;
import javax.swing.*;
// import java.net.URL; 

public class c1305 extends JFrame {
    public static void main(String[] args) {
        new c1305();
    }

    public c1305() {
        Container ct = getContentPane();
        JLabel jl = new JLabel("awa", JLabel.CENTER);
        // URL url = c1305.class.getResource("D:\\_lr580\\program\\C\\java\\img.png");
        // 报错
        Icon ic = new ImageIcon("img2.png"); //同一目录下
        jl.setIcon(ic);
        // jl.setHorizontalAlignment(SwingConstants.CENTER);
        // jl.setOpaque(true);//不透明
        ct.add(jl);
        setSize(1000, 1000);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}
```

点击按钮轮播图片的实现示例：

```java
package Lab7;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.net.URL;

public class Lab7_3 extends JFrame {
    public static void main(String[] args) {
        new Lab7_3();
    }

    public int nowi = 1;

    public Lab7_3() {
        Container ct = getContentPane();
        ct.setLayout(null);
        JLabel jl = new JLabel("", JLabel.CENTER);
        int w = 600, h = 600;
        nowi = 1;

        ImageIcon img[] = new ImageIcon[4]; //Icon img会炸
        for (int i = 1; i <= 3; ++i) {
            URL d = Lab7_3.class.getResource(i + ".png"); //或this.getClass().getResource
            img[i] = new ImageIcon(d);
            img[i].setImage(img[i].getImage().getScaledInstance(w, h, Image.SCALE_DEFAULT));
        }

        jl.setIcon(img[nowi]);
        jl.setOpaque(true);
        jl.setHorizontalAlignment(SwingConstants.CENTER);
        jl.setBounds(10, 60, w, h);
        ct.add(jl);

        JButton img_nx = new JButton("下一张");
        img_nx.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                Lab7_3.this.nowi--; // fail when not Lab7_3.this.
                Lab7_3.this.nowi = (nowi + 1) % 3;
                Lab7_3.this.nowi++;
                jl.setIcon(img[nowi]); // ok when not Lab7.2.this.
            }
        });
        img_nx.setBounds(500, 10, 100, 30);
        ct.add(img_nx);

        JButton img_pr = new JButton("上一张");
        img_pr.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                Lab7_3.this.nowi--;
                Lab7_3.this.nowi = (nowi - 1 + 3) % 3;
                Lab7_3.this.nowi++;
                jl.setIcon(img[nowi]);
            }
        });
        img_pr.setBounds(380, 10, 100, 30);
        ct.add(img_pr);

        setVisible(true);
        setSize(w + 100, h + 120);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```

##### JLabel

标签，父类为 `JComponent` 。显示一行只读文本、一个图像或带图像文本。

文本可使用 HTML 格式，如可以使用 `<br> &nbsp;`  ，需要用 `<html> </html>` ，对 CSS 有支持，不全面(如 `color:wheat`不可用)。甚至可以使用 `table` 标签。

构造方法：

- `JLabel()`
- `JLabel(Icon icon, [int aligment])` 图标和水平对齐方式
- `JLabel(String t, [int alignment])`
- `JLabel(String t, Icon icon, int alignment)`

设置图标：`setIcon(Icon icon)`

不透明：`setOpaque(true)`

如：

```java
String t = "<html>";
for (int i = 1; i <= 9; ++i) {
    for (int j = 1; j <= i; ++j) {
        t += Integer.toString(i * j) + " ";
    }
    t += "<br/>";
}
t += "</html>";

JLabel jl = new JLabel(t);
```

```java
String t = "<html><div style='color:red;font-size:18;font-weight:900'>--by lr580</div></html>"; // align不可用
JLabel jl = new JLabel(t);
```

##### JButton

普通按钮。构造方法：

- `JButton()`
- `JButton(String text)`
- `JButton(Icon icon)`
- `JButton(String text, Icon icon)` 图标在左，字在右

常用方法：

- `setEnabled(false)` 禁用状态
- `setIcon(icon)`
- `setToolTipText(string)` 鼠标放置时显示文字
- `setBorderPainted(false)` 不显示边界

点击事件需要：`import java.awt.event.*;` ，模板为：

```java
jb.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
		//点击后做什么写在这里
    }
});
```

如：

```java
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class c1313 extends JFrame {
    public static void main(String[] args) {
        new c1313();
    }

    public c1313() {
        Container ct = getContentPane();
        setLayout(null);
        ImageIcon ico = new ImageIcon("ico4.png");
        ico.setImage(ico.getImage().getScaledInstance(60, 50, Image.SCALE_DEFAULT));
        JButton jb = new JButton("awa", ico);
        // jb.setHideActionText(true);
        jb.setToolTipText("123");
        jb.setBorderPainted(false);
        // setMaximumSize(new Dimension(600, 400));
        jb.setBounds(10, 10, 150, 80);
        jb.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                JOptionPane.showMessageDialog(null, "go away");
            }// 弹出确认对话框
        });
        ct.add(jb);
        setVisible(true);
        setSize(500, 300);
        // setMinimumSize(new Dimension(400, 300));
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}
```

##### JRadioButton

单选框。圆形图标+说明文字。为 `AbstractButton` 类的子类  `JToggleBottion `的子类。

构造方法：

- `JRadioButton([[String text],[Icon icon],[boolean selected]])`

常用方法：

- `setSelected(b)`
- `isSelected()`
- `setText(str)`
- `setIcon(ic)`
- `getText()`

需要放在按钮组里才能实现单选。按钮组为 `ButtonGroup` ，有 `add` 方法；注意按钮组不能放在面板上，每个单选框还得自己放在面板上。

如：(两种遍历方法)

```java
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class c1315 extends JFrame {
    public static void main(String[] args) {
        new c1315();
    }

    public c1315() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(0, 10, 10));
        final JRadioButton jr[] = new JRadioButton[3];
        final ButtonGroup bg = new ButtonGroup();
        for (int i = 0; i < 3; ++i) {
            jr[i] = new JRadioButton("" + i, i == 0);
            ct.add(jr[i]);
            bg.add(jr[i]);
        }
        JButton jb = new JButton("submit");
        jb.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                for (int i = 0; i < 3; ++i) {
                    if (jr[i].isSelected()) {
                        JOptionPane.showMessageDialog(null, "" + i);
                        break;
                    }
                }
            }
        });
        ct.add(jb);

        setSize(500, 100);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```

```java
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class c1316 extends JFrame {
    public static void main(String[] args) {
        new c1316();
    }

    public c1316() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(0, 10, 10));
        final JRadioButton jr[] = new JRadioButton[3];
        final ButtonGroup bg = new ButtonGroup();
        for (int i = 0; i < 3; ++i) {
            jr[i] = new JRadioButton("" + i, i == 0);
            ct.add(jr[i]);
            bg.add(jr[i]);
        }
        JButton jb = new JButton("submit");
        jb.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                Component cps[] = ct.getComponents();
                for (Component cp : cps) {
                    if (cp instanceof JRadioButton) {
                        JRadioButton j = (JRadioButton) cp;
                        if (j.isSelected()) {
                            JOptionPane.showMessageDialog(null, j.getText());
                            break;
                        }
                    }
                }
            }
        });
        ct.add(jb);

        setSize(500, 100);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```

##### JCheckBox

复选框。用法跟 `JRadioButton` 类似，但是不需要按钮组。如：

```java
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class c1317 extends JFrame {
    public static void main(String[] args) {
        new c1317();
    }

    public c1317() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(0, 10, 10));
        final JCheckBox jr[] = new JCheckBox[3];
        for (int i = 0; i < 3; ++i) {
            jr[i] = new JCheckBox("" + i, i == 0);
            ct.add(jr[i]);
        }
        JButton jb = new JButton("submit");
        jb.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                String res = ""; //小心作用域陷阱
                for (int i = 0; i < 3; ++i) {
                    if (jr[i].isSelected()) {
                        res += i + ", ";
                    }
                }
                JOptionPane.showMessageDialog(null, res);//不要弹窗三次
            }
        });
        ct.add(jb);

        setSize(500, 100);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```

##### JComboBox

下拉列表框， `javax.swing.JComponent` 类的子类。构造方法：

- `public JComboBox()`
- `public JComboBox(ComboBoxModel datamodel)`
- `public JComboBox(Object[] arraydata)`
- `public JComboBox(Vector vector)`

有方法：

- `public void setSelectedItem(Object item)`

  设置下拉列表框的选中项
  
- `public Object getSelectedItem()`

  返回选中项(返回值类型具体而定)
  
- `public Object getElementAt(int index)`

  根据索引返回值
  
- `public int getItemCount()`

  返回列表长度
  
- `public void setSelectedIndex(int index)`

  设置当前选中项下标

可以自定义列表项为任意内容(乃至是控件，面板等)，需要自定义一个接口，如：

```java
class 类名 extends AbstractListModel<类型> implements ComboBoxModel<同一类型> {
    实现上述四个方法
}
```

创建下拉列表框则：(JDK7新特性)

```java
JComboBox<该类型> jc = new JComboBox<>(new 类名());
```

如：

```java
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class c1319 extends JFrame {
    public static void main(String[] args) {
        new c1319();
    }

    public c1319() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(0, 10, 10));

        String s[] = { "123", "456awa" };
        JComboBox jc = new JComboBox(s);
        ct.add(jc);

        JLabel jl = new JLabel("click me");
        jl.addMouseListener(new MouseAdapter() {
            public void mousePressed(MouseEvent e) {
                int i = e.getButton();
                if (i == MouseEvent.BUTTON1) {
                    JOptionPane.showMessageDialog(null, jc.getSelectedItem() + "!");
                }
            }
        });
        ct.add(jl);

        setSize(500, 100);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}
```

```java
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

class test2 extends AbstractListModel<String> implements ComboBoxModel<String> {
    String t[] = { "ac automaton", "awa", "123456" };
    String sele = null;

    public String getElementAt(int index) {
        return t[index];
    }

    public int getSize() {
        return t.length;
    }

    public void setSelectedItem(Object item) {
        sele = (String) item;
    }

    public Object getSelectedItem() {
        return sele;
    }
}

public class c1321 extends JFrame {
    public static void main(String[] args) {
        new c1321();
    }

    public c1321() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(0, 10, 10));

        JComboBox<String> jc = new JComboBox<>(new test2());
        ct.add(jc);

        JLabel jl = new JLabel("click me");
        jl.addMouseListener(new MouseAdapter() {
            public void mousePressed(MouseEvent e) {
                System.out.println("1");
                int i = e.getButton();
                if (i == MouseEvent.BUTTON1) {
                    JOptionPane.showMessageDialog(null, jc.getSelectedItem() + "!");
                }
            }
        });
        ct.add(jl);

        setSize(500, 100);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}
```



##### JList

列表框。无滚动效果，如果需要要用滚动面板。按住shift/ctrl可以多选。构造方法为：

- `JList()`
- `JList(Object[] listData)`
- `JList(Vector listData)`
- `JList(ListModel dataModel)`

有方法：

- `setListData()`
- `getSelectedIndex()` 返回 int (不会跳到下一个)
- `getSelectedValue()` 返回对应类型对象或 null 
- `getSelectedIndices()` 返回 int[]
- `getModel()` 返回 ListModel ，有 `getElementAt` ，配合下标使用

自定义模型需要以 `AbstractListModel<>` 为父类，需要实现两个方法：

- `public 类型 getElementAt(int i)`
- `public int getSize()`

可以用默认模型 `DefaultListModel` ，有方法 `addElement` 。



举例：(自定义模型+滚动面板)

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Arrays;

class jlistjb extends JButton {
    public jlistjb(JList jl) {
        super("submit");
        addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int[] sele = jl.getSelectedIndices();
                ListModel tmp = jl.getModel();
                String res = "";
                for (int i = 0; i < sele.length; ++i) {
                    res += tmp.getElementAt(sele[i]) + "\n";
                }
                JOptionPane.showMessageDialog(null, res);
            }
        });
    }
}

public class c1323 extends JFrame {
    private class mlistmodel extends AbstractListModel<String> {
        private String[] x;

        public mlistmodel(String y[]) {
            x = Arrays.copyOf(y, y.length);
        }

        public String getElementAt(int i) {
            if (i < x.length) {
                return x[i++];
            } else {
                return null;
            }
        }

        public int getSize() {
            return x.length;
        }
    }

    public c1323() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(1, 10, 2));
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(300, 300);

        String[] x = new String[20];
        for (int i = 0; i < x.length; ++i) {
            x[i] = "item " + Integer.toString(i + 1);
        }
        JList<String> jl = new JList<>(new mlistmodel(x));
        JScrollPane js = new JScrollPane(jl);
        ct.add(js);
        ct.add(new jlistjb(jl));

        setVisible(true);
    }

    public static void main(String[] args) {
        new c1323();
    }
}

```



例如：(Vector的基本操作)

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class c1322 extends JFrame {
    public c1322() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(1, 10, 2));
        Vector nr = new Vector();
        JList jl = new JList(nr);
        for (int i = 1; i <= 5; ++i) {
            nr.add("item " + Integer.toString(i));
        }
        ct.add(jl);
        ct.add(new jlistjb(jl));

        //         // ListModel tmp = jl.getModel(); 原地输出全部列表项
        //         // int siz = tmp.getSize();
        //         // for (int i = 0; i < siz; ++i) {
        //         // System.out.println(tmp.getElementAt(i));
        //         // }

        //         // List<Integer> sele = jl.getSelectedValuesList(); 不会用
        //         // Iterator<Integer> it = sele.iterator();
        //         // while (it.hasNext()) {
        //         // System.out.println(it.next());
        //         // }
        //     }
        // });
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(300, 300);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c1322();
    }
}

```



举例：默认模型

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class c1324 extends JFrame {
    public c1324() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(1, 10, 2));
        String[] x = { "lr580", "awa", ">_<" };
        DefaultListModel items = new DefaultListModel();
        JList jl = new JList(items);
        for (int i = 0; i < 3; ++i) {
            items.addElement(x[i]);
        }
        ct.add(jl);
        ct.add(new jlistjb(jl));

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(300, 300);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c1324();
    }
}

```



##### JTextField

显示或编辑单行文本，继承自 `javax.swing.text.JTextComponent` ，构造方法：

- `JTextField()`
- `JTextField(String text)`
- `JTextField(int fieldwidth)`
- `JTextField(String text, int fieldwidth)`
- `JTextField(Document docModel, String, int)`

int 代表文本框长度。

方法：

- `setText()`
- `getText()`
- `requestFocus()` 焦点回到文本框

如：

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class c1326 extends JFrame {
    public c1326() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(1, 10, 2));

        final JTextField ja = new JTextField(10);
        ct.add(ja);

        JButton jb = new JButton("submit");
        jb.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                JOptionPane.showMessageDialog(null, ja.getText());
                ja.setText("");
                ja.requestFocus();
            }
        });
        ct.add(jb);

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(300, 300);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c1326();
    }
}
```



##### JPasswordField

密码框。构造方法同文本框。有新的方法：

- `setEchoChar(char xxx)` 回显字符 默认是点
- `getPassword()` 获取密码(需要传入String构造函数才能正常显示)

如：

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class c1325 extends JFrame {
    public c1325() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(1, 10, 2));

        final JPasswordField ja = new JPasswordField("aa", 10);// 也是密文
        // ja.setEchoChar('.');
        ct.add(ja);

        JButton jb = new JButton("submit");
        jb.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                JOptionPane.showMessageDialog(null, new String(ja.getPassword()));
                ja.setText("awa");
                ja.requestFocus();
            }
        });
        ct.add(jb);

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(300, 300);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c1325();
    }
}

```



##### JTextArea

可写多行文本框。

构造函数：

- `JTextArea()`
- `JTextArea(String text)`
- `JTextArea(int rows, int columns)`
- `JTextArea(Document doc)`
- `JTextArea(Document doc, String Text, int rows, int columns)`

方法：

- `setLineWrap(true)` 超过宽度自动换行
- `setForeground(Color.颜色常量)` 设置字的颜色
- `append(String s)` 添加内容到尾部(`\n`换行)
- `setText(String s)` 更改内容
- `getText()` 获取内容
- `setSelectionEnd(int pos)` 将光标移到特定字符位置前(.length是末尾)



如：

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class c1327 extends JFrame {
    public c1327() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(1, 10, 2));

        final JTextArea ja = new JTextArea(10, 10);
        ja.setForeground(Color.blue);
        ja.setLineWrap(true);
        ja.append("1\n22\n333\n");
        ja.append("4444\n");
        ct.add(ja);

        JButton jb = new JButton("submit");
        jb.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                JOptionPane.showMessageDialog(null, ja.getText());
                ja.setText("ok\n");
                ja.setSelectionEnd(ja.getText().length());
            }
        });
        ct.add(jb);

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(300, 300);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c1327();
    }
}

```



##### JFileChooser

文件选择器。

方法：

- `setCurrentDirectory(new File(路径))` 选择初始路径

- `showOpenDialog(Container)` 打开一个对话框，返回值是 int

  若返回值为 JFileChooser.APPROVE_OPTION ，是无效选择

- `getSelectedFile()` 返回 File，是选择的文件；或 `..Files`方法

- `setMultiSelectionEnabled(boolean)` 默认单选

- `setFileSelectionMode(int)` `FILES_ONLY` 默认， `DIRECTORIES_ONLY, FILES_AND_DIRECTORIES`

- `setFileFilter(FileFilter filter)`

其中 `FileFilter` 抽象类是 `javax.swing.filechooser.FileFilter` ，需要实现：

- `boolean accept(File f)`
- `String getDescription()`

而同包下的 `FileNameExtensionFilter` 是实现类，构造方法是 `String dsc, String...extensions` ，后者是后缀名(不含 `.`)

如：

```java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;

public class Lab9_4 extends JFrame {
    public static void main(String[] args) {
        new Lab9_4();
    }

    public Lab9_4() {
        Container ct = getContentPane();
        final JTextArea t_res = new JTextArea(10, 40);
        t_res.setLineWrap(true);
        final JScrollPane s_res = new JScrollPane(t_res);
        ct.add(s_res, BorderLayout.CENTER);

        JPanel p_but = new JPanel(new FlowLayout(1, 20, 10));
        JButton b_in = new JButton("Read from file");
        b_in.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                JFileChooser fc = new JFileChooser();
                fc.setCurrentDirectory(new File("."));
                int i = fc.showOpenDialog(ct);
                if (i != JFileChooser.APPROVE_OPTION) {
                    return;
                }

                File f = fc.getSelectedFile();
                if (!f.exists()) {
                    try {
                        f.createNewFile();
                    } catch (Exception e1) {
                        e1.printStackTrace();
                    }
                }

                try {
                    FileReader fr = new FileReader(f);
                    BufferedReader bfr = new BufferedReader(fr);
                    StringBuilder res = new StringBuilder();
                    String line = "";
                    while (null != (line = bfr.readLine())) {
                        res.append(line + "\n");
                    }
                    bfr.close();
                    fr.close();
                    t_res.setText(res.toString());
                } catch (Exception e2) {
                    e2.printStackTrace();
                }
            }
        });

        JButton b_out = new JButton("Write into file");
        b_out.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                JFileChooser fc = new JFileChooser();
                fc.setCurrentDirectory(new File("."));
                int i = fc.showOpenDialog(ct);
                if (i != JFileChooser.APPROVE_OPTION) {
                    return;
                }

                File f = fc.getSelectedFile();
                try {
                    FileWriter fw = new FileWriter(f);
                    BufferedWriter bfw = new BufferedWriter(fw);
                    bfw.write(t_res.getText());
                    bfw.close();
                    fw.close();
                } catch (Exception e2) {
                    e2.printStackTrace();
                }
            }
        });

        p_but.add(b_out);
        p_but.add(b_in);
        ct.add(p_but, BorderLayout.SOUTH);

        setSize(500, 400);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```

```java
import javax.swing.*;
import javax.swing.filechooser.*;
import java.awt.*;
import java.awt.event.*;
import java.io.File;

public class c2302 extends JFrame {
    public c2302() {
        JButton jb = new JButton("fulge");
        final Container ct = getContentPane();
        jb.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                JFileChooser fc = new JFileChooser();
                fc.setCurrentDirectory(new File("."));
                FileFilter filt = new FileNameExtensionFilter("我的最爱(code)", "c", "cpp", "java", "py");
                fc.setFileFilter(filt);
                if (fc.showOpenDialog(ct) != JFileChooser.APPROVE_OPTION) {
                    return;
                }
                File f = fc.getSelectedFile();
                System.out.println(f);
            }
        });
        ct.add(jb);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2302();
    }
}

```





##### JSlider

滑动条

方法：

- `setMaximum()`
- `setMinimum()`
- `setValue()`
- `getValue()`

可以添加的事件模板为 `ChangeEvent` ，需要 `import javax.swing.event.*;` ，模板为：

```java
.addChangeListener(new ChangeListener() {
    public void stateChanged(ChangeEvent e) {
        cv.repaint();
    }
});
```





##### JprogressBar

进度条

- `setIndeterminate(boolean)` true 是不明确表示进度(来回滚动)样式
- `setStringPainted(boolean b)`
- `setString(String s)`
- `setValue(int)` $[0,100]$ ，显示百分比



##### SystemTray

SystemTray 系统托盘类，即右下角小图标。通过该类静态方法 `getSystemTray()` 获得。还有静态方法 `isSupported()`

方法：

- `add(TrayIcon)`
- `remove(TrayIcon)`

有类 `TrayIcon` 类，传入参数(后两个可选)构造：

- `TrayIcon(Image, String tooltip, PopupMenu)`

  注意不是 `JPopupMenu`

方法：

- `getSize()` 或 `getTrayIconSize()` 获得支持的最大尺寸



##### Desktop

在 java 启动本机注册的应用程序，如浏览器。

静态方法： `isDesktopSupported()`

方法：

- `browse(URL)` 浏览器
- `edit(File)` 记事本
- `open(File)` 打开 Word

提供的每一种操作都属于 `Desktop.Action` 表示的动作类型，如 `Desktop.EDIT` ，把它传到  `isDesktopSupported()` 。



##### JTree

`import javax.swing.tree.*;`

树。构造方法：

- `JTree()` 会给定有若干预设节点的树
- `JTree(TreeNode root)` 根节点
- `JTree(TreeModel newModel)`

`DefaultMutableTreeNode` 类实现了 `TreeNode` 接口。构造方法如下：

- `DefaultMutableTreeNode()` 默认节点，可以有子节点
- `DefaultMutableTreeNode(Object userObject)` 指定标签
- `DefaultMutableTreeNode(Object, boolean allow)` 子节点拥有是否允许

该类有方法：`add(DefaultMutableTreeNode child)`

`DefaultTreeModel` 类实现了 `TreeModel` 接口，提供以下两个构造方法：

- `DefaultTreeModel(TreeNode root)` 默认方式判定节点是否是叶子(是否不存在子节点)
- `DefaultTreeModel(Treenode, boolean ask)` 若 `true` ，不允许有子节点的节点是叶子；否则是默认

`TreeSelectionModel` 类对象可以设置树的选择模式，可以通过 `JTree` 类的 `getSelectionModel()` 方法获得，然后通过模型类的方法 `setSelectionMode(int mode)` 设置选择模式，入口参数为该类的静态常量：

- `SINGLE_TREE_SELECTION` 1
- `CONTIGUOUS_TREE_SELECTION` 2
- `DISCONTIGUOUS_TREE_SELECTION` 4，默认

选中和取消选中节点时，发出事件 `TreeSelectionEvent` ，可以实现该接口来获取事件：

```java
.addTreeSelectionListener(new TreeSelectionListener() {
    public void valueChanged(TreeSelectionEvent e) {
        
    }
});
```

通过 `JTree` 类的 `getSelectionPaths()` 获得所有被选中节点的路径，得到 `TreePath` 类数组。(若没有 `s` ，得到索引最小的节点的路径，即距离根节点最近的)。可以通过 `isSelectionEmpty()` 查看被选中节点，通过 `getSelectionCount()` 查看被选中数量。 `TreePath` 可以获得子节点所属父节点等，方法为：

- `getPath()` 以 `Object` 数组返回路径所有节点对象，顺序从根到子

  对该 Object 的操作需要用 `.getUserObject()` ，可以进行输出

- `getLastPathComponent()` 获得路径最后一个节点

- `getParentPath()` 除了最后一个节点的路径

- `pathByAddingChild(Object child)` 获得加节点后路径

- `getPathCount()` 节点数

- `getPathComponent(int elem)` 获得路径指定索引位置的节点对象

对节点对象，有方法：

- `preorderEnumeration() ` 
- `postorderEnumeration()`
- `breadthFirstEnumeration()`
- `depthFristEnumeration()` (同后序遍历)

返回 `Enumberation<?>`  ，有方法 `hasMoreElements()` 和 `nextElement()` (需要库 `import java.util.Enumeration; `，其跟 `iterator` 相似)

其他方法：

- `getLevel()` 根节点是1
- `getDepth()` 以该节点为根的树深度，叶子是0
- `getParent()`
- `getChildCount()`
- `getFirstChild()`
- `getSiblingCount()` 兄弟节点数目
- `getPreviousSibling()` 
- `getNextSibling()`
- `getPath()`
- `isRoot()`
- `isLeaf()`

默认显示根节点，不显示根节点手柄。可以设置 `setRootVisible()` 取消显示根节点。可以 `setShowsRootHandles(boolean)` 显示根节点手柄。默认非叶子节点图标是文件夹图标，叶子是文件图标。可以通过 `DefaultTreeCellRenderer` 类对象修改，获取方法是 `getCellRenderer()` ，有方法 `setLeafIcon(Icon)`,  `setClosedIcon(Icon)` , `setOpenIcon(Icon)` 。可以设 null 。

通过 `putClientProperty(Object key, Object value)` 设置连接线绘制方式，其 key 为字符串 `JTree.lineStyle` ，value 字符串可以设置为 `None, Horizontal` (水平分栏线), `Angled`(默认)。

设置 `expandPath(TreePath)` 可以设置一开始哪个地方节点是展开的，可以 DFS 展开所有非叶子节点。

对树模型，有方法：

- `insertNodeInto(MutableTreeNode newchild, MutableTreeNode parent, int index)` ，其 index 表示添加到父节点的索引位置，从 0 开始
- `nodeChanged(TreeNode)` ，如果修改的是节点的用户对象，不会同步 GUI ，通知后才同步
- `removeNodeFromParent(MutableTreeNode)` 根节点不能删除

`JTree` 类还有 `setFont, isVisible, makeVisible` 等通用方法

展开折叠树节点事件捕获：(依次是将要折叠，将要展开)

```java
.addTreeWillExpandListener(new TreeWillExpandListener(){
   public void treeWillCollapse(TreeExpansionEvent e) { 
       
   } 
   public void treeWillExpand(TreeExpansionEvent e) { 
       
   } 
});
```

也可以改成展开时才捕获：

```java
tr.addTreeExpansionListener(new TreeExpansionListener(){
    public void treeCollapsed(TreeExpansionEvent e) { 

    } 
    public void treeExpanded(TreeExpansionEvent e) { 

    } 
});
```



如：

```java
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.awt.*;
import java.util.Enumeration;

public class c2201 extends JFrame {
    public c2201() {
        DefaultMutableTreeNode p = new DefaultMutableTreeNode("root");
        DefaultMutableTreeNode tc = new DefaultMutableTreeNode("child2");
        p.add(new DefaultMutableTreeNode("child1"));
        p.add(tc);
        tc.add(new DefaultMutableTreeNode("ccc"));
        DefaultTreeModel tm = new DefaultTreeModel(p);
        final JTree tr = new JTree(tm);
        // treesele
        tr.addTreeSelectionListener(new TreeSelectionListener() {
            public void valueChanged(TreeSelectionEvent e) {
                if (!tr.isSelectionEmpty()) {
                    TreePath[] seles = tr.getSelectionPaths();
                    for (int i = 0; i < seles.length; ++i) {
                        TreePath path = seles[i];
                        Object[] p = path.getPath();
                        for (int j = 0; j < p.length; ++j) {
                            DefaultMutableTreeNode node = (DefaultMutableTreeNode) p[j];
                            String s = node.getUserObject() + (j + 1 == p.length ? "" : "-->");
                            System.out.print(s);
                        }
                        System.out.println();
                    }
                    System.out.println();
                }
            }
        });
        // TreeSelectionModel tsm = tr.getSelectionModel();
        // tsm.setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        getContentPane().add(tr);
        Enumeration<?> it = p.depthFirstEnumeration();
        while (it.hasMoreElements()) {
            DefaultMutableTreeNode po = (DefaultMutableTreeNode) it.nextElement();
            for (int i = 0; i < po.getLevel(); ++i) {
                System.out.print("--");
            }
            System.out.println(po.getUserObject());
        }
       tr.addTreeWillExpandListener(new TreeWillExpandListener() {
        //     public void treeWillCollapse(TreeExpansionEvent e) {
        //         System.out.println("aaa");
        //     }

        //     public void treeWillExpand(TreeExpansionEvent e) {
        //         System.err.println("bbb");
        //     }
        // });
        // tr.addTreeExpansionListener(new TreeExpansionListener(){
        //     public void treeCollapsed(TreeExpansionEvent e) { 
                
        //     } 
        //     public void treeExpanded(TreeExpansionEvent e) { 
                
        //     } 
        //  }); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2201();
    }
}

```





#### 布局

##### 绝对布局

指定每个组件的位置和大小。

- `Container.setLayout(null)` 取消布局管理器

  否则在其他布局方式里，不能保证位置和大小正确(优先级低)

  一般 JFrame 实例即可
- `Component.setBounds(x,y,w,h)`

  窗口也能用

如：

```java
import java.awt.*;
import javax.swing.*;

class fr extends JFrame {
    public fr() {
        setLayout(null);
        setBounds(100, 0, 400, 200);
        Container ct = getContentPane();
        JLabel x1 = new JLabel("awa");
        x1.setBounds(0, 30, 30, 30);
        ct.add(x1);
        JLabel x2 = new JLabel("qwq");
        x2.setBounds(50, 50, 80, 40);
        ct.add(x2);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

public class c1306 {
    public static void main(String[] args) {
        new fr();
    }
}
```

##### 流布局管理器

最基本管理器。从左到右摆放组件，直到占满一行，在后往下移动一行。组件在行内默认居中。当窗口大小变化时，会动态改变组件布局(下同)。

不可以自行设置组件的大小。

> `FlowLayout` 组件**大小**不随容器大小变化而变化

构造方法：

- `FlowLayout([int alignment, [int horizGap, int vertGap]])`

  alignment 可以是：

  - `FlowLayout.LEFT = 0`
  - `FlowLayout.CENTER = 1`
  - `FlowLayout.RIGHT = 2`

  horizGap 和 vertGap  以像素为单位，指定组件水平和垂直间隔

然后将构造实例放到 `setLayout`即可，如 `setLayout(new FlowLayout(...))`

如：

```java
import java.awt.*;
import javax.swing.*;

public class c1308 extends JFrame {
    public static void main(String[] args) {
        new c1308();
    }

    public c1308() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(2, 10, 2));//ct.也能跑
        for (int i = 0; i < 10; ++i) {
            ct.add(new JButton("button " + i));
        }
        setVisible(true);
        setSize(300, 300);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}
```

##### 边界布局管理器

默认布局管理器。会让组件自动排满整个窗口。(`JPanel`不默认)

在添加组件时，`ct.add(区域, 组件)` 可以控制放置的区域（下述常量类型是字符串）：

- `BorderLayout.NORTH`
- `BorderLayout.SOUTH`
- `BorderLayout.EAST`
- `BorderLayout.WEST`
- `BorderLayout.CENTER` 在中间开始填充，直到与其他组件边界连接

注意一个方位只能有一个组件。不然会被覆盖掉。可以让方位区域无组件。如：

```java
import java.awt.*;
import javax.swing.*;

public class c1309 extends JFrame {
    public static void main(String[] args) {
        new c1309();
    }

    public c1309() {
        Container ct = getContentPane();
        String[] border = { BorderLayout.CENTER, BorderLayout.NORTH, BorderLayout.SOUTH, BorderLayout.WEST,
                BorderLayout.EAST };
        ct.add(border[0], new JButton("1"));
        ct.add(border[1], new JButton("2"));
        ct.add(border[1], new JButton("3"));
        ct.add(border[2], new JButton("4"));
        ct.add(border[3], new JButton("5"));
        ct.add(border[3], new JButton("6"));
        ct.add(border[3], new JButton("7"));
        ct.add(border[4], new JButton("8"));
        setVisible(true);// 只有13478被显示
        setSize(300, 300);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```

##### 网格布局管理器

按行列排列，每一个组件大小相同。每一个组件填满整个网格。缺省时，排列方式比较神奇。

构造方法：

- `public GridLayout(int rows, int columns, [int horizGap, int vertGap])`

如：

```java
import java.awt.*;
import javax.swing.*;

public class c1310 extends JFrame {
    public static void main(String[] args) {
        new c1310();
    }

    public c1310() {
        Container ct = getContentPane();
        setLayout(new GridLayout(3, 5, 2, 15));
        for (int i = 0; i < 12; ++i) {
            ct.add(new JButton("button " + i));
        } //i<13时又不一样了
        setVisible(true);
        setSize(500, 300);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}
```

##### 网格组布局管理器

`GridBagLayout` ，动态矩形网络，由无数单元格组成，每个组件可以占用若干个；行列数动态可加

添加组件时，需要为每个组件创建一个与之关联的 `GridBagConstraints` 类对象，通过该类属性设置布局信息

容器方向决定绘制方向，若容器从左到右，位于矩形网络左上角单元格列索引是 0 ，左上角是起点；从右到左则右上角单元格列索引为 0 ，右上角起点

属性：

1. `gridx, gridy`

   组件起始点所在单元格索引值，起始点所在列和行

2. `gridwidth, gridheight`

   占用行数和列数

3. `anchor`

   设置所在显示区域的显示位置，九个方位大写单词是该类静态常量(中心是 CENTER，默认)

4. `fill`

   组件填充方式，单元格显示区域大于组件面积或组件占用多个单元格时，可以设置，四个静态常量:
   `NONE` 不调整组件大小

   `HORIZONTAL` 宽度拉到填满

   `VERTICAL` 高度

   `BOTH`

5. `insets`

   组件四周与单元格边缘之间的最小距离，属性类型为 `Insets` 类，构造方法是 `Insets(int top, int left, int bottom, int right)` ，即外边距最小距离，单位像素

6. `ipadx, ipady`

   修改组件的首选大小，宽度高度，正数增加，负数减小

7. `weightx, weighty`

   网格组每一行每一列对额外空间的分布方式，不设置(默认)不分布容器额外空间。列取所有单元格 `weightx` 最大值，行同理，建议只设置第一行第一列

   对行，先获取 `weightx` 最大值，然后计算每个最大值占所有最大值总和的百分比，然后将额外空间按比例分配给行，列同理。

它们都是 `GridBagConstraints` 类公有对象。在`add`时第一个参数是组件，第二个是`GridBagConstraints` 类对象。



#### 面板

##### JPanel

继承自 `java.awt.Container` ，自己可以有自己内部的布局。由此可以实现布局嵌套。用法同 `Container` 。构造函数可以传入一个布局实例参数。

如：

```java
import java.awt.*;
import javax.swing.*;

public class c1311 extends JFrame {
    public static void main(String[] args) {
        new c1311();
    }

    public c1311() {
        Container ct = getContentPane();
        JPanel top = new JPanel();
        top.add(new JLabel("****, world!"));
        ct.add(BorderLayout.NORTH, top);

        JPanel mid = new JPanel(new GridLayout(2, 5, 5, 5));
        for (int i = 0; i < 10; ++i) {
            mid.add(new JButton("click" + i));
        }
        ct.add(BorderLayout.CENTER, mid);

        JPanel bottom = new JPanel(new FlowLayout(2, 8, 10));
        for (int i = 0; i < 3; ++i) {
            bottom.add(new JButton("button " + i));
        }
        ct.add(BorderLayout.SOUTH, bottom);
        setVisible(true);
        setSize(500, 300);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```

##### JScrollPane

滚动面板。用于装一个组件(可以是 `JPanel`)，之后让一个面板放入滚动面板(组件就不用再单独放置了)，使得组件可以滚动。不支持布局管理器。长度足够时，不会显示滚动条。当哪一轴不够位置时，会自动显示。如：

```java
import java.awt.*;
import javax.swing.*;

public class c1312 extends JFrame {
    public static void main(String[] args) {
        new c1312();
    }

    public c1312() {
        Container ct = getContentPane();
        JTextArea ta = new JTextArea(3,20);
        JScrollPane sp = new JScrollPane(ta);
        ct.add(sp);
        setVisible(true);
        setSize(500, 300);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```

也可以后面再设置装载组建，用 `setViewportView(组件)`

有方法 `setRowHeaderView` ，可以放入一个 `JViewport` ，其有方法 `viewport(Component)` 和 `setPreferredSize` ，可以用组件的 `getPreferredSize()` 得之。



##### JOptionPane

有弹窗：

普通确认窗：`JOptionPane.showMessageDialog(null, String info);`

除此之外还有是否窗。`showConfirmDialog`

会打断当前控制流，直到点击把窗口弄掉才会跑下面的代码。是否框例子参见事件-窗体事件。例如：

```java
int i = JOptionPane.showConfirmDialog(null, "是否保存当前修改", "提示", JOptionPane.OK_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE);
if (i == JOptionPane.OK_OPTION) {// 保存
    ProcessCtrl.save();
} else if (i == JOptionPane.CLOSED_OPTION) {// 叉掉
    return;
} else if (i == JOptionPane.CANCEL_OPTION) {// 不保存
    ProcessCtrl.undoall();
}
```





##### JSplitPane

分割面板，分隔条可调整

- `JSplitPane()` 水平分割，竖分割线，调整分割线位置时重绘
- `JSplitPane(int p)` 参数为 `HORIZONTAL_SPLIT, VERTICAL_SPLIT`
- `JSplitPane(int p, boolean f)` 若 true ，调整过程连续重绘；否则只有调整完成时重绘

方法：

- `setOrientation(int p)` 水平还是垂直

- `setDividerLocation(int p)` 分隔条绝对位置

- `setDividerLocation(double p)` 百分比

- `setDividerSize(int s)` 分隔条宽度，默认5像素

- `setLeftComponent(Component)` 添加组件到左侧

  同理有 `Right, Top, Bottom` (Left=Top , 同理)

- `setOneTouchExpandable(boolean)` 分隔条提供按钮将其快速占据整个区域

- `setContinuousLayout(boolean f)` 重绘方式



##### JTabbedPane

选项卡面板

- `JTabbedPane()` 标签位于上方，布局为限制布局
- `JTabbedPane(int tabPlacement)` TOP, BOTTOM, LEFT, RIGHT
- `JTabbedPane(int tP, int tabLayoutPolicy)` 有 `WRAP_TAB_LAYOUT` 限制布局， `SCROLL_TAB_LAYOUT` 滚动布局(选项卡可以左右按钮移动视野)

方法：

- `addTab(String title, Component )` 添加选项卡
- `addTab(String title, Icon , Component )`
- `addTab(String title, Icon , Component , String tip)`
- `InsertTab(String, Icon, Component, String, int idx)` 从0开始，在该索引处插入
- `setTabPlacement(int)`
- `setTabLayoutPolicy(int)`
- `setSelectedIndex(int)`
- `setEnabledAt(int idx, boolean enabled)` true 可用
- `setDisabledIconAt(int idx, Icon)` 不可用时图标
- `getTabCount()`
- `getSelectedIndex()` 从 0 开始
- `getTitleAt(int idx)` 从 0 开始
- `addChangeListener(ChangeListener l)`

> `addTab` 可以参数都是 null

例如：

```java
addChangeListener(new ChangeListener() {
    public void stateChanged(ChangeEvent e) {
        System.out.println(getSelectedIndex());
    }
});
```





##### JDesktopPane

桌面面板类。第二类窗口管理策略(窗口放在主窗体上)。

`JInternalFrame` 内部窗体类，容器类，轻量级对象，支持拖动、关闭、图标化、调整大小、标题、菜单。放在桌面面板上。

方法：

- `getAllFrames()` 数组返回所有 `JInternalFrame`
- `getSelectedFrame()` null 或目标
- `removeAll()`
- `remove(int idx)`
- `setSelectedFrame(JInternalFrame f)`
- `setDragMode(int)` `LIVE_DRAG_MODE, OUTLINE_DRAG_MODE`，拖动时是否重绘(依次为)

可以在窗体 Container 加一个桌面面板

`JInternalFrame` 构造方法有六个：

- `JInternalFrame(String title, boolean resizable, boolean closable, boolean maximizable, boolean iconifiable)`

后面三个是是否提供关闭、最大化、最小化按钮

方法：

- `setResizable(boolean)`

- `setClosable(boolean)`

  同理 Maximizable, Iconifiable

- `setSelected(boolean)` 是否被激活

- `isMaximum()` 是否最大化中

- `isIcon()` 最小化

- `isClosed()`

- `setFrameIcon(Icon)`

在桌面面板上面放东西时，可以设第二个参数代表层次，越大越在顶层。



##### JToolBar

工具栏。构造方法可以传名字字符串。

方法：

- `setFloatable(boolean)` 允许随意拖动和脱离窗口
- `add(Component)`
- `addSeparator()`
- `addSeparator(Dimension size)` ，其构造函数是两个整形



#### 事件

加载：

`import java.awt.event.*;`

Swing 事件模型由三个分离的对象完成对事件的处理，分别为事件源、事件和监听程序 (事件监听器) 。事件源触发一个事件，被一个或多个监听器接收处理事件。监听器是类对象。所有事件源都有 `addXXXListener` 和 `removeXXXListener` 方法，其中 `XXX` 是监听事件类型。

可以由任意控件添加监听器。可以实现 `XXXListener` 接口。必须实现方法：

```java
public void actionPerformed(XXXEvent e)
```

> 要在事件源上注册事件监听器；不只有组件能产生事件； Java 中的事件处理基于授权事件模型 （委托事件模型 ？）
>
> 不只有外部操作会产生事件。可以通过继承 `EventObject` 类编写自定义事件类

同一个控件新生成的监听器会覆盖旧的监听器

`ActionEvent` 有 `getSource()` 方法返回触发的控件 Component。

对监听程序，可以用 `.setActionCommand(String)` 方法设置指令，然后用事件 `ActionEvent e` 的 `getActionCommand()` 获取指令，从而形成信息传递。

一般而言每个接口都有适配器实现类，即把关键字 `Listener`换成 `Adapter` 即可，适配器不必实现接口的全部方法，只需要按需实现需要的方法即可。



##### 动作事件

`ActionEvent` ，事件源是 `JButton, JList, JTextField` 等。监听器要实现的接口是 `ActionListener` 。 `XXX=Action` 。需要用 `addActionListener` 方法将实现了接口的类实例传入。

按钮被单击、文本框回车会触发动作事件。

例如：

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class c1329 extends JFrame implements ActionListener {
    private JTextField jt = null;// 必须构造，不然报错，可以是Null

    public c1329() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(1, 10, 2));

        JButton jb = new JButton("submit");
        jb.addActionListener(this);
        ct.add(jb);

        jt = new JTextField(10);
        jt.addActionListener(this);
        ct.add(jt);

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(300, 300);
        setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        String res = "submit ur hd";
        if (e.getSource() == jt) {
            res += "\n" + jt.getText();
        }
        JOptionPane.showMessageDialog(null, res);
    }

    public static void main(String[] args) {
        new c1329();
    }
}

```



##### 焦点事件

XXX $=$ Focus 。实现两个接口函数：

```java
public void focusLost(FocusEvent e)
public void focusGained(FocusEvent e)
```

如：

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class c1330 extends JFrame {
    public c1330() {
        super("awa");
        Container ct = getContentPane();
        setLayout(new FlowLayout(1, 10, 2));

        JLabel jl = new JLabel("giz.");
        ct.add(jl);

        JTextField jt = new JTextField(8);
        jt.addFocusListener(new FocusListener() {
            public void focusLost(FocusEvent e) {
                jl.setText("Don't leave me~");
                setTitle("...");
            }// 只有焦点在别的窗口才会看到文本，否则只能看到另一个Gained

            public void focusGained(FocusEvent e) {
                jl.setText("leave me alone >_<");
            }
        });
        ct.add(jt);
        JTextField jt2 = new JTextField(8);
        jt2.addFocusListener(new FocusListener() {
            public void focusLost(FocusEvent e) {
                jl.setText("num hen hen aaaaaa");
                setTitle("red tea");
            }

            public void focusGained(FocusEvent e) {
                jl.setText("1145141919180");
            }
        }); // 注意覆盖关系
        ct.add(jt2);

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 100);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c1330();
    }
}

```



##### 键盘事件

`KeyEvent` 文本框输入内容时

监听器抽象方法：

- `keyTyped(KeyEvent e)`

- `keyPressed(KeyEvent e)`

- `keyReleased(KeyEvent e)`

  输入法时每输入一次会有 release，然后最后一次是 (press-)release-typed-release；一般是press-typed-release；连按会不断触发press-typed

事件方法：

- `getSource()`  获得触发对象 Object
- `getKeyChar()`
- `getKeyCode() `是`KeyEvent`静态常量，以 `VK_` 开头
- `getKeyText(int keyCode)`
- `isActionKey()`
- `isControlDown()`
- `isAltDown()`
- `isShiftDown()`

如：

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class c2401 extends JFrame {
    public c2401() {
        JTextField jtf = new JTextField(10);
        jtf.addKeyListener(new KeyListener() {
            public void keyPressed(KeyEvent e) {
                System.out.println("press");
            }

            public void keyReleased(KeyEvent e) {
                System.out.println("release");
            }

            public void keyTyped(KeyEvent e) {
                System.out.println("typed");
            }
        });
        getContentPane().add(jtf);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2401();
    }
}

```



##### 鼠标事件

`MouseEvent`

监听器抽象方法有五个：

- `mouseEntered(MouseEvent e)`

- `mousePressed(MouseEvent e)`

- `mouseReleased(MouseEvent e)`

- `mouseClicked(MouseEvent e)`

- `mouseExited(MouseEvent e)`

  点击必须按下和释放间隔较短；顺序触发是`pressed-released-clicked`

常用方法：

- `getSource()`
- `getButton()` 有`MouseEvent`静态常量`BUTTON1,BUTTON2,BUTTON3`，值是1,2,3,代表左键、滚轮、右键
- `getClickCount()` 单击次数(可以判定双击，双击前必然先判定了一次单击)

如：

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class c2402 extends JFrame {
    public c2402() {
        getContentPane().addMouseListener(new MouseAdapter() {
            public void mousePressed(MouseEvent e) {
                System.out.println("pressed");
            }
            public void mouseReleased(MouseEvent e) {
                System.out.println("released");
            }
            public void mouseClicked(MouseEvent e) {
                System.out.println("clicked");
                System.out.println(e.getClickCount());
            }
        });
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2402();
    }
}
```





##### 窗体事件

事件 `WindowEvent` 三个监听器如下：

`WindowFocusListener, WindowStateListener, WindowListener`

以此表示焦点获得失去、状态(正常最小化、最大化)、其他(激活、打开最小化、非最小化、将要关闭、不再激活、已经关闭)

添加监听器只能由窗口来做，不能由面板来做。

这些接口依次具有的监听器为：

焦点：

- `public void windowGainedFocus(WindowEvent e)`
- `public void windowLostFocus(WindowEvent e)`

状态：

- `public void WindowStateChanged(WindowEvent e)`

其他：

- `public void windowActivated(WindowEvent e)`
- `public void windowOpened(WindowEvent e)`
- `public void windowIconified(WindowEvent e)`
- `public void windowDeiconified(WindowEvent e)`
- `public void windowClosing(WindowEvent e)`
- `public void windowDeactivated(WindowEvent e)`
- `public void windowClosed(WindowEvent e)`

事件的方法：

- `getNewState()`

- `getOldState()`

  `Frame` 类静态常量 `NORMAL, ICONIFIED, MAXIMIZED_BOTH` 0,1,6 正常，最小化，最大化

如：

(1)询问是否关闭

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class c2403 extends JFrame {
    public c2403() {
        addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                int i = JOptionPane.showConfirmDialog(null, "确认关闭吗", "提示",
                        JOptionPane.YES_NO_CANCEL_OPTION,//或OK_CANCEL_OPTION
                        JOptionPane.INFORMATION_MESSAGE);
                System.out.println(i + " " + JOptionPane.OK_OPTION);
                if (JOptionPane.OK_OPTION == i) {
                    dispose();
                }
            }
        });
        setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);//注意
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2403();
    }
}

```

(2)大小改变刷新窗口

```java
jframe.addComponentListener(new ComponentAdapter(){
	public void componentResized(ComponentEvent e){
		ct.removeAll();
		init();
	}
})
```





##### 选项事件

`ItemEvent` ，监听器抽象方法只有 `itemStateChanged(ItemEvent e)` ，修改一次下拉菜单选中项发生两次(取消原有、获得新有)

事件方法有：

- `getItem()` 得到此次事件的选项 Object 
- `getStateChange()` 可以得到`ItemEvent`静态常量 `SELECTED, DESELECTED`

如：

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class c2404 extends JFrame {
    public c2404() {
        JComboBox jc = new JComboBox();
        for (int i = 1; i <= 5; ++i) {
            jc.addItem("Choice " + i);
        }
        ItemListener lis = new ItemListener() {
            public void itemStateChanged(ItemEvent e) {
                Object item = e.getItem();
                String name = "";
                if (item instanceof String) {// JComboBox项目addItem是字符串
                    name = item.toString();// 不toString会炸(还是Object)
                } else if (item instanceof JCheckBox) {
                    name = ((JCheckBox) item).getText();
                } else if (item instanceof JRadioButton) {
                    name = ((JRadioButton) item).getText();
                } else {
                    System.out.println(item.getClass());
                }
                System.out.println(name + (e.getStateChange() == ItemEvent.SELECTED ? "选中" : "取消选中"));
            }
        };
        jc.addItemListener(lis);
        setLayout(new FlowLayout(1, 10, 10));
        Container ct = getContentPane();
        ct.add(jc);
        JCheckBox jcb1 = new JCheckBox("awa");
        JCheckBox jcb2 = new JCheckBox("qwq");
        jcb1.addItemListener(lis);
        jcb2.addItemListener(lis);
        ct.add(jcb1);
        ct.add(jcb2);
        ButtonGroup grp = new ButtonGroup();
        JRadioButton jrd1 = new JRadioButton("1437");
        JRadioButton jrd2 = new JRadioButton("580");
        grp.add(jrd1);
        grp.add(jrd2);
        jrd1.addItemListener(lis);
        jrd2.addItemListener(lis);
        //JFrame, Container 不能加这个lis
        ct.add(jrd1);
        ct.add(jrd2);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2404();
    }
}

```





##### 表格模型事件

`TableModelEvent` ，监听器是 `java.util.EventListener` ，其抽象方法是 `tableChanged(TableModelEvent e)` 添加行，修改、删除表格模型现有行触发。添加到表格模型上。事件有方法如下：

- `getType()`

  `TableModelEvent` 的静态常量 `INSERT, UPDATE, DELETE`

- `getFirstRow()` 触发事件的最小行索引值

- `getLastRow()`

- `getColumn()` UPDATE 有效，否则是 -1



#### 绘图

Graphics 是所有图形上下文的抽象基类，允许应用程序在组件及闭屏图像上绘制，封装了 Java 支持的基本绘图操作所需的状态信息，主要包括颜色、字体、画笔、文本、图像等，提供常用绘图方法和状态设置方法

Graphics 不能改变线条粗细，图片旋转、模糊、过滤；而 `Graphics2D` 继承 Graphics 类，实现了更多功能。但程序设计提供的绘图对象大多是 `Graphics` ，所以可以先向下转型

`JPanel, Canvas` 有绘图方法：

- `paint(Graphics g)` 初始执行，绘制图形

  需要第一行 `super.paint(g)` 。

- `repaint()` 重新执行绘图操作

##### Graphics

该抽象类的常用方法有：

- `drawArc(int x, int y, int width, int height, int ang1, int ang2)` 弧形
- `drawLine(int x1, int y1, int x2, int y2)`
- `drawOval(int x, int y, int w, int h)`
- `drawPolygon(int[] x, int[] y, int n)` 起末相连
- `drawPolyLine(int[] x, int [] y, int n)` 最后一下不封闭起末不相连
- `drawRect(int x, int y, int w, int h)`
- `drawRoundRect(int x, int y, int w, int h, int aw, itn ah)` 圆角矩形

以下 2D 类特有：

- `draw(Shape)` 绘制 Shape 接口的实现类(fill 也可以)

- `drawString(String s, int/float x, int/float y)` 

- `drawImage(Image img, int x, int y, ImageObserver obs)`

  `drawImage(Image img, int x, int y, int w, int h, ImageObserver obs)` 最后一个参数可以填null或this

  `drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, ImageObserver obs)` 目标矩形和源矩形的坐标(只取反sx或sy可以获得水平/垂直翻转)

draw 是框， 把所有 draw 换成 fill 是填充。其中弧看作圆填充的一部分扇形；多边形按封闭方式填充；角都是角度制。直线和多边线(折线)不能填充。

常见的 Shape 有 `java.awt.geom` 的：`Arc2D, CubicCurve2D, Ellipse2D, Line2D, Point2D, QuadCurve2D, Rectangle2D, RoundRectangle2D`

> 它们都是抽象的，有 `Double, Float` 两个实现类，精度不一样。通常用前者，除非图形很多。实现类即 `该Shape.数据类型(参数)` ，如 `Rectangle2D.Double(110, 5, 100, 100)`

` ImageObserver `用 this 即可



2D 类特有属性调节：

- `setColor(Color对象)`
- `setBackgroundColor(Color对象)`
- `setStroke(Stroke实现类)`
- `setFont(Font对象)`
- `rotate(double t)` 沿左上角顺时针旋转弧度

  `rotate(double t, int x, int y)` 规定中心点
- `shear(double x, double y)` 水平，垂直方向倾斜量



其他方法：

- `setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);`



倾斜的另一种写法：仿射变换

```java
AffineTransform affineTransform = new AffineTransform();
affineTransform.rotate(Math.toRadians(-30), 0, 0); //角度(弧度)和中心点
```

倾斜后可以把 `Font` 对象使用 `deriveFont(affineTransform)` 方法返回得到倾斜字体。



##### Color

Color 类。构造方法：

- `Color(int r, int g, int b)`
- `Color(int rgb)` `0xrrggbb` 十六进制
- `Color(float r, float g, float b)` 范围是 $[0,1.0f]$

也可以赋值为常量，如 `Color.全大写/全小写颜色单词`



##### Stroke

画笔接口。 `java.awt` 有实现类 `BasicStroke` ，构造方法：

- `BasicStroke()`
- `BasicStroke(float width)`
- `BasicStroke(float width, int cap, int join)`
- `BasicStroke(float width ,int cap, int join, float miterlimit)`
- `BasicStroke(float width ,int cap, int join, float miterlimit, float[] dash, float dash_phase)`

画笔宽度为 0.0f 时设置为设备默认值

cap 有 `BasicStroke.` 的三个常量：`CAP_BUTT, CAP_ROUND, CAP_SQUARE` 圆边，短，长。默认长。

join 有 `JOIN_BEVEL, JOIN_MITER, JOIN_ROUND` ，折线处不处理，尖和圆



##### Font

`java.awt` Font 类。构造方法：

- `Font(String 字体名, int 样式, int 字号大小)`

样式有 `Font.PLAIN, Font.BOLD, Font.ITALIC, Font.BOLD|Font.ITALIC`



##### Image

先获取路径，通过字符串或 URL，然后使用构造函数：

```java
Toolkit.getDefaultToolkit().getImage(路径)
```

有方法：

- `getWidth(this)` 传入的参数是 `ImageObserver`
- `getHeight(this)`
- `getRGB(int x, int y)` 获取某一坐标的颜色值
- `setRGB(int x, int y, int rgb)` 设置 RGB 值



有 `BufferedImage` 类，构造参数有宽高和 `BufferedImage.TYPE_INT_RGB` 。

有 `createGrahics` 方法，得到 `Graphics2D` 对象。

再在另一个普通的 `Graphics2D` 里再 `drawImage` 即可。

> 当随机交换每个点及其周围一个点的 RGB 值时，可以对图像进行模糊化



Image无法得到宽高，`ImageIcon`可以，用`.getImage()`；Icon可以得到`getX`等属性



##### 举例

###### Shape

```java
import java.awt.*;
import java.awt.geom.*;
import javax.swing.*;

public class c2501 extends JFrame {
    private class mcv extends JPanel {
        public void paint(Graphics g0) {
            super.paint(g0);
            Graphics2D g = (Graphics2D) g0;
            Shape s[] = new Shape[2];
            s[0] = new Ellipse2D.Double(5, 5, 100, 100);
            s[1] = new Rectangle.Float(5, 5, 100, 100);
            g.fill(s[0]);
            g.draw(s[1]);
        }
    }

    public c2501() {
        add(new mcv());
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(200, 200);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2501();
    }
}

```

###### 虚线

```java
import java.awt.*;
import javax.swing.*;

public class c2502 extends JFrame {
    private class mcv extends JPanel {
        public void paint(Graphics g0) {
            super.paint(g0);
            Graphics2D g = (Graphics2D) g0;
            g.setStroke(new BasicStroke(2.5f)); // 2.5会炸;2不会
            int h = 10;
            g.drawLine(10, h, 160, h);
            g.setStroke(new BasicStroke(8));
            h += 20;
            g.drawLine(10, h, 160, h);

            g.setStroke(new BasicStroke(8, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_BEVEL));
            h += 20;
            g.drawLine(10, h, 160, h);

            g.setStroke(new BasicStroke(8, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL));
            h += 20;
            g.drawLine(10, h, 160, h);

            g.setStroke(new BasicStroke(8, BasicStroke.CAP_ROUND, BasicStroke.JOIN_BEVEL));
            h += 20;
            g.drawLine(10, h, 160, h);

            g.setStroke(new BasicStroke(10, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL));
            h += 20;
            g.drawPolyline(new int[] { 10, 160, 10 }, new int[] { h, h, h + 10 }, 3);

            g.setStroke(new BasicStroke(10, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));
            h += 40;
            g.drawPolyline(new int[] { 10, 160, 10 }, new int[] { h, h, h + 10 }, 3);

            g.setStroke(new BasicStroke(10, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND));
            h += 40;
            g.drawPolyline(new int[] { 10, 160, 10 }, new int[] { h, h, h + 10 }, 3);

            g.setStroke(new BasicStroke(10, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND, 20));
            h += 40;
            g.drawPolyline(new int[] { 10, 160, 10 }, new int[] { h, h, h + 10 }, 3);

            g.setStroke(
                    new BasicStroke(3f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND, 0f,
                            new float[] { 2, 4, 6, 8, 10, 12 }, 0f));
            h += 20;
            g.drawLine(10, h, 160, h);
            
            g.setStroke(
                    new BasicStroke(3f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND, 0f,
                            new float[] { 2, 4, 6, 8, 10, 12 }, 6f));
            h += 20;
            g.drawLine(10, h, 160, h);
        }
    }

    public c2502() {
        add(new mcv());
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(200, 600);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2502();
    }
}

```



###### 行星动图

```java
package Lab14;

import javax.swing.*;
import java.awt.*;

public class Lab14_1 extends JFrame {
    private static final int w = 400, h = 400;
    private int d = 135;
    private canvas cv = null;

    private class canvas extends JPanel {
        public void paint(Graphics g) {
            super.paint(g);
            cycle((Graphics2D) g, d);

        }

        private void cycle(Graphics2D g, int d) {

            int r = 80;
            Color c_sun = new Color(255, 193, 37);
            g.setColor(c_sun);
            g.fillOval(w / 2 - r / 2, h / 2 - r / 2, r, r);

            int fw = 20;
            Color c_text = new Color(0, 0, 0);
            g.setColor(c_text);
            g.setFont(new Font("宋体", Font.BOLD, fw));
            g.drawString("SUN", w / 2 - fw / 2, h / 2 + fw / 2);

            int r2 = 300;
            g.setStroke(new BasicStroke(2, BasicStroke.CAP_ROUND,
                    BasicStroke.JOIN_ROUND, 1.0f,
                    new float[] { 5f, 5f }, 0f));
            g.drawOval(w / 2 - r2 / 2, h / 2 - r2 / 2, r2, r2);

            int x = (int) (r2 / 2 * Math.cos(d * 1.0 / 180 * 2 * Math.PI));
            int y = (int) (r2 / 2 * Math.sin(d * 1.0 / 180 * 2 * Math.PI));
            x += w / 2 - fw / 2;
            y += h / 2 + fw / 2;
            g.setColor(new Color(30, 144, 255));
            g.drawString("★", x, y);
        }
    }

    public Lab14_1() {
        cv = new canvas();
        setContentPane(cv);
        setSize(w, h);
        new Thread(new Runnable() {
            public void run() {
                while (true) {
                    d = d % 360 + 1;
                    cv.repaint();
                    try {
                        Thread.sleep(10);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setVisible(true);
    }

    public static void main(String[] args) {
        new Lab14_1();
    }
}

```

###### 图片旋转

```java
package Lab14;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.net.URL;

public class Lab14_2 extends JFrame {
    private final static int w = 400, h = 400;
    private Image img = null;
    private mcv cv = null;
    private int deg = 0, x = 0, y = 0;

    private class mcv extends Canvas {
        public void paint(Graphics g0) {
            super.paint(g0);

            Graphics2D g = (Graphics2D) g0;
            g.rotate(Math.toRadians(deg));
            g.drawImage(img, x, y, w, h, this);
        }
    }

    public Lab14_2() {
        Container ct = getContentPane();
        URL imgpath = Lab14_2.class.getResource("1.png");
        img = Toolkit.getDefaultToolkit().getImage(imgpath);
        setSize(w, h);

        cv = new mcv();
        ct.add(cv, BorderLayout.CENTER);

        JButton con = new JButton("旋转");
        con.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                deg = (deg + 90) % 360;
                y = w * (deg == 90 || deg == 180 ? -1 : 0);
                x = h * (deg >= 180 ? -1 : 0);
                cv.repaint();
            }
        });
        ct.add(con, BorderLayout.NORTH);

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setVisible(true);
    }

    public static void main(String[] args) {
        new Lab14_2();
    }
}

```

###### 验证码

```java
package Lab14;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class Lab14_4 extends JFrame {
    private static final int w = 300, h = 200;

    private class CAPTCHA extends JPanel {
        public void paint(Graphics g0) {
            super.paint(g0);
            Graphics2D g = (Graphics2D) g0;
            for (int i = 0, ie = randrange(1, 4); i < ie; ++i) {
                g.setColor(new Color(randc(), randc(), randc()));
                g.setStroke(new BasicStroke(randrange(1, 3)));
                g.drawLine(randrange(0, w), randrange(20, h), randrange(0, w), randrange(20, h));
            }
            for (int i = 0, ie = randrange(3, 10); i < ie; ++i) {
                g.setColor(new Color(randc(), randc(), randc()));
                int r = randrange(1, 4);
                g.fillOval(randrange(0, w), randrange(20, h), r, r);
            }
            for (int i = 0; i < 4; ++i) {
                int ang = randrange(-10, 10);
                double rang = Math.toRadians(ang);
                g.rotate(rang);
                g.setColor(new Color(randc(), randc(), randc()));
                g.setFont(new Font("宋体", Math.random() > 0.5 ? Font.PLAIN : Font.ITALIC, randrange(20, 60)));
                g.drawString(Integer.toString(randrange(0, 9)), i * w / 4 + randrange(0, w / 8) - 5,
                        10 + randrange(3 * w / 16, 13 * w / 32));
                g.rotate(-rang);
            }
        }

        private int randc() {
            return (int) (Math.random() * 255);
        }

        private int randrange(int mi, int mx) {
            return (int) (Math.random() * (mx - mi + 1)) + mi;
        }

    }

    public Lab14_4() {
        setSize(w, h + 20);
        Container ct = getContentPane();
        final CAPTCHA cv = new CAPTCHA();
        ct.add(cv, BorderLayout.CENTER);
        JButton con = new JButton("Refresh");
        con.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                cv.repaint();
            }
        });
        ct.add(con, BorderLayout.NORTH);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setVisible(true);
    }

    public static void main(String[] args) {
        new Lab14_4();
    }
}

```

###### 图片缩放

```java
package test;

import java.awt.*;
import javax.swing.*;
import javax.swing.event.*;
import java.net.URL;

public class c2503 extends JFrame {
    URL imgpath = c2503.class.getResource("1.png");
    Image img = Toolkit.getDefaultToolkit().getImage(imgpath);
    JSlider js = null;

    private class mcv extends JPanel {
        public void paint(Graphics g0) {
            super.paint(g0);
            Graphics2D g = (Graphics2D) g0;
            float r = js.getValue();
            int w = (int) (img.getWidth(this) * r / 100);
            int h = (int) (img.getHeight(this) * r / 100);
            g.drawImage(img, 0, 0, w, h, this);
        }
    }

    public c2503() {
        // imgpath = c2503.class.getResource("1.png");
        // img = Toolkit.getDefaultToolkit().getImage(imgpath);
        final mcv cv = new mcv();
        Container ct = getContentPane();
        ct.add(cv, BorderLayout.CENTER);
        js = new JSlider();
        js.setMaximum(1000);
        js.setMinimum(1);
        js.setValue(100);
        js.addChangeListener(new ChangeListener() {
            public void stateChanged(ChangeEvent e) {
                cv.repaint();
            }
        });
        ct.add(js, BorderLayout.SOUTH);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(600, 600);
        setVisible(true);
    }

    public static void main(String[] args) {
        System.out.println(c2503.class.getResource(""));
        new c2503();
    }
}

```

###### 图片水平垂直翻转

```java
package test;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.net.URL;

public class c2504 extends JFrame {
    private final static int w = 400, h = 400;
    private int dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2;
    private URL imgpath = c2503.class.getResource("1.png");
    private Image img = Toolkit.getDefaultToolkit().getImage(imgpath);
    JSlider js = null;

    private class mcv extends JPanel {
        public void paint(Graphics g0) {
            super.paint(g0);
            Graphics2D g = (Graphics2D) g0;
            g.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, this);
        }
    }

    public c2504() {
        dx2 = sx2 = w;// 只截取左上角(两个矩形大小不能不一样，不然渲染不对)
        dy2 = sy2 = h;
        Container ct = getContentPane();
        final mcv cv = new mcv();
        ct.add(cv, BorderLayout.CENTER);

        JPanel dfb = new JPanel(new FlowLayout(1, 10, 10));
        JButton r_hor = new JButton("Rotate horizontally");
        r_hor.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                sx1 = Math.abs(sx1 - w);
                sx2 = Math.abs(sx2 - w);
                cv.repaint();
            }
        });
        dfb.add(r_hor);

        JButton r_ver = new JButton("Rotate horizontally");
        r_ver.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                sy1 = Math.abs(sy1 - h);
                sy2 = Math.abs(sy2 - h);
                cv.repaint();
            }
        });
        dfb.add(r_ver);

        ct.add(dfb, BorderLayout.SOUTH);

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(w, h);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2504();
    }
}

```

###### 图片倾斜

```java
package test;

import java.awt.*;
import javax.swing.*;
import java.net.URL;

public class c2505 extends JFrame {
    private class mcv extends JPanel {
        public void paint(Graphics g0) {
            super.paint(g0);
            Graphics2D g = (Graphics2D) g0;
            URL imgpath = c2503.class.getResource("1.png");
            Image img = Toolkit.getDefaultToolkit().getImage(imgpath);
            g.shear(0.3, 0.1);
            g.drawImage(img, 100, 100, 200, 200, this);
        }
    }

    public c2505() {
        add(new mcv());
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2505();
    }
}

```







#### 菜单

包括菜单栏和弹出式菜单。优点：内容丰富、层次鲜明、使用快捷；弹出还有方便灵活的特点。

##### 菜单栏

位于窗口顶部，包括菜单名字、菜单项、子菜单

基本步骤：

1. 创建菜单栏对象，添加到窗体菜单栏中
2. 创建菜单对象，添加到菜单栏对象中
3. 创建菜单项对象，添加到菜单对象中
4. 为菜单项添加事件监听器，完成相应业务逻辑
5. 菜单可以包含子菜单，添加到上级菜单对象中
6. 添加新的菜单到菜单栏，回到第二步

###### JMenuBar

菜单栏。方法：

- `add(JMenuItem)` 添加菜单项、子菜单
- `add(String s)` 返回菜单项对象
- `insert(JMenuItem mi, int pos)`
- `insert(String s, int pos)` 不返回对象
- `getMenuComponentCount()` 包括菜单项、子菜单、分割线
- `isTopLevelMenu()` 是否是顶层菜单
- `isMenuComponent(Component )` 指定菜单项/子菜单是否在该菜单

单击触发动作事件 `ActionListener`。窗体的 `setJMenuBar()` 方法加入菜单栏 (注意不是 `setMenuBar`)

###### JMenu

菜单对象，构造函数传字符串。

方法：

- `addSearator()` 尾部添加

- `insertSeparator(int index)`

- `setIcon(Icon)` 继承自 `AbstractButton`

- `setMnemonic(int/char memonic)` 设置快捷键

  `int` 用 `java.awt.event.KeyEvent` 的 `VK_` 静态常量

  char 只支持 `A-Z`

  不区分大小写

- `setAcclerator(KeyStroke ks)` 加速器(可以组合按键)

  通过 `KeyStroke` 静态方法 `getKeyStroke(int keycode, int modifiers)`  获得，其中第二个参数可以是诸如 `java.awt.event.KeyEvent` 的 `CTRL_MASK, ALT_MASK, SHIFT_MASK, META_MASK` 	组合用或运算符

  第二个参数可以不设置，即 0 ，第一个参数是普通按键
  
  区别在于加速器是任何时候按都有效，且自动添加快捷键显示，前面那个不显示快捷键也只有菜单在按了才有效



###### JMenuItem

选项框菜单，有子类单选框菜单 `JRadioButtonMenuItem` , 复选框菜单 `JCheckBoxMenuItem` 。单选需要按钮组

菜单项可以用 `setEnabled(boolean)` 禁用



##### 弹出式菜单

第一步创建 `JPopupMenu` ，其他跟菜单栏相同。

###### JPopupMenu

使得右击开启，可以：

```java
final JPopupMenu pm = new JPopupMenu();
getContentPane().addMouseListener(new MouseAdapter() {
    public void mouseReleased(MouseEvent e) {
        if (e.isPopupTrigger()) {// 弹起
            pm.show(e.getComponent(), e.getX(), e.getY());
        }
    }
});
```



综合举例：

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class c2301 extends JFrame {
    public c2301() {
        JMenuBar menubar = new JMenuBar();
        setJMenuBar(menubar);
        JMenu menu1 = new JMenu("文件");
        menubar.add(menu1);
        JMenu menu2 = new JMenu("编辑");
        JMenuItem gis = new JMenuItem("你好");
        gis.setEnabled(false);
        menu2.add(gis);
        JMenuItem ugis = new JMenuItem("再见");
        menu2.add(ugis);
        JRadioButtonMenuItem sele1 = new JRadioButtonMenuItem("普通");
        sele1.setSelected(true);
        JRadioButtonMenuItem sele2 = new JRadioButtonMenuItem("地狱");
        ButtonGroup grp = new ButtonGroup();
        grp.add(sele1);
        grp.add(sele2);
        menu2.addSeparator();
        menu2.add(sele1);
        menu2.add(sele2);

        ugis.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                JOptionPane.showMessageDialog(null, "qwq");
            }
        });

        menubar.add(menu2);
        JMenuItem save = new JMenuItem("保存");
        save.setMnemonic(KeyEvent.VK_S);// 打开了菜单时按下有效,非输入方法状态
        menu1.add(save);
        JMenu open = new JMenu("打开");
        open.setMnemonic(KeyEvent.VK_O);
        menu1.add(open);
        JMenuItem openrcn = new JMenuItem("最近文件");
        openrcn.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, KeyEvent.CTRL_DOWN_MASK));
        open.add(openrcn);
        JMenuItem opendef = new JMenuItem("默认位置");
        opendef.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, 0));
        open.add(opendef);
        menu1.addSeparator();
        menu1.add(new JMenuItem("关于"));
        // menu1.setMnemonic(KeyEvent.VK_A);// 无效

        final JPopupMenu popupMenu = new JPopupMenu();
        JMenu menu3 = new JMenu("a");
        menu3.add(new JMenuItem("awa"));
        popupMenu.add(menu3);// menu1的话前面就无了
        getContentPane().addMouseListener(new MouseAdapter() {
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    popupMenu.show(e.getComponent(), e.getX(), e.getY());
                }
            }
        });

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2301();
    }
}

```



#### 表格

##### JTable

`import javax.swing.table.*`

`JTable` 生成的表格单元每一项默认可以修改，双击即可进入编辑，但表头不可以。可以调整表头以调整各列宽高。

静态表格的构造函数：

- `JTable(Object[][] data, Object[] colnames)`

  data 二维数组先行后列，下同

- `JTable(Vector<Vector<e>>, Vector<>)`



行列下标都从 0 开始算。方法 `isCellEditable(int row, int column)` 查询单元格是否可以编辑。设置表格单元是否可以编辑，需要重写方法 `public boolean isCellEditable(int row, int col)` 。

设置单元格居中：

```java
DefaultTableCellRenderer r = new DefaultTableCellRenderer();
r.setHorizontalAlignment(JLabel.CENTER);
表格对象.setDefaultRenderer(Object.class, r);
```

表头设置类似。也可以重写方法 `public JTableHeader getTableHeader()` ，在里面操作，把操作后的表头返回。

其他设置方法：

- `setRowHeight(int row_h)` 行高，默认16像素

- `setRowSelectionAllowed(boolean)` 是否允许选中表格行，默认允许，每次选中有一格+一行；否则只有一格

  关闭了以后点击单元格也能获取选中行

- `setSelectionMode(int)` 表格行选择模式，用来自 `ListSelectionModel` 的常量：

  `SINGLE_SELECTION` 0 单选，禁止表格行选择默认(且此时都是如此)

  `SINGLE_INTERVAL_SELECTION` 1 多个

  `MULTIPLE_INTERVAL_SELECTION` 2 任意多个，允许表格行默认

- `setSelectionBackground(Color)`

- `getSelectionForeground(Color)`

- `setAutoResizeMode(int)` 自动调整模型，来自 `JTable` 常量，控制调整一列宽度时，如何调整总宽度：

  `AUTO_RESIZE_OFF` 0 不给调整

  `AUTO_RESIZE_NEXT_COLUMN` 1 只调整下一行(同理有 LAST 3)

  `AUTO_RESIZE_SUBSEQUENT_COLUMNS` 2 按比例调整其后的所有

  `AUTO_RESIZE_ALL_COLUMNS` 4 默认，按比例调整所有



表格信息获取和修改：

- `getRowCount()`
- `getColumnCount()`
- `getColumnName(int idx)`
- `setRowSelectionInteval(int from, int to)` 选中行 $[from,to]$
- `addRowSelectionInteval(int from ,int to)` 追加到选中
- `isRowSelected(int row)`
- `selectAll()`
- `clearSelection()` 去选所有
- `getSelectedRowCount()`
- `getSelectedRow()` 未选中 -1
- `getSelectedRows()`
- `moveColumn(int a, int b)` 将 a 列冒泡移到 b 列
- `getValueAt(int row, int col)`
- `setValueAt(int row, int col)` 可以用这种方法修改一列



列表选中事件监听：

```java
getSelectionModel().addListSelectionListener(new ListSelectionListener() {
    public void valueChanged(ListSelectionEvent e) {
    }
};
```





##### JTableHeader

需要由 `ScrollPane` 嵌套才能显示表头。否则，需要先用 `getTableHeader()` 得到类型为 `JTableHeader` 的表头，再单独将其添加到面板上。

有方法 `setReorderingAllowed()` 设置表头是否可以拖拽以更改列顺序。默认 `false` 。



##### JTableModel

接口 `JTableModel` 定义表格模型。 `AbstractTableModel` 抽象类实现了 `TableModel` 接口大部分，但是未实现：

```java
public int getRowCount();
public int getColumnCount();
public Object getValueAt(int rowIndex, int columnIndex);
```

而 `DefaultTableModel` 类实现了。其常用构造方法如下：

- 空
- `DefaultTableModel(int rowcount, int colcount)`
- `DefaultTableModel(Object[][] data, Object[] cols)`
- `DefaultTableModel(Vector<Vector<>> data, Vector<> cols)`

然后将模型传入 `JTable` 的构造方法即可。

JDK 1.6 开始，`JTable`  提供方法可以设置排序器：

- `setRowSorter(RowSorter<? extends TableModel> sorter)`

排序器的构造函数是 `TableRowSorter(TableModel)` ；也可以用 `setModel()` 方法随后设置。可以自定义排序。

> 发现自己会出现 `can not resolve to a type` 问题，上述方法暂时无解

可以用表格的 `.setAutoCreateRowSorter(true);` 设置排序器。

设置排序器后，单击某一列头，就会按其升序，在单击降序。



表格模型有维护数据的方法如下：

- `addColumn(String)`
- `setColumnCount()` 可以强行清零
- `setRowCount()` 可以强行清零
- `addRow(Object[]/Vector data)`
- `insertRow(int rowidx, data)`
- `removeRow(int rowidx)` 注意删除多个建议倒序，以免影响下标







##### 举例

###### 静态表格

```java
getContentPane().add(new JScrollPane(
    new JTable(new String[][] { new String[] { "awa", "512" }, new String[] { "qwq", "1437" } },
               new String[] { "name", "value" })));
```

或：

```java
JTable jt = new JTable(new String[][] { new String[] { "awa", "512" }, new String[] { "qwq", "1437" } },
                       new String[] { "name", "value" });
JTableHeader jth = jt.getTableHeader();
ct.add(jth, BorderLayout.NORTH);
ct.add(jt, BorderLayout.CENTER);
```



###### 基本属性

```java
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;

import java.awt.*;

public class c2102 extends JFrame {
    private class mt extends JTable {
        public mt(Object[][] a, Object[] b) {// 没有会炸
            super(a, b);
        }

        @Override
        public JTableHeader getTableHeader() {
            JTableHeader jh = super.getTableHeader();
            DefaultTableCellRenderer cr = (DefaultTableCellRenderer) jh.getDefaultRenderer();
            cr.setHorizontalAlignment(DefaultTableCellRenderer.LEFT);
            return jh;
        }

        // @override (useless)
        // public TableCellRenderer getDefaulRenderer(Class<?> columnClass) {
        // DefaultTableCellRenderer cr = (DefaultTableCellRenderer)
        // super.getDefaultRenderer(columnClass);
        // cr.setHorizontalAlignment(DefaultTableCellRenderer.CENTER);
        // return cr;
        // }

        @Override
        public boolean isCellEditable(int row, int col) {
            return col == 0;// 第一列可以编辑
        }
    }

    public c2102() {
        Container ct = getContentPane();
        JTable jt = new mt(
                new String[][] { new String[] { "awa", "512", "1" }, new String[] { "qwq", "1437", "3" },
                        new String[] { "=w=", "580", "2" } },
                new String[] { "name", "value", "special" });
        JTableHeader jth = jt.getTableHeader();
        jth.setReorderingAllowed(true);

        DefaultTableCellRenderer r = new DefaultTableCellRenderer();
        r.setHorizontalAlignment(JLabel.CENTER);
        jt.setDefaultRenderer(Object.class, r);

        jt.setRowSelectionAllowed(false);
        jt.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        jt.setAutoResizeMode(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS);

        ct.add(jth, BorderLayout.NORTH);
        ct.add(jt, BorderLayout.CENTER);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);

    }

    public static void main(String[] args) {
        new c2102();
    }
}

```



###### 获取选中项

```java
import javax.swing.*;
import java.awt.event.*;
import javax.swing.table.*;
import java.awt.*;

public class c2103 extends JFrame {
    public c2103() {
        Container ct = getContentPane();
        final JTable jt = new JTable(
                new String[][] { new String[] { "awa", "512", "1" }, new String[] { "qwq", "1437", "3" },
                        new String[] { "=w=", "580", "2" } },
                new String[] { "name", "value", "special" });
        JScrollPane jsrc = new JScrollPane(jt);
        jt.setRowSelectionAllowed(false);
        ct.add(jsrc);

        JButton jb = new JButton("get");
        jb.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                // System.out.println(jt.getSelectedRow());
                int col = jt.getSelectedColumn();
                int row = jt.getSelectedRow();
                System.out.println(jt.getValueAt(row, col));
            }
        });
        ct.add(jb, BorderLayout.NORTH);

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2103();
    }
}

```



###### 模型和排序

```java
import javax.swing.*;
import java.awt.*;
import javax.swing.table.*;

public class c2104 extends JFrame {
    public c2104() {
        DefaultTableModel tm = new DefaultTableModel();
        tm.addColumn("name");
        for (int i = 1; i <= 3; ++i) {
            tm.addColumn("value" + i);
        }
        for (int i = 1; i <= 6; ++i) {
            String name = "lorem" + i;
            String[] row = new String[tm.getColumnCount()];
            row[0] = name;
            for (int j = 1; j < tm.getColumnCount(); ++j) {
                row[j] = Integer.toString((int) (Math.random() * 1437));
            }
            tm.addRow(row);
        }
        JTable jt = new JTable(tm);
        // jt.setRowSorter(new TableRowSorter(tm));
        jt.setAutoCreateRowSorter(true);
        JScrollPane jsrc = new JScrollPane(jt);
        getContentPane().add(jsrc);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2104();
    }
}

```

###### 冻结列首

思路：自定义两个表格，一个是列首，一个是其余，然后每次单个操作绑定到两个操作上，然后用一个面板封装起来。

```java
import javax.swing.*;
import javax.swing.event.*;

import java.awt.*;
import java.util.Vector;
import javax.swing.table.*;

class mftable extends JPanel {
    private Vector<String> col;
    private Vector<Vector<Object>> data;
    private int fixc = 1;

    private class lftm extends AbstractTableModel {
        public int getColumnCount() {
            return fixc;
        }

        public int getRowCount() {
            return data.size();
        }

        public Object getValueAt(int x, int y) {
            return data.get(x).get(y);
        }

        public String getColumnName(int x) {
            return col.get(x);
        }
    }

    private class rftm extends AbstractTableModel {
        public int getColumnCount() {
            return col.size() - fixc;
        }

        public int getRowCount() {
            return data.size();
        }

        public Object getValueAt(int x, int y) {
            return data.get(x).get(y + fixc);
        }

        public String getColumnName(int x) {
            return col.get(x + fixc);
        }
    }

    private JTable lft, rft;
    private lftm lfm;
    private rftm rfm;

    private class mev implements ListSelectionListener {
        boolean islf = true;

        public mev(boolean b) {
            islf = b;
        }

        public void valueChanged(ListSelectionEvent e) {
            if (islf) {
                int row = lft.getSelectedRow();
                rft.setRowSelectionInterval(row, row);
            } else {
                int row = rft.getSelectedRow();
                lft.setRowSelectionInterval(row, row);
            }
        }
    }

    public mftable(Vector<String> pcol, Vector<Vector<Object>> pdata, int pfix) {
        super();
        setLayout(new BorderLayout());
        col = pcol;
        data = pdata;
        fixc = pfix;
        lfm = new lftm();
        lft = new JTable(lfm);
        ListSelectionModel fixed = lft.getSelectionModel();
        fixed.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        fixed.addListSelectionListener(new mev(true));

        rfm = new rftm();
        rft = new JTable(rfm);
        rft.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        ListSelectionModel floati = rft.getSelectionModel();
        floati.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        mev liser = new mev(false);
        floati.addListSelectionListener(liser);
        JScrollPane jsrc = new JScrollPane();
        jsrc.setCorner(JScrollPane.UPPER_LEFT_CORNER, lft.getTableHeader());
        JViewport viewport = new JViewport();
        viewport.setView(lft);
        viewport.setPreferredSize(lft.getPreferredSize());
        jsrc.setRowHeaderView(viewport);
        jsrc.setViewportView(rft);
        add(jsrc, BorderLayout.CENTER);
    }
}

public class c2105 extends JFrame {
    public c2105() {
        Vector<String> col = new Vector<>();
        col.addElement("日期");
        for (int i = 1; i <= 20; ++i) {
            col.addElement("商品" + i);
        }
        Vector<Vector<Object>> data = new Vector<>();
        for (int i = 1; i <= 30; ++i) {
            Vector<Object> row = new Vector<>();
            row.addElement(i);
            for (int j = 1; j <= col.size(); ++j) {
                row.addElement((int) (Math.random() * 1024));
            }
            data.addElement(row);
        }
        final mftable jt = new mftable(col,data,1);
        getContentPane().add(jt,BorderLayout.CENTER);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2105();
    }
}
```

###### 可编辑

```java
import javax.swing.*;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.*;
import java.awt.*;
import java.awt.event.*;

public class c2405 extends JFrame {
    public c2405() {
        final DefaultTableModel tm = new DefaultTableModel();
        tm.addColumn("index");
        tm.addColumn("score");
        for (int i = 1; i <= 3; ++i) {
            String v1 = Integer.toString((int) (Math.random() * 1024));
            String v2 = Integer.toString((int) (Math.random() * 1024));
            tm.addRow(new String[] { v1, v2 });
        }
        tm.addTableModelListener(new TableModelListener() {
            public void tableChanged(TableModelEvent e) {
                if (e.getType() == TableModelEvent.UPDATE) {
                    int row = e.getFirstRow();
                    int col = e.getColumn();
                    System.out.println(row + " " + col + " " + tm.getValueAt(row, col));
                }
            }
        });// 无论修改后跟原来一不一样，点击到别的单元后触发
        JTable jt = new JTable(tm);
        JScrollPane jsrc = new JScrollPane(jt);
        getContentPane().add(jsrc);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(400, 400);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c2405();
    }
}

```

###### 字体

```java
Font ft = new Font("宋体", Font.PLAIN, 16);
setFont(ft);
JTableHeader jh = getTableHeader();
jh.setFont(ft);
setTableHeader(jh);
```



#### 其他

##### 边框

有很多，还有border factory ，这里只展示一种凸起和凹陷：

```java
import javax.swing.*;
import javax.swing.border.BevelBorder;
import java.awt.*;
import java.awt.event.*;

public class c1328 extends JFrame {
    public c1328() {
        Container ct = getContentPane();
        setLayout(new FlowLayout(1, 10, 2));

        JLabel jl1 = new JLabel("<html>awa<br>qwq =w= &gt;_&lt; </html>");
        jl1.setBorder(new BevelBorder(BevelBorder.RAISED));
        // jl1.setBackground(Color.CYAN);// 边框色
        ct.add(jl1);

        JLabel jl2 = new JLabel("啊哈哈哈哈哈哈");
        jl2.setBorder(new BevelBorder(BevelBorder.LOWERED));
        ct.add(jl2);

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setSize(300, 100);
        setVisible(true);
    }

    public static void main(String[] args) {
        new c1328();
    }
}

```



##### 边界

`java.awt.Rectangle` 矩形边界类，可以做碰撞检测。



##### 应用举例

###### 注册页面

一个综合使用各控件的例子：

```java
package Lab8;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

class dialog_submitted extends JDialog {
    public dialog_submitted(JFrame f, String tx) {// Jframe suits for both lab8_1 and lab8_3
        super(f, "Submitted successfully!", true);
        Container ct = getContentPane();
        ct.add(new JScrollPane(new JLabel(tx)));
        setBounds(100, 100, 300, 300);
    }
}

// 感觉写成内部类比较好……下次注意
class combobox_schooling extends AbstractListModel<String> implements ComboBoxModel<String> {
    private String selected = null;
    private String text[] = { "专科", "本科", "研究生" };

    public String getElementAt(int index) { // return Object leads error
        return text[index];
    }

    public int getSize() {
        return text.length;
    }

    public void setSelectedItem(Object item) {
        selected = (String) item;
    }

    public Object getSelectedItem() {
        return selected;
    }

}

class schoolarea_list extends AbstractListModel<String> {
    private String[] text = { "五山", "南海", "大学城  " };
    // avoid error by UTF-8, extra spaces to let complier recognize quote syntax

    public String getElementAt(int x) {
        if (x < text.length) {
            return text[x++];// so why ++
        } else {
            return null;
        }
    }

    public int getSize() {
        return text.length;
    }
}

public class Lab8_1 extends JFrame {
    public static void main(String[] args) {
        new Lab8_1();
    }

    public Lab8_1() {
        Container ct = getContentPane();
        setLayout(new GridLayout(8, 2, 15, 15));

        ct.add(new JLabel("Name:"));
        final JTextField i_name = new JTextField(20);
        ct.add(i_name);

        ct.add(new JLabel("Password:"));
        final JPasswordField i_psw = new JPasswordField();
        i_psw.setEchoChar('*');
        ct.add(i_psw);

        ct.add(new JLabel("Gender:"));
        final JPanel p_gender = new JPanel(new FlowLayout(0));
        final JRadioButton i_male = new JRadioButton("男");
        final JRadioButton i_female = new JRadioButton("女");
        i_male.setSelected(true);
        final ButtonGroup i_gender = new ButtonGroup();
        i_gender.add(i_male);
        i_gender.add(i_female);
        p_gender.add(i_male);
        p_gender.add(i_female);
        ct.add(p_gender);

        ct.add(new JLabel("Hobby:"));
        final JPanel p_hobby = new JPanel(new GridLayout(2, 2, 30, 8));
        String s_hobby[] = { "debug", "ACM", "hack", "invest in stocks" };
        final JCheckBox i_hobby[] = new JCheckBox[4];
        for (int i = 0; i < s_hobby.length; ++i) {
            i_hobby[i] = new JCheckBox(s_hobby[i]);
            p_hobby.add(i_hobby[i]);
        }
        ct.add(p_hobby);

        ct.add(new JLabel("Length of Schooling:"));
        final JComboBox<String> i_schooling = new JComboBox<>(new combobox_schooling());
        ct.add(i_schooling);

        ct.add(new JLabel("School Area:"));
        final JList<String> i_schoolarea = new JList<>(new schoolarea_list()); // but not final is okay
        ct.add(i_schoolarea);

        ct.add(new JLabel("Self Introduction:"));
        final JTextArea i_itd = new JTextArea(1, 30);
        i_itd.setLineWrap(true);
        final JScrollPane scroll_itd = new JScrollPane(i_itd);
        ct.add(scroll_itd);

        ct.add(new JLabel("User Registration"));
        JButton b_submit = new JButton("register");
        b_submit.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                String res = "<html><div>";
                res += "Hello, " + (i_male.isSelected() ? "Mr." : "Ms.") + " ";
                res += i_name.getText() + "<br/>";
                res += "Please remember your password: " + String.valueOf(i_psw.getPassword()) + "<br/>";
                res += "You relish ";
                for (int i = 0, j = 0; i < 4; ++i) {
                    if (i_hobby[i].isSelected()) {
                        res += (j++ == 0 ? " " : ", ") + s_hobby[i];
                    }
                }
                res += "<br/>";
                res += "You are a " + i_schooling.getSelectedItem() + " student.<br/>";
                res += "You are studying in " + i_schoolarea.getSelectedValue() + ", SCNU.<br/>";
                res += "Here's what you introduce yourself:<br/>";
                StringBuilder itd = new StringBuilder();
                char itd_text[] = i_itd.getText().toCharArray();
                int linelen = 0, linemax = 30;
                for (char c : itd_text) {
                    if (linelen >= linemax || c == '\n') {
                        itd.append("<br/>");
                        linelen = 0;
                    }
                    linelen++;
                    itd.append(c);
                }
                res += itd.toString() + "<br/>";
                res += "</div></html>";
                new dialog_submitted(Lab8_1.this, res).setVisible(true);
            }
        });
        ct.add(b_submit);

        setTitle("User Register");
        setVisible(true);
        setSize(700, 600);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```



###### 投票页面

```java
package Lab8;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.TreeSelectionEvent;

class vote_panel extends JPanel {
    public int vote = 0; // otherwise Actionlistener fail to update it

    public vote_panel(String name) { // param: LayoutManager lm
        super(new FlowLayout(0));
        add(new JLabel(name));

        final JLabel votebar = new JLabel("<html><div style='background-color:red'>&nbsp;</div></html>");
        final JLabel t_res = new JLabel("0 ticket");

        JButton b_vote = new JButton("vote for me");
        b_vote.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                vote++;
                StringBuilder bar = new StringBuilder("<html><div style='background-color:red'>");
                for (int i = 0; i < vote; ++i) {
                    for (int j = 0; j < 3; ++j) {
                        bar.append("&nbsp;");
                    }
                }
                bar.append("</div></html>");
                votebar.setText(bar.toString());
                t_res.setText(vote + " ticket" + (vote <= 1 ? "" : "s"));
            }
        });
        add(b_vote);
        add(t_res);
        add(votebar);
    }
}

public class Lab8_2 extends JFrame {
    public static void main(String[] args) {
        new Lab8_2();
    }

    public Lab8_2() {
        setLayout(new GridLayout(4, 1, 10, 20));
        Container ct = getContentPane();
        final String name[] = { "zhang3", "li4", "lr580", "baicha" };
        for (int i = 0; i < 4; ++i) {
            ct.add(new vote_panel(name[i]));
        }
        setVisible(true);
        setSize(600, 240);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```



###### 图片放大缩小

```java
package Lab8;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.net.URL;
import java.nio.channels.Pipe;
import java.text.DecimalFormat;

public class Lab8_4 extends JFrame {
    public static void main(String[] args) {
        new Lab8_4();
    }

    private final int w = 1095, h = 778;
    private double zoom = 1.0;// zoomratio
    private JLabel pic_scaled, l_ratio;
    private ImageIcon ic;
    private JScrollPane p_pic;
    private final DecimalFormat ratio_format = new DecimalFormat("x0.0");
    private final URL path = Lab8_4.class.getResource("4.png");

    private void blender() {
        int ww = (int) Math.ceil(w * zoom);
        int hh = (int) Math.ceil(h * zoom);
        ic = new ImageIcon(path);// must re new one, or the picture weird
        ic.setImage(ic.getImage().getScaledInstance(ww, hh, Image.SCALE_DEFAULT));
        l_ratio.setText(ratio_format.format(zoom));
        pic_scaled.setIcon(ic);
    }

    public Lab8_4() {
        Container ct = getContentPane();

        ImageIcon ic_abbr = new ImageIcon(path);
        ic_abbr.setImage(ic_abbr.getImage().getScaledInstance((int) (w * 0.08), (int) (h * 0.08), Image.SCALE_DEFAULT));
        JLabel pic_abbr = new JLabel("thumbnail", JLabel.CENTER);
        pic_abbr.setIcon(ic_abbr);
        JPanel topbar = new JPanel(new FlowLayout(1, 10, 20));
        topbar.add(pic_abbr);

        pic_scaled = new JLabel("", JLabel.CENTER);

        p_pic = new JScrollPane(pic_scaled);
        ct.add(p_pic, BorderLayout.CENTER);

        JButton b_zoomin = new JButton("Zoom in");
        b_zoomin.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                zoom += 0.1;
                blender();
            }
        });
        topbar.add(b_zoomin);

        JButton b_zoomout = new JButton("Zoom out");
        b_zoomout.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                zoom = Math.max(zoom - 0.1, 0.5);
                blender();
            }
        });
        topbar.add(b_zoomout);

        l_ratio = new JLabel("x1.0");
        blender();
        topbar.add(l_ratio);

        ct.add(topbar, BorderLayout.NORTH);
        setSize(650, 550);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
}

```







### 集合类

继承关系为：

```mermaid
graph TD;
	a["java.lang.Object"]---b["Map"];
	a---c["Collection"];
	b---b1["Hashmap"];
	b---b2["TreeMap"];
	c---c1["Set"];
	c---c2["List"];
	c1---c11["HashSet"];
	c1---c12["TreeSet"];
	c2---c21["ArrayList"];
	c2---c22["LinkedList"];
```

> 注意 Collection, List 和 Set 是接口，诸如 `ArrayList` 才是类。

![img](img/74C2C3389688C6364FF2DE8AA768A039.jpeg)

![img](img/E26BABF74692B006DA33C112A6FD5EEC.jpeg)

> 实现箭头是泛化，虚线箭头是实现

> `java.util` 下大部分是线程不安全的，而 `Collections` 工具类的 `synchronizedXxx` 方法包装可成线程安全的。`util` 下 `Vector, Hashtable` 是古老的线程安全的性能差的集合类。
>
> Java 5 开始，`java.util.concurrent` 包下提供支持高效并发的类：
>
> - 以 `Concurrent` 开头的集合类支持并发访问和写入，读不必锁定。保证不会永远锁住整个集合。
> - 以 `CopyOnWrite` 开头的，复制底层数组来写。读时直接读集合本身无需加锁和阻塞，写对副本操作。
>
> 线程安全的如下：
>
> ![img](img/53AA859E1B3A9CD7709DF9366999B88D.jpeg)
>
> Collections工具类可以将一个Map转换成线程安全的实现，其实也就是通过一个包装类，然后把所有功能都委托给传入的Map，而包装类是基于synchronized关键字来保证线程安全的（Hashtable也是基于synchronized关键字），底层使用的是互斥锁，性能与吞吐量比较低

#### 通用操作

可以如下方便载入：

```java
import java.util.*;
```

创建一个集合类：`集合类名<模板类名> 实例名=new 集合类名<>();`

> 从Java 5开始，Java引入了“参数化类型”的概念，允许程序在创建集合时指定集合元素的类型，Java的参数化类型被称为泛型（Generic）。例如 `List<String>`，表明该List只能保存字符串类型的对象。
>
> 有了泛型以后，程序再也不能“不小心”地把其他对象“丢进”集合中。而且程序更加简洁，集合自动记住所有集合元素的数据类型，从而无须对集合元素进行强制类型转换。

模板类不能基本数据类型如 `int`，但是可以是 `Integer`。因为这是对象数组。也可以不用模板类。

- add(E e)
- remove(Object o)
- isEmpty() 返回boolean
- iterator()
- size() 返回int，元素数
- contains(E e) 是否包含该元素
- addAll(Collection ) 将一个 Container 转化为它
- replaceAll(一元操作符) 类似 python 的 map 函数，语法为 `参数 -> 表达式` 
- removeAll(Collection e) 只保留e没有的元素
- retainAll(Collection e) 只保留e有的元素
- clear(), 可能 O(n)
- removeIf(一元操作符)
- toArray()
- forEach(一元函数) 以每个元素执行该函数

迭代器为 `Iterator<模板类名>`，常用方法：

- hasNext() 返回boolean
- next() 返回元素并迭代器往下，返回Object

重载了 `toString`，直接输出能够输出每个元素。

如：

```java
import java.util.*;

public class c1401 {
    public static void main(String[] args) {
        Collection<String> lt = new ArrayList<>(); //向上转型
        lt.add("awa");
        lt.add("qwq");
        lt.add(">_<");
        Iterator<String> it = lt.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}
```

```java
import java.util.*;

public class c1705 {
    public static void main(String[] args) {
        LinkedList x = new LinkedList<>();//<>可以不要
        x.add(1);
        x.add("123");
        Iterator it = x.iterator();
        while(it.hasNext()){
            System.err.println(it.next());
        }
    }
}

```

```java
import java.util.*;

public class c1404 {
    public static void main(String[] args) {
        LinkedList<Integer> arr = new LinkedList<>();
        for (int i = 1; i <= 10; ++i) {
            arr.add(i);
        }
        arr.replaceAll(x -> x * x);
        Iterator<Integer> it = arr.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
        System.out.println(arr.contains(81));
    }
}

```

```java
import java.util.*;

public class c1609 {
    public static void prt(Collection<Integer> x) {
        Iterator<Integer> it = x.iterator();
        while (it.hasNext()) {
            System.out.print(it.next() + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        LinkedList<Integer> a1 = new LinkedList<>();
        for (int i = 2; i <= 5; ++i) {
            a1.add(i);
        }
        LinkedList<Integer> a2 = new LinkedList<>();
        for (int i = 1; i <= 10; ++i) {
            a2.add(i);
        }
        LinkedList<Integer> a3 = (LinkedList<Integer>) a2.clone();
        // a3.addAll(a2);
        a3.removeAll(a1);
        prt(a3);
        prt(a2);
        LinkedList<Integer> a4 = new LinkedList<>();
        for (int i = -1; i <= 3; ++i) {
            a4.add(i);
        }
        a4.retainAll(a1);
        prt(a4);
        a4.clear();
        System.out.println(a4.isEmpty());
        a2.removeIf(x -> x % 2 == 0);
        prt(a2);
        Integer xx[] = Arrays.copyOfRange(a2.toArray(), 0, a2.size(), Integer[].class); // Object[]转Integer[]
        int dest[] = Arrays.stream(xx).mapToInt(Integer::valueOf).toArray();// Integer[]转int[]
        for (int i = 0; i < dest.length; ++i) {
            System.out.print(dest[i] + " ");
        }
    }
}

```

```java
package exam1;

import java.util.ArrayList;
import java.util.List;

public class foreach {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        list.forEach(System.out::println);
        list.forEach(v -> System.out.println(v));//lambda
    }
}
```



#### List

新方法：

- get(int index) 指定索引的元素(索引从0开始)，越界报错 `IndexOutOfBoundsException`

  注：即使构造方法给了 size，默认还是 0 个元素

- set(int index, Object obj) 修改该索引对象为 obj

Collections 静态操作：

- sort

- reverse

- binarySearch(list, value)

  如果查找成功返回对应下标(有多个相等的则返回任意)，如果查找失败，返回一个负数v，其 `-(v+1)` 代表该值应该插入到的位置。

有两种实现类：

- ArrayList 数组实现的，可变长，允许保存含 `null` 的元素，向指定位置插入或删除元素较慢，更常用
- LinkedList 双向链表实现的，优点时集中插入删除快，但随机访问效率低，内存占用大

> 数组与 list 互转：[参考](https://blog.csdn.net/bitcarmanlee/article/details/71079468)
>
> - 数组转 list: `Arrays.asList(数组)`。注意对基本元素必须用如 Integer 数组而不是 int 数组
> - list 转数组：`.toArray()` 方法。默认返回Object数组，参数填 `new 类型[大小]` 以改变

如：

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Lab6_4 {

    static int testcases = 10000;

    static long nowmemory = (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1024;

    // 乱序插入和乱序删除
    public static void randBruteTest(List<Integer> lt) {
        long time1 = System.currentTimeMillis();
        int len = 0;
        for (int i = 0; i < testcases; ++i, ++len) {
            lt.add((int) (Math.random() * (len + 1)), i);
        }
        for (int i = 0; i < testcases; ++i, --len) {
            lt.remove((int) (Math.random() * len));
        }
        long time2 = System.currentTimeMillis();
        System.out.println("time used: " + (time2 - time1) + " ms");
        long memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        memory /= (1024);
        long newme = memory;
        memory -= nowmemory;
        nowmemory = newme;
        System.out.println("memory used: " + memory + " KB");
    }

    // 乱序插入和乱序删除
    public static void orderedBruteTest(List<Integer> lt) {
        long time1 = System.currentTimeMillis();
        int len = 0;
        for (int i = 0; i < testcases; ++i, ++len) {
            lt.add(i, i);
        }
        for (int i = 0; i < testcases; ++i, --len) {
            lt.remove(0);
        }
        long time2 = System.currentTimeMillis();
        System.out.println("time used: " + (time2 - time1) + " ms");
        long memory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        memory /= (1024);
        long newme = memory;
        memory -= nowmemory;
        nowmemory = newme;
        System.out.println("memory used: " + memory + " KB");
    }

    public static void main(String[] args) {
        System.out.println("random test:");
        System.out.println("- linked list:");
        List<Integer> ll = new LinkedList<>();
        randBruteTest(ll);
        System.out.println("- array list:");
        List<Integer> la = new ArrayList<>();
        randBruteTest(la);
        /*
         * 结果：对于随机访问的插入和删除，Array比Linked更快，原因为：
         * 寻址过程对数组是O(1)的，而对链表是O(n)的，所以插入删除复杂度有差异
         */
      
        System.out.println("-------");
        // 有序很快，可以数据量大一个数量级看差异
        testcases *= 10;
        System.out.println("ordered test:");
        System.out.println("- linked list:");
        List<Integer> ll2 = new LinkedList<>();
        orderedBruteTest(ll2);
        System.out.println("- array list:");
        List<Integer> la2 = new ArrayList<>();
        orderedBruteTest(la2);
         /*
         * 结果：对于非随机的插入和删除，Array比Linked更慢，原因为：
         * 链表在头结点的寻址操作是O(1)的，数组也是O(1)的
         * 但链表插入后移位操作是O(1)的，而数组是O(n)的，所以Array更慢
         */
    }
}
```

> ArrayList的底层是用数组来实现的，默认第一次插入元素时创建大小为10的数组，超出限制时会增加50%的容量，并且数据以 System.arraycopy() 复制到新的数组，因此最好能给出数组大小的预估值
>
> 线程安全的 List：
>
> 1. Vector 较古老的API，虽然保证了线程安全，但是由于效率低一般不建议使用。
>
> 2. Collections.SynchronizedList
>
>    SynchronizedList是Collections的内部类，Collections提供了synchronizedList方法，可以将一个线程不安全的List包装成线程安全的List，即SynchronizedList。它比Vector有更好的扩展性和兼容性，但是它所有的方法都带有同步锁，也不是性能最优的List。
>
> 3. CopyOnWriteArrayList
>
>    CopyOnWriteArrayList是Java 1.5在java.util.concurrent包下增加的类，它采用复制底层数组的方式来实现写操作。当线程对此类集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。当线程对此类集合执行写入操作时，集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。由于对集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。在所有线程安全的List中，它是性能最优的方案
>
>    简单来说它就是一个线程安全且读操作无锁的ArrayList。在写操作时会复制一份新的List，在新的List上完成写操作，然后再将原引用指向新的List。这样就保证了写操作的线程安全。
>
>    CopyOnWriteArrayList允许线程并发访问读操作，这个时候是没有加锁限制的，性能较高。写操作是上锁的。结束之后再将原容器的引用指向新容器。注意，在上锁执行写操作的过程中，如果有需要读操作，会作用在原容器上。因此上锁的写操作不会影响到并发访问的读操作。
>
>    - 优点：读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。在遍历传统的List时，若中途有别的线程对其进行修改，则会抛出ConcurrentModificationException异常。而CopyOnWriteArrayList由于其"读写分离"的思想，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了。
>    - 缺点：一是内存占用问题，每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC。二是无法保证实时性，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。



#### Set

set会跳过重复数据。传入数据有重复值或可变元素改变了自身状态导致 `Object.equals(Object)==true` 会出问题。

实现类有：

- HashSet 由 HashMap 支持，不保证迭代顺序不变，允许使用 `null`
- TreeSet 实现了 `java.util.SortedSet` ，按递增顺序排序，不能 null

TreeSet 新方法：

- first() 返回首个元素
- last() 返回末个元素
- comparator() 返回排序比较器，若自然排序则 `null`
- headSet(E e1) 返回从开始到 e1 前(不包括 e1 )的元素
- subSet(E e1, E e2) 返回 $[e1,e2)$ 范围元素
- tailSet(E e1) 返回 e2 和它之后的全部元素
- higher(E) 返回严格大于 E 的最小元素
- ceiling(E) 不严格大于
- lower(E) 返回严格小于 E 的最大元素
- floor(E) 不严格小于

重复元素去重举例：

```java
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class c1402 {
    public static void main(String[] args) {
        Set<String> s = new HashSet<>();
        s.add("1");
        s.add("2");
        s.add("1");
        Iterator<String> it = s.iterator();
        while (it.hasNext()) { //输出1,2
            System.out.println(it.next());
        }
    }
}
```

结构体排序举例：

```java
import java.util.Iterator;
import java.util.TreeSet;

class node implements Comparable<Object> {
    private long id1, id2;
    private String title;

    public node(long a, long b, String c) {
        id1 = a;
        id2 = b;
        title = c;
    }

    private int sgn(long x, long y) {
        return x > y ? 1 : (x < y ? -1 : 0);
    }

    public int compareTo(Object o) {
        node rhs = (node) o;
        if (id1 != rhs.id1) {
            return sgn(id1, rhs.id1);
        }
        return sgn(id2, rhs.id2);
    }

    public void show() {
        System.out.println("<" + id1 + ", " + id2 + "> " + title);
    }
}

public class Lab6_2 {
    public static void iter_until_end(Iterator<node> it) {
        while (it.hasNext()) {
            node v = it.next();
            v.show();
        }
    }

    public static void main(String[] args) {
        TreeSet<node> t = new TreeSet<>();
        t.add(new node(3, 2, "a32"));
        t.add(new node(1, 5, "b15"));
        t.add(new node(1, 1, "c11"));
        t.add(new node(2, 0, "d20"));
        t.add(new node(3, 3, "e33"));
        Iterator<node> it = t.iterator();
        System.out.println("all elements in treeset:");
        iter_until_end(it);

        System.out.println("elements before(not included) <2, 0> d20");
        // equal in compare is fine; not require memory dir is totally same
        it = t.headSet(new node(2, 0, "d20")).iterator();
        iter_until_end(it);

        System.out.println("elements in [<1,5> b15, <3,2> a32)");
        it = t.subSet(new node(1, 5, "b15"), new node(3, 2, "a32")).iterator();
        iter_until_end(it);

        System.out.println("elements after(included) <2, 0> d20");
        it = t.tailSet(new node(2, 0, "d20")).iterator();
        iter_until_end(it);
    }
}

```

addAll 和 contains 示例：

```java
import java.util.*;

public class c1403 {
    public static void main(String[] args) {
        LinkedList<Integer> arr = new LinkedList<>();
        for (int i = 1; i <= 9; ++i) {
            arr.add(i * i % 10);
        }
        TreeSet<Integer> s = new TreeSet<>();
        s.addAll(arr);
        Iterator<Integer> it = s.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
        System.out.println(s.contains(5));
    }
}

```

> HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。它封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象



#### Map

不继承 Collection 。Map 接口提供了集合的常用方法，和下面方法：

- put(K key, V value) 向集合中添加键值对(已有则覆盖)

- putAll() 是集合版的 addAll

- containsKey(K key) 如果有key返回true

- containsValue(V value) 若存在key的value是参数返回true

- get(K key) 存在返回对应value，否则 `null`

- getOrDefault(K, V) 如果有就取，没有就返回 V

- keySet() 返回key组成的Set集合, O(1)

- values() 返回集合值组成的Collection集合

- celingKey(K key) 返回第一个大于等于key的键

- celingKey(K key) 返回键值对

- entrySet() 返回键值对数组用于遍历

- merge(key, init, f) 如果key不存在将值设为 init, 否则与原有值通过f函数合并；求和频次使用如 `.merge("key", 1, Integer::sum)`，其中：

  > ```java
  > public static int sum(int a, int b) { //Integer::sum
  >     return a + b;
  > }
  > ```

> clear On

Map 允许值对象是 `null` 且没有个数限制。

有 `Map.Entry<K, V>` 类，代表键值对。有方法 `getKey()` 和 `getValue()`

实现类有：

- HashMap 基于哈希表，允许使用 null 值或键，需要保证键唯一性
- TreeMap 实现了 `java.util.SortedMap` ，添加删除和定位性能不如前者，不允许键是 `null`

> 不需要排序优先考虑 `HashMap`, 性能最好。线程安全 `ConcurrentHashMap`，比 `Hashtable` 性能更好，put 时采用分段锁/CAS的加锁机制，后者 put/get 都做同步处理。
>
> 要排序，按插入顺序用 `LinkedHashMap`，按 key 排序 `TreeMap`。线程安全用 `Collections` 工具类将其包装。

代码例子如：

```java
import java.util.HashMap;
import java.util.TreeMap;
import java.util.Map;
import java.util.Iterator;

public class Lab6_3 {
    public static void iterall(Map<String, String> m) {
        Iterator<String> it = m.keySet().iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }

    public static void main(String[] args) {
        String words[] = { "the", "quick", "brown", "fox", "jumps", "over", "lazy", "dog", "named", "Larry" };
        // for kinds of convenience, let value = empty String
        Map<String, String> mh = new HashMap<>();
        Map<String, String> mt = new TreeMap<>();
        for (String x : words) {
            mh.put(x, "");
            mt.put(x, "");
        }
        System.out.println("elements in hashmap order:");
        iterall(mh);

        System.out.println("elements in treemap order:");
        iterall(mt);
        /* 
        存储结果的不同为：
            HashMap 键无序
            TreeMap 以字典序排序 String 键
        内部机制：
        HashMap只是使用了普通的哈希表实现
        TreeMap使用了红黑树(平衡二叉树)
         */
    }
}
```

```java
import java.util.*;

public class c1405 {
    public static void main(String[] args) {
        TreeMap<String, Integer> m = new TreeMap<>();
        m.put("lr580", 580);
        m.put("Zombie", 114514);
        m.put("tianjiang", 0);
        System.out.println(m.ceilingKey("Zombie"));
        System.out.println(m.ceilingKey("Zz"));
        Map.Entry<String, Integer> item = m.ceilingEntry("Z");
        System.out.println(item.getKey() + ", " + item.getValue());
        HashMap<String, Integer> m2 = new HashMap<>();
        m2.putAll(m);
        for (Map.Entry<String, Integer> it : m2.entrySet()) {
            System.out.println(it.getKey() + " - " + it.getValue());
        }
    }
}
```

> TreeMap包含几个重要的成员变量：root、size、comparator。其中root是红黑树的根节点。它是Entry类型，Entry是红黑树的节点，它包含了红黑树的6个基本组成：key、value、left、right、parent和color。Entry节点根据根据Key排序，包含的内容是value
>
> `HashMap` 的 put 的过程：
>
> ![img](img/18330EB2310CB83A25FA317E65ED60EB.png)
>
> 1. 若数组为空，进行第一次扩容 resize
> 2. 若当前位置为空，直接插入；不为空且 key 已存在则覆盖；不为空且 key 不存在将其链到单向链表末端；链表长度达到 8 就转红黑树(小于又转回去)
> 3. 如果数组中元素个数 size 超过 threshold，再次扩容。默认装填因子是 0.75，初始容量 16，每次扩容让容量翻倍
>
> JDK7 不会转红黑树，导致如果有 n 个冲突元素就 O(n) 暴力，转红黑树后能对数级找冲突。递增维护 Entry 数组。JDK8 维护 Node 数组。
>
> 具体扩容：装填因子可以构造器传入，如果大于 1 就不会扩容。检查是否转红黑树前，还判断当前数组是否达到阈值(64)，没达到先扩充数组，所以可能会出现放弃转换。
>
> 因为 hashCode 是 int，而对应到 map 里只需要取它的低位，每次扩容后只需要多看一位就能重新判断所在位置，所以无需重新计算哈希值。
>
> hashmap 的循环链表产生：在多线程的情况下，当重新调整HashMap大小的时候，就会存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历。如果条件竞争发生了，那么就会产生死循环了。put 时产生链表是线程不安全的原因
>
> B/B+树多用于外存上时，B/B+也被成为一个磁盘友好的数据结构。如果用B/B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面，这个时候遍历效率就退化成了链表。
>
> Hashtable不允许使用null作为key和value，它的命名甚至没有遵守Java的命名规范：每个单词的首字母都应该大写，但因大量Java程序中使用了Hashtable类，所以这个类名也就不能改为HashTable了，否则将导致大量程序需要改写
>
> 在 jdk 1.7 中，ConcurrentHashMap 是由 Segment 数据结构和 HashEntry 数组结构构成，采取分段锁来保证安全性。Segment 是 ReentrantLock 重入锁，在 ConcurrentHashMap 中扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，Segment 的结构和 HashMap 类似，是一个数组和链表结构。
>
> <img src="img/A064CF0DD49D1B3694548913C28728DB.png" alt="img" style="zoom:50%;" />
>
> JDK1.8 的实现已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 Synchronized 和 CAS 来操作，整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本
>
> <img src="img/9C8ABF1CD3475339A49DE3B9E1696FE7.png" alt="img" style="zoom:50%;" />
>
> Segment的get操作实现非常简单和高效，先经过一次再散列，然后使用这个散列值通过散列运算定位到 Segment，再通过散列算法定位到元素。get操作的高效之处在于整个get过程都不需要加锁，除非读到空的值才会加锁重读。原因就是将使用的共享变量定义成 volatile 类型
>
> 当执行put操作时，会经历两个步骤：判断是否需要扩容；定位到添加元素的位置，将其放入 HashEntry 数组中。
>
> 插入过程会进行第一次 key 的 hash 来定位 Segment 的位置，如果该 Segment 还没有初始化，即通过 CAS 操作进行赋值，然后进行第二次 hash 操作，找到相应的 HashEntry 的位置，这里会利用继承过来的锁的特性，在将数据插入指定的 HashEntry 位置时（尾插法），会通过继承 ReentrantLock 的 tryLock() 方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用 tryLock() 方法去获取锁，超过指定次数就挂起，等待唤醒。
>
> LinkedHashMap使用双向链表来维护key-value对的顺序（其实只需要考虑key的顺序），该链表负责维护Map的迭代顺序，迭代顺序与key-value对的插入顺序保持一致。
>
> LinkedHashMap可以避免对HashMap、Hashtable里的key-value对进行排序（只要插入key-value对时保持顺序即可），同时又可避免使用TreeMap所增加的成本。
>
> LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能。但因为它以链表来维护内部顺序，所以在迭代访问Map里的全部元素时将有较好的性能



#### Vector

动态数组，有很多不属于集合框架的传统方法，是同步访问的。

构造函数：

- `Vector()` 默认长度 10
- `Vector(int size)` 
- `Vector(int size, int incr)` 每次增加的元素数目
- `Vector(Collection c)`

基本特点：不是泛型，可以装不同的元素。也可以用泛型，用法同上。

> vetor集合类其实跟arrayList相似，不同点是Vector是线程安全的

方法：

- `add(int index, Object e)`
- `add(Object e)` 插入到末尾
- `addAll(int index, Collection c)` 指定位置插入（同理有 addAll )
- `addElement(Object e)` 加入末尾，大小加一
- `capacity()` 容量
- `clear()`
- `clone()` 副本
- `containsAll(Collection c)`
- `copyInto(Object[] arr)` 将该向量复制到指定数组
- `elementAt(int index)` 
- `elements()` 返回向量的枚举 Enumeration
- `ensureCapacity(int min)` 增加容量（如有必要）使其不小于 min
- `firstElement()`
- `get(int index)`
- `indexOf(Object e)` 第一次出现的元素下标或 -1
- `indexOf(Object e, int idx)` 从 `idx` 开始搜
- `insertElementAt(Object e, int idx)`
- `isEmpty()`
- `lastElement()`
- `lastIndexOf(Object e[, int idx])` 倒找
- `remove(int idx)`
- `remove(Object e)` 返回 `boolean`
- `removeAll(Collection c)`
- `removeAllElements()` 移除并大小置零
- `removeElementAt(int idx)`
- `removeRange(int from, int to)` 移除 $[from, to)$
- `retainAll(Collection c)`
- `set(int idx, Object e)` 更改替换单个元素
- `setElementAt(Object o ,int idx)`
- `setSize(int)`
- `size()`
- `subList(int from ,int to)`
- `toArray([Object[] a])` 
- `trimToSize()` 调整容量=大小

如：

```java
import java.util.*;

public class c1608 {
    public static void main(String[] args) {
        Vector v = new Vector();
        v.addElement(5.8);
        v.addElement(143.7f);
        v.addElement("QwQ");
        for (int i = 0; i < v.size(); ++i) {
            System.out.println(v.elementAt(i) + " " + v.elementAt(i).getClass().getName());
        }
    }
}
```



#### Queue

是接口，有方法如下：

- `isEmpty()`

- `peek()` 取队首

- `poll()` 队首出队，返回出队的队首

- `add()` 入队新元素

  > 注: 返回 true 如果成功，否则报错；如果用 `offer` 方法，功能等效但如果不成功不报错而返回 false

- `size()` 元素数

普通队列用 linkedlist 即可

下有 `PriorityQueue` 优先级队列(小根堆)，构造函数可以传一个对象，其类为 `Comparator<类名> cmp` 作参数作为比较依据来自定义，需要实现 `public int compare(对象, 对象)` ，前者大返回正数；小负数，相等 $0$

```java
q = new PriorityQueue<Integer>((a, b) -> (b - a)); //大根堆 (可写为<>下同)
q = new PriorityQueue<Integer>((a, b) -> (a - b)); //小根堆
```

如：

```java
import java.util.*;

class node {// 图的节点(点编号从1递增)
    public String name;// 站点名字
    public int line;// 站点所属线路编号

    public node(final String x, final int y) {
        name = x;
        line = y;
    }
}

//...
{
private static Comparator<elem> cmp = new Comparator<elem>() {
    public int compare(elem lhs, elem rhs) {
        return rhs.v - lhs.v;
    }
};

//...
public static int pr[] = new int[max_edges];// 在答案中编号i的点的上一站是pr[i]
public static int d[] = new int[max_edges];// 在答案中编号i为终点的最短路值
public static void dijkstra(int s, int type) {// 以s为源点跑最短路,type=1是最小距离/花费; type=2是最小用时; type=3是最小换乘
    d = new int[n + 3];// 当前从s到终点i最短路之和是d[i]
    boolean vis[] = new boolean[n + 3];// 是否遍历过点i,是则vis[i]=true
    Arrays.fill(d, 0, n + 1, big);
    Arrays.fill(vis, 0, n + 1, false);
    Arrays.fill(pr, 0, n + 1, 0);// 0代表遍历结束
    d[s] = 0;// 起点到自己距离是0
    Queue<elem> q = new PriorityQueue<>(cmp);// 优先级队列实现二叉堆
    q.add(new elem(s, 0));// 新元素入堆，堆的比较依据是d[s]的大小
    while (!q.isEmpty()) {
        elem t = q.peek();// 取堆顶
        q.poll();// 删除堆顶
        int u = t.i;// 当前点
        if (vis[u]) {// 已经遍历过
            continue;
        }
        vis[u] = true;
        for (int i = hd[u], v; i != 0; i = e[i].next) {// 链式前向星的遍历；即取所有以u为起点的边，每次边编号分别是i
            v = e[i].to;// 该边终点
            int d_edge = get_weight(i, type);// 边权
            if (d[v] > d[u] + d_edge) {// 满足三角形不等式，代表当前更优
                d[v] = d[u] + d_edge;// 更新更优值
                pr[v] = u;// 更新路径答案
                if (!vis[v]) {
                    q.add(new elem(v, d[v]));// 新元素入堆
                }
            }
        }
    }
//...
}
```

也可以传 Comparable，如：

```java
import java.util.PriorityQueue;

public class t03 {
    class node implements Comparable<node> {
        int i, v;

        node(int i, int v) {
            this.i = i;
            this.v = v;
        }
        
        @Override
        public int compareTo(node rhs) {
            return this.v - rhs.v;
        }//right hand side
    }
    
    public void f() {
        PriorityQueue<node> q = new PriorityQueue<>();
        q.add(new node(1,10));
        q.add(new node(2,5));
        System.out.println(q.peek().i);
    }
}
```

二元组的使用举例：

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] pair1, int[] pair2) {
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
            }
        });
        for (int i = 0; i < k; ++i) {
            pq.offer(new int[]{nums[i], i});
        }
        int[] ans = new int[n - k + 1];
        ans[0] = pq.peek()[0];
        for (int i = k; i < n; ++i) {
            pq.offer(new int[]{nums[i], i});
            while (pq.peek()[1] <= i - k) {
                pq.poll();
            }
            ans[i - k + 1] = pq.peek()[0];
        }
        return ans;
    }
}
```

> 为了应对不同的业务场景，BlockingQueue 提供了4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每组方法的表现是不同的。这些方法如下：
>
> |      | 抛异常    | 特定值   | 阻塞   | 超时                 |
> | ---- | --------- | -------- | ------ | -------------------- |
> | 插入 | add(e)    | offer(e) | put(e) | offer(e, time, unit) |
> | 移除 | remove()  | poll()   | take() | poll(time, unit)     |
> | 检查 | element() | peek()   |        |                      |

> - 抛异常：如果操作无法立即执行，则抛一个异常；
> - 特定值：如果操作无法立即执行，则返回一个特定的值(一般是 true / false)。
> - 阻塞：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行；
> - 超时：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行。但等待时间不会超过给定值，并返回一个特定值以告知该操作是否成功(典型的是true / false)。
>
> BlockingQueue(任意时刻只有一个线程可以进行take或者put操作)是一个接口，它的实现类有ArrayBlockingQueue、DelayQueue、 LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue等。它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于put与take操作的原理是类似的。
>
> ArrayBlockingQueue的构造函数，它初始化了put和take函数中用到的关键成员变量，这两个变量的类型分别是ReentrantLock和Condition。ReentrantLock是AbstractQueuedSynchronizer（AQS）的子类，它的newCondition函数返回的Condition实例，是定义在AQS类内部的ConditionObject类，该类可以直接调用AQS相关的函数。
>
> put函数会在队列末尾添加元素，如果队列已经满了，无法添加元素的话，就一直阻塞等待到可以加入为止。函数的源码如下所示。put函数使用了wait/notify的机制。与一般生产者-消费者的实现方式不同，同步队列使用ReentrantLock和Condition相结合的机制，即先获得锁，再等待，而不是synchronized和wait的机制。
>
> take函数在队列为空时会被阻塞，一直到阻塞队列加入了新的元素。
>
> ArrayBlockingQueue并没有使用Object.wait，而是使用的Condition.await，Condition对象可以提供和Object的wait和notify一样的行为，但是后者必须先获取synchronized这个内置的monitor锁才能调用，而Condition则必须先获取ReentrantLock。这两种方式在阻塞等待时都会将相应的锁释放掉，但是Condition的等待可以中断，这是二者唯一的区别。
>
> await函数的流程大致如下图所示。await函数主要有三个步骤，一是调用addConditionWaiter函数，在condition wait queue队列中添加一个节点，代表当前线程在等待一个消息。然后调用fullyRelease函数，将持有的锁释放掉，调用的是AQS的函数。最后一直调用isOnSyncQueue函数判断节点是否被转移到sync queue队列上，也就是AQS中等待获取锁的队列。如果没有，则进入阻塞状态，如果已经在队列上，则调用acquireQueued函数重新获取锁。
>
> ![img](img/37DE256DECC211F4D5230BF7A654E128.png)
>
> signal函数将condition wait queue队列中队首的线程节点转移等待获取锁的sync queue队列中。这样的话，await函数中调用isOnSyncQueue函数就会返回true，导致await函数进入最后一步重新获取锁的状态。
>
> condition wait queue是等待消息的队列，因为阻塞队列为空而进入阻塞状态的take函数操作就是在等待阻塞队列不为空的消息。而sync queue队列则是等待获取锁的队列，take函数获得了消息，就可以运行了，但是它还必须等待获取锁之后才能真正进行运行状态。
>
> signal函数其实就做了一件事情，就是不断尝试调用transferForSignal函数，将condition wait queue队首的一个节点转移到sync queue队列中，直到转移成功。因为一次转移成功，就代表这个消息被成功通知到了等待消息的节点。
>
> ![img](img/61A52D5795794D763D6F8D37D13AFE07.png)



#### Stack

泛型。有方法：

- `add()` 
- `size()`
- `isEmpty()`
- `peek()`
- `pop()`



#### BitSet

`java.util`。

构造函数填位数。

- `set(i)` 该位设 true

  `set(i, bool)` 设特定值

  `set(i, j)` [i,j) 设 true

- `and(bitset)` 与一个 bitset 运算

- `cardinality` 1 的个数

还有别的用到再补。自行查 gpt。



### 流

流是一组有序的数据序列，分为输入流和输出流两种(根据操作类型)。在 `java.io` 包。输入流类是抽象类 `InputStream` 或 `Reader` (分别是字节、字符输入流) 子类；输出流是 `OutputStream` 、`Writer` 子类。

> 流按传输单位分为字节流和字符流。
>
> 特别地，可以使用 Scanner 扫描文件 File 。
>
> 字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件
>
> 字节是 8bit ，字符是 2byte = 16bit

> 类层次结构图：
>
> ```mermaid
> graph LR
> 	f["InputStream"]--> AudioInputStream
> 	f--> ByteArrayInputStream
> 	f--> StringBufferInputStream
> 	f-->g["FilterInputStream"]
> 	g-->BufferedInputStream
> 	g-->DataInputStream
> 	g-->PushbackInputSteam
> 	g-->gc["..."]
> 	f-->InputStream
> 	f-->ObjectInputStream
> 	f-->SequenceInputStream
> 	f-->PipedInputStream
> ```
>
> ```mermaid
> graph LR
> 	f["Reader"]-->CharArrayReader
> 	f-->BufferedReader-->LineNumberReader
> 	f-->FilterReader-->PushbackReader
> 	f-->InputStreamReader-->FileReader
> 	f-->PipedReader
> 	f-->StringReader
> ```
>
> ```mermaid
> graph LR
>     f["OutputStream"]-->ByteArrayOutputStream
>     f-->FileOutputStream
>     f-->g["FfilterOutputStream"]
>     g-->BufferedOutputStream
>     g-->DataOutputStream
>     g-->gc["..."]
>     f-->ObjectOutputStream-->OutputStream
>     f-->PipedOutputStream
> ```
>
> ```mermaid
> graph LR
> 	f["Writer"]-->BufferedWriter
> 	f-->CharArrayWriter
> 	f-->FilterWriter
> 	f-->OutputStreamWriter-->FileWriter
> 	f-->PipedWriter
> 	f-->PrintWriter
> 	f-->StringWriter
> ```
>
> 

> `RandomAccessFile` 实现 `DataInput` 和 `DataOutput` 接口，其`getFilePointer()` 方法：返回此文件中的当前偏移量；有诸如 `readFloat` 方法，有诸如 `writeChar(int v)` 方法，按双字节值将 `char` 写入文件，先写高字节 
>
> `DataOutputStream` 写变量到文件时，文件看到的大小就是写进去的总大小，不会额外添加EOF等

> IO（Input Output）用于实现对数据的输入与输出操作，Java把不同的输入/输出源（键盘、文件、网络等）抽象表述为流（Stream）。流是从起源到接收的有序数据，有了它程序就可以采用同一方式访问不同的输入/输出源。
>
> - 按照数据流向，可以将流分为输入流和输出流，其中输入流只能读取数据、不能写入数据，而输出流只能写入数据、不能读取数据。
> - 按照数据类型，可以将流分为字节流和字符流，其中字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符。
> - 按照处理功能，可以将流分为节点流和处理流，其中节点流可以直接从/向一个特定的IO设备（磁盘、网络等）读/写数据，也称为低级流，而处理流是对节点流的连接或封装，用于简化数据读/写功能或提高效率，也称为高级流。
>
> 下图黑色字体的是抽象基类，其他所有的类都继承自它们。红色字体的是节点流，蓝色字体的是处理流。
>
> ![img](img/3813D6FF51EAD282F3995515D9A61541.png)
>
> - 以File开头的文件流用于访问文件；
> - 以ByteArray/CharArray开头的流用于访问内存中的数组；
> - 以Piped开头的管道流用于访问管道，实现进程之间的通信；
> - 以String开头的流用于访问内存中的字符串；
> - 以Buffered开头的缓冲流，用于在读写数据时对数据进行缓存，以减少IO次数；
> - InputStreamReader、InputStreamWriter是转换流，用于将字节流转换为字符流；
> - 以Object开头的流是对象流，用于实现对象的序列化；
> - 以Print开头的流是打印流，用于简化打印操作；
> - 以Pushback开头的流是推回输入流，用于将已读入的数据推回到缓冲区，从而实现再次读取；
> - 以Data开头的流是特殊流，用于读写Java基本类型的数据



#### 输入/输出流

##### 输入流

`InputStream` 的方法：

- `read()`

  从输入流获得下一字节，返回 $[0,255]$ 的 int 。若达到了流末尾而无可用字节返回 $-1$
- `read(byte[] b)`

  读入一定长度的字节，以整数形式返回字节数
- `mark(int readlimit)`

  在输入流当前位置放置一个标记，`readlimit` 参数告知此输入路在标记位置失效之前允许的字节数
- `reset()`

  将输入指针返回当前所做的标记处
- `skip(long n)`

  跳过输入流上的 $n$ 个字节并返回实际跳过的字节数 (不保证输入流都支持)
- `markSupported()`

  返回当前流是否支持 `mark,reset`操作
- `close`

  关闭和释放资源

Java 字符是 Unicode 编码，双字节。字符读取用 `Reader` ，方法与上类似。

##### 输出流

显然需要 `import java.io.FileOutputStream`

`OutputStream` 的方法：

- `write(int b)`

  将指定字节写入此输出流
- `write(byte[] b)`

  $b$ 个字节写入
- `write(byte[] b, int off, int len)`

  偏移量 $off$ 开始的 $len$ 个写入
- `flush()`

  彻底完成输出，清空缓存区
- `close()`

#### File类

文件包含常规文件和目录。

> 文件与目录本质都是同一类内容，只不过实现方式不同。从路径来看，以斜杠结尾的是文件夹，文件夹可以是空名字，名字里可以带 `.`，可以与同目录下文件同名。(如 `a.b\` 和 `a.b`)

> File 类对象对应系统中的一个目录和文件；对象描述文件名、可否读写等属性，但不读写文件。一旦创建，对象表示的抽象路径名将不会改变。

显然需要 `import java.io.File;`

创建文件对象：

- `new File(String pathname)`

  路径名可以是相对/绝对，`/`和 `\\` 可以互换(`\\`是绝对路径)
- `new File(String parent, String child)`

  两个路径，然后自行链接
- `new File(File f, String child)`

  同理链接两个路径

有方法：

- `exists()` 该文件是否存在
- `delete()` 删除该文件
- `deleteOnExit()`
- `createNewFile()` 新建该文件
- `mkdir()` 创建路径指定的目录
- `mkdirs()` 区别在于包括创建所必须的父目录
- `getName()` 返回文件名(相对路径)
- `getAbsolutePath()`
- `canRead()` 是否可读
- `canWrite()` 是否可写
- `exists()` 是否存在
- `length()` 返回 `long` ，文件内容长度(大小)，以字节为单位
- `getAbsolutePath()` 返回绝对路径
- `getAbsoluteFile()` 返回 File O(1)
- `getParent()` 返回父路径(即使绝对路径有父路径，也可能会没有)
- `isFile()` 文件是否存在
- `isDirectory()` 是否是目录
- `listFiles()` 返回目录下的直接所有路径 `File []`
- `isHidden()` 是否隐藏文件
- `lastModified()` 最后修改时间，`long`
- `renameTo(File)` 重命名为新名字
- `hashCode()` 根据文件路径做哈希，常用 `f.getAbsoluteFile().hashCode()`
- `createTempFile(String prefix, String suffix)` 创建前缀(至少长3)，在系统的默认临时文件目录，退出时不会自动删除的临时文件

**读文件**，创建输入流：

```java
FileInputStream in = new FileInputStream(文件实例);
```

存入字符数组：

```java
byte byt[] = new byte[1024];//最大读入长度，若动态则用缓存流
int len = in.read(byt);
String res = new String(byt, 0, len); //不要取多余的字节
```

注意一定要放在 `try` 里。否则会直接报错(参见throw知识点)。

也可以用 `FileReader` ，基本大同，除了要用 `char` 数组。

**写文件**，创建输出流 `FileOutputStream` ，写入传入 `字符串.getBytes()`。而如果用 `FileWriter` ，直接写字符串即可。

**缓存优化**。对读入流，是 `BufferedInputStream` ，传入参数是 `InputStream` ，可以再传一个 `int size` ，规定缓冲区大小。否则创造带 $32$ 字节的缓存流。有方法：

- `read()` 读取单个字符
- `readLine()` 读取一行，若无数据可读，返回 `null`

对输出流，同理有 `BufferedOutputStream` 。新增 `flush` 方法将缓冲区数据强制输出完。有方法：

- `write(String s, int off, int len)` ，写入字符串的一部分
- `flush()` 刷新缓存
- `newLine()` 写入一个行分隔符

显然有类似的 `BufferedWrite, BufferedReader` 。

读取默认是 Unicode，如果需要读UTF-8，需要用 `import java.nio.charset.Charset` ，用 `InputStreamReader` ，第一个参数是 `FileInputStream` ，其可以用 File 构造；第二个参数是 `Charset.forName("UTF-8")` 。

##### 举例

###### 普通创建与新建

```java
import java.io.File;

public class c1501 {
    public static void main(String[] args) {
        File f = new File("1.in");
        if (f.exists()) {
            f.delete(); // 删除文件
            System.out.println("delete automaton");
        } else {
            try {
                f.createNewFile(); // 新建文件
                System.out.println("create automaton");
                System.out.println(f.getName() + " " + f.length() + " " + f.getAbsolutePath() + " " + f.getParent());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

###### 读入(非缓冲)

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;

public class c1503 {
    public static void main(String[] args) {
        File f = new File("2.in");
        // try {
        // FileInputStream in = new FileInputStream(f);
        // byte byt[] = new byte[1024];
        // int len = in.read(byt);
        // System.out.println(new String(byt, 0, len));
        // in.close();
        // } catch (Exception e) {
        // e.printStackTrace();
        // }
        try {
            FileReader fr = new FileReader(f);
            char cc[] = new char[1024];
            int len = fr.read(cc);
            System.out.println(new String(cc, 0, len));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

###### 写入(非缓冲)

```java
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;

public class c1504 {
    public static void main(String[] args) {
        File f = new File("1.out");
        final String s = "阿斯蒂芬放倒是放而奋斗菲尔德为无所谓";
        if (f.exists()) {
            f.delete();
        }
        try {
            f.createNewFile();
            // FileWriter fw = new FileWriter(f);
            // fw.write(s);
            // fw.close();
            FileOutputStream out = new FileOutputStream(f);
            out.write(s.getBytes());
            out.close();
            System.out.println("=w=");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

###### 缓存读写

```java
import java.io.*;

public class c1505 {
    public static void main(String[] args) {
        final String a = "ukrghbfdligekujdi;\n ef\njdfniife哈哈哈";
        File f = new File("2.out");
        try {
            FileWriter fw = new FileWriter(f);
            BufferedWriter bfw = new BufferedWriter(fw);
            bfw.write(a);
            bfw.close();
            fw.close();
          
            FileReader fr = new FileReader(f);
            BufferedReader bfr = new BufferedReader(fr);
            String res = "";
            while (null != (res = bfr.readLine())) {
                System.out.println(res);
            }
            bfr.close();
            fr.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

###### 重命名

```java
import java.io.File;
import java.io.IOException;
 
public class RunoobTest {
    public static void main(String[] args) throws IOException {
        // 旧的文件或目录
        File oldName = new File("./runoob-test.txt");
        // 新的文件或目录
        File newName = new File("./runoob-test-2.txt");
        if (newName.exists()) {  //  确保新的文件名不存在
            throw new java.io.IOException("file exists");
        }
        if(oldName.renameTo(newName)) {
            System.out.println("已重命名");
        } else {
            System.out.println("Error");
        }
    }
}
```

###### UTF-8读取

```java
import java.nio.charset.Charset;//UTF-8文本文档读取使用
//...
File f = new File("data.txt");
InputStreamReader fr = new InputStreamReader(new FileInputStream(f), Charset.forName("UTF-8"));
BufferedReader bfr = new BufferedReader(fr);
```

###### 跳转读二进制

`RandomAccessFile`

读取某一块二进制数据：(MIT6.830)

```java
public Page readPage(PageId pid) { //pid看成int, page看成data
    // DONE: some code goes here
    long offset = pid.getPageNumber() * BufferPool.getPageSize();
    byte[] data = new byte[BufferPool.getPageSize()];
    try {
        RandomAccessFile file = new RandomAccessFile(f, "r");
        file.seek(offset);
        for (int i = 0, n = BufferPool.getPageSize(); i < n; ++i) {
            data[i] = file.readByte();
        }
        file.close();
        return new HeapPage((HeapPageId) pid, data);
    } catch (IOException e) {
        //            e.printStackTrace();
        return null;
    }
}
```





#### 压缩流

载入用 `import java.util.zip.*`

压缩文件用 `ZipOutputStream` ，压缩格式显然是 `.zip` ，构造函数为：

- `ZipOutputStream(OutputStream out)`

方法如下：

- `putNextEntry(new ZipEntry(路径))` 创建一个入口，并将流位置移动到入口开头；该入口可以是文件或文件夹
- `write(int)` 写入单个数据，该数据通过指向入口路径的 `FileInputStream` 读入，方法为 `read()` ，显然读到 $-1$ 时是 `EOF`
- `finish()` 完成输出，无需关闭所用的 `OutputStream`
- `setComment(String)` 设置注释文字

压缩的基本思路是：创建压缩输出流，从传入路径开始，创建入口，如果路径是文件，创建该路径的文件读入流，读取文件，将读到的内容用压缩流 `write`；如果路径是文件夹，对每个文件/文件夹 DFS 递归上述流程。

解压缩文件用 `ZipInputStream` ，构造方法为：

- `ZipInputStream(InputStream in)`

方法如下：

- `getNextEntry()` 获取下一个压缩包里的入口，返回 `ZipEntry` 或 `null`
- `closeEntry()` 关闭当前条目然后读下一个条目
- `read(byte[] b, int off, int len)`
- `available()` 是否已经读完当前 `entry` 的数据
- `skip(long n)` 跳过字节数
- `createZipEntry(String name)` 创建返回 `ZipEntry`

`ZipEntry` 有 `File` 的全部方法。

解压缩的基本思路是：创建 `ZipFile` 压缩文件流，以同一路径的文件输入流创建压缩输入流，不断让 `ZipEntry` 获取下一个入口，创建入口名字的 `File` 类，如果发现是目录，创建该目录；如果发现是文件，创建该路径的输出流，创建压缩文件流的该入口的输入流 (`.getInputStream`) ，不断读单一字节，然后写入输出流。注意不需要 DFS 。

参考代码：

```java
import java.io.*;
import java.util.zip.*;

class mzip {
    private ZipOutputStream zout;

    public mzip(String destname, String srcname) throws Exception {
        zout = new ZipOutputStream(new FileOutputStream(destname));
        File src = new File(srcname);
        dfs(src, src.getName());
        zout.close();
    }

    private void dfs(File f, String prefix) throws Exception {
        if (f.isDirectory()) {
            File fs[] = f.listFiles();
            prefix = prefix.length() == 0 ? "" : prefix + "/";// 特判空名文件夹
            zout.putNextEntry(new ZipEntry(prefix));
            for (int i = 0; i < fs.length; ++i) {
                dfs(fs[i], prefix + fs[i].getName());// 累加，否则f/与f/f/重名
            }
        } else {
            zout.putNextEntry(new ZipEntry(prefix));
            FileInputStream fin = new FileInputStream(f);
            int bit;
            while (-1 != (bit = fin.read())) {
                zout.write(bit);
            }
            fin.close();
        }
    }
}

class muzip {
    public muzip(String destname, String srcname) throws Exception {
        if (destname.indexOf(destname.length() - 1) != '\\') {
            destname += '\\';
        }
        File f0 = new File(srcname);
        ZipFile zf = new ZipFile(f0);
        ZipInputStream zin = new ZipInputStream(new FileInputStream(f0));
        ZipEntry ze;
        while (null != (ze = zin.getNextEntry())) {
            File f = new File(destname + ze.getName());
            if (ze.isDirectory()) {
                f.mkdirs();
            } else {
                OutputStream out = new FileOutputStream(f);
                InputStream sc = zf.getInputStream(ze);
                int bit = 0;
                while (-1 != (bit = sc.read())) {
                    out.write(bit);
                }
                out.close();
                sc.close();
            }
            zin.closeEntry();
        }
        zin.close();
        zf.close();
    }
}

public class c1507 {
    public static void main(String[] args) {
        try {
            new mzip("a.zip", "prj1");
            new muzip("uprj1", "a.zip");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

一个完整实现的单文件压缩和解压缩：

```java
package Lab9;

import java.io.*;
import java.util.zip.*;

public class Lab9_3 {
    public static void main(String[] args) {
        StringBuilder str = new StringBuilder();
        for (int i = 0; i < 10000; ++i) { // if 100000 too big to write
            str.append((char) ('a' + Math.random() * ('z' - 'a' + 1)));
        } // big file to text zip can downsize
        System.out.println("input: (first 100 chars)");
        System.out.println(str.toString().substring(0, 100));
        System.out.println();

        try {
            FileOutputStream fs = new FileOutputStream("MyText.txt");
            DataOutputStream ds = new DataOutputStream(fs);
            ds.writeUTF(str.toString());
            ds.close();

            File fori = new File("MyText.txt");
            ZipOutputStream zout = new ZipOutputStream(new FileOutputStream("MyText.zip"));
            zout.putNextEntry(new ZipEntry(""));
            FileInputStream tempin = new FileInputStream(fori);
            int b;
            while ((b = tempin.read()) != -1) {
                zout.write(b);
            }
            tempin.close();
            zout.close();
            fs.close();

            File fzori = new File("MyText.zip");
            ZipFile zf = new ZipFile(fzori);
            ZipInputStream zin = new ZipInputStream(new FileInputStream(fzori));
            ZipEntry entry;// = zin.getNextEntry();
            while (null != (entry = zin.getNextEntry())) {
                // File tmp = new File(entry.getName());
                File tmp = new File("NewText.txt");
                if (tmp.exists()) {
                    tmp.delete();
                }
                OutputStream os = new FileOutputStream(tmp);
                InputStream tin = zf.getInputStream(entry);
                int c = 0;
                while (-1 != (c = tin.read())) {
                    os.write(c);
                }
                os.close();
                tin.close();

            }
            zf.close();
            zin.closeEntry();
            zin.close();

            FileInputStream fis = new FileInputStream("NewText.txt");
            DataInputStream dis = new DataInputStream(fis);
            System.out.println("output: (first 100 chars)");
            System.out.println(dis.readUTF().substring(0, 100));
            dis.close();
            fis.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```





#### 数据流

数据输入/输出流( `DataInputStream` , `DataOutputStream` ) ，类似于二进制读写。

构造函数：

- `DataInputStream(InputStream in)`
- `DataOutputStream(OutputStream out)`

输出流方法如下：

- `writeBytes(String s)` 将 Java 本以 Unicode 编码的双字节每个字符低字节内容写入目标设备中
- `writeChars(String s)` 将字符串每个字符双字节都写到目标设备中
- `writeUTF(String s)` 按照 UTF 编码后直接长度写入目标设备，仅这种方法才能向目标设备写入字符串长度，能够反过来读回字符串

输入流方法只有 `readUTF`

如：

```java
import java.io.*;

public class c1506 {
    public static void main(String[] args) {
        try {
            FileOutputStream fs = new FileOutputStream("datat.txt");
            DataOutputStream ds = new DataOutputStream(fs);
            ds.writeUTF("at一二三");
            ds.writeChars("qwq啊啊啊");
            ds.writeBytes("cout<<\"啊啊啊\"");
            ds.close();

            FileInputStream fis = new FileInputStream("datat.txt");
            DataInputStream dis = new DataInputStream(fis);
            System.out.println(dis.readUTF());
            dis.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```



#### NIO

NIO non-blocking IO

> 打开大文件，应避免直接将文件中的数据全部读取到内存中，可以采用分次读取的方式。
>
> 1. 使用缓冲流。缓冲流内部维护了一个缓冲区，通过与缓冲区的交互，减少与设备的交互次数。使用缓冲输入流时，它每次会读取一批数据将缓冲区填满，每次调用读取方法并不是直接从设备取值，而是从缓冲区取值，当缓冲区为空时，它会再一次读取数据，将缓冲区填满。使用缓冲输出流时，每次调用写入方法并不是直接写入到设备，而是写入缓冲区，当缓冲区填满时它会自动刷入设备。
> 2. 使用NIO。NIO采用内存映射文件的方式来处理输入/输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了（这种方式模拟了操作系统上的虚拟内存的概念），通过这种方式来进行输入/输出比传统的输入/输出要快得多。
>
> Java的NIO主要由三个核心部分组成：Channel、Buffer、Selector。
>
> 基本上，所有的IO在NIO中都从一个Channel开始，数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。Channel有好几种类型，其中比较常用的有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等，这些通道涵盖了UDP和TCP网络IO以及文件IO。
>
> Buffer本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。Java NIO里关键的Buffer实现有CharBuffer、ByteBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。这些Buffer覆盖了你能通过IO发送的基本数据类型，即byte、short、int、long、float、double、char。
>
> Buffer对象包含三个重要的属性，分别是capacity、position、limit，其中position和limit的含义取决于Buffer处在读模式还是写模式。但不管Buffer处在什么模式，capacity的含义总是一样的。
>
> - capacity：作为一个内存块，Buffer有个固定的最大值，就是capacity。Buffer只能写capacity个数据，一旦Buffer满了，需要将其清空才能继续写数据往里写数据。
> - position：当写数据到Buffer中时，position表示当前的位置。初始的position值为0。当一个数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity–1。当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。
> - limit：在写模式下，Buffer的limit表示最多能往Buffer里写多少数据，此时limit等于capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据，此时limit会被设置成写模式下的position值。
>
> 三个属性之间的关系，如下图所示：
>
> <img src="img/242CC72B9020D2512E353D972261C386.png" alt="img" style="zoom:50%;" />
>
> Java NIO根据操作系统不同， 针对NIO中的Selector有不同的实现：
>
> - macosx：KQueueSelectorProvider
> - solaris：DevPollSelectorProvider
> - Linux：EPollSelectorProvider (Linux kernels >= 2.6)或PollSelectorProvider
> - windows：WindowsSelectorProvider
>
> 所以不需要特别指定，Oracle JDK会自动选择合适的Selector。如果想设置特定的Selector，可以设置属性，例如： -Djava.nio.channels.spi.SelectorProvider=sun.nio.ch.EPollSelectorProvider。
>
> JDK在Linux已经默认使用epoll方式，但是JDK的epoll采用的是水平触发，所以Netty自4.0.16起, Netty为Linux通过JNI的方式提供了native socket transport。Netty重新实现了epoll机制。
>
> 1. 采用边缘触发方式；
> 2. netty epoll transport暴露了更多的nio没有的配置参数，如 TCP_CORK, SO_REUSEADDR等等；
> 3. C代码，更少GC，更少synchronized。



#### 序列化

序列化机制可以将对象转换成字节序列，这些字节序列可以保存在磁盘上，也可以在网络中传输，并允许程序将这些字节序列再次恢复成原来的对象。其中，对象的序列化（Serialize），是指将一个Java对象写入IO流中，对象的反序列化（Deserialize），则是指从IO流中恢复该Java对象。

若对象要支持序列化机制，则它的类需要实现Serializable接口，该接口是一个标记接口，它没有提供任何方法，只是标明该类是可以序列化的，Java的很多类已经实现了Serializable接口，如包装类、String、Date等。

若要实现序列化，则需要使用对象流ObjectInputStream和ObjectOutputStream。其中，在序列化时需要调用ObjectOutputStream对象的writeObject()方法，以输出对象序列。在反序列化时需要调用ObjectInputStream对象的readObject()方法，将对象序列恢复为对象

serialVersionUID代表序列化的版本，通过定义类的序列化版本，在反序列化时，只要对象中所存的版本和当前类的版本一致，就允许做恢复数据的操作，否则将会抛出序列化版本不一致的错误。

> 如果不定义序列化版本，在反序列化时可能出现冲突的情况，例如：
>
> 1. 创建该类的实例，并将这个实例序列化，保存在磁盘上；
> 2. 升级这个类，例如增加、删除、修改这个类的成员变量；
> 3. 反序列化该类的实例，即从磁盘上恢复修改之前保存的数据。
>
> 在第3步恢复数据的时候，当前的类已经和序列化的数据的格式产生了冲突，可能会发生各种意想不到的问题。增加了序列化版本之后，在这种情况下则可以抛出异常，以提示这种矛盾的存在，提高数据的安全性。

> 序列化工具：
>
> - JSON：目前使用比较频繁的格式化数据工具，简单直观，可读性好，有jackson，gson，fastjson等等，比较优秀的JSON解析工具的表现还是比较好的，有些json解析工具甚至速度超过了一些二进制的序列化方式。
> - Protobuf：一个用来序列化结构化数据的技术，支持多种语言诸如C++、Java以及Python语言，可以使用该技术来持久化数据或者序列化成网络传输的数据。相比较一些其他的XML技术而言，该技术的一个明显特点就是更加节省空间（以二进制流存储）、速度更快以及更加灵活。另外Protobuf支持的数据类型相对较少，不支持常量类型。由于其设计的理念是纯粹的展现层协议（Presentation Layer），目前并没有一个专门支持Protobuf的RPC框架。
> - Thrift：是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求。 但是，Thrift并不仅仅是序列化协议，而是一个RPC框架。 相对于JSON和XML而言，Thrift在空间开销和解析性能上有了比较大的提升，对于对性能要求比较高的分布式系统，它是一个优秀的RPC解决方案。但是由于Thrift的序列化被嵌入到Thrift框架里面， Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用（例如HTTP）。
> - Avro：提供两种序列化格式，即JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美， JSON格式方便测试阶段的调试。 Avro支持的数据类型非常丰富，包括C++语言里面的union类型。Avro支持JSON格式的IDL和类似于Thrift和Protobuf的IDL（实验阶段），这两者之间可以互转。Schema可以在传输数据的同时发送，加上JSON的自我描述属性，这使得Avro非常适合动态类型语言。 Avro在做文件持久化的时候，一般会和Schema一起存储，所以Avro序列化文件自身具有自我描述属性，所以非常适合于做Hive、Pig和MapReduce的持久化数据格式。对于不同版本的Schema，在进行RPC调用的时候，服务端和客户端可以在握手阶段对Schema进行互相确认，大大提高了最终的数据解析速度
>
> 用Java原生的序列化机制，效率比较低一些，适合小项目。上述三个第三方类库效率更高。



#### Stream

> Stream提供了大量的方法进行聚集操作，这些方法既可以是“中间的”，也可以是“末端的”。
>
> - 中间方法：中间操作允许流保持打开状态，并允许直接调用后续方法。上面程序中的map()方法就是中间方法。中间方法的返回值是另外一个流。
> - 末端方法：末端方法是对流的最终操作。当对某个Stream执行末端方法后，该流将会被“消耗”且不再可用。上面程序中的sum()、count()、average()等方法都是末端方法。
>
> 除此之外，关于流的方法还有如下两个特征：
>
> - 有状态的方法：这种方法会给流增加一些新的属性，比如元素的唯一性、元素的最大数量、保证元素以排序的方式被处理等。有状态的方法往往需要更大的性能开销。
> - 短路方法：短路方法可以尽早结束对流的操作，不必检查所有的元素。
>
> 下面简单介绍一下Stream常用的中间方法：
>
> - filter(Predicate predicate)：过滤Stream中所有不符合predicate的元素。
> - mapToXxx(ToXxxFunction mapper)：使用ToXxxFunction对流中的元素执行一对一的转换，该方法返回的新流中包含了ToXxxFunction转换生成的所有元素。
> - peek(Consumer action)：依次对每个元素执行一些操作，该方法返回的流与原有流包含相同的元素。该方法主要用于调试。
> - distinct()：该方法用于排序流中所有重复的元素（判断元素重复的标准是使用equals()比较返回true）。这是一个有状态的方法。
> - sorted()：该方法用于保证流中的元素在后续的访问中处于有序状态。这是一个有状态的方法。
> - limit(long maxSize)：该方法用于保证对该流的后续访问中最大允许访问的元素个数。这是一个有状态的、短路方法。
>
> 下面简单介绍一下Stream常用的末端方法：
>
> - forEach(Consumer action)：遍历流中所有元素，对每个元素执行action。
> - toArray()：将流中所有元素转换为一个数组。
> - reduce()：该方法有三个重载的版本，都用于通过某种操作来合并流中的元素。
> - min()：返回流中所有元素的最小值。
> - max()：返回流中所有元素的最大值。
> - count()：返回流中所有元素的数量。
> - anyMatch(Predicate predicate)：判断流中是否至少包含一个元素符合Predicate条件。
> - noneMatch(Predicate predicate)：判断流中是否所有元素都不符合Predicate条件。
> - findFirst()：返回流中的第一个元素。
> - findAny()：返回流中的任意一个元素。
>
> 除此之外，Java 8允许使用流式API来操作集合，Collection接口提供了一个stream()默认方法，该方法可返回该集合对应的流，接下来即可通过流式API来操作集合元素。由于Stream可以对集合元素进行整体的聚集操作，因此Stream极大地丰富了集合的功能。
>
> Java 8新增了Stream、IntStream、LongStream、DoubleStream等流式API，这些API代表多个支持串行和并行聚集操作的元素。上面4个接口中，Stream是一个通用的流接口，而IntStream、LongStream、DoubleStream则代表元素类型为int、long、double的流。
>
> Java 8还为上面每个流式API提供了对应的Builder，例如Stream.Builder、IntStream.Builder、LongStream.Builder、DoubleStream.Builder，开发者可以通过这些Builder来创建对应的流。
>
> 独立使用Stream的步骤如下：
>
> 1. 使用Stream或XxxStream的builder()类方法创建该Stream对应的Builder。
> 2. 重复调用Builder的add()方法向该流中添加多个元素。
> 3. 调用Builder的build()方法获取对应的Stream。
> 4. 调用Stream的聚集方法。
>
> 在上面4个步骤中，第4步可以根据具体需求来调用不同的方法，Stream提供了大量的聚集方法供用户调用，具体可参考Stream或XxxStream的API文档。对于大部分聚集方法而言，每个Stream只能执行一次。
>



### 多线程

同时进行多个活动叫并发，并发完成的每一件事情叫做线程。

有两种方法实现线程，分别是继承 `java.lang.Thread` 和实现接口 `java.lang.Runnable`

不需要 `import `。

> 线程组 `ThreadGroup` ，每个线程都隶属于惟一一个线程组 ；多个线程的执行顺序不是按顺序执行的；线程是(进程 process 的)一个执行单位
>
> 守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。

#### 创建

> 可以同时 `extends Thread implements Runnable` ，会警告冗余不会报错。Thread 实现了 Runnable 接口。

> 通过继承Thread类、实现Runnable接口、实现Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。因此可以将实现Runnable接口和实现Callable接口归为一种方式。
>
> 采用实现Runnable、Callable接口的方式创建多线程的优缺点：
>
> - 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。
> - 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
> - 劣势是，编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread()方法。
>
> 采用继承Thread类的方式创建多线程的优缺点：
>
> - 劣势是，因为线程类已经继承了Thread类，所以不能再继承其他父类。
> - 优势是，编写简单，如果需要访问当前线程，则无须使用Thread.currentThread()方法，直接使用this即可获得当前线程。
>
> 鉴于上面分析，因此一般推荐采用实现Runnable接口、Callable接口的方式来创建多线程。

##### Thread

需要重写方法 `run` ，执行线程时会执行 `run` 方法**一次** ，如果需要反复执行线程，可以让线程本身是循环的或者反复启动线程。启动线程用父类的 `start()` 方法。

例如：

```java
public class c1801 extends Thread {
    public static void main(String[] args) {
        new c1801().start();
        for (int i = 1; i <= 10; ++i) {
            System.out.println("oth " + i);
        } // 体现多线程
    }

    public void run() {
        int cnt = 0;
        final int maxcnt = 10;
        while ((cnt++) < maxcnt) {
            System.out.println("thr " + cnt);
        }
    }
}

```

> 只能对处于新建状态的线程调用start()方法，否则将引发IllegalThreadStateException异常
>
> run()方法被称为线程执行体，它的方法体代表了线程需要完成的任务，而start()方法用来启动线程。
>
> 调用start()方法启动线程时，系统会把该run()方法当成线程执行体来处理。但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，如果直接调用线程对象的run()方法，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。



##### Runnable

适用于本身继承了别的类，但是又想实现多线程的类。以间接达到多继承目的。例如 `JFrame` 。

实现该接口会创建一个 `Thread` 对象，将 `Runnable` 对象与之关联。 `Thread` 构造函数：

- `Thread(Runnable target)`
- `Thread(Runnable target, String name)`

`Runnable` 可用匿名内部类方法实现 `public void run()` 。

使用步骤为：用 `Runnable` 创建 `Thread` 实例，然后将该实例 `.start()`

特别注意： `Runnable` 没有 `getName` 和 `sleep` ，分别用 `Thread.currentThread().getName()` 和 `Thread.sleep()` 实现。

如：

```java
public class c1802 {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i < 10; ++i) {
                    System.out.println("thr " + i);
                }
            }
        }).start();
        for (int i = 0; i < 10; ++i) {
            System.out.println("oth " + i);
        }
    }
}

```

##### Timer

计时器。 `java.util` 

周期任务是 `TimerTrask` ，也在这个包，任务有 `run` 发方法。计时器有 `schedule(任务, 首次延时ms, 周期ms)` 。有 `cancel()` 方法终止。如：

```java
import java.util.Timer;
import java.util.TimerTask;
public class ce08 {
    public static void main(String[] args) {
        Timer t = new Timer();
        t.schedule(new TimerTask() {
            public void run() {
                System.out.println("awa");
            }
        }, 500, 1000);
        try {
            Thread.sleep(5000);
        } catch (Exception e) {
            e.printStackTrace();
        }
        t.cancel();
    }
}
```

##### Callable

[参考](https://blog.csdn.net/qq_40378795/article/details/124806102), [更好的参考](https://blog.csdn.net/oLevin/article/details/16808901?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EESLANDING%7Edefault-2-16808901-blog-124806102.pc_relevant_landingrelevant&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EESLANDING%7Edefault-2-16808901-blog-124806102.pc_relevant_landingrelevant&utm_relevant_index=5)

```java
import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

class TestCallable implements Callable<Boolean> {
    private int id;

    public TestCallable(int id) {
        this.id = id;
    }

    @Override
    public Boolean call() throws Exception {
        for (int i = 0; i < 2; ++i) {
            System.out.println("id=" + id + ",i=" + i);
        }
        return true;
    }
}

public class t09 {
    public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        ArrayList<Future<Boolean>> res = new ArrayList<>();
        for (int i = 0; i < 5; ++i) {
            res.add(exec.submit(new TestCallable(i)));
        }
        for(Future<Boolean> fs : res) {
            if(fs.isDone()) {
                try {
                    System.out.println(fs.get());
                } catch (InterruptedException | ExecutionException e) {
                    e.printStackTrace();
                }
            }else {
                System.out.println("Future is not complete");
            }
        }
        exec.shutdown();
    }
}
```

另一种思路：

1. 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，且该call()方法有返回值。然后再创建Callable实现类的实例。
2. 使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
3. 使用FutureTask对象作为Thread对象的target创建并启动新线程。
4. 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值



#### 生命周期

有七种状态：出生、就绪、运行、等待、休眠、阻塞、死亡

> 新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）和死亡（Dead）

1. 出生：实例被创建，但被 `start` 之前

   > 当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体

2. 就绪：(可执行状态)，调用 `start` 后从出生到就绪；就绪得到系统资源后进入执行，跑方法 `run`

   > Java虚拟机会为其创建方法调用栈和程序计数器

3. 执行：跑当前的线程的代码 `run` (不管跑了多少)，时间片结束后返回就绪状态

   > 计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象

4. 等待：调用 `wait` 时进入，不再执行；使用 `notify` 或 `notifyAll` 唤醒

5. 休眠：调用 `sleep`

6. 阻塞：线程在运行状态发出输入/输出请求进入；输入/输出结束返回就绪

   > 采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务。当该时间段用完后，系统就会剥夺该线程所占用的资源

7. 死亡：`run` 方法执行结束；也可以通过外部 `interrupt` 使其死亡

![img](img/B6700F052B8C52C28D140E41896513FE.png)

三种导致死亡的方法里，stop 容易引起死锁，不建议使用。



##### 优先级

多个线程都在就绪状态时，优先级高的更快进入运行状态，低优先级优先进入的概率低(如垃圾回收机制是低优先级)。不保证一定是按优先级。

常量：

- `Thread.MIN_PRIORITY` 常数 1
- `Thread.MAX_PRIORITY` 常数 10
- `Thread.NORM_PRIORITY` 常数 5

取值范围是 `[Thread.MIN_PRIORITY, Thread.MAX_PRIORITY]` ，越界产生 `IllegalArgumentException`

设置方法： `setPriority()`

如：

```java
public class c1714 {
    private class thr extends Thread {
        public void run() {
            for (int i = 0; i < 3; ++i) {
                System.out.println(getName() + " " + i);
            }
        }
    }

    public c1714() {
        for (int i = 1; i <= 3; ++i) {
            thr x = new thr();
            x.setPriority(i);
            x.start();
        }
    }

    public static void main(String[] args) {
        new c1714();
    }
}

```





##### sleep

参数是整型，毫秒

参数是不准的，实际休眠时间在预期上下波动)，需要 `try` 才能执行 `sleep` (可能抛出 `InterruptedException`

##### join

强行规定先后顺序，使得被 `join`线程先执行完毕再让其他线程(如 `main`)跑。启动子线程后，立即调用该线程的join()方法，则主线程必须等待子线程执行完成后再执行.如：

```c++
public class c1806 extends Thread {
    static public int x = 0;

    public void run() {
      
        for (int i = 0; i < 100; ++i) {
            ++x;
        }
        System.out.println(getName() + " " + x);
    }

    public static void main(String[] args) {
        c1806 a = new c1806();
        c1806 b = new c1806();
        a.start();
        try {
            a.join();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(x);
        b.start();
        try {
            b.join();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(x);
    }
}

```

注： `a,b` 都 `start` ，再 `join` ，先 `start` 的先执行；之后的若干时间片里，在无线程锁下， `a,b` 同优先级，先后顺序不一定

```java
public class c1708 {
    public c1708() {
        Thread thr1 = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i < 5; ++i) {
                    try {
                        System.out.println(Thread.currentThread().getName() + " " + i);
                        Thread.sleep(100);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        thr1.start();
        new Thread(new Runnable() {
            public void run() {
                try {
                    thr1.join();
                    for (int i = 0; i < 3; ++i) {
                        System.out.println(Thread.currentThread().getName() + " " + i);
                        Thread.sleep(100);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
        System.out.println("Done.");
    }

    public static void main(String[] args) {
        new c1708();
    }
}

```



##### interrupted

终止一个线程。有 `throws InterruptedException`

如：

```java
public class c1709 {
    public c1709() {
        Thread thr = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    try {
                        Thread.sleep(100);
                        System.out.println("Running");
                    } catch (InterruptedException e) {
                        System.out.println("Bye");
                        break;
                    }
                }
            }
        });
        thr.start();
        try {
            Thread.sleep(580);
        } catch (Exception e) {
            e.printStackTrace();
        }
        thr.interrupt();
        System.out.println("awa");
    }

    public static void main(String[] args) {
        new c1709();
    }
}

```



##### wait

由任意对象触发，需要用同步块同步它自己。需要 try catch 。同步锁要跟被触发对象一致。建议用一个普通 object

##### notify

由被 wait 的对象触发，需要同步块。不需要 try catch。只唤醒第一个 wait 的线程。

例如：

```java
public class c1711 {
    private Thread thr = null;
    public c1711() {
        thr = new Thread(new Runnable() {
            public void run() {
                synchronized (thr) {
                    System.out.println("awa");
                    try {
                        thr.wait();
                        System.out.println("qwq");
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        thr.start();
        try {
            Thread.sleep(300);
        } catch (Exception e) {
            e.printStackTrace();
        }
        synchronized (thr) {
            thr.notify();
        }
        System.out.println("=w=");
    }

    public static void main(String[] args) {
        new c1711();
    }
}

```

##### notifyAll

唤醒同一个 wait 的所有线程。

```java
public class c1712 {
    final static Object sth = new Object(), sth2 = new Object();

    private class thr extends Thread {
        public void run() {
            synchronized (sth) {
                System.out.println(getName() + " started");
                try {
                    sth.wait();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                System.out.println(getName() + " finished");
            }
        }
    }

    public c1712() {
        new thr().start();
        new thr().start();
        new Thread(new Runnable() {
            public void run() {
                synchronized (sth2) {
                    System.out.println("ano started");
                    try {
                        sth2.wait();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    System.out.println("ano finished");//never await
                }
            }
        }).start();
        try {
            Thread.sleep(300);
        } catch (Exception e) {
            e.printStackTrace();
        }
        synchronized (sth) {
            sth.notifyAll();
        }
    }

    public static void main(String[] args) {
        new c1712();
    }
}

```

##### yield

提醒当前线程将资源礼让给其他线程，不保证一定会礼让。同样优先级的线程会有可执行状态的机会。成功礼让会进入就绪状态。对支持多任务的操作系统来说，不需要调用，因为会为线程自动分配时间片来执行。

如：

```java
public class c1713 {
    private class thr extends Thread {
        public void run() {
            for (int i = 0; i < 5; ++i) {
                System.out.println(getName() + " " + i);
                yield();
            }
        }
    }

    public c1713() {
        new thr().start();
        new thr().start();
        new thr().start();
    }

    public static void main(String[] args) {
        new c1713();
    }
}

```





#### 方法

Thread类常用构造方法：

- Thread()
- Thread(String name)
- Thread(Runnable target)
- Thread(Runnable target, String name)

*其中，参数 name为线程名，参数 target为包含线程体的目标对象。*

Thread类常用静态方法：

- currentThread()：返回当前正在执行的线程；
- interrupted()：返回当前执行的线程是否已经被中断；
- sleep(long millis)：使当前执行的线程睡眠多少毫秒数；
- yield()：使当前执行的线程自愿暂时放弃对处理器的使用权并允许其他线程执行；

Thread类常用实例方法：

- getId()：返回该线程的id；

- getName()：返回该线程的名字；

- getPriority()：返回该线程的优先级；

- interrupt()：使该线程中断；

- isInterrupted()：返回该线程是否被中断；

- isAlive()：返回该线程是否处于活动状态；

- isDaemon()：返回该线程是否是守护线程；

- setDaemon(boolean on)：将该线程标记为守护线程或用户线程，如果不标记默认是非守护线程；

  通过调用线程对象的 setDaemon(true) 方法将一个线程设置为守护线程。在主线程结束后，守护线程也会自动结束

- setName(String name)：设置该线程的名字；

- setPriority(int newPriority)：改变该线程的优先级；

- join()：等待该线程终止；

- join(long millis)：等待该线程终止,至多等待多少毫秒数。



```c++
public class c1805 extends Thread {

    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName());
        c1805 a = new c1805();
        a.run();
        a.start();
        // a.start(); error
        a.run();
    }

    public void run() {
       System.out.println(Thread.currentThread().getName());
    }
}
```

高并发 三要素：原子性、可见性、有序性

> 所谓生产者-消费者问题，实际上主要是包含了两类线程。一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库。生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为。而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。但是，这个共享数据区域中应该具备这样的线程间并发协作的功能：
>
> 1. 如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；
> 2. 如果共享数据区为空的话，阻塞消费者继续消费数据。
>
> 在Java语言中，实现生产者消费者问题时，可以采用三种方式：
>
> 1. 使用 Object 的 wait/notify 的消息通知机制；
> 2. 使用 Lock 的 Condition 的 await/signal 的消息通知机制；
> 3. 使用 BlockingQueue 实现。



#### 线程池

##### 概述

> [参考文献](https://www.cnblogs.com/dolphin0520/p/3932921.html)

> 系统启动一个新线程的成本是比较高的，因为它涉及与操作系统交互。在这种情形下，使用线程池可以很好地提高性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。
>
> 与数据库连接池类似的是，线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会启动一个空闲的线程来执行它们的run()或call()方法，当run()或call()方法执行结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个Runnable对象的run()或call()方法。
>
> 工作原理：
>
> ![img](img/70D6B0404AB5E9C7AF6699C94B4766BF.png)

当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：

1. AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。
2. DiscardPolicy：也是丢弃任务，但是不抛出异常。
3. DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复该过程）。
4. CallerRunsPolicy：由调用线程处理该任务。

线程池主要有如下6个参数：(构造有更详细讲解)

1. corePoolSize（核心工作线程数）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时。
2. maximumPoolSize（最大线程数）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。
3. keepAliveTime（多余线程存活时间）：当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。
4. workQueue（队列）：用于传输和保存等待执行任务的阻塞队列。
5. threadFactory（线程创建工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。
6. handler（拒绝策略）：当线程池和队列都满了，再加入线程会执行此策略



##### 构造

从Java 5开始，Java内建支持线程池。Java 5新增了一个Executors工厂类来产生线程池，该工厂类包含如下几个静态工厂方法来创建线程池。创建出来的线程池，都是通过ThreadPoolExecutor类来实现的。

- newCachedThreadPool()：创建一个具有缓存功能的线程池，系统根据需要创建线程，这些线程将会被缓存在线程池中。
- newFixedThreadPool(int nThreads)：创建一个可重用的、具有固定线程数的线程池。
- newSingleThreadExecutor()：创建一个只有单线程的线程池，它相当于调用newFixedThreadPool()方法时传入参数为1。
- newScheduledThreadPool(int corePoolSize)：创建具有指定线程数的线程池，它可以在指定延迟后执行线程任务。corePoolSize指池中所保存的线程数，即使线程是空闲的也被保存在线程池内。
- newSingleThreadScheduledExecutor()：创建只有一个线程的线程池，它可以在指定延迟后执行线程任务。
- ExecutorService newWorkStealingPool(int parallelism)：创建持有足够的线程的线程池来支持给定的并行级别，该方法还会使用多个队列来减少竞争。
- ExecutorService newWorkStealingPool()：该方法是前一个方法的简化版本。如果当前机器有4个CPU，则目标并行级别被设置为4，也就是相当于为前一个方法传入4作为参数。

`ThreadPoolExecutor` 类，管理多个线程，构造函数如下：

- `ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)`
- `ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory)`
- `ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler)`
- `ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)`

参数含义：

- `corePoolSize` 核心池大小

  默认情况下线程池没有任何线程，有任务时创建且执行任务

  若调用了`prestartAllCoreThreads()`或`prestartCoreThread()`，没有任务前就创建 `corePoolSize` 个线程

  默认创建线程池里线程数为 $0$ ，有任务后创建线程执行任务，池中线程数目达到 `corePoolSize` 后把到达的任务放到缓存队列中

- `maximumPoolSize` 线程池最大线程数

- `keepAliveTime` 线程没有任务执行时最久多久会终止，默认线程池中线程数大于 `corePoolSize` 时才起作用，若一个线程空闲时间达到了这个值就终止

  若调用了 `allowCoreThreadTimeOut(boolean)` 方法，池中线程数不大于 `corePoolSize` 时也会起作用

- `unit` 是上一个参数的时间单位，有：

  1. `TimeUnit.DAYS`
  2. `TimeUnit.HOURS`
  3. `TimeUnit.MINUTES`
  4. `TimeUnit.SECONDS`
  5. `TimeUnit.MILISECONDS `  毫秒($10^{-3}$)
  6. `TimeUnit.MICROSECONDS`  微秒($10^{-6}$)
  7. `TimeUnit.NANOSECONDS`

- `workQueue` 阻塞队列，存储等待执行的任务，可选：

  1. `ArrayBlockingQueue` 较少使用，必须指定大小
  2. `PriorityBlockingQueue ` 较少使用
  3. `LinkedBlockingQueue` 默认大小为`Integer.MAX_value`
  4. `SynchronousQueue` 不保存提交的任务，直接新建一个线程执行新来的任务

- `threadFactory` 线程工厂，主要用于创建线程

- `handler` 拒绝处理任务的策略

  1. `ThreadPoolExecutor.AbortPolicy`:丢弃任务并抛出`RejectedExecutionException`异常。 
  2. `ThreadPoolExecutor.DiscardPolicy`：也是丢弃任务，但是不抛出异常。 
  3. `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
  4. `ThreadPoolExecutor.CallerRunsPolicy`：由调用线程处理该任务 



##### 常用方法

> `ThreadPoolExecutor` 继承自 `AbstractExecutorService` 类。`AbstractExecutorService` 实现了 `ExecutorService` 接口。而 `ExecutorService` 继承了 `Executor` 接口。
>
> `Executor` 只有 `execute(Runnable)` 方法。
>
> `ExecutorService` 有 `submit, invokeAll, invokeAny, shutDown` 等方法。 ($invoke$ 调用)

`ThreadPoolExecutor` 的方法：

- `execute()` 向线程池提交一个任务给线程池执行
- `submit()` 调用`execute`执行，并用`Future`获取任务执行的结果
- `shutdown()` 关闭线程池接收
- `shotdownNow()`   强制关闭线程池
- `getQueue() ` 取缓存队列
- `getPoolSize()`  当前线程数目
- `getActiveCount() `
- `getCompletedTaskCount()`  已执行完的任务数目



##### 线程池状态

线程池一共有五种状态, 分别是：

1. RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务。
2. SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。
3. STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。
4. TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。
5. TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。进入TERMINATED的条件如下：
   - 线程池不是RUNNING状态；
   - 线程池状态不是TIDYING状态或TERMINATED状态；
   - 如果线程池状态是SHUTDOWN并且workerQueue为空；
   - workerCount为0；
   - 设置TIDYING状态成功。

![img](img/B9BDBBE80CB68358A7FE417961EDC122.png)

定义了一个 `volatile` 整型变量，名为 `runState` ，几个常量代表状态：

- `RUNNING` $0$ ，创建线程池后初始时
- `SHUTDOWN` $1$ ，调用了 `showdown` 方法后进入该状态，此时不接受新任务并等待所有任务执行完毕
- `STOP` $2$ ，调用 `shutdownNow` 方法进入，不接受新任务且尝试终止正在执行的任务
- `TERMINATED` $3$ ，处于 $1,2$ 之一且所有工作线程销毁，且任务缓存队列已清空或执行结束后进入



##### 任务执行

有 `corePoolSize`、`maximumPoolSize`、`largestPoolSize` ，大体区别如下：

- `corePoolSize` 是通常并发线程数
- `maximumPoolSize` 是允许的最大并发线程数
- `largestPoolSize` 是历史出现过的最大并发线程数

`Worker` 类是实现了 `Runnable` 的类，用于执行线程任务。

执行任务的步骤：

- 若当前线程池线程数目小于 `corePoolSize` ，每来一个任务创建一个线程执行它
- 若池中线程数目大于等于 `corePoolSize` ，尝试将任务添加到任务缓存队列，添加成功后等待空闲线程将其取出；添加失败(通常是缓存队列满了)则创建新线程执行这个任务
- 若池中线程数目到达 `maximumPoolSize` ，使用参数的拒绝策略进行处理
- 若池中线程数大于 `corePoolSize` 且某线程空闲时间超过 `keepAliveTime` ，被终止直到线程数目不大于 `corePoolSize` 。若允许核心池线程设置存活时间，那么核心池线程空闲时间超过时也会被终止



##### 线程初始化

- `prestartCoreThread()` 初始化一个核心线程
- `prestartAllCoreThreads()` 初始化所有



##### 动态调整

- `setCorePoolSize` 设置核心池大小
- `setMaximumPoolSize` 设置线程池最大能创建的线程数目大小

参数增大时，进行线程赋值并可能立刻创建新的线程执行任务



##### 标配线程池

构造方法：

1. `Executors.newCachedThreadPool()` 创建一个缓冲池，缓冲池容量大小为`Integer.MAX_VALUE`
2. `Executors.newSingleThreadExecutor()` 容量为 $1$ 缓冲池
3. `Executors.newFixedThreadPool(int)`  固定大小缓冲池

> 等效代码：
>
> ```java
> public static ExecutorService newFixedThreadPool(int nThreads) {
>     return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
> }
> public static ExecutorService newSingleThreadExecutor() {
>     return new FinalizableDelegatedExecutorService
>         (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()));
> }
> public static ExecutorService newCachedThreadPool() {
>     return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
> }
> ```
>



##### 配置建议

根据任务类型配置线程池大小：

- CPU 密集型任务：参考值为 $N_{CPU}+1$
- IO 密集型任务：参考值为 $2N_{CPU}$

具体根据运行情况、系统负载、资源利用率适当调整

> 建议：
>
> 1. CPU密集型任务
>
>    尽量使用较小的线程池，一般为CPU核心数+1。 因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。
>
> 2. IO密集型任务
>
>    可以使用稍大的线程池，一般为2CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。
>
> 3. 混合型任务
>
>    可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。因为如果划分之后两个任务执行时间有数据级的差距，那么拆分没有意义。因为先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。



##### 线程工厂

`import java.util.concurrent.ThreadFactory`

可以自定义，需要实现 `ThreadFactory` 接口，实现如下方法：

```java
public Thread newThread(Runnable r)
```



通常可以做的事情：

```java
Thread t = new Thread(传入的Runnable);
t.setPriority(Thread.NORM_PRIORITY);//强转原优先级
t.setDaemon(false); //非守护线程
```



##### 阻塞策略

`import java.util.concurrent.*`

自定义阻塞策略，实现接口 `RejectedExecutionHandler` ，方法：

```java
public void rejectedExecution(Runnable r, ThreadPoolExecutor executor)
```



参考：

```java
if(!executor.isShutdown()) {
    try{ 
        Thread.sleep(10);//稍等后再尝试加入队尾
        executor.getQueue().poll();//失败则继续
        executor.execute(runnable);//成功就放入
    }catch(Exception e){
        e.printStackTrace();
    }
}
```



##### 举例

###### 创建和使用线程池

> 可能有原理错误之处

```java
package Lab11;

// import java.util.Scanner;
import java.util.concurrent.*;

public class Lab11_2 {
    private static final int num_thr = 10000;

    private class thr extends Thread {
        private static final int ie = 400;

        public void run() {// do sth for a while of time
            double x = Math.random();
            for (int i = 0; i < ie; ++i) {
                x += Math.random();
            }
            synchronized ("") {// or use atomic
                ++cnt;
                // System.out.println(cnt);
                if (cnt == num_thr) {
                    timeprint();
                    f2();
                } else if (cnt == 2 * num_thr) {
                    timeprint();
                    f3();
                } else if (cnt == 3 * num_thr) {
                    timeprint();
                    f4();
                } else if (cnt == 4 * num_thr) {
                    timeprint();
                }
            }
            // System.out.println(getName());
            // f2();
            // System.out.println("1");
            // } else if (++cnt == 2 * num_thr) {
            // timeprint();
            // }
        }
    }

    private long curtime1, curtime2;
    public int cnt = 0;

    private void timeset() {
        curtime1 = System.currentTimeMillis();
    }

    private void timeprint() {
        curtime2 = System.currentTimeMillis();
        System.out.println("Time used: " + (curtime2 - curtime1) + " ms");
    }

    public void f1() {
        System.out.println("SingleThreadExecutor");
        timeset();
        ExecutorService single = Executors.newSingleThreadExecutor();
        for (int i = 0; i < num_thr; ++i) {
            single.execute(new thr());
        }
        single.shutdown();
    }

    public void f2() {
        System.out.println("FixedThreadPool (param 10)");
        timeset();
        ExecutorService fixed = Executors.newFixedThreadPool(10);
        // the param more, the slower
        for (int i = 0; i < num_thr; ++i) {
            fixed.execute(new thr());
        }
        fixed.shutdown();
    }

    public void f3() {
        System.out.println("ScheduledThreadPool (param 1 1ms)");
        timeset();
        ScheduledExecutorService cyc = Executors.newScheduledThreadPool(1);
        for (int i = 0; i < num_thr; ++i) {
            cyc.schedule(new thr(), 1, TimeUnit.MILLISECONDS);
        }
        cyc.shutdown();
    }

    public void f4() {
        System.out.println("CachedThreadPool");
        timeset();
        // ExecutorService cach = Executors.newCachedThreadPool();
        ExecutorService cach = new ThreadPoolExecutor(0, 10010, 1L, TimeUnit.MILLISECONDS,
                new SynchronousQueue<Runnable>());
        for (int i = 0; i < num_thr; ++i) {
            cach.execute(new thr());
        }
        cach.shutdown();
    }

    public Lab11_2() {
        f1();
        // int cmd;
        // Scanner sc = new Scanner(System.in);
        // System.out.println("to test SingleThreadExecutor, input 1.");
        // System.out.println("to test FixedThreadPool, input 2.");
        // System.out.print("please input number:");
        // cmd = sc.nextInt();
        // if (cmd == 1) {
        // f1();
        // } else if (cmd == 2) {
        // f2();
        // }
    }

    public static void main(String[] args) {
        new Lab11_2();
    }
}

// Thread x1 = new Thread(new Runnable() {
// public void run() {
// timeset();
// ExecutorService single = Executors.newSingleThreadExecutor();
// for (int i = 0; i < num_thr; ++i) {
// single.execute(new thr());
// }
// single.shutdown();
// }
// });
// x1.start();
// try {
// x1.join();
// } catch (Exception e) {
// e.printStackTrace();
// }
```



###### 自定义线程工厂和阻塞策略

```java
package Lab11;

import java.util.concurrent.*;

public class Lab11_3 {
    private class mthreadfactory implements ThreadFactory {
        private int cnt = 0;

        public Thread newThread(Runnable r) {
            System.out.println("summon " + (++cnt));
            Thread thr = new Thread(r);
            thr.setName(Integer.toString(cnt));
            return thr;
        }
    }

    private int cnt2 = 0;

    private class thr extends Thread {

        public thr() {
            setName(Integer.toString(++cnt2));
        }

        public void run() {
            try {
                System.out.println("running " + getName());
                sleep(300);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private static final int testnum = 10;
    private int sucnum = 0, failnum = 0;
    ThreadPoolExecutor tp1, tp2;

    private void f1() {
        // 测试1：自定义线程工厂(默认策略 队列满了丢任务抛出异常)
        BlockingQueue<Runnable> workqueue = new ArrayBlockingQueue<>(5);
        tp1 = new ThreadPoolExecutor(2, 2, 1, TimeUnit.MINUTES, workqueue,
                new mthreadfactory(), new ThreadPoolExecutor.AbortPolicy());
        try {
            for (int i = 1; i <= testnum; ++i) {
                tp1.execute(new thr());
                ++sucnum;
            }
        } catch (Exception e) {
            System.out.println("Queue is full.");
        }
        tp1.shutdown();
        /*
         * 测试结果：
         * 丢弃任务抛出异常；由于队列长为5，一开始两个核心线程跑了2个任务
         * 然后5个任务入队，此时队满，再无法入队，所以阻塞策略类抛出异常
         */
    }

    // 阻塞执行条件：线程数目到达maximumPoolSize
    private class mreject implements RejectedExecutionHandler {
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            System.out.println("now reach reject part");
            synchronized ("") {
                ++failnum; // 不知为何--sucnum会出错
            }
        }
    }

    private void f2() {
        // 测试二：自定义阻塞策略类：策略为直接忽略该任务，并自减添加成功数
        BlockingQueue<Runnable> workqueue = new ArrayBlockingQueue<>(5);
        tp2 = new ThreadPoolExecutor(2, 2, 1, TimeUnit.MINUTES, workqueue,
                new mthreadfactory(), new mreject());
        sucnum = 0;
        cnt2 = 0;
        for (int i = 1; i <= testnum; ++i) {
            tp2.execute(new thr());
            ++sucnum;
        }
        tp2.shutdown();
    }

    public Lab11_3() {
        new Thread(new Runnable() {// 该线程用于使得总流程先执行f1再执行f2
            public void run() {
                f1();
                while (true) {
                    try {
                        if (tp1.getCompletedTaskCount() == sucnum) {
                            System.out.println("done f1");
                            f2();
                        }
                        if (tp2 != null && tp2.getCompletedTaskCount() == sucnum - failnum) {
                            System.out.println("done f2");
                            break;
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }

    public static void main(String[] args) {
        new Lab11_3();
    }
}

```



#### 同步

1. 同步方法

   即有synchronized关键字修饰的方法，由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。需要注意， synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。

2. 同步代码块

   即有synchronized关键字修饰的语句块，被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。需值得注意的是，同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

3. ReentrantLock

   Java 5新增了一个java.util.concurrent包来支持同步，其中ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。需要注意的是，ReentrantLock还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，因此不推荐使用。

4. volatile

   volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值。需要注意的是，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。

5. 原子变量

   在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。例如AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中（如以原子方式增加的计数器），但不能用于替换Integer。可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。

> 1. synchronized是Java关键字，在JVM层面实现加锁和解锁；Lock是一个接口，在代码层面实现加锁和解锁。
> 2. synchronized可以用在代码块上、方法上；Lock只能写在代码里。
> 3. synchronized在代码执行完或出现异常时自动释放锁；Lock不会自动释放锁，需要在finally中显示释放锁。
> 4. synchronized会导致线程拿不到锁一直等待；Lock可以设置获取锁失败的超时时间。
> 5. synchronized无法得知是否获取锁成功；Lock则可以通过tryLock得知加锁是否成功。
> 6. synchronized锁可重入、不可中断、非公平；Lock锁可重入、可中断、可公平/不公平，并可以细分读写锁以提高效率。
>
> 可重入锁,指的是以线程为单位,当一个线程获取对象*锁*之后,这个线程可以再次获取本对象上的*锁*,而其他的线程是不可以的
>
> 如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁

保证线程安全：

1. synchronized

2. lock

3. volatile

4. 原子变量

5. 本地存储

   可以通过ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。

6. 不可变的

   只要一个不可变的对象被正确地构建出来，那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态，“不可变”带来的安全性是最直接、最纯粹的。Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。String类是一个典型的不可变类，可以参考它设计一个不可变类

> ThreadLocal顾名思义是线程私有的局部变量存储容器，可以理解成每个线程都有自己专属的存储容器，它用来存储线程私有变量，其实它只是一个外壳，内部真正存取是一个Map。每个线程可以通过set()和get()存取变量，多线程间无法访问各自的局部变量，相当于在每个线程间建立了一个隔板。只要线程处于活动状态，它所对应的ThreadLocal实例就是可访问的，线程被终止后，它的所有实例将被垃圾收集。
>
> ThreadLocal经典的使用场景是为每个线程分配一个 JDBC 连接 Connection，这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection。 另外ThreadLocal还经常用于管理Session会话，将Session保存在ThreadLocal中，使线程处理多次处理会话时始终是同一个Session。
>
> Thread类中有个变量threadLocals，它的类型为ThreadLocal中的一个内部类ThreadLocalMap，这个类没有实现map接口，就是一个普通的Java类，但是实现的类似map的功能。每个线程都有自己的一个map，map是一个数组的数据结构存储数据，每个元素是一个Entry，entry的key是ThreadLocal的引用，也就是当前变量的副本，value就是set的值。
>
> ThreadLocal中的hash code非常简单，就是调用AtomicInteger的getAndAdd方法，参数是个固定值0x61c88647。上面说过ThreadLocalMap的结构非常简单只用一个数组存储，并没有链表结构，当出现Hash冲突时采用线性查找的方式，所谓线性查找，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。如果产生多次hash冲突，处理起来就没有HashMap的效率高，为了避免哈希冲突，使用尽量少的threadlocal变量。



在Java中线程通信主要有以下三种方式：

1. wait()、notify()、notifyAll()

   如果线程之间采用synchronized来保证线程安全，则可以利用wait()、notify()、notifyAll()来实现线程通信。这三个方法都不是Thread类中所声明的方法，而是Object类中声明的方法。原因是每个对象都拥有锁，所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作。并且因为当前线程可能会等待多个线程的锁，如果通过线程来操作，就非常复杂了。另外，这三个方法都是本地方法，并且被final修饰，无法被重写。

   wait()方法可以让当前线程释放对象锁并进入阻塞状态。notify()方法用于唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。notifyAll()用于唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。

   每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了已就绪（将要竞争锁）的线程，阻塞队列存储了被阻塞的线程。当一个阻塞线程被唤醒后，才会进入就绪队列，进而等待CPU的调度。反之，当一个线程被wait后，就会进入阻塞队列，等待被唤醒。

2. await()、signal()、signalAll()

   如果线程之间采用Lock来保证线程安全，则可以利用await()、signal()、signalAll()来实现线程通信。这三个方法都是Condition接口中的方法，该接口是在Java 1.5中出现的，它用来替代传统的wait+notify实现线程间的协作，它的使用依赖于 Lock。相比使用wait+notify，使用Condition的await+signal这种方式能够更加安全和高效地实现线程间协作。

   Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() 。 必须要注意的是，Condition 的 await()/signal()/signalAll() 使用都必须在lock保护之内，也就是说，必须在lock.lock()和lock.unlock之间才可以使用。事实上，await()/signal()/signalAll() 与 wait()/notify()/notifyAll()有着天然的对应关系。即：Conditon中的await()对应Object的wait()，Condition中的signal()对应Object的notify()，Condition中的signalAll()对应Object的notifyAll()。

3. BlockingQueue

   Java 5提供了一个BlockingQueue接口，虽然BlockingQueue也是Queue的子接口，但它的主要用途并不是作为容器，而是作为线程通信的工具。BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue中取出元素时，如果该队列已空，则该线程被阻塞。

   程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。线程之间需要通信，最经典的场景就是生产者与消费者模型，而BlockingQueue就是针对该模型提供的解决方案。

> 1. sleep()是Thread类中的静态方法，而wait()是Object类中的成员方法；
> 2. sleep()可以在任何地方使用，而wait()只能在同步方法或同步代码块中使用；
> 3. sleep()不会释放锁，而wait()会释放锁，并需要通过notify()/notifyAll()重新获取锁。



JUC是java.util.concurrent的缩写，该包参考自EDU.oswego.cs.dl.util.concurrent，是JSR 166标准规范的一个实现。JSR 166是一个关于Java并发编程的规范提案，在JDK中该规范由java.util.concurrent包实现。即JUC是Java提供的并发包，其中包含了一些并发编程用到的基础组件。

JUC这个包下的类基本上包含了我们在并发编程时用到的一些工具，大致可以分为以下几类：

- 原子更新

  Java从JDK1.5开始提供了java.util.concurrent.atomic包，方便程序员在多线程环 境下，无锁的进行原子操作。在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新 数组，原子更新引用和原子更新字段。

- 锁和条件变量

  java.util.concurrent.locks包下包含了同步器的框架 AbstractQueuedSynchronizer，基于AQS构建的Lock以及与Lock配合可以实现等待/通知模式的Condition。JUC 下的大多数工具类用到了Lock和Condition来实现并发。

- 线程池

  涉及到的类比如：Executor、Executors、ThreadPoolExector、 AbstractExecutorService、Future、Callable、ScheduledThreadPoolExecutor等等。

- 阻塞队列

  涉及到的类比如：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque等等。

- 并发容器

  涉及到的类比如：ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、CopyOnWriteArraySet等等。

- 同步器

  剩下的是一些在并发编程中时常会用到的工具类，主要用来协助线程同步。比如：CountDownLatch、CyclicBarrier、Exchanger、Semaphore、FutureTask等等



抽象队列同步器AbstractQueuedSynchronizer （以下都简称AQS），是用来构建锁或者其他同步组件的骨架类，减少了各功能组件实现的代码量，也解决了在实现同步器时涉及的大量细节问题，例如等待线程采用FIFO队列操作的顺序。在不同的同步器中还可以定义一些灵活的标准来判断某个线程是应该通过还是等待。

AQS采用模板方法模式，子类只需要实现特定的几个方法（不是抽象方法），就可以实现子类自己的需求。

基于AQS实现的组件，诸如：

- ReentrantLock 可重入锁（支持公平和非公平的方式获取锁）；
- Semaphore 计数信号量;
- ReentrantReadWriteLock 读写锁

AQS内部维护了一个int成员变量来表示同步状态，通过内置的FIFO(first-in-first-out)同步队列来控制获取共享资源的线程。

- 同步状态（state）的维护管理；
- 等待队列的维护管理；
- 线程的阻塞与唤醒

通过AQS内部维护的int型的state，可以用于表示任意状态

- ReentrantLock用它来表示锁的持有者线程已经重复获取该锁的次数，而对于非锁的持有者线程来说，如果state大于0，意味着无法获取该锁，将该线程包装为Node，加入到同步等待队列里。
- Semaphore用它来表示剩余的许可数量，当许可数量为0时，对未获取到许可但正在努力尝试获取许可的线程来说，会进入同步等待队列，阻塞，直到一些线程释放掉持有的许可（state+1），然后争用释放掉的许可。
- FutureTask用它来表示任务的状态（未开始、运行中、完成、取消）。
- ReentrantReadWriteLock在使用时，稍微有些不同，int型state用二进制表示是32位，前16位（高位）表示为读锁，后面的16位（低位）表示为写锁。
- CountDownLatch使用state表示计数次数，state大于0，表示需要加入到同步等待队列并阻塞，直到state等于0，才会逐一唤醒等待队列里的线程。

AQS通过内置的FIFO(first-in-first-out)同步队列来控制获取共享资源的线程。CLH队列是FIFO的双端双向队列，AQS的同步机制就是依靠这个CLH队列完成的。队列的每个节点，都有前驱节点指针和后继节点指针。如下图：

![img](img/47171F86630383C48B1F7E94E85E69CC.png)

CLH队列是 Craig, Landin and Hagersten 队列的缩写, 是一种用于实现自旋锁的队列数据结构。这种队列被用来实现高效的非阻塞锁。



#### volatile

##### 内存模型

CPU 执行速度远快于内存读写速度；因此运行程序时会将数据从主存复制到 cache ，然后读 cache ，然后运算，然后写到 cache ，然后刷新到主存中

在多线程时，因为上述机制的存在，会产生缓存一致性问题，这种被多个线程访问的变量称为共享变量

硬件上的解决办法有：

- 总线加LOCK#锁，阻塞其他CPU的访问，使得只能有一个CPU使用某内存，执行完毕后解锁，缺点是效率低下
- 缓存一致性协议(如Intel MESI协议)，当CPU写数据到主存时，若是共享变量，会通知其他CPU将该变量的cache设为无效，并要用时重新读取

##### 并发编程

###### 原子性

定义：一个或多个操作，要么全部执行且执行时不被任何其他因素打断，要么全部不执行

多线程通常变量不满足原子性

###### 可见性

定义：多个线程访问同一变量时，一个线程修改了该变量，其他线程立刻可以看到修改后的值

多线程通常变量不满足可见性

###### 有序性

程序执行按照代码先后顺序

JVM 执行代码时不保证满足有序性，可能会发生指令重排序(instruction reorder)，不影响单线程结果，但影响多线程结果

并发程序的正确性需要同时满足原子性、可见性和有序性

##### Java内存模型

JVM定义了内存模型JMM(java memory model)屏蔽硬件平台和操作系统的内存访问差异，规定所有变量存在主存，线程有自己的工作内存，所有操作在其进行(不能直接对主存操作)，线程不能访问其他线程的工作内存

java只保证基本数据类型变量的读取和赋值是原子性操作，例如：

```java
x = 10; //原子性
y = x; //非原子性
x++; //非原子性
x = x + 1; //非原子性
```

> 32位平台对64位数据读取和赋值不是原子性的(但最新JDK中JMM保证也是原子性)

原子性、可见性、有序性的实现通过`synchronized`实现。

被`volatile`关键字修饰的变量保证修改的值立刻更新到主存，使得其他线程需要读取时要到主存读取，保证了可见性。

JMM保证的有序性为`happens-before`原则(先行发生原则)，有：

- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 (但仍会发生指令重排序)
- 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

> 如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障，内存屏障会提供3个功能：

1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
2. 它会强制将对缓存的修改操作立即写入主存；
3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。



##### volatile含义

类的成员或静态成员变量被`volatile`修饰后：

- 保证可见性，一个线程修改值后新值对其他线程立刻可见

  当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，这个写会操作会导致其他线程中的volatile变量缓存无效

- 禁止进行指令重排序

  - 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行；
  - 在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

  即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见

例如下面代码有小概率会死循环：

```java
//线程1
boolean stop = false;
while(!stop){
    doSomething();
}
 
//线程2
stop = true;
```

可以使用 volatile 关键字保证正确读取。

但 volatile 不保证原子性，因为运算操作符并非原子操作，需要保证原子性可以使用下面三种方法之一：

1. synchronized
2. Lock 
3. `AtomicInteger`

代码依次为：

```java
public class Test {
    public  int inc = 0;
    
    public synchronized void increase() {
        inc++;
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i<10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j<1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()>1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
```

```java
public class Test {
    public  int inc = 0;
    Lock lock = new ReentrantLock();
    
    public  void increase() {
        lock.lock();
        try {
            inc++;
        } finally{
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i<10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j<1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()>1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
```

```java
public class Test {
    public  AtomicInteger inc = new AtomicInteger();
     
    public  void increase() {
        inc.getAndIncrement();
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i<10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j<1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()>1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
//java.util.concurrent.atomic
```



常用应用场合：

- 写操作不依赖于当前值
- 该变量没有包含在具体其他变量的不变式里



#### 原子类

满足原子性的类。相比普通的锁，粒度更细，效率更高(高度竞争除外)

`import java.util.concurrent.atomic.AtomicInteger;`

创建：

```java
AtomicInteger x = new AtomicInteger(值);
```

自增：`.incrementAndGet()`

输出：syso即可。

更多方法参见tab键补全



把普通变量升为原子变量：

`AtomicIntegerFieldUpdater<T>` 类

构造： `AtomicIntegerFieldUpdater.newUpdater(T.class, 成员名字String)`

或直接使用：`AtomicIntegerFieldUpdater.getAndIncrement(普通变量)`



高并发时，`LongAdder` 比原子的`AtomicLong` 操作效率更高。构造为：

```java
LongAdder x = new LongAdder();
```

增加：`.increment()`

取值：`.sum()`

赋值 `.set()`

> 高并发下计数，一般最先想到的应该是AtomicLong/AtomicInt，AtmoicXXX使用硬件级别的指令 CAS 来更新计数器的值，这样可以避免加锁，机器直接支持的指令，效率也很高。但是AtomicXXX中的 CAS 操作在出现线程竞争时，失败的线程会白白地循环一次，在并发很大的情况下，因为每次CAS都只有一个线程能成功，竞争失败的线程会非常多。失败次数越多，循环次数就越多，很多线程的CAS操作越来越接近 自旋锁（spin lock）。计数操作本来是一个很简单的操作，实际需要耗费的cpu时间应该是越少越好，AtomicXXX在高并发计数时，大量的cpu时间都浪费会在 自旋 上了，这很浪费，也降低了实际的计数效率。
>
> LongAdder是jdk8新增的用于并发环境的计数器，目的是为了在高并发情况下，代替AtomicLong/AtomicInt，成为一个用于高并发情况下的高效的通用计数器。说LongAdder比在高并发时比AtomicLong更高效，这么说有什么依据呢？LongAdder是根据锁分段来实现的，它里面维护一组按需分配的计数单元，并发计数时，不同的线程可以在不同的计数单元上进行计数，这样减少了线程竞争，提高了并发效率。本质上是用空间换时间的思想，不过在实际高并发情况中消耗的空间可以忽略不计。
>
> 现在，在处理高并发计数时，应该优先使用LongAdder，而不是继续使用AtomicLong。当然，线程竞争很低的情况下进行计数，使用Atomic还是更简单更直接，并且效率稍微高一些。其他情况，比如序号生成，这种情况下需要准确的数值，全局唯一的AtomicLong才是正确的选择，此时不应该使用LongAdder。



#### synchronized

多线程共同操作共享数据(又称临界资源)，为保证同一时刻只有一个线程再操作，可以增加互斥锁

关键字 synchronized 保证在同一时刻只有一个线程可以执行某个方法/代码块，应用有：

- 修饰实例方法，作用于实例，进入同步代码前要获得当前实例的锁

  直接给方法定义时加关键字即可

- 修饰静态方法，给类对象加锁，进入前要获得当前类对象的锁

  直接给方法定义时加关键字即可

- 修饰代码块，指定加锁对象，进入前要获得特定对象的锁

> synchronized可以修饰静态方法，但不能修饰静态代码块。
>
> 当修饰静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁

保证所有具有同一把锁的线程受到锁制约，对于实例方法，需要保证实例是同一个，例如：

```java
public class AccountingSync implements Runnable{
    //共享资源(临界资源)
    static int i=0;

    /**
     * synchronized 修饰实例方法
     */
    public synchronized void increase(){
        i++;
    }
    @Override
    public void run() {
        for(int j=0;j<1000000;j++){
            increase();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        AccountingSync instance=new AccountingSync();
        Thread t1=new Thread(instance);
        Thread t2=new Thread(instance);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(i);
    }
    /**
     * 输出结果:
     * 2000000
     */
}
```

而下面是错误的：

```java
public class AccountingSyncBad implements Runnable{
    static int i=0;
    public synchronized void increase(){
        i++;
    }
    @Override
    public void run() {
        for(int j=0;j<1000000;j++){
            increase();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        //new新实例
        Thread t1=new Thread(new AccountingSyncBad());
        //new新实例
        Thread t2=new Thread(new AccountingSyncBad());
        t1.start();
        t2.start();
        //join含义:当前main线程等待t1t2线程终止之后才能输出i
        t1.join();
        t2.join();
        System.out.println(i);
    }
}
```

也可以用静态方法：

```java
public class AccountingSyncClass implements Runnable{
    static int i=0;

    /**
     * 作用于静态方法,锁是当前class对象,也就是
     * AccountingSyncClass类对应的class对象
     */
    public static synchronized void increase(){
        i++;
    }

    /**
     * 非静态,访问时锁不一样不会发生互斥
     */
    public synchronized void increase4Obj(){
        i++;
    }

    @Override
    public void run() {
        for(int j=0;j<1000000;j++){
            increase();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(new AccountingSyncClass());
        Thread t2=new Thread(new AccountingSyncClass());
        t1.start();t2.start();
        t1.join();t2.join();
        System.out.println(i);
    }
}
```

多数情况下，需要同步的只是一段代码，可以直接同步一段代码块，如：

```java
public class AccountingSync implements Runnable{
    static AccountingSync instance=new AccountingSync();
    static int i=0;
    @Override
    public void run() {
        //省略其他耗时操作....
        //使用同步代码块对变量i进行同步操作,锁对象为instance
        synchronized(instance){
            for(int j=0;j<1000000;j++){
                    i++;
              }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(instance);
        Thread t2=new Thread(instance);
        t1.start();t2.start();
        t1.join();t2.join();
        System.out.println(i);
    }
}

```

可以把同步部分放其他参数，如`xxx.class`

> 一、synchronized作用在代码块时，它的底层是通过monitorenter、monitorexit指令来实现的。
>
> - monitorenter：
>
>   每个对象都是一个监视器锁（monitor），当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：
>
>   如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1。如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。
>
> - monitorexit：
>
>   执行monitorexit的线程必须是objectref所对应的monitor持有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。
>
>   monitorexit指令出现了两次，第1次为同步正常退出释放锁，第2次为发生异步退出释放锁。
>
> 二、方法的同步并没有通过 monitorenter 和 monitorexit 指令来完成，不过相对于普通方法，其常量池中多了 ACC_SYNCHRONIZED 标示符。JVM就是根据该标示符来实现方法的同步的：
>
> 当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。
>
> 两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响



#### 锁

##### 概念

###### 阻塞

阻塞锁在线程请求资源时，如果该资源已经被其他线程占用，则请求线程会进入阻塞状态，直到资源被释放。

非阻塞锁：当线程请求锁时，如果该锁已经被其他线程占用，则请求线程会立即返回失败，而不是阻塞。这样，线程可以继续执行其他操作，而不会被阻塞

###### 悲观乐观

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。Java中悲观锁是通过synchronized关键字或Lock接口来实现的。

乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在JDK1.5 中新增 java.util.concurrent (J.U.C)就是建立在CAS之上的。相对于对于 synchronized 这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升

CAS,即Compare and Swap,是基于硬件级别的指令实现的同步原语



###### 公平

[参考](https://zhuanlan.zhihu.com/p/115543000)

公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。

- 优点：所有的线程都能得到资源，不会饿死在队列中。
- 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。

- 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
- 缺点：这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死

###### 互斥

互斥锁 mutex

在Java里面，最基本的互斥同步手段就是synchronized关键字，这是一种块结构（Block Structured）的同步语法。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference。如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。

自JDK 5起，Java类库中新提供了java.util.concurrent包（J.U.C包），其中的java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构（Non-Block Structured）来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步，这也为日后扩展出不同调度算法、不同特征、不同性能、不同语义的各种锁提供了广阔的空间。

###### 分段

在并发程序中，串行操作是会降低可伸缩性，并且上下文切换也会减低性能。在锁上发生竞争时将通水导致这两种问题，使用独占锁时保护受限资源的时候，基本上是采用串行方式—-每次只能有一个线程能访问它。所以对于可伸缩性来说最大的威胁就是独占锁。

我们一般有三种方式降低锁的竞争程度：

1. 减少锁的持有时间；
2. 降低锁的请求频率；
3. 使用带有协调机制的独占锁，这些机制允许更高的并发性。

在某些情况下我们可以将锁分解技术进一步扩展为一组独立对象上的锁进行分解，这称为分段锁。其实说的简单一点就是：容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

ConcurrentHashMap使用Segment数据结构，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。所以说，ConcurrentHashMap在并发情况下，不仅保证了线程安全，而且提高了性能。

###### 读写

与传统锁不同的是读写锁的规则是可以共享读，但只能一个写，总结起来为：读读不互斥、读写互斥、写写互斥，而一般的独占锁是：读读互斥、读写互斥、写写互斥，而场景中往往读远远大于写，读写锁就是为了这种优化而创建出来的一种机制。 注意是读远远大于写，一般情况下独占锁的效率低来源于高并发下对临界区的激烈竞争导致线程上下文切换。因此当并发不是很高的情况下，读写锁由于需要额外维护读锁的状态，可能还不如独占锁的效率高。因此需要根据实际情况选择使用。

在Java中ReadWriteLock的主要实现为ReentrantReadWriteLock，其提供了以下特性：

1. 公平性选择：支持公平与非公平（默认）的锁获取方式，吞吐量非公平优先于公平。
2. 可重入：读线程获取读锁之后可以再次获取读锁，写线程获取写锁之后可以再次获取写锁。
3. 可降级：写线程获取写锁之后，其还可以再次获取读锁，然后释放掉写锁，那么此时该线程是读锁状态，也就是降级操作。

##### ReentrantLock

ReentrantLock是基于AQS实现的，AQS即AbstractQueuedSynchronizer的缩写，这个是个内部实现了两个队列的抽象类，分别是同步队列和条件队列。其中同步队列是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而条件队列是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，AQS所做的就是管理这两个队列里面线程之间的等待状态-唤醒的工作。

在同步队列中，还存在2中模式，分别是独占模式和共享模式，这两种模式的区别就在于AQS在唤醒线程节点的时候是不是传递唤醒，这两种模式分别对应独占锁和共享锁。

AQS是一个抽象类，所以不能直接实例化，当我们需要实现一个自定义锁的时候可以去继承AQS然后重写获取锁的方式和释放锁的方式还有管理state，而ReentrantLock就是通过重写了AQS的tryAcquire和tryRelease方法实现的lock和unlock。

ReentrantLock 结构如下图所示：

<img src="img/2F192BDFAD9C22C62FE4D23692FDE892.png" alt="img" style="zoom:50%;" />

首先ReentrantLock 实现了 Lock 接口，然后有3个内部类，其中Sync内部类继承自AQS，另外的两个内部类继承自Sync，这两个类分别是用来公平锁和非公平锁的。通过Sync重写的方法tryAcquire、tryRelease可以知道，ReentrantLock实现的是AQS的独占模式，也就是独占锁，这个锁是悲观锁。

在Java中实现锁的方式有两种，一种是使用Java自带的关键字synchronized对相应的类或者方法以及代码块进行加锁，另一种是ReentrantLock，前者只能是非公平锁，而后者是默认非公平但可实现公平的一把锁。

ReentrantLock是基于其内部类FairSync(公平锁)和NonFairSync(非公平锁)实现的，并且它的实现依赖于Java同步器框架AbstractQueuedSynchronizer（AQS），AQS使用一个整形的volatile变量state来维护同步状态，这个volatile变量是实现ReentrantLock的关键

![img](img/A72631473CC01A899A1A693A35194C44.jpeg)

ReentrantLock 的公平锁和非公平锁都委托了 `AbstractQueuedSynchronizer#acquire` 去请求获取。

- tryAcquire 是一个抽象方法，是公平与非公平的实现原理所在。
- addWaiter 是将当前线程结点加入等待队列之中。公平锁在锁释放后会严格按照等到队列去取后续值，而非公平锁在对于新晋线程有很大优势。
- acquireQueued 在多次循环中尝试获取到锁或者将当前线程阻塞。
- selfInterrupt 如果线程在阻塞期间发生了中断，调用 Thread.currentThread().interrupt() 中断当前线程。

公平锁和非公平锁在说的获取上都使用到了 volatile 关键字修饰的state字段， 这是保证多线程环境下锁的获取与否的核心。但是当并发情况下多个线程都读取到 state == 0时，则必须用到CAS技术，一门CPU的原子锁技术，可通过CPU对共享变量加锁的形式，实现数据变更的原子操作。volatile 和 CAS的结合是并发抢占的关键



##### 锁升级

DK 1.6之前，synchronized 还是一个重量级锁，是一个效率比较低下的锁。但是在JDK 1.6后，JVM为了提高锁的获取与释放效率对synchronized 进行了优化，引入了偏向锁和轻量级锁 ，从此以后锁的状态就有了四种：无锁、偏向锁、轻量级锁、重量级锁。并且四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级，这四种锁的级别由低到高依次是：无锁、偏向锁，轻量级锁，重量级锁。如下图所示：

![img](img/1E93EF873A5A8C896878DBD7EB5E6C36.png)

1. 无锁

   无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁的特点是修改操作会在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。

2. 偏向锁

   初次执行到synchronized代码块的时候，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并不会主动释放偏向锁。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。

   偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。

   当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。

   偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。

3. 轻量级锁

   轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。

   轻量级锁的获取主要由两种情况：

   1. 当关闭偏向锁功能时；
   2. 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。

   一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。

   在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，比较并设置是原子性发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。

   长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，短时间的忙等，换取线程在用户态和内核态之间切换的开销。

4. 重量级锁

   重量级锁显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。

   重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源。

#### Semaphore

```java
import java.util.concurrent.Semaphore;
```

信号量：(类似PV)

- acquire 是如果信号量为正整数时取走，信号量减一；否则阻塞直到信号量能用
- release 是信号量加一

如：

```java
class IntConsumer {
    public void accept(int x) {
        System.out.print(x);
    }
}
class ZeroEvenOdd {
    private int n;

    // 默认 zero 有一个信号量可用
    private Semaphore zero = new Semaphore(1);

    // 默认 even 和 odd 没有可用信号量
    private Semaphore even = new Semaphore(0);
    private Semaphore odd = new Semaphore(0);

    public ZeroEvenOdd(int n) {
        this.n = n;
    }

    // printNumber.accept(x) outputs "x", where x is an integer.
    public void zero(IntConsumer printNumber) throws InterruptedException {

        for (int i = 1;i <= n; i++){

            // 首次执行时， zero 有一个可用的信号量
            zero.acquire();
            printNumber.accept(0);
            if(i % 2 == 1){
                // 可以理解为 odd 增加一个信号量，这样 odd 可以继续走流程
                odd.release();
            }else{
                // 可以理解为 even 增加一个信号量， 这样 even 可以继续走流程
                even.release();
            }
        }
    }

    public void even(IntConsumer printNumber) throws InterruptedException {

        for (int i = 2; i <= n;i += 2){

            // 等待信号量，获取到了信号后，往下走
            even.acquire();

            printNumber.accept(i);

            // 发送信号量给 zero
            zero.release();
        }

    }

    public void odd(IntConsumer printNumber) throws InterruptedException {

        for (int i = 1; i <= n; i += 2){

            // 等待信号量，获取到了信号后，往下走
            odd.acquire();
            printNumber.accept(i);

            // 发送信号量给 zero
            zero.release();
        }
    }
}
```

然后三个线程执行同一个对象的这三个方法，能保证输出顺序是 01020304...

### 网络通信

#### 基本概念

TCP 面向连接的可靠协议 (传输控制协议)

UDP 面向无连接的不可靠协议 (用户报数据协议)

UDP 更快但不保证发送顺序与接收顺序相同

常用端口号：

1. 80 HTTP 服务端口
2. 21 FTP
2. 53 DNS
3. $[0,1023]$ 通常用于知名网络服务和应用

Socket (套接字) 将应用程序与端口连接起来

常用 cmd 指令：

* `ipconfig /all`
* `netstat /ano` 查询当前设备已用端口
* `ping 网址` 查询域名对应IP
  如 `ping socoding.cn`
* `tracert 网址` 路由追踪IP



#### TCP

##### InetAddress 类

加载：

```java
import java.net.*;
```

常用方法：

* `InetAddress.getLocalHost()` 获取本机实例
* `InetAddress.getByName(String host)` 获取与Host对应的对象
* `getHostAddress()` 得到 IP 地址 String
* `getHostName()` 获取 IP 名

可能会抛出异常 `UnknownHostException` 异常，所以需要 `try..catch` 。

代码示例：

```java
import java.net.*;

public class c1901 {
    public static void main(String[] args) {
        try {
            InetAddress ip = InetAddress.getLocalHost();
            System.out.println("本机名："+ip.getHostName());
            System.out.println("本机IP："+ip.getHostAddress());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

##### ServerSocket 类

表示服务器套接字，主要功能是等待来自网络上的请求。一次与一个套接字链接。若多台客户机同时提出请求，会存入队列依次取出；若达到最大容纳数，多出的会被拒绝。默认大小是 $50$ 

构造方法会抛出 `IOException` 异常，构造方法如下：

- `ServerSocket()` 创建非绑定服务器套接字
- `ServerSocket(int port)` 创建绑定到特定端口的服务器套接字
- `ServerSocket(int port, int backlog)` 用 `backlog` 创建，并绑定到指定端口
- `ServerSocket(int port, int bakclog, InetAddress bindAddress)` 使用指定端口，侦听 `backlog` 和要绑定的本地 IP 地址创建服务器(适用于计算机有多块网卡、多个IP地址情况)

 常用方法：

- `accept()` 返回 `Socket` ，等待客户机链接，若链接则创建一个套接字
- `isBound()` 绑定状态判定
- `getInetAddress` 返回该服务器套接字的本地地址 `InetAddress`
- `isClosed()` 关闭状态判定
- `close()` 关闭服务器套接字
- `bind(SocketAddress endpoint)` 绑定到指定地址(IP+端口号)
- `getInetAddress()` 返回等待的端口号 `int`

服务端 `Socket` 对象使用 `getOutputStream()` 方法获得输出流将会指向客户端 `Socket` 对象使用 `getInputStream` 方法获得的输入流。反之相反。

`accept` 方法会阻塞线程执行，直到收到呼叫。若不阻塞就是绑定失败，如被占用端口。

可以使用 `cmd` 的 `netstat-help` ，用 `netstat-an` 查看所有程序所使用端口



##### 例子

一个收信息服务器和发信息客户端的例子：

###### 服务端

服务端(以 `eclipse`运行)：

```java
package test;
import java.io.*;
import java.net.*;

public class c1902 {
    private BufferedReader reader;
    private ServerSocket server;
    private Socket socket;

    void getserver() {
        try {
            server = new ServerSocket(5801);
            System.out.println("server started successfully");
            while (true) {
                socket = server.accept();
                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                getClientMessage();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    void getClientMessage() {
        try {
            while (true) {
                System.out.println("read:" + reader.readLine());
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        // 必须放在另一个try是因为那个while是通过catch退出的
        try {
            if (reader != null) {
                reader.close();
            }
            if (socket != null) {
                reader.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        new c1902().getserver();
    }
}
```

###### 客户端

客户端：(以vscode运行)

```java
import javax.swing.*;
import javax.swing.border.BevelBorder;

import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.io.*;

public class c1903 extends JFrame {
    private PrintWriter writer;
    private Socket socket;
    private JTextArea ta = new JTextArea();
    private JTextField tf = new JTextField();

    public c1903() {
        Container ct = getContentPane();

      
        JScrollPane scr = new JScrollPane();
        scr.setBorder(new BevelBorder(BevelBorder.RAISED));
        ct.add(scr, BorderLayout.CENTER);
        scr.setViewportView(ta);

        ct.add(tf, BorderLayout.SOUTH);
        tf.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                writer.println(tf.getText());
                ta.append(tf.getText() + "\n");
                tf.setSelectionEnd(ta.getText().length());
                tf.setText("");
            }
        });

        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(200, 200);
        setVisible(true);
        connect();
    }

    private void connect() {
        ta.append("尝试连接服务器\n");
        try {
            socket = new Socket("127.0.0.1", 5801);
            writer = new PrintWriter(socket.getOutputStream(), true);
            ta.append("连接成功\n");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        new c1903();
    }
}

```

###### 多线程

改进了上文例子，使得服务器可以同时处理多个访问。

```java
package ezm3;

import java.io.*;
import java.net.*;

public class tcpServer {
    public static final int PORT = 8888;

    class myThread extends Thread {
        Socket ss = null;

        public myThread(Socket ss) {
            this.ss = ss;
        }

        public void run() {
            System.out.println("Socket accept:" + ss);
            try {
                // 连接成功，建立相应的I/O数据流
                DataInputStream dis = new DataInputStream(ss.getInputStream());
                DataOutputStream dos = new DataOutputStream(ss.getOutputStream());
                // 在循环中，与客户机通信
                while (true) {
                    String str = dis.readUTF(); // 从客户机中读数据
                    if (str.equals("end"))
                        break; // 当读到end时，程序终止
                    System.out.println(str);
                    dos.writeUTF("Echoing:" + str); // 向客户机中写数据
                }
                dos.close();
                dis.close();
            } catch (Exception e) {
            } finally {
                try {
                    ss.close();
                } catch (Exception e) {
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
        // 建立ServerSocket
        new tcpServer().solve();
    }

    public void solve() throws IOException {
        ServerSocket s = new ServerSocket(PORT);
        System.out.println("ServerSocket:" + s);
        try {
            /* 程序阻塞,等待连接。即直到有一个客户请求到达,程序方能继续执行 */
            while (true) {
                Socket ss = s.accept();
                myThread thread = new myThread(ss);
                thread.start();
            }
        } finally {
            s.close();
        }
    }
}
```

```java
package ezm3;

import java.io.*;
import java.net.*;

public class tcpClient {
    public static void main(String[] args) {

        for (int i = 0; i < 3; ++i) {
            new Thread(new Runnable() {
                public void run() {
                    try {
                        // 建立Socket，服务器在本机的8888端口处进行“侦听”
                        Socket ss = new Socket("127.0.0.1", 8888);
                        System.out.println("Socket:" + ss);
                        try {
                            // 套接字建立成功，建立I/O流进行通信
                            DataInputStream dis = new DataInputStream(ss.getInputStream());
                            DataOutputStream dos = new DataOutputStream(ss.getOutputStream());
                            for (int i = 0; i < 6; i++) {
                                dos.writeUTF("测试:" + i); // 向服务器发数据
                                dos.flush(); // 刷新输出缓冲区，以便立即发送
                                System.out.println(dis.readUTF()); // 将从服务器接收的数据输出
                                Thread.sleep(100);
                            }
                            dos.writeUTF("end"); // 向服务器发送终止标志
                            dos.flush(); // 刷新输出缓冲区，以便立即发送
                            dos.close();
                            dis.close();
                        } finally {
                            ss.close();
                        }
                    } catch (Exception e) {
                    } finally {
                    }
                }
            }).start();
        }
    }
}
```



#### UDP

##### DatagramPacket 类

表示数据包，是 UDP 接发的基本单位。构造函数有：

- `DatagramPacket(byte[] buf, int length)`
- `DatagramPacket(byte[] buf, int length, InetAddress addresss, int port)`

指定数据包空间大小，目标地址和端口

对发送，步骤是创建地址(用`getByName`) ，然后传入端口，用构造函数创建 `MulticastSocket` 类，实例化多点广播套接字，将其使用 `.setTimeToLive(1)` 可以指定发送范围是本地网络。然后使用 `.joinGroup(inet)` 加入广播组。

接收建立同样的地址 `InetAddress` 和 `socket` 且加入组(不需要设置 `live`) 。



##### DatagramSocket 类

发送和接受所用套接字。构造函数有：

- `DatagramSocket()`
- `DatagramSocket(int port)`
- `DatagramSocket(int port, InetAddress addr)`

第二个绑定到本机；第三个适用于多个网卡和多个IP；接收方必须指定端口，不允许随机生成，但发送可以不指定，而系统分配。

发送和接收必须在同一个组内，地址范围是 `224.0.0.0~224.255.255.255` 该地址不代表某个特定主机的位置，加入到同一个组的主机可以在某个端口广播信息和接收信息

数据包类为 `DatagramPacket` ，构造函数传入 `byte[], int len, InetAddress, int port` 四个参数，然后用 `socket` 的 `.send` 方法发送该数据包，需要 `try` 。 发送通常用循环线程。

接收用死循环线程，使用 `socket.receive(DatagramPacket)` 方法得到数据包。用 `String` 构造函数传入参数： `数据包实例.getData(),0,数据包实例.getLength()` 得到字符串，可以用于输出。



##### 例子

###### 服务端

放在一个文件夹里vscode运行

```java
import java.net.*;

public class c1904 extends Thread {
    private InetAddress iadd = null;
    private MulticastSocket socket = null;
    private final static int port = 5802;

    public c1904() {
        try {
            iadd = InetAddress.getByName("224.255.10.0");
            socket = new MulticastSocket(port);
            socket.setTimeToLive(1);
            socket.joinGroup(iadd);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void run() {
        System.out.println("server ran successfully.");
        while (true) {
            DatagramPacket packet = null;
            byte data[] = "abc中文测试".getBytes();
            packet = new DatagramPacket(data, data.length, iadd, port);
            try {
                socket.send(packet);
                sleep(1000);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        new c1904().start();
    }
}
```

###### 客户端

放在一个子文件夹用另一个vscode窗口运行

```java
import java.net.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class c1905 extends JFrame implements Runnable, ActionListener {
    private int port = 5802;
    private InetAddress group = null;
    private MulticastSocket socket = null;
    private JButton ince = new JButton("start receive");
    private JButton stop = new JButton("stop receive");
    private JTextArea incea = new JTextArea(10, 10);
    private JTextArea inced = new JTextArea(10, 10);
    private Thread thr;
    boolean b = false;

    public c1905() {
        thr = new Thread(this);
        ince.addActionListener(this);
        stop.addActionListener(this);
        incea.setForeground(Color.blue);
        JPanel north = new JPanel();
        north.add(ince);
        north.add(stop);
        add(north, BorderLayout.NORTH);

        JPanel center = new JPanel();
        center.setLayout(new GridLayout(1, 2));
        center.add(incea);
        center.add(inced);
        add(center, BorderLayout.CENTER);
        validate();// refresh

        try {
            group = InetAddress.getByName("224.255.10.0");
            socket = new MulticastSocket(port);
            socket.joinGroup(group);
        } catch (Exception e) {
            e.printStackTrace();
        }

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setBounds(100, 50, 360, 380);
        setSize(460, 200);
        setVisible(true);
    }

    public void run() {
        while (true) {
            byte data[] = new byte[1024];
            DatagramPacket packet = new DatagramPacket(data, data.length, group, port);
            try {
                socket.receive(packet);
                String message = new String(packet.getData(), 0, packet.getLength());
                incea.setText("receiving:" + message);
                inced.append(message + "\n");
            } catch (Exception e) {
                e.printStackTrace();
            }
            if (b == true) {
                break;
            }
        }
    }

    public void actionPerformed(ActionEvent e) {
        if (e.getSource() == ince) {
            ince.setBackground(Color.red);
            stop.setBackground(Color.yellow);
            if (!thr.isAlive()) {
                thr = new Thread(this);
            }
            thr.start();
            b = false;
        }
        if (e.getSource() == stop) {
            ince.setBackground(Color.yellow);
            stop.setBackground(Color.red);
            b = true;
        }
    }

    public static void main(String[] args) {
        new c1905();
    }
}

```



#### 网页链接

先创建 URL，传入参数是字符串，描述 `url` 。然后使用 `HttpURLConnection` 类。使用 URL 的 `openConnection()` 方法返回并强转得到这个类。该类有 `getInputStream()` 方法，得到的值可以用于构造其他流。然后读入即可。

例如：读取某网页的所有 `<a href=></a>` 的网址信息：

```java
package Lab12;

import java.io.*;
import java.net.*;
import java.util.regex.*;

public class Lab12_4 {
    private File f; // local is not ok
    private FileWriter fw;
    private BufferedWriter bfw;

    private static final String href_regex = "<a\\s+href\\s*=\\s*(\"|\')?(.*?.html?)[\"|\'|>].*</a>";
    private static Pattern href_pattern = Pattern.compile(href_regex, Pattern.CASE_INSENSITIVE);

    public Lab12_4() {
        try {
            URL page = new URL("https://www.qq.com");
            HttpURLConnection conn = (HttpURLConnection) page.openConnection();
            InputStreamReader in = new InputStreamReader(conn.getInputStream());
            BufferedReader bfr = new BufferedReader(in);
            System.out.println("Got tencent successfully, now analyzing.");

            f = new File("HyperLink.txt");
            fw = new FileWriter(f);
            bfw = new BufferedWriter(fw);

            while (true) {
                String res = bfr.readLine();
                if (res.equals("null")) {
                    break;
                }
                Matcher m = href_pattern.matcher(res);
                while (m.find()) {
                    res = res.replaceAll(href_regex, "");
                    String res2 = m.group(2);
                    bfw.write(res2 + '\n');
                }
            }
        } catch (Exception e) {
            System.out.println("Analyzed successfully.");
        }
        try {
            bfw.close();
            fw.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("Written in HyperLink.txt successfully.");
    }

    public static void main(String[] args) {
        new Lab12_4();
    }
}

```

```java
package ezm3;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import org.eclipse.jdt.annotation.Nullable;
// import org.springframework.lang.Nullable;
import org.junit.Test;

public class TestHttp {
    public static String get(String Url, @Nullable String param) {
        HttpURLConnection connection = null;
        InputStream is = null;
        BufferedReader br = null;
        StringBuffer result = new StringBuffer();
        try {
            URL url = new URL(Url);
            connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("GET");
            connection.setReadTimeout(15000);// ms
            connection.connect();
            if (connection.getResponseCode() == 200) {
                is = connection.getInputStream();
                if (null != is) {
                    br = new BufferedReader(new InputStreamReader(is, "UTF-8"));
                }
                String temp = null;
                while (null != (temp = br.readLine())) {
                    result.append(temp);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (null != br) {
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (null != is) {
                try {
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            connection.disconnect();
        }
        return result.toString();
    }

    @Test
    public void test() {
        String res = get("https://oj.socoding.cn/", "");
        // String res = get("http://ssbylw.scnu.edu.cn/stuinfo.jsp?sid=20192005001", "");
        System.out.println(res.length());
        System.out.println(res);
    }
}
```





### 数据库

#### 基本概念

数据库可以实现并发控制，允许对数据实现多路存取。

数据库系统基于某种数据模型的分类：

- 层次性数据库：类似树结构，特点是记录之间的联系通过指针实现，顺序严格且复杂
- 网络型数据库：图结构，实体间联系。容易实现多对多联系
- 面向对象型数据库：顾名思义
- 关系型数据库：目前最流行。关系模型由一系列表格组成

JDK6 开始，安装目录有 `db` 目录，即 Java DB ，是纯 Java 实现的开源数据库管理系统 (DBMS) 

SQL 语言主要由以下几个部分组成：

- 数据定义语言 DDL data definition language
- 数据操纵语言 DML manipulation ，是核心
- 数据控制语言 DCL control
- 事务控制语言 Transaction Control Language

> 执行存储过程的 SQL 语句是 Statement (说是负责存储要执行的SQL语句字符串是不对的)
>
> `DriverManager` 类是驱动管理器类，用来管理和卸载 JDBC 驱动程序
>
> SQL 是结构化查询语言的缩写 Structured Query Language ，是关于数据库操作的语言；数据库是相互关联的数据的集合；以关系模型为数据组织存储方式的数据库称为关系型数据库
>
> B/S体系(Browser/Server,浏览器/服务器模式)

> SQL 提供 like 操作符模糊查找， % 代替 0 到多个字符， \_ 代替一个字符 
>



#### JDBC

可用于执行 SQL 语句的 Java API (`application programmnig interface`)

> JDBC java database connectivity 面向对象应用程序接口，制定了统一的访问各种关系型数据库标准接口，是底层 API 。该技术主要完成以下几个任务：与数据库建立连接，向数据库发送 SQL 语句，处理从数据库返回的结果。
>
> JDBC 必须依赖数据库厂商提供的 JDBC 驱动程序。
>
> JDBC 由 4 个组件组成：应用程序、驱动程序管理器、驱动程序和数据源组成。驱动基本分为四类：
>
> - JDBC-ODBC 桥，依靠 ODBC (Open Database Connectivity 开放数据库链接)驱动器和数据库通信，将 ODBC 二进制代码加载到使用该驱动程序的客户机上，适合企业网或用 java 编写的1三层结构应用程序服务器代码。
> - 本地 API 一部分用 Java 编写的驱动程序：这类驱动程序把客户机的 API 上的 JDBC 调用转换为 Oracle , DB2, Sybase 或其他 DBMS 的调用，这种驱动程序也需要将某些二进制代码加载到每台客户机上
> - JDBC 网络驱动：将 JDBC 转换为与 DBMS 无关的网络协议，又被某个服务器转换为一种 DBMS 协议，是一种利用 java 编写的 JDBC 驱动程序，也是最灵活的 JDBC 驱动程序，提供了适合企业内部互联网 (Intranet) 用的产品。为使之支持 Internet 访问，需要处理 Web 提出的安全性，通过防火墙的访问等额外要求
> - 本地协议驱动：纯 Java 驱动程序，将 JDBC 调用直接转换为 DBMS 所使用的网络协议，允许客户机直接调用 DBMS 服务器，是一种实用的访问 Internet 的解决方法
>
> 后两者是首选，提供了 java 的所有优点。

JDBC-ODBC 桥是 JDBC 驱动程序，完成从 JDBC 到 ODBC 的转换工作。允许 JDBC 驱动程序被用作 ODBC 驱动程序。

> `jdk 1.8` 开始删除了桥。 

然而通常而言不需要用这个桥，用什么数据库就用对应的 java 驱动即可。如对 `mysql` ，可以用下面的步骤：



#### DriverManager

管理数据库所有驱动程序，是 JDBC 管理层，作用于用户和驱动程序之间，跟踪可用的驱动程序，在数据库的驱动程序之间建立联系。通过 `getConnection()` 方法可以建立链接，或抛出 `SQLException` 异常

该类的常用方法：

- `getConnection(String url, String user, String psw)` 指定三个入口参数，获取数据库链接
- `setLoginTimeout()` 获取驱动程序试图登录到某一数据库时可以等待的最长时间，单位是秒
- `println(String msg)` 将一条消息打印到当前 JDBC 日志流



#### Connection

该接口代表与特定数据库的链接，在连接上下文中执行 SQL 语句并返回结果，常用方法有：

- `createStatement()` 创建 Statement 对象
- `createStatement(int resultSetType, int resultSetConcurrency)` 该 Statement 对象将生成具有给定类型、并发性和可保存性的 `ResultSet` 对象
- `preparedStatement()` 创建预处理对象 `preparedStatement` ，参数是 SQL 语句，其中 `?` 的地方是占位通配符参数
- `isReadOnly()` 是否只读
- `setReadOnly()` 默认非只读模式
- `commit()` 使所有上一次提交/回滚后进行的更改称为持久更改，并释放此 Connection 对象当前持有的所有数据库锁
- `rollback()` 取消在当前事务中进行的所有更改，并释放此 Connection 对象当前持有的所有数据库锁
- `close()` 立即释放该对象的数据库和 JDBC 资源，而不是等待被自动释放

预处理等需要经过一系列过程：

前置步骤：

1. 对 `mysql5` 下载 `mysql_connector_java_5.1.36_bin` ，对 `mysql8` ，下载 `mysql-connector-java-8.0.16` ，放到项目文件 (通常是 `/lib/` 下)
2. 对 eclipse ，右击项目， build path - configure build path ，选 java build path 下的 libraries ，点 add external JARs ，选中自己导入的外部库，确认 apply and close 。
3. 确保本地已经安装并启动 `mysql` 服务

那么，首先加载外部库：

```java
Class.forName("com.mysql.cj.jdbc.Driver"); // mysql [8,?)
Class.forName("com.mysql.jdbc.Driver"); // mysql [5,8)
```

注意，数据库语句都应该在 try 内执行。

注意实现加载对应包：

```java
import java.sql.*;
```

有 `Connection` 对象，代表一个与数据库的链接，创建方法是：

```java
DriverManager.getConnection("jdbc:mysql://IP地址:端口/数据库名","数据库用户名","数据库密码");
```

为了防止时区报错，可能需要在第一个参数加上 `url` 格式的参数  `serverTimezone=UTC` 。例如：

```java
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/javase?serverTimezone=UTC", "root", "1");
```

接下来，有 `Statement` SQL语句对象，用于执行 `sql` 语句。获得方法是：

```java
conn.createStatement();
```



#### Statement

Statement 对象用于执行不带参数的简单 SQL 语句。 `PreparedStatement` 继承 `Statement` 执行动态 SQL 语句。 `CallableStatement` 继承 `PreparedStatement` 执行对数据库的存储过程的调用。

该接口的常用方法：

- `execute(String sql)` 执行静态 SELECT 语句，可能返回多个结果集；可以执行 创建数据表
- `executeQuery(String sql)` 执行指定语句，返回单个结果集
- `executeUpdate(String sql)` 执行 INSERT UPDATE DELETE 语句
- `clearBatch()` 清空该对象当前的 SQL 命令列表
- `executeBatch()` 将一批命令交给数据库执行，若全部执行成功返回更新计数组成的数组，数组元素排序与 SQL 语句的添加顺序对应
- `addBatch(String sql)` 添加到命令列表；若驱动程序不支持批量处理就抛出异常
- `close()` 释放该实例占用的数据库和 JDBC 资源

`PreparedStatement` 接口常用方法：

- `setInt(int index, int k)` 将指定位置参数设置值，同理有其它数据类型方法包括 Date, String, Null ，这里 execute 系方法不需要写参数。 index 从 1 开始
- `clearParameters()` 清除所有参数

用 `toSring()`并取第一个 `:` 后的子串可以得到对应的 SQL语句。



#### ResultSet

该接口类似于一个临时表，暂存数据库查询操作获得的结果集，有指向当前数据行的指针， JDBC 2.0 (JDK 1.2 java development kit) 后添加了一组更新方法 `UpdateXXX` ，有重载方法，根据数据列索引号和列名更新指定列，但不将其同步到数据库，需要执行 `updateRow, insertRow` 方法更新到数据库。

该接口常用方法：

- `getInt()` 获得当前列指定数据类型值，传入列号或列名；值为 NULL 返回 0 (对 `getDate, getBoolean` 等返回 null)
- `first()` 指针移到当前记录首行
- `last()`
- `next()` 指针下移，到尾部了就 false
- `beforeFirst()` 移动到第一行，集合的开头
- `afterLast()`
- `absolute(int index)` 一道指定编号行
- `isFirst()`
- `isLast()`
- `updateInt()` 同理其它数据类型, Object 兼容诸如 String
- `getrow()` 当前行索引号
- `insertRow()` 插入行的内容插入到数据库
- `updateRow()` 当前行的内容同步到数据库
- `deleteRow()` 删除当前行， `close` 后同步到数据库



有 `ResultSetMetaData` 类，通过 `.getMetaData()` 方法获得，有方法：

- `getColumnCount()`
- `getColumnName(i)` $i$ 从 $1$ 开始
- `getColumnType(i)` 返回整型



特别注意resultset不能同时共存，找下一个时上一个会closed



#### 举例

##### 基本操作集

###### 数据库

对数据库：

```mysql
-- MySQL dump 10.13  Distrib 8.0.27, for Win64 (x86_64)
--
-- Host: localhost    Database: javase
-- ------------------------------------------------------
-- Server version	8.0.27

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `score`
--

DROP TABLE IF EXISTS `score`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `score` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `student_id` int unsigned NOT NULL,
  `semester` int unsigned NOT NULL,
  `subject_name` varchar(40) NOT NULL,
  `score` int unsigned NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `score`
--

LOCK TABLES `score` WRITE;
/*!40000 ALTER TABLE `score` DISABLE KEYS */;
INSERT INTO `score` VALUES (1,1,3,'JAVA',100),(2,2,3,'JAVA',98),(3,3,3,'JAVA',96),(4,2,2,'C++',80),(6,3,2,'C++',86),(7,3,9,'Python',59),(8,3,1,'算法',100),(9,2,1,'算法',99);
/*!40000 ALTER TABLE `score` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `student`
--

DROP TABLE IF EXISTS `student`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `student` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `student_name` varchar(20) NOT NULL,
  `grade` int unsigned NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `student`
--

LOCK TABLES `student` WRITE;
/*!40000 ALTER TABLE `student` DISABLE KEYS */;
INSERT INTO `student` VALUES (1,'lr580',2020),(2,'果冻',2021),(3,'禾枫',2021);
/*!40000 ALTER TABLE `student` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-12-21 13:12:00

```

```mysql
/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50624
Source Host           : localhost:3306
Source Database       : test

Target Server Type    : MYSQL
Target Server Version : 50624
File Encoding         : 65001

Date: 2015-12-04 15:45:37
*/
USE test
SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `tb_stu`
-- ----------------------------
DROP TABLE IF EXISTS `tb_stu`;
CREATE TABLE `tb_stu` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(30) DEFAULT NULL,
  `sex` varchar(2) DEFAULT NULL,
  `birthday` date DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tb_stu
-- ----------------------------
INSERT INTO tb_stu(id,name,sex,birthday) VALUES ( 1,'小明', '男', '2015-11-02');
INSERT INTO tb_stu(id,name,sex,birthday) VALUES ( 2,'小红', '女', '2015-09-01');
INSERT INTO tb_stu(id,name,sex,birthday) VALUES ( 3,'张三', '男', '2010-02-12');
INSERT INTO tb_stu(id,name,sex,birthday) VALUES ( 4,'李四', '女', '2009-09-10');
```



###### 代码

执行全部查询、删除、导入数据库：

```java
package Lab13;

import java.sql.*;
import java.util.*;

public class Lab13_2 {
    private class score {
        int semester, score;
        String subject;
    }

    private class student {
        public String name;
        public int grade;
        LinkedList<score> sco = new LinkedList<>(); // remember init!!
    }

    private Connection conn = null;
    private Statement sql = null;
    private ResultSet res = null;

    void queryAll() {
        try {
            TreeMap<Integer, student> stu = new TreeMap<>();
            res = sql.executeQuery("select * from student;");
            while (res.next()) {
                student temp = new student();
                temp.name = res.getString("student_name");
                Integer id = res.getInt("id");
                temp.grade = res.getInt("grade");
                stu.put(id, temp);
            }

            res = sql.executeQuery("select * from score;");
            while (res.next()) {
                score tem = new score();
                tem.semester = res.getInt("semester");
                tem.score = res.getInt("score");
                tem.subject = res.getString("subject_name");
                Integer sid = res.getInt("student_id");
                student s = stu.get(sid);
                s.sco.add(tem);
            }

            Iterator<student> it1 = stu.values().iterator();
            while (it1.hasNext()) {
                student t = it1.next();
                System.out.println(t.name + " " + t.grade + " :");
                Iterator<score> it2 = t.sco.iterator();
                while (it2.hasNext()) {
                    score ts = it2.next();
                    System.out.println("    " + ts.subject + " studied in " + ts.semester + " th, score: " + ts.score);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public Lab13_2() {

        try { // MySQL 8.0.27
            Class.forName("com.mysql.cj.jdbc.Driver");
        } catch (Exception e) {
            e.printStackTrace();
        }
        try { // use the database named javase created before
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/javase?serverTimezone=UTC", "root",
                    "1");
            // if not added serverTimezone, errors arisen
            sql = conn.createStatement();

            // query all the data
            queryAll();

            // delete some data
            System.out.println("\nNow delete the last data:");
            sql.executeUpdate("delete from score where id=5;");
            queryAll();

            // update some data
            System.out.println("\nNow update one specific data:");
            sql.executeUpdate("update score set score = 80 where id = 4;");
            queryAll();

            // copy database
            sql.executeUpdate("create database if not exists test character set UTF8MB4;");
            conn.close();

            String cmd1 = "mysqladmin -h 127.0.0.1 -u root -p1 create test";
            String cmd2 = "cmd /c mysql -h 127.0.0.1 -u root -p1 test < tb_thu.sql";
            try {
                Runtime.getRuntime().exec(cmd1);
            }catch(Exception e){
                System.out.println("Database \"test\" already exists.");
            }
            try{
                Runtime.getRuntime().exec(cmd2);
                System.out.println("Import database \"test\" successfully.");
            } catch (Exception e) {
                e.printStackTrace();
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        new Lab13_2();
    }
}

```



##### 图形化模拟

数据库沿用上面，实现了管理两张表的查询、插入、删除、修改

```java
package Lab13;

import java.sql.*;
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.table.*;

public class Lab13_3 extends JFrame {

    private class score {
        int semester, score, id;
        String subject;
    }

    private class student {
        public String name;
        public int grade, id;
        LinkedList<score> sco = new LinkedList<>();
    }

    private Connection conn = null;
    private Statement sql = null;
    private ResultSet res = null;
    private JTable jt = null;
    private DefaultTableModel jtm = null;
    private JScrollPane jsrc = null;
    private JButton jb_help = null;
    private JComboBox jc_con = null;
    private JButton jb_ope = null;
    private JPanel jp_top = null;
    private JLabel jl_con = null;
    private Container ct = null;
    private JTextField jtf_stuname = null;
    private JTextField jtf_stugrade = null;
    private JLabel jl_stuname = null;
    private JLabel jl_stugrade = null;
    private JLabel jl_info = null;
    private JComboBox jc_stu = null;// 不考虑重名问题
    private JLabel jl_stu = null;
    // private String[] lt_stu = null;
    private JTextField jtf_subj = null;
    private JTextField jtf_semester = null;
    private JTextField jtf_score = null;
    private JLabel jl_subj = null;
    private JLabel jl_semester = null;
    private JLabel jl_score = null;
    private TreeMap<Integer, student> stu = null;

    private void read_all() {
        try {
            stu = new TreeMap<>();
            res = sql.executeQuery("select * from student;");
            while (res.next()) {
                student temp = new student();
                temp.name = res.getString("student_name");
                Integer id = res.getInt("id");
                temp.id = id;
                temp.grade = res.getInt("grade");
                stu.put(id, temp);
            }

            res = sql.executeQuery("select * from score;");
            while (res.next()) {
                score tem = new score();
                tem.semester = res.getInt("semester");
                tem.score = res.getInt("score");
                tem.subject = res.getString("subject_name");
                tem.id = res.getInt("id");
                Integer sid = res.getInt("student_id");
                student s = stu.get(sid);
                s.sco.add(tem);
            }

            construct_lt_stu();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void init_db() {
        try { // MySQL 8.0.27
            Class.forName("com.mysql.cj.jdbc.Driver");
        } catch (Exception e) {
            e.printStackTrace();
        }
        try {
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/javase?serverTimezone=UTC", "root",
                    "1");
            sql = conn.createStatement();
            // read_all();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void show_help() {
        String res = "使用说明:  \n";
        res += "先选择指令类型，再输入对应参数即可。 \n";
        res += "要进行删除前，请先进行查询操作。 \n";
        res += "在添加成绩前，请先进行查询操作。 \n";
        res += "在更新数据前，请先执行查询操作。 \n";
        res += "仅支持表格单选和文本框输入，直接对表格输入无效。\n ";
        res += "仅支持单条件精准查询，即输入框中第一个有值的作为查询条件。 \n";
        res += "查询前请先执行一次查询所有。若所有输入框无值，查询单个学生。 \n";
        JOptionPane.showMessageDialog(null, res);
    }

    private void print_all_stus() {
        String cols[] = { "index", "name", "grade", "subject", "semester", "score" }; // utf-8 gbk error
        // String cols[] = { "编号", "姓名", "年级", "科目 ","学期","得分  ;    
        jtm.setColumnCount(0);
        for (int i = 0; i < cols.length; ++i) {
            jtm.addColumn(cols[i]);
        }
        jtm.setRowCount(0);

        read_all();
        Iterator<student> it = stu.values().iterator();
        while (it.hasNext()) {
            String res[] = new String[cols.length];
            student tmp = it.next();
            res[1] = tmp.name;
            res[2] = Integer.toString(tmp.grade);
            Iterator<score> it2 = tmp.sco.iterator();
            while (it2.hasNext()) {
                score tmp2 = it2.next();
                res[0] = Integer.toString(tmp2.id);
                res[3] = tmp2.subject;
                res[4] = Integer.toString(tmp2.semester);
                res[5] = Integer.toString(tmp2.score);
                jtm.addRow(res);
            }
        }

        // jt = new JTable(res, cols);
        // jsrc = new JScrollPane(jt);
        // blend(0);
        // ct.remove(jsrc);
        // ct.add(jsrc, BorderLayout.CENTER);
    }

    private void add_stu() {
        // 假设输入绝对正确
        String nw_name = jtf_stuname.getText();
        int nw_grade = Integer.valueOf(jtf_stugrade.getText());
        // System.out.println(nw_name + " " + nw_grade);
        boolean suc = true;
        try {
            res = sql.executeQuery("select max(id) from student;");
            int new_id = 999;
            while (res.next()) {
                new_id = res.getInt("max(id)") + 1;
            }
            // System.out.println(new_id);
            sql.executeUpdate(
                    "insert into student values (" + new_id + "," + nw_name + ", " + nw_grade + ");");
        } catch (Exception e) {
            suc = false;
            jl_info.setText("添加失败：" + e.getMessage());
            e.printStackTrace();
        }
        if (suc) {
            jl_info.setText("添加 " + nw_name + ", " + nw_grade + " 成功！ ");
        }
    }

    private void add_score() {
        // read_all();// 可以只读学生或优化成不读
        boolean suc = true;
        try {
            res = sql.executeQuery("select max(id) from score;");
            int new_id = 999;
            while (res.next()) {
                new_id = res.getInt("max(id)") + 1;
            }
            if (jc_stu.getSelectedIndex() == -1) {
                throw new Exception("未选中学生！ ");
            }
            String stu_raw = (String) jc_stu.getSelectedItem();
            stu_raw = stu_raw.substring(0, stu_raw.indexOf('('));
            int stu_index = Integer.valueOf(stu_raw);
            // System.out.println(stu_index);

            String new_subj = jtf_subj.getText();// 假设输入正确
            int new_seme = Integer.valueOf(jtf_semester.getText());
            int new_score = Integer.valueOf(jtf_score.getText());

            String cmd = "insert into score values (" + new_id + "," + stu_index + "," + new_seme + ",'" + new_subj
                    + "'," + new_score + ");";
            // System.out.println(cmd);
            sql.executeUpdate(cmd);

        } catch (Exception e) {
            suc = false;
            jl_info.setText("添加失败：" + e.getMessage());
            e.printStackTrace();
        }
        if (suc) {
            jl_info.setText("添加成功！ ");
            print_all_stus();
        }
    }

    private void construct_lt_stu() {
        Iterator<student> it = stu.values().iterator();
        jc_stu.removeAllItems();
        for (int i = 0; i < stu.size(); ++i) {
            // lt_stu[i] = it.next().name;
            student ss = it.next();
            jc_stu.addItem(ss.id + "(" + ss.name + ")");
        }
        // System.out.println(jc_stu.getItemCount());
    }

    private void del_score() {
        int idx = jt.getSelectedRow();
        if (idx == -1) {
            jl_info.setText("你没有选中要删除的一项。 ");
            return;
        }
        if (0 != JOptionPane.showConfirmDialog(null, "该操作不可逆，确认要删除吗？ ", "警告 ", 0, 2)) {
            return;
        }

        boolean suc = true;
        try {
            int id = Integer.valueOf((String) jt.getValueAt(idx, 0));
            sql.executeUpdate("delete from score where id=" + id + ";");
        } catch (Exception e) {
            suc = false;
            jl_info.setText("删除失败：" + e.getMessage());
            e.printStackTrace();
        }
        if (suc) {
            jl_info.setText("删除成功！ ");
            print_all_stus();
        }
    }

    private void del_stu() {
        if (jc_stu.getSelectedIndex() == -1) {
            jl_info.setText("未选中学生！ ");
            return;
        }
        String stu_raw = (String) jc_stu.getSelectedItem();
        stu_raw = stu_raw.substring(0, stu_raw.indexOf('('));
        int stu_index = Integer.valueOf(stu_raw);
        boolean suc = true;
        try {
            sql.executeUpdate("delete from score where student_id=" + stu_index + ";");
            sql.executeUpdate("delete from student where id=" + stu_index + ";");
        } catch (Exception e) {
            suc = false;
            jl_info.setText("删除失败：" + e.getMessage());
            e.printStackTrace();
        }
        if (suc) {
            jl_info.setText("删除成功！ ");
            print_all_stus();
        }
    }

    private int get_selected_id() {
        int idx = jt.getSelectedRow();
        if (idx == -1) {
            jl_info.setText("你没有选中要删除的一项。 ");
            return -1;
        }
        return Integer.valueOf((String) jt.getValueAt(idx, 0));
    }

    private void upd_score() {
        int id = get_selected_id();
        if (id == -1) {
            return;
        }
        String new_subj = jtf_subj.getText();// 假设输入正确
        int new_seme = Integer.valueOf(jtf_semester.getText());
        int new_score = Integer.valueOf(jtf_score.getText());
        boolean suc = true;
        String cmd = "update score set subject_name='" + new_subj + "',semester='" + new_seme + "',score='" + new_score
                + "' where id=" + id + ";";
        // System.out.println(cmd);
        try {
            sql.executeUpdate(cmd);
        } catch (Exception e) {
            suc = false;
            jl_info.setText("更新失败: " + e.getMessage());
            e.printStackTrace();
        }
        if (suc) {
            jl_info.setText("更新成功! ");
            print_all_stus();
        }
    }

    private void upd_stu() {
        String nw_name = jtf_stuname.getText();
        int nw_grade = Integer.valueOf(jtf_stugrade.getText());
        if (jc_stu.getSelectedIndex() == -1) {
            jl_info.setText("未选中学生！ ");
            return;
        }
        String stu_raw = (String) jc_stu.getSelectedItem();
        stu_raw = stu_raw.substring(0, stu_raw.indexOf('('));
        int stu_index = Integer.valueOf(stu_raw);
        boolean suc = true;
        String cmd = "update student set student_name='" + nw_name + "',grade='" + nw_grade + "' where id = "
                + stu_index + ";";
        try {
            sql.executeUpdate(cmd);
        } catch (Exception e) {
            suc = false;
            jl_info.setText("更新失败: " + e.getMessage());
            e.printStackTrace();
        }
        if (suc) {
            jl_info.setText("更新成功! ");
            print_all_stus();
        }
    }

    private void query() {// 有BUG，表格不会更新，但确实读到了结果，原因未知
        String new_subj = jtf_subj.getText();// 假设输入正确
        int new_seme = jtf_semester.getText().length() == 0 ? -1 : Integer.valueOf(jtf_semester.getText());
        int new_score = jtf_score.getText().length() == 0 ? -1 : Integer.valueOf(jtf_score.getText());
        if (jc_stu.getSelectedIndex() == -1) {
            jl_info.setText("未选中学生！ ");
            return;
        }
        String stu_raw = (String) jc_stu.getSelectedItem();
        stu_raw = stu_raw.substring(0, stu_raw.indexOf('('));
        int stu_index = Integer.valueOf(stu_raw);
        boolean suc = true;
        String cmd = "select * from score ";
        if (new_subj.length() != 0) {
            cmd += "where subject_name='" + new_subj + "';";
        } else if (jtf_semester.getText().length() != 0) {
            cmd += "where semester='" + new_seme + "';";
        } else if (jtf_score.getText().length() != 0) {
            cmd += "where score='" + new_score + "';";
        } else {
            cmd += "where student_id = " + stu_index + ";";
        }
        System.out.println(cmd);

        String cols[] = { "index", "name", "grade", "subject", "semester", "score" };
        jtm.setColumnCount(0);
        for (int i = 0; i < cols.length; ++i) {
            jtm.addColumn(cols[i]);
        }
        // while (jtm.getRowCount() > 0) {
        // jtm.removeRow(jtm.getRowCount() - 1);
        // }

        jtm.setRowCount(0);
        int cnt = 0;

        try {
            res = sql.executeQuery(cmd);
            String ret[] = new String[cols.length];
            while (res.next()) {
                ++cnt;
                ret[0] = Integer.toString(res.getInt("id"));
                int stu_id = res.getInt("student_id");
                student t_stu = stu.get(stu_id);
                ret[1] = t_stu.name;
                ret[2] = Integer.toString(t_stu.grade);
                ret[3] = res.getString("subject_name");
                ret[4] = Integer.toString(res.getInt("semester"));
                ret[5] = Integer.toString(res.getInt("score"));
                // for (int i = 0; i < 10; ++i) {
                // jtm.addRow(ret);
                // }
                jtm.addRow(ret);
                // System.out.println(jtm.getRowCount());
            }

        } catch (Exception e) {
            suc = false;
            jl_info.setText("查询失败: " + e.getMessage());
            e.printStackTrace();
        }
        if (suc) {
            jl_info.setText("查询成功! 找到 " + cnt + "个项目。 ");
            print_all_stus();
        }
    }

    private void blend(int mode) {
        jp_top.removeAll();
        jp_top.revalidate();
        jp_top.add(jb_help);
        jp_top.add(jl_con);
        jp_top.add(jc_con);
        if (mode == 1 || mode == 5) {
            if (mode == 5) {
                jp_top.add(jl_stu);
                jp_top.add(jc_stu);
            }
            jp_top.add(jl_stuname);
            jp_top.add(jtf_stuname);
            jp_top.add(jl_stugrade);
            jp_top.add(jtf_stugrade);
        }
        // if (mode == 2) {
        // print_all_stus();
        // }
        else if (mode == 3 || mode == 6 || mode == 7) {

            jp_top.add(jl_subj);
            jp_top.add(jtf_subj);
            jp_top.add(jl_semester);
            jp_top.add(jtf_semester);
            jp_top.add(jl_score);
            jp_top.add(jtf_score);
        } else if (mode == 4) {
            jp_top.add(jl_stu);
            jp_top.add(jc_stu);
        }
        jp_top.add(jb_ope);
    }

    public Lab13_3() {
        init_db();
        ct = getContentPane();
        jp_top = new JPanel(new FlowLayout(1, 10, 2));
        ct.add(jp_top, BorderLayout.NORTH);

        jtm = new DefaultTableModel();
        jt = new JTable(jtm);
        jsrc = new JScrollPane(jt);
        ct.add(jsrc, BorderLayout.CENTER);

        jl_info = new JLabel();
        ct.add(jl_info, BorderLayout.SOUTH);

        jb_help = new JButton("帮助 ");
        jb_help.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                show_help();
            }
        });

        jl_con = new JLabel("指令选择:");
        final String con_name[] = { "query all ", "add student ", "delete score", "add score", "delete student",
                "update student", "update score", "query score" };
        // final String con_name[] = { "查询所有成绩 ", "添加学生 ","删除选中成绩 " };
        jc_con = new JComboBox(con_name); // 懒得创建自定义对象了
        jc_con.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                String cmd = (String) jc_con.getSelectedItem();
                int idx = -1;
                for (int i = 0; i < con_name.length; ++i) {
                    if (cmd.equals(con_name[i])) {
                        idx = i;
                        break;
                    }
                }
                if (idx >= 0) {
                    blend(idx);
                }
            }
        });

        jl_stuname = new JLabel("学生姓名: ");
        jl_stugrade = new JLabel("年级: ");
        jtf_stuname = new JTextField(6);
        jtf_stugrade = new JTextField(4);

        jl_stu = new JLabel("请选择学生:  ");

        jc_stu = new JComboBox();
        // lt_stu = new String[0];
        // jc_stu = new JComboBox(lt_stu);

        jl_semester = new JLabel("学期: ");
        jl_subj = new JLabel("科目: ");
        jl_score = new JLabel("分数: ");
        jtf_semester = new JTextField(2);
        jtf_subj = new JTextField(10);
        jtf_score = new JTextField(3);

        jb_ope = new JButton("执行 ");
        jb_ope.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                String cmd = (String) jc_con.getSelectedItem();
                if (cmd.equals(con_name[0])) {
                    print_all_stus();
                } else if (cmd.equals(con_name[1])) {
                    add_stu();
                } else if (cmd.equals(con_name[2])) {
                    del_score();
                } else if (cmd.equals(con_name[3])) {
                    add_score();
                } else if (cmd.equals(con_name[4])) {
                    del_stu();
                } else if (cmd.equals(con_name[5])) {
                    upd_stu();
                } else if (cmd.equals(con_name[6])) {
                    upd_score();
                } else if (cmd.equals(con_name[7])) {
                    query();
                }
            }
        });

        blend(0);
        setSize(900, 500);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }

    public static void main(String[] args) {
        new Lab13_3();
    }
}

```





### 库

#### 加解密

##### Base64

在老版本(java8前)用`sun.misc.BASE64Decoder;` 等，新版本用 `java.util.Base64` 

> 参考：[sun.misc导入](https://blog.csdn.net/u012998306/article/details/90906069) , [Base64新版本介绍](https://blog.csdn.net/zhou_kapenter/article/details/62890262) , [用法](https://www.runoob.com/java/java8-base64.html)
>
> 可能需要 eclipse - build path - configure build path - libraries - jre system library - access rules - edit - add - accessible(resulution) 和 **

实现模板：

```java
package plugin;

// import sun.misc.BASE64Decoder;
import java.util.Base64;

public class Base64Plugin {// Java8 做法；java8之前用sun.misc.BASE64Decoder;
    public static String get(byte[] key) {
        try {
            return Base64.getUrlEncoder().encodeToString(key);
        } catch (Exception e) {
            e.printStackTrace();
            return e.getMessage();
        }
    }

    public static byte[] from(String key) {
        try {
            return Base64.getUrlDecoder().decode(key);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}// 测试用例见Entrypt.java的main方法
```

显然，String 用 getBytes 转 byte 数组，然后用 toString 转回来。故可实现 String 间的参数加解密。



##### AES

加密解密，

> 参考 [各加密算法](https://blog.csdn.net/theUncle/article/details/100156976)

一个固定密码模板如下：

```java
package plugin;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Entrypt {
    // NOPadding
    private static final String transormation = "AES/CBC/PKCS5Padding";
    private static final String key = "1437580lr_CZGv1-";// 密码
    private static final byte key_b[] = key.getBytes();// 密码
    private static final String alg = "AES";
    private static Cipher cipher = null;
    private static SecretKeySpec keySpec = null;
    private static IvParameterSpec iv = null;
    static {// 初始化
        try {
            cipher = Cipher.getInstance(transormation);
            keySpec = new SecretKeySpec(key_b, alg);
            iv = new IvParameterSpec(key_b);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static String encode(String ori) {
        try {
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);
            byte[] res = cipher.doFinal(ori.getBytes());// "utf-8"不可
            return Base64Plugin.get(res);
        } catch (Exception e) {
            e.printStackTrace();
            return e.getMessage();
        }
    }

    public static String decode(String ori) {
        try {
            cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);
            byte[] res = cipher.doFinal(Base64Plugin.from(ori));
            return new String(res);
        } catch (Exception e) {
            e.printStackTrace();
            return e.getMessage();
        }
    }

    public static void main(String[] args) {// 测试用例
        String a = encode("awa你好");// 是否成功测试(含中文测试)
        System.out.println(a);
        System.out.println(decode(a));
        String b = encode("再见QwQ");// 可否复用测试
        System.out.println(b);
        System.out.println(decode(b));
    }
}

```

一个不固定密码模板如下：

```java
package plugin;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Entrypt {
    // NOPadding
    private static final String transormation = "AES/CBC/PKCS5Padding";
    private static final String key = "1437580lr_CZGv1.";// 默认密码
    private static final String alg = "AES";
    private static Cipher cipher = null;
    private static SecretKeySpec keySpec = null;
    private static IvParameterSpec iv = null;
    static {// 初始化
        try {
            cipher = Cipher.getInstance(transormation);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static byte[] fill(String psw) {// 不足16位填充，手写PKCS5Padding
        byte[] b = psw.getBytes();
        int len = 16;
        byte[] c = new byte[len];
        int left = (16 - b.length % 16) % 16;// 密码只能是16位长
        int i = 0;
        for (i = 0; i < b.length; ++i) {
            c[i] = b[i];
        }
        for (; i < c.length; ++i) {
            c[i] = (byte) left;
        }
        return c;
    }

    public static String encode(String ori, String psw) {
        try {
            byte[] key_b = fill(psw);
            keySpec = new SecretKeySpec(key_b, alg);
            iv = new IvParameterSpec(key_b);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);
            byte[] res = cipher.doFinal(ori.getBytes());// "utf-8"不可
            return Base64Plugin.get(res);
        } catch (Exception e) {
            return null;
        }
    }

    public static String encode(String ori) {
        return encode(ori, key);
    }

    public static String decode(String ori, String psw) {
        try {
            byte[] key_b = fill(psw);
            keySpec = new SecretKeySpec(key_b, alg);
            iv = new IvParameterSpec(key_b);
            cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);
            byte[] res = cipher.doFinal(Base64Plugin.from(ori));
            return new String(res);
        } catch (Exception e) {
            return null;
        }
    }

    public static String decode(String ori) {
        return decode(ori, key);
    }

    public static void main(String[] args) {// 测试用例
        String a = encode("awa你好");// 是否成功测试(含中文测试)
        System.out.println(a);
        System.out.println(decode(a));
        String b = encode("再见QwQ");// 可否复用测试
        System.out.println(b);
        System.out.println(decode(b));

        String c = encode("awa你好", "66");// 自定义密码
        System.out.println(c);
        System.out.println(decode(c, "66"));
        String d = encode("再见QwQ", "77");
        System.out.println(d);
        System.out.println(decode(d, "77"));

        if (null == decode(c, "77")) {
            System.out.println("密码错误");
        }
        if (null != decode(c, "66")) {
            System.out.println("密码正确");
        }
    }
}

```



##### MD5

只能加密不能解密的算法，可以生成校验码，常用于检查密码，通常给密码加盐(即加上特殊字串后缀)，防止彩虹表破解MD5校验码

> 参考文章：[这里 ](https://blog.csdn.net/qq_30683329/article/details/80879058) [加盐](https://blog.csdn.net/kswkly/article/details/90758505)

参考模板：

```java
package plugin;

import java.math.BigInteger;
import java.security.MessageDigest;

public class PswMD5 {
    private static final String salt = "Lr580143758&";// 密码加盐

    public static String encrypt(String data) {
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            md5.update(data.getBytes());
            return new BigInteger(1, md5.digest()).toString(16);// 校验码
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static String password_md5(String psw) {
        return encrypt(psw + salt);
    }

    public static void main(String[] args) {// 测试用例
        String md5_1 = password_md5("123456");
        String md5_2 = password_md5("123457");
        String md5_3 = password_md5("123456");
        System.out.println(md5_1);
        System.out.println(md5_2);
        System.out.println(md5_3.equals(md5_1));
        System.out.println(md5_3.equals(md5_2));
    }
}

```



#### 正则表达式

`java.util.regex`

##### 基本语法

三个类：`Pattern` , `Matcher` , `PatternSyntaxException`

使用静态方法 `Pattern.compile(字符串)` 得到模式对象 `Pattern` ，显然需要注意特殊字符的转义。

需要捕获分组时，调用 `matcher` 对象。构造为 `pattern实例.matcher(字符串)` ，方法有：

- `start()` 返回以前匹配的初始索引
- `start(int group)` 由给定组所捕获的子序列初始索引(第一个子序列是 1 )
- `end()` 最后匹配字符之后的偏移量
- `end(int group)`
- `lookingAt()` 从区域开头开始尝试与模式匹配，返回布尔值
- `find()` 下一匹配，返回布尔值
- `find(int start)` 重置匹配器，从指定开始，返回布尔值
- `matches()` 整个区域与模式尝试匹配，返回布尔值
- `appendReplacement(StringBuffer sb, String repl) `返回 Matcher
- `appendTail(StringBuffer sb)` 返回`StringBuffer`
- `replaceAll(String repl)` 返回 String
- `replaceFirst(String repl)`
- `quoteReplacement(String s)` 返回 `String`



> `PatternSyntaxException` 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。
>
> 方法为：
>
> - `getDescription()`
> - `getIndex()`
> - `getPattern()`
> - `getMessage()`



##### 使用示例

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class RegexMatches
{
    private static final String REGEX = "\\bcat\\b";
    private static final String INPUT =
                                    "cat cat cat cattie cat";
 
    public static void main( String[] args ){
       Pattern p = Pattern.compile(REGEX);
       Matcher m = p.matcher(INPUT); // 获取 matcher 对象
       int count = 0;
 
       while(m.find()) {
         count++;
         System.out.println("Match number "+count);
         System.out.println("start(): "+m.start());
         System.out.println("end(): "+m.end());
      }
   }
}
```

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class RegexMatches
{
    private static final String REGEX = "foo";
    private static final String INPUT = "fooooooooooooooooo";
    private static final String INPUT2 = "ooooofoooooooooooo";
    private static Pattern pattern;
    private static Matcher matcher;
    private static Matcher matcher2;
 
    public static void main( String[] args ){
       pattern = Pattern.compile(REGEX);
       matcher = pattern.matcher(INPUT);
       matcher2 = pattern.matcher(INPUT2);
 
       System.out.println("Current REGEX is: "+REGEX);
       System.out.println("Current INPUT is: "+INPUT);
       System.out.println("Current INPUT2 is: "+INPUT2);
 
 
       System.out.println("lookingAt(): "+matcher.lookingAt());
       System.out.println("matches(): "+matcher.matches());
       System.out.println("lookingAt(): "+matcher2.lookingAt());
   }
}
```

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class RegexMatches
{
    private static String REGEX = "dog";
    private static String INPUT = "The dog says meow. " +
                                    "All dogs say meow.";
    private static String REPLACE = "cat";
 
    public static void main(String[] args) {
       Pattern p = Pattern.compile(REGEX);
       // get a matcher object
       Matcher m = p.matcher(INPUT); 
       INPUT = m.replaceAll(REPLACE);
       System.out.println(INPUT);
   }
}
```

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class RegexMatches
{
   private static String REGEX = "a*b";
   private static String INPUT = "aabfooaabfooabfoobkkk";
   private static String REPLACE = "-";
   public static void main(String[] args) {
      Pattern p = Pattern.compile(REGEX);
      // 获取 matcher 对象
      Matcher m = p.matcher(INPUT);
      StringBuffer sb = new StringBuffer();
      while(m.find()){
         m.appendReplacement(sb,REPLACE);
      }
      m.appendTail(sb);
      System.out.println(sb.toString());
   }
}
```



##### 应用

###### 账号密码

```java
//由大小写字母数字组合构成,长度不小于6,并且不包含特殊字符
String pswRegex = "^(?=.*[A-Z])(?=.*[a-z])(?=.*[1-9])(?!.*[\\W]).{6,}$";

//由大小写字母数字和特殊符号组合构成，且长度不小于6
String pswRegex = "^(?=.*[A-Z])(?=.*[a-z])(?=.*[1-9])(?=.*[\\W]).{6,}$";
```



#### 音效

`JDK` 原生支持的播放格式很少，参考 `javax.sound.sampled.AudioFileFormat.Type` 类。

`javax.sound.sampled` 包提供混音器工具。通过线程不断循环把音乐文件以音频输入流格式读入创建的缓冲区byte 数组，然后将其写入混音器源数据行中，就可以不断向音频设备发送信号。

音频输入流 `AudioInputStream` 用 `AudioSystem.getAudioInputStream(File)` 获取，可以用 `getFormat()` 方法得到 `AudioFformat` 对象的音频格式。

用 `Dateline.Info` 类对象，通过构造函数传入两个参数，第一个是 `SourceDataLine.class` ，第二个是格式类。然后让一个 `SourceDataLine` 类对象赋值为 `AudioSystem.getLine( Dateline.Info 类对象)` ，注意强转。然后这个对象使用 `.open(格式)` 和 `.start()` 方法。

然后循环读入  `AudioInputStream` 的 `.read(缓存数组, 0, 数组长度)` 到 int ，然后写入给 `SourceDataLine` 类对象，参数`.write(缓存数组, 0, 该int)` 。

之后用 `.drain()` 清空 `SourceDataLine` 类对象数据行并 `.close()`

模板如下：

```java
package com.mr.service;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import javax.sound.sampled.UnsupportedAudioFileException;

/**
 * 音乐播放器
 * 
 * @author mingrisoft
 */
public class MusicPlayer implements Runnable {
    File soundFile; // 音乐文件
    Thread thread;// 父线程
    boolean circulate;// 是否循环播放

    /**
     * 构造方法，默认不循环播放
     * 
     * @param filepath
     *            音乐文件完整名称
     * @throws FileNotFoundException
     */
    public MusicPlayer(String filepath) throws FileNotFoundException {
        this(filepath, false);
    }

    /**
     * 构造方法
     * 
     * @param filepath
     *            音乐文件完整名称
     * @param circulate
     *            是否循环播放
     * @throws FileNotFoundException
     */
    public MusicPlayer(String filepath, boolean circulate)
            throws FileNotFoundException {
        this.circulate = circulate;
        soundFile = new File(filepath);
        if (!soundFile.exists()) {// 如果文件不存在
            throw new FileNotFoundException(filepath + "未找到");
        }
    }

    /**
     * 播放
     */
    public void play() {
        thread = new Thread(this);// 创建线程对象
        thread.start();// 开启线程
    }

    /**
     * 停止播放
     */
    public void stop() {
        thread.stop();// 强制关闭线程
    }

    /**
     * 重写线程执行方法
     */
    public void run() {
        byte[] auBuffer = new byte[1024 * 128];// 创建128k缓冲区
        do {
            AudioInputStream audioInputStream = null; // 创建音频输入流对象
            SourceDataLine auline = null; // 混频器源数据行
            try {
                // 从音乐文件中获取音频输入流
                audioInputStream = AudioSystem.getAudioInputStream(soundFile);
                AudioFormat format = audioInputStream.getFormat(); // 获取音频格式
                // 按照源数据行类型和指定音频格式创建数据行对象
                DataLine.Info info = new DataLine.Info(SourceDataLine.class,
                        format);
                // 利用音频系统类获得与指定 Line.Info 对象中的描述匹配的行，并转换为源数据行对象
                auline = (SourceDataLine) AudioSystem.getLine(info);
                auline.open(format);// 按照指定格式打开源数据行
                auline.start();// 源数据行开启读写活动
                int byteCount = 0;// 记录音频输入流读出的字节数
                while (byteCount != -1) {// 如果音频输入流中读取的字节数不为-1
                    // 从音频数据流中读出128K的数据
                    byteCount = audioInputStream.read(auBuffer, 0,
                            auBuffer.length);
                    if (byteCount >= 0) {// 如果读出有效数据
                        auline.write(auBuffer, 0, byteCount);// 将有效数据写入数据行中
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            } catch (UnsupportedAudioFileException e) {
                e.printStackTrace();
            } catch (LineUnavailableException e) {
                e.printStackTrace();
            } finally {
                auline.drain();// 清空数据行
                auline.close();// 关闭数据行
            }
        } while (circulate);// 根据循环标志判断是否循环播放
    }
}
```

模板用例：

```java
package com.mr.service;

import java.io.FileNotFoundException;

/**
 * 音效类
 * 
 * @author mingrisoft
 *
 */
public class Sound {
    static final String DIR = "music/";// 音乐文件夹
    static final String BACKGROUD = "background.wav";// 背景音乐
    static final String JUMP = "jump.wav";// 跳跃音效
    static final String HIT = "hit.wav";// 撞击音效

    /**
     * 播放跳跃音效
     */
    static public void jump() {
        play(DIR + JUMP, false);// 播放一次跳跃音效
    }

    /**
     * 播放撞击音效
     */
    static public void hit() {
        play(DIR + HIT, false);// 播放一次撞击音效
    }

    /**
     * 播放背景音乐
     */
    static public void backgroud() {
        play(DIR + BACKGROUD, true);// 循环播放背景音乐
    }

    /**
     * 播放
     * 
     * @param file
     *            音乐文件完整名称
     * @param circulate
     *            是否循环播放
     */
    private static void play(String file, boolean circulate) {
        try {
            // 创建播放器
            MusicPlayer player = new MusicPlayer(file, circulate);
            player.play();// 播放器开始播放
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}

```



#### 日期

##### Date

```java
import java.util.Date;
```

构造函数：

- `Date()` 取现在
- `Date(long)` 取 $1970$ 年 $1$ 月 $1$ 日起始到现在的毫秒数

其他方法：

- `getTime()` 获取时间戳(单位毫秒)，返回 `long`



应用：

1. 计算两个日期相差多少天：

   ```java
   (int) ((d1.getTime() - d2.getTime()) / (1000 * 3600 * 24))
   ```

   

##### Calendar

```java
import java.util.Calendar;
```

构造函数：

```java
Calendar c = Calendar.getInstance();
```

获取当前日期：

```java
c.getTime();
c.getTime().toLocaleString();
```



取一个日期：

```java
c.setTime(Date d)
```

进行日期运算，改变自身：

```java
c.add(单位, 数量);
```

如：

```java
c.add(Calendar.DAY_OF_YEAR, -1000);
```

常见的值有：

- `DAY_OF_WEEK` 周日是 $1$ ，周一到周六是 $[2,7]$

  强转周一到周日范围为 $[0,6]$ 的方法：

  ```java
  (c.get(Calendar.DAY_OF_WEEK) + 5) % 7
  ```

- `DAY_OF_MONTH` 一个月里的第几天，从 $1$ 开始

取范围最值，如获得这个日期月份有多少天：

```java
c.getActualMaximum(Calendar.DAY_OF_MONTH);
```





##### SimpleDateFormat

```java
import java.text.SimpleDateFormat;
```

构造函数传一个字符串代表格式，如：

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
SimpleDateFormat sdf = new SimpleDateFormat("yyMMdd");
SimpleDateFormat sdf = new SimpleDateFormat("yyMM");
```

有两个函数：

```java
sdf.parse(String source); //转 Date ，需要 throws
sdf.format(Date res); //转 String
```



#### XML

##### SAX

手写 bean 的实现示例：

```java
package util;

import java.io.File;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class XMLUtil {
    /**
     * 
     * @param path URL of a XML file
     * @return the Class of the XML described
     * @exampleXML like below
     * <?xml version="1.0"?>
       <config>
           <className>lab1_2.FileLogFactory</className>
        </config>
     * it gets FileLogFactory
     */
    public static Object getBean(String path) {
        try {
            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = dFactory.newDocumentBuilder();
            Document doc = builder.parse(new File(path));
            NodeList nl = doc.getElementsByTagName("className");
            Node classNode = nl.item(0).getFirstChild();
            String cName = classNode.getNodeValue();
//            System.out.println(cName);
            
            @SuppressWarnings("rawtypes")
            Class c = Class.forName(cName);
            Object obj = c.newInstance();
            return obj;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

测试代码如下：

```java
package lab1_2;
//日志记录器接口：抽象产品Log
public interface Log {
    public void writeLog();
}

```

```java
package lab1_2;

//文件日志记录器：具体产品FileLog
public class FileLog implements Log {
  @Override
  public void writeLog() {
      System.out.println("This is a file log.");
  }
}
```

```java
package lab1_2;

//日志记录器工厂接口：抽象工厂LogFactory
public interface LogFactory {
    public Log createLog();
}
```

```java
package lab1_2;

//文件日志记录器工厂类：具体工厂FileLogFactory
public class FileLogFactory implements LogFactory {
    @Override
    public Log createLog() {
        return new FileLog();
    }
}
```

```java
package lab1_2;

import util.XMLUtil;

//客户端测试类
class lab1_2 {
    public static void main(String args[]) {
        LogFactory factory;
        Log log;
        System.out.println(FileLogFactory.class.toString());
//    factory = new FileLogFactory();
        factory = (LogFactory) XMLUtil.getBean("src/lab1_2/lab1_2.xml");
        log = factory.createLog();
        log.writeLog();
    }
}
```

上述目录下的 xml：

```xml
<?xml version="1.0"?>
<config>
    <className>lab1_2.DatabaseLogFactory</className>
</config>
```





#### Toolkit

```java
import java.awt.Toolkit;
```

##### 剪切板

###### 复制到剪切板

文本复制到剪切板：

```java
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.StringSelection;
public static void toClipboard(String s) {
    Transferable res = new StringSelection(s);
    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(res, null);
}
```



### 其他

#### 枚举

优点：类型安全、紧凑有效的数据定义、可以与程序其他部分完美交互、运行效率高

声明：

```java
enum 枚举类名 {
	常量名, 常量名2, ... , 常量名n //不需要分号结束
}
//应当放在某个类内
```

调用：`枚举类名.常量名x`  ，如果直接输出，会输出字符串，名字为常量名，例如：

```java
public class c1701 {
    enum ts {
        uf, df, Lf, rf
    }

    public static void f(ts v) {
        if (v == ts.uf) {
            System.out.println("awa");
        } else {
            System.out.println("qaq");
        }
    }

    public static void main(String[] args) {
        f(ts.uf);
        f(ts.df);
        System.out.println(ts.Lf);
    }
}
```

不可以强转整型。

枚举可以看成是一个类，这意味着可以定义方法，继承于 `java.lang.Enum` ，每个枚举类型成员都是枚举类型的一个实例，默认被  `final, public, static` 三重修饰。常用方法有：

- `values()` 数组形式返回枚举类型成员
- `valueOf(String v)` 将普通字符串转枚举实例
- `compareTo(枚举类实例)`  (是下标差，相等是 $0$ ，正数是大于)
- `ordinal()` 得到位置索引

如：

```java
public class c1702 {
    enum enu {
        c1, c2, c3
    }

    public static void main(String[] args) {
        enu[] x = enu.values();
        for (int i = 0; i < x.length; ++i) {
            System.out.println(x[i]); // 或enu.values()[i]
        }
        System.out.println(x[0].compareTo(enu.c1) + " " + x[0].compareTo(enu.c3));
        enu y = enu.valueOf("c2");
        System.out.println(y.compareTo(x[1]));
        System.out.println(y.ordinal());
    }
}

```

可以定义其他成员和私有构造方法，此时枚举常量后面应该加分号。枚举常量可以加括号加值，这个值在构造函数调用，当存在加值的枚举常量时，不再能 `syso` 输出，需要重载。如：

```java
public class c1703 {
    enum enu {
        c1("lr580"), c2("awa"), c3(10);

        private int cnt = 1; // 好像不可以static
        private String dsc = "No response.";

        private enu(String s) {
            cnt += s.length();
            dsc = s;
        }

        private enu(int x) {
            cnt += x;
        }

        @Override
        public String toString() {
            return dsc;
        }

        public int getcnt() {
            return cnt;
        }

    }

    public static void main(String[] args) {
        for (int i = 0; i < enu.values().length; ++i) {
            System.out.println(enu.values()[i] + ", " + enu.values()[i].getcnt());
        }
    }
}

```

枚举类可以实现接口。那么每个枚举常量都加大括号，括号里定义接口的函数。常量间仍然用逗号分离。显然枚举类也可以有 main 方法。

`enum`不可以公有化构造方法，可以xxx(value)格式定义枚举

`enum`类名.values() 按序返回可以for : 的东西



#### Annotation

##### 语法

`import java.lang.annotation.*`

编译指令，不影响程序运行，但是可以避免一些警告。

基本格式为 `@` + 关键字。可以用于函数、类的范围 (类、构造方法、成员变量、方法、参数的声明)。

可以定义 Annotation 类型，隐含意思是继承 `java.lang.annotation.Annotation` 接口。关键字为 `@interface` ，加上名字，例如：

```java
public @interface NoMemberAnnotation {
}
```

可以包含成员，成员类型有 `String, Class, primitive, enumerated, annotation` 及其数组。唯一成员的名字一般设为 `value` 。可以设置默认值，加上关键字`default`和值。格式为：

`类型 名字();` 或 `类型 名字() default 值;` 

注意 public 的话，必须单独放一个代码文件。可以设置为内部 public 类。

例如：

```java
public @interface sthanno {
    String dsc();
    Class type();
}
```

```java
public @interface sthanno {
    String dsc() default "no dsc";
    Class type() default void.class; 
}
```

定义的时候，可以通过 `@Target` 来设置使用的程序元素种类，不设置表示通配。枚举类 `ElementType` 的常量通常用来设置，有：

- `ANNOTATION_TYPE`
- `TYPE` 类、接口、枚举、`Annotation` 类型
- `CONSTRUCTOR` 构造方法
- `FIELD` 成员变量、枚举常量
- `METHOD` 
- `PARAMETER`
- `LOCAL_VARIABLE`
- `PACKAGE`

如果有多个，用大括号包起来。

通过 `@Retention` 设置有效范围。枚举类 `RetentionPolicy` 常量：

- `SOURCE` 不编译 `Annotation` 类到文件中，有效范围最小
- `CLASS` 编译但运行时不加载到 JVM 中
- `RUNTIME` 加载到 JVM，有效范围最大

如：

```java
@Target(ElementType.CONSTRUCTOR)
@Retention(RetentionType.RUNTIME)
public @interface sthanno2 {
    String value() default "qwq";
}
```

> `import java.lang.annotation.ElementType;`

调用时 `@类名(成员=值, ...)` ，如：

```java
import java.lang.annotation.*;

public class c1606 {
    @Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
    @Retention(RetentionPolicy.RUNTIME)
    public @interface note {
        String dsc() default "No response.";
        Class type() default void.class;
    }

    @note(dsc = "userid", type = int.class)
    int id;

    // @note() 不允许用，没有定义构造方法枚举
    public c1606(@note(dsc = "id", type = int.class) int x) {
        id = x;
    }

    @note()
    public void prt() {
        System.out.println("" + id);
    }

    public static void main(String[] args) {
        new c1606(10).prt();
    }
}
```

如果设置为了 RUNTIME ，那么运行时可以通过反射获得信息。类 `Constructor, Field, Method` 都继承了 `AccessibleObject` 类，定义了三个关于 `Annotation` 的方法：

- `isAnnotationPresent(Class<? extends Annotation>)` 查看是否添加了指定类型的 Annotation
- `getAnnotation(Class<T>)` 获得指定类型的 Annotation ，返回对象或 null
- `getAnnotations()` 返回数组

`Constructor, Method` 还定义了：

- `getParameterAnnotations()` 以二维数组形式返回所有参数的 Annotation ，强转为对应类型的 Annotation 类，之后调用 `成员()` 获取值。

如：

```java
import java.lang.annotation.Annotation;
import java.lang.reflect.*;

public class c1607 {
    public static void main(String[] args) {
        c1606 x = new c1606(5);
        Class c = x.getClass();
        Constructor cons = c.getConstructors()[0];
        if (cons.isAnnotationPresent(c1606.note.class) == false) {
            System.out.println("No annotations.");
        }
        Annotation[][] paraAnno = cons.getParameterAnnotations();
        for (int i = 0; i < paraAnno.length; ++i) {
            for (int j = 0; j < paraAnno[i].length; ++j) {
                c1606.note a = (c1606.note)paraAnno[i][j];
                System.out.println(a.dsc() + ", " + a.type());
            }
        }
    }
}

```



##### 常用

> 参数前加 `@Nullable`，代表参数可空(但是真的缺省的话也会报错)
>
> ```java
> import org.eclipse.jdt.annotation.Nullable;
> // import org.springframework.lang.Nullable;
> ```





## Spring

### 安装与配置

#### 理论简介

##### 简介

SSM 框架：

- SpringMVC
- Spring
- MyBatis

C/S 萎缩，B/S 盛行，早期 B/S 鼻祖是 ASP，缺点是高访问量不行。J2EE 分层体系与 EJB(Enterprise JavaBean)开启分层编程。之后出现 MVC 框架，之后出现 Spring framework。之后形成旧三大框架 SSH(Struts2+Spring+hibernate)，struts2配置繁琐，性能慢，安全漏洞一个又一个。而hibernate性能差强人意，加上一些致命的bug漏洞，故出现注解编程方式，形成新三大框架 SSM，目前是软件开发核心(2018)。

三大框架只是市场的一部分，目前市场主流技术：大前端，移动端，微服务，互联网架构，大数据，人工智能等。
大前端：VOE,node.js
微服务：Dubbo和SpringCloud
互联网框架：Nginx,redis,mycat, RabbitMQ,docker，kubernetes

![image-20220901092233861](img/image-20220901092233861.png)

![image-20220901092250682](img/image-20220901092250682.png)

##### 实现

###### 依赖注入

核心：

Spring框架包含众多模块，如Core、Testing、Data Access、Web Servlet等，其中Core是整个Spring框架的核心模块。Core模块提供了IoC容器、AOP功能、数据绑定、类型转换等一系列的基础功能，而这些功能以及其他模块的功能都是建立在IoC和AOP之上的，所以IoC和AOP是Spring框架的核心。

IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。

说到IoC就不得不说DI（Dependency Injection），DI是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。

在具体的实现中，主要由三种注入方式：

1. 构造方法注入

   就是被注入对象可以在它的构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。然后，IoC Service Provider会检查被注入的对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。

2. setter方法注入

   通过setter方法，可以更改相应的对象属性。所以，当前对象只要为其依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些， 可以在对象构造完成后再注入。

3. 接口注入

   相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。相对于前两种依赖注入方式，接口注入比较死板和烦琐。

总体来说，构造方法注入和setter方法注入因为其侵入性较弱，且易于理解和使用，所以是现在使用最多的注入方式。而接口注入因为侵入性较强，近年来已经不流行了。

> 首先，需要明确的是spring对循环依赖的处理有三种情况：
>
> 1. 构造器的循环依赖：这种依赖spring是处理不了的，直接抛出BeanCurrentlylnCreationException异常。
> 2. 单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。
> 3. 非单例循环依赖：无法处理。
>
> 接下来，我们具体看看spring是如何处理第二种循环依赖的。
>
> Spring单例对象的初始化大略分为三步：
>
> 1. createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象；
> 2. populateBean：填充属性，这一步主要是多bean的依赖属性进行填充；
> 3. initializeBean：调用spring xml中的init 方法。
>
> 从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一步、第二步。也就是构造器循环依赖和field循环依赖。 Spring为了解决单例的循环依赖问题，使用了三级缓存。
>
> 这三级缓存的作用分别是：
>
> - singletonFactories ： 进入实例化阶段的单例对象工厂的cache （三级缓存）；
> - earlySingletonObjects ：完成实例化但是尚未初始化的，提前暴光的单例对象的Cache （二级缓存）；
> - singletonObjects：完成初始化的单例对象的cache（一级缓存）。
>
> 我们在创建bean的时候，会首先从cache中获取这个bean，这个缓存就是sigletonObjects。
>
> 让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。

###### AOP

AOP（Aspect Oriented Programing）是面向切面编程思想，这种思想是对OOP的补充，它可以在OOP的基础上进一步提高编程的效率。简单来说，它可以统一解决一批组件的共性需求（如权限检查、记录日志、事务管理等）。在AOP思想下，我们可以将解决共性需求的代码独立出来，然后通过配置的方式，声明这些代码在什么地方、什么时机调用。当满足调用条件时，AOP会将该业务代码织入到我们指定的位置，从而统一解决了问题，又不需要修改这一批组件的代码。

> 面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。
>
> AOP的术语：
>
> - 连接点（join point）：对应的是具体被拦截的对象，因为Spring只能支持方法，所以被拦截的对象往往就是指特定的方法，AOP将通过动态代理技术把它织入对应的流程中。
> - 切点（point cut）：有时候，我们的切面不单单应用于单个方法，也可能是多个类的不同方法，这时，可以通过正则式和指示器的规则去定义，从而适配连接点。切点就是提供这样一个功能的概念。
> - 通知（advice）：就是按照约定的流程下的方法，分为前置通知、后置通知、环绕通知、事后返回通知和异常通知，它会根据约定织入流程中。
> - 目标对象（target）：即被代理对象。
> - 引入（introduction）：是指引入新的类和其方法，增强现有Bean的功能。
> - 织入（weaving）：它是一个通过动态代理技术，为原有服务对象生成代理对象，然后将与切点定义匹配的连接点拦截，并按约定将各类通知织入约定流程的过程。
> - 切面（aspect）：是一个可以定义切点、各类通知和引入的内容，SpringAOP将通过它的信息来增强Bean的功能或者将对应的方法织入流程。
>
> Spring AOP：
>
> AOP可以有多种实现方式，而Spring AOP支持如下两种实现方式。
>
> - JDK动态代理：这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。
> - CGLib动态代理：采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。
>
> Spring AOP为IoC的使用提供了更多的便利，一方面，应用可以直接使用AOP的功能，设计应用的横切关注点，把跨越应用程序多个模块的功能抽象出来，并通过简单的AOP的使用，灵活地编制到模块中，比如可以通过AOP实现应用程序中的日志功能。另一方面，在Spring内部，一些支持模块也是通过Spring AOP来实现的，比如事务处理。从这两个角度就已经可以看到Spring AOP的核心地位了。
>
> 1. Spring AOP只能对IoC容器中的Bean进行增强，对于不受容器管理的对象不能增强。
> 2. 由于CGLib采用动态创建子类的方式生成代理对象，所以不能对final修饰的类进行代理。
>
> JDK动态代理
>
> 这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。
>
> CGLib动态代理
>
> 采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。
>
> 在性能方面，CGLib创建的代理对象比JDK动态代理创建的代理对象高很多。但是，CGLib在创建代理对象时所花费的时间比JDK动态代理多很多。所以，对于单例的对象因为无需频繁创建代理对象，采用CGLib动态代理比较合适。反之，对于多例的对象因为需要频繁的创建代理对象，则JDK动态代理更合适。

###### Bean

容器：

Spring主要提供了两种类型的容器：BeanFactory和ApplicationContext。

- BeanFactory：是基础类型的IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延 迟初始化策略。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。

  BeanFactory是一个类工厂，与传统类工厂不同的是，BeanFactory是类的通用工厂，它可以创建并管理各种类的对象。这些可被创建和管理的对象本身没有什么特别之处，仅是一个POJO，Spring称这些被创建和管理的Java对象为Bean。并且，Spring中所说的Bean比JavaBean更为宽泛一些，所有可以被Spring容器实例化并管理的Java类都可以成为Bean。

  BeanFactory是Spring容器的顶层接口，Spring为BeanFactory提供了多种实现，最常用的是XmlBeanFactory。但它在Spring 3.2中已被废弃，建议使用XmlBeanDefinitionReader、DefaultListableBeanFactory替代。BeanFactory最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的Bean。

- ApplicationContext：它是在BeanFactory的基础上构建的，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容 器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。

Spring通过IoC容器来管理Bean，我们可以通过XML配置或者注解配置，来指导IoC容器对Bean的管理。因为注解配置比XML配置方便很多，所以现在大多时候会使用注解配置的方式。

以下是管理Bean时常用的一些注解：

1. @ComponentScan用于声明扫描策略，通过它的声明，容器就知道要扫描哪些包下带有声明的类，也可以知道哪些特定的类是被排除在外的。
2. @Component、@Repository、@Service、@Controller用于声明Bean，它们的作用一样，但是语义不同。@Component用于声明通用的Bean，@Repository用于声明DAO层的Bean，@Service用于声明业务层的Bean，@Controller用于声明视图层的控制器Bean，被这些注解声明的类就可以被容器扫描并创建。
3. @Autowired、@Qualifier用于注入Bean，即告诉容器应该为当前属性注入哪个Bean。其中，@Autowired是按照Bean的类型进行匹配的，如果这个属性的类型具有多个Bean，就可以通过@Qualifier指定Bean的名称，以消除歧义。
   1. @Autowired是Spring提供的注解，@Resource是JDK提供的注解。
   2. @Autowired是只能按类型注入，@Resource默认按名称注入，也支持按类型注入。
   3. @Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。
4. @Scope用于声明Bean的作用域，默认情况下Bean是单例的，即在整个容器中这个类型只有一个实例。可以通过@Scope注解指定prototype值将其声明为多例的，也可以将Bean声明为session级作用域、request级作用域等等，但最常用的还是默认的单例模式。
5. @PostConstruct、@PreDestroy用于声明Bean的生命周期。其中，被@PostConstruct修饰的方法将在Bean实例化后被调用，@PreDestroy修饰的方法将在容器销毁前被调用。

默认情况下，Bean在Spring容器中是单例的，我们可以通过@Scope注解修改Bean的作用域。该注解有如下5个取值，它们代表了Bean的5种不同类型的作用域：

| 类型          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| singleton     | 在Spring容器中仅存在一个实例，即Bean以单例的形式存在。       |
| prototype     | 每次调用getBean()时，都会执行new操作，返回一个新的实例。     |
| request       | 每次HTTP请求都会创建一个新的Bean。                           |
| session       | 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。 |
| globalSession | 同一个全局的Session共享一个Bean，一般用于Portlet环境。       |

Spring容器管理Bean，涉及对Bean的创建、初始化、调用、销毁等一系列的流程，这个流程就是Bean的生命周期。整个流程参考下图：

<img src="img/7EF8F66C3DFA7434E4CA11B47CF8F1F7.png" alt="img" style="zoom:80%;" />

这个过程是由Spring容器自动管理的，其中有两个环节我们可以进行干预。

1. 我们可以自定义初始化方法，并在该方法前增加@PostConstruct注解，届时Spring容器将在调用SetBeanFactory方法之后调用该方法。
2. 我们可以自定义销毁方法，并在该方法前增加@PreDestroy注解，届时Spring容器将在自身销毁前，调用这个方法。

Spring容器本身并没有提供Bean的线程安全策略。如果单例的Bean是一个无状态的Bean，即线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例的Bean是线程安全的。比如，Controller、Service、DAO这样的组件，通常都是单例且线程安全的。如果单例的Bean是一个有状态的Bean，则可以采用ThreadLocal对状态数据做线程隔离，来保证线程安全。

###### 事务

Spring为事务管理提供了一致的编程模板，在高层次上建立了统一的事务抽象。也就是说，不管是选择MyBatis、Hibernate、JPA(Java Persistence API)还是Spring JDBC，Spring都可以让用户以统一的编程模型进行事务管理。

Spring支持两种事务编程模型：

1. 编程式事务

   Spring提供了TransactionTemplate模板，利用该模板我们可以通过编程的方式实现事务管理，而无需关注资源获取、复用、释放、事务同步及异常处理等操作。相对于声明式事务来说，这种方式相对麻烦一些，但是好在更为灵活，我们可以将事务管理的范围控制的更为精确。

2. 声明式事务

   Spring事务管理的亮点在于声明式事务管理，它允许我们通过声明的方式，在IoC配置中指定事务的边界和事务属性，Spring会自动在指定的事务边界上应用事务属性。相对于编程式事务来说，这种方式十分的方便，只需要在需要做事务管理的方法上，增加@Transactional注解，以声明事务特征即可。

当我们调用一个业务方法时，它的内部可能会调用其他的业务方法，以完成一个完整的业务操作。这种业务方法嵌套调用的时候，如果这两个方法都是要保证事务的，那么就要通过Spring的事务传播机制控制当前事务如何传播到被嵌套调用的业务方法中。

Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时如何进行传播，如下表：

| 事务传播类型              | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| PROPAGATION_REQUIRED      | 如果当前没有事务，则新建一个事务；如果已存在一个事务，则加入到这个事务中。这是最常见的选择。 |
| PROPAGATION_SUPPORTS      | 支持当前事务，如果当前没有事务，则以非事务方式执行。         |
| PROPAGATION_MANDATORY     | 使用当前的事务，如果当前没有事务，则抛出异常。               |
| PROPAGATION_REQUIRES_NEW  | 新建事务，如果当前存在事务，则把当前事务挂起。               |
| PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，则把当前事务挂起。   |
| PROPAGATION_NEVER         | 以非事务方式执行操作，如果当前存在事务，则抛出异常。         |
| PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |

事务的打开、回滚和提交是由事务管理器来完成的，我们使用不同的数据库访问框架，就要使用与之对应的事务管理器。在Spring Boot中，当你添加了数据库访问框架的起步依赖时，它就会进行自动配置，即自动实例化正确的事务管理器。

对于声明式事务，是使用@Transactional进行标注的。这个注解可以标注在类或者方法上。

- 当它标注在类上时，代表这个类所有公共（public）非静态的方法都将启用事务功能。
- 当它标注在方法上时，代表这个方法将启用事务功能。

另外，在@Transactional注解上，我们可以使用isolation属性声明事务的隔离级别，使用propagation属性声明事务的传播机制。

###### MVC

MVC是一种设计模式，在这种模式下软件被分为三层，即Model（模型）、View（视图）、Controller（控制器）。Model代表的是数据，View代表的是用户界面，Controller代表的是数据的处理逻辑，它是Model和View这两层的桥梁。将软件分层的好处是，可以将对象之间的耦合度降低，便于代码的维护。

MVC 执行流程：

1. 整个过程开始于客户端发出的一个HTTP请求，Web应用服务器接收到这个请求。如果匹配DispatcherServlet的请求映射路径，则Web容器将该请求转交给DispatcherServlet处理。
2. DispatcherServlet接收到这个请求后，将根据请求的信息（包括URL、HTTP方法、请求报文头、请求参数、Cookie等）及HandlerMapping的配置找到处理请求的处理器（Handler）。可将HandlerMapping看做路由控制器，将Handler看做目标主机。值得注意的是，在Spring MVC中并没有定义一个Handler接口，实际上任何一个Object都可以成为请求处理器。
3. 当DispatcherServlet根据HandlerMapping得到对应当前请求的Handler后，通过HandlerAdapter对Handler进行封装，再以统一的适配器接口调用Handler。HandlerAdapter是Spring MVC框架级接口，顾名思义，HandlerAdapter是一个适配器，它用统一的接口对各种Handler方法进行调用。
4. 处理器完成业务逻 辑的处理后，将返回一个ModelAndView给DispatcherServlet，ModelAndView包含了视图逻辑名和模型数据信息。
5. ModelAndView中包含的是“逻辑视图名”而非真正的视图对象，DispatcherServlet借由ViewResolver完成逻辑视图名到真实视图对象的解析工作。
6. 当得到真实的视图对象View后，DispatcherServlet就使用这个View对象对ModelAndView中的模型数据进行视图渲染。
7. 最终客户端得到的响应消息可能是一个普通的HTML页面，也可能是一个XML或JSON串，甚至是一张图片或一个PDF文档等不同的媒体形式。

> 注解：
>
> @RequestMapping：
>
> 作用：该注解的作用就是用来处理请求地址映射的，也就是说将其中的处理器方法映射到url路径上。
>
> 属性：
>
> - method：是让你指定请求的method的类型，比如常用的有get和post。
> - value：是指请求的实际地址，如果是多个地址就用{}来指定。
> - produces：指定返回的内容类型，当request请求头中的Accept类型中包含指定的类型才可以返回的。
> - consumes：指定处理请求的提交内容类型，比如一些json、html、text等的类型。
> - headers：指定request中必须包含那些的headed值时，它才会用该方法处理请求的。
> - params：指定request中一定要有的参数值，它才会使用该方法处理请求。
>
> @RequestParam：
>
> 作用：是将请求参数绑定到你的控制器的方法参数上，是Spring MVC中的接收普通参数的注解。
>
> 属性：
>
> - value是请求参数中的名称。
> - required是请求参数是否必须提供参数，它的默认是true，意思是表示必须提供。
>
> @RequestBody：
>
> 作用：如果作用在方法上，就表示该方法的返回结果是直接按写入的Http responsebody中（一般在异步获取数据时使用的注解）。
>
> 属性：required，是否必须有请求体。它的默认值是true，在使用该注解时，值得注意的当为true时get的请求方式是报错的，如果你取值为false的话，get的请求是null。
>
> @PathVaribale：
>
> 作用：该注解是用于绑定url中的占位符，但是注意，spring3.0以后，url才开始支持占位符的，它是Spring MVC支持的rest风格url的一个重要的标志。

拦截器会对处理器进行拦截，这样通过拦截器就可以增强处理器的功能。Spring MVC中，所有的拦截器都需要实现HandlerInterceptor接口，该接口包含如下三个方法：preHandle()、postHandle()、afterCompletion()。

这些方法的执行流程如下图：

<img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694469544/31C010B3F63CB1CC1ADC5481E9E77BDB" alt="img" style="zoom:80%;" />

> Spring MVC拦截器的开发步骤如下：
>
> 1. 开发拦截器：
>
>    实现handlerInterceptor接口，从三个方法中选择合适的方法，实现拦截时要执行的具体业务逻辑。
>
> 2. 注册拦截器：
>
>    定义配置类，并让它实现WebMvcConfigurer接口，在接口的addInterceptors方法中，注册拦截器，并定义该拦截器匹配哪些请求路径。
>
> 如果是对Controller记性拦截，则可以使用Spring MVC的拦截器。
>
> 如果是对所有的请求（如访问静态资源的请求）进行拦截，则可以使用Filter。
>
> 如果是对除了Controller之外的其他Bean的请求进行拦截，则可以使用Spring AOP。

DAO是Data Access Object的缩写，即数据访问对象，在项目中它通常作为独立的一层，专门用于访问数据库。这一层的具体实现技术有很多，常用的有Spring JDBC、Hibernate、JPA、MyBatis等，在Spring框架下无论采用哪一种技术访问数据库，它的编程模式都是统一的。

###### 杂项

cookie vs session:

1. 存储位置不同：cookie存放于客户端；session存放于服务端。
2. 存储容量不同：单个cookie保存的数据<=4KB，一个站点最多保存20个cookie；而session并没有上限。
3. 存储方式不同：cookie只能保存ASCII字符串，并需要通过编码当时存储为Unicode字符或者二进制数据；session中能够存储任何类型的数据，例如字符串、整数、集合等。
4. 隐私策略不同：cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的；session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。
5. 生命周期不同：可以通过设置cookie的属性，达到cookie长期有效的效果；session依赖于名为JSESSIONID的cookie，而该cookie的默认过期时间为-1，只需关闭窗口该session就会失效，因此session不能长期有效。
6. 服务器压力不同：cookie保存在客户端，不占用服务器资源；session保管在服务器上，每个用户都会产生一个session，如果并发量大的话，则会消耗大量的服务器内存。
7. 浏览器支持不同：cookie是需要浏览器支持的，如果客户端禁用了cookie，则会话跟踪就会失效；运用session就需要使用URL重写的方式，所有用到session的URL都要进行重写，否则session会话跟踪也会失效。
8. 跨域支持不同：cookie支持跨域访问，session不支持跨域访问。

对于敏感数据，应存放在session里，因为cookie不安全。

对于普通数据，优先考虑存放在cookie里，这样会减少对服务器资源的占用。

ession依赖于cookie。

当客户端首次访问服务器时，服务器会为其创建一个session对象，该对象具有一个唯一标识SESSIONID。并且在响应阶段，服务器会创建一个cookie，并将SESSIONID存入其中。

客户端通过响应的cookie而持有SESSIONID，所以当它再次访问服务器时，会通过cookie携带这个SESSIONID。服务器获取到SESSIONID后，就可以找到与之对应的session对象，进而从这个session中获取该客户端的状态。



- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。

GET请求是可以将参数放到BODY里面的，官方并没有明确禁止，但给出的建议是这样不符合规范，无法保证所有的实现都支持。这就意味着，如果你试图这样做，可能出现各种未知的问题，所以应该当避免。

HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它。

POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI。所以，POST方法不具备幂等性。



400状态码标识请求的语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。通常情况下，是本次请求中包含有错误的参数，此时应该排查前端传递的参数。

服务端出现请求乱码的原因是，客户端编码与服务器解码方案不一致，可以有如下几种解决办法：

1. 将获得的数据按照客户端编码转成BYTE，再将BYTE按服务端编码转成字符串，这种方案对各种请求方式均有效，但是十分的麻烦。
2. 在接受请求数据之前，显示声明实体内容的编码与服务器一致，这种方式只对POST请求有效。
3. 修改服务器的配置文件，显示声明请求路径的编码与服务器一致，这种方式只对GET请求有效。



Spring给我们提供了可执行定时任务的线程池ThreadPoolTaskScheduler，该线程池提供了多个可以与执行定时任务的方法，如下图。在Spring Boot中，只需要在配置类中启用线程池注解，就可以直接使用这个线程池了。

<img src="img/D5738E9CC452DEB565C933A55C36FBFB.png" alt="img" style="zoom:80%;" />



可以定义一个记录日志的组件，并通过AOP将其织入到这个接口的调用中。这种方式对接口无需做任何改造，业务代码中也无需增加任何调用的逻辑，完美地消除了记录日志和业务代码的耦合度。

JPA即Java Persistence API，它是一个基于O/R映射的标准规范。也就是说它指定标准规则，不提供实现，软件提供商可以按照标准规范来实现，而使用者只需按照规范中定义的方式来使用，不用和软件提供商打交道。JPA主要实现有Hibernate、EclipseLink、OpenJPA等，我们使用JPA来开发，无论是采用哪一种实现方式都一样。

> O/R映射层是持久层的一个特例，它的数据模型是对象模型（Object），存储模型是关系模型（Relational）

#### 版本关系

![image-20220913001252251](img/image-20220913001252251.png)

本笔记多以 5.1.9 framework 为例，建议用 java 1.8，高版本可能会出错。

> 例如用注解装配可能会遇到 `org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class`，此时应当降低版本。

#### tomcat

[参考](https://blog.csdn.net/m0_53336918/article/details/126224810) 若 preference 没有 server 栏，先安装：

在 help 查看版本号，然后在 help-install new software-add 输入版本号和 `http://download.eclipse.org/releases/+你的eclipse的version`，如 2021-06。之后选择 web, xml…… 大类，选 jst server adapters extensions，一路 next，等待安装完毕并重启

[参考](https://blog.csdn.net/MinggeQingchun/article/details/109204867?utm_medium=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-109204867-blog-null.pc_404_mixedpudn&depth_1-utm_source=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-109204867-blog-null.pc_404_mixedpud) 在上一步中，建议还需要再装多四个插件 Eclipse Java EE Developer Tools, Eclipse Java Web Developer Tools, Eclipse Web Developer Tools, Eclipse XML Editors and Tools。否则新建项目没有file-new-dynamic web project。

下载 tomcat 解压(一个参考是 [提取码x9wb](https://pan.baidu.com/s/11JBPWl3tMxRfQyAkgDMNhg))，记录根目录，然后preference-server-runtime environment，选 apache tomcat，找到刚刚的目录输入，finish

#### spring头自动引入

下载 spring-framework 并解压到一个目录。preference-xml-xml catalog-use specified entries-add，然后点 file system 打开目录下 `schema\beans\spring-beans.xsd` 下面 key 键入 `http://www.springframework.org/schema/beans/spring-beans.xsd`(可从 `applicationContext.xml` 拷贝)

新建一个 applicationContext.xml(不能打开就重启)，点下面 source 输入源码：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans></beans>
```

点回 design，右击 bean 点 edit namespaces，add，specify new namespace，browse，select xml catalog entry，找到(或搜索到)刚刚的 xsd，ok，把 `http://www.springframework.org/schema/beans/` 键入到 namespace name。此时可以看到已经导入。

再次 edit namespaces-add-select from registered namespaces，勾选 xsi, ok。看到导入成功，有：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd "></beans>
```

windows-preferences-xml-xml files-editor-templates-new，键入 `spring_beans` 为 name，pattern 是上文 xml。

使用：在 xml 源码里，输入 spring，按 `alt+/`，点击 `spring_beans`，自动生成。

接着，仿照类似的方法，添加一个 `spring_context`，作为配置自动引入 context 约束，以后要用。内容为：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd ">
</beans>
```

再引入 aop 模板：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:context="http://www.springframework.org/schema/context" 
xmlns:aop="http://www.springframework.org/schema/aop"
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd 
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd ">
</beans>
```

再引入` tx`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" 
xmlns:tx="http://www.springframework.org/schema/tx" 
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd 
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd ">
```

上传文件支持：

```xml
xmlns:p="http://www.springframework.org/schema/p"
```

比较完整：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:util="http://www.springframework.org/schema/util"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="
                           http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop 
                           http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/tx 
                           http://www.springframework.org/schema/tx/spring-tx.xsd
                           http://www.springframework.org/schema/util 
                           http://www.springframework.org/schema/util/spring-util.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/mvc
                           http://www.springframework.org/schema/mvc/spring-mvc.xsd">
```





#### hello world

file-new-project-dynamic web project，随便输入项目名，finish

导入 jar 包：(具体而言，先复制到项目根目录如 `lib/`，然后在左侧栏框选这些 jar，右击build path-add to build path；如果要删除，点referenced libraries同理右击build path-remove from build path)

```
commons-logging-1.2.jar
spring-beans-5.1.9.RELEASE.jar
spring-context-5.1.9.RELEASE.jar
spring-core-5.1.9.RELEASE.jar
spring-expression-5.1.9.RELEASE.jar
spring-test-5.1.9.RELEASE.jar
spring-web-5.1.9.RELEASE.jar
```

<!--<div href="springdao"></div>-->

创建接口和接口的实体类：(先在 `src/first/java` 下建包)(不想这个路径的话可以创项目时 next 后改一下，但是改不成 `src`，必须加子目录)

```java
package com.first.dao;

public interface HelloSpring {
    public void hello();
}
```

```java
package com.first.dao;

public class HelloSpringImpl implements HelloSpring {
    @Override
    public void hello() {
        System.out.println("再见! Spring!");
    }
}
```

配置文件的命名规则：id 是 bean 的唯一标识符，不能重复，首字母小写之后驼峰。class是类的类型，报名.类名，如：

建一个 xml，如：`applicationContext.xml`，可以放 `src/`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd ">
    <bean id="hello" class="com.first.dao.HelloSpringImpl"/>
</beans>
```

建一个测试类：

```java
package com.first.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.first.dao.HelloSpring;

public class TestHello {
    //@Text 对应第三行 import
    @Test
    public void test01() {
        @SuppressWarnings("resource")
        ApplicationContext context = 
          new ClassPathXmlApplicationContext("applicationContext.xml");
        HelloSpring helloSpring = (HelloSpring)context.getBean("hello");
        helloSpring.hello();
    }
}
```

运行，选有 junit 那个，能跑出结果就对了。(输入 @Test 时报错时，点一下 add junit 4 那个)

原理解释：

Spring容器启动时，首先会加载Spring的核心配置文件；Spring容器逐行进行解析xml配置文件；当解析bean标签时开始创建对象，根据class属性中的值，通过反射机制创建对象；将创建好的对象存入Spring所维护的`Map<key,value>`中 key就是bean中的ID，value就是生成的对象；用户传入key，通过key来获取Map中的value（对象）；Spring容器中的对象的生命周期默认条件下与Spring容器“同生共死”

默认情况下，多次获取同一个id的bean，得到的将是同个对象，即使是同一个类，如果配置多个`<bean>`标签具有不同的id，每个id都会在内置的Map有一个键值对，其中的值是这个类创建的不同对象;不允许配置多个相同ID的`<bean>`标签，如果配置，则启动异常

若通过class类型获取对象 。通过class类型获取时，可能会有风险，如果出现相同的class类型会报错，如 `HelloSpring helloSpring =context.getBean(HelloSpring.class);`

> 若 test 跑不通报错 class not found，可以preferences改java-compiler-building-build path problems-abort build when 打勾，incomplete 和 circular 两项改 warning



### Spring IOC

#### 概念

创建对象的方式：

```java
Person p1 = new Person();  // 传统
```

```java
// 由Spring容器创建
Person p2 = Spring容器.getXXX()方法；  
HelloSpring helloSpring = (HelloSpring)context.getBean("hello");
```

```mermaid
graph LR
	A["person"]-->|"传统方式new"|B["获取对象"]
	A-->|"Spring容器管理对象"|C["Spring容器<br>xxx对象"]
	B-->|"GetXXX"|C
```

IOC(Inversion of Control)是控制反转，是Spring框架的核心。在Spring中，对象不再由调用者创建，而是由Spring容器来创建，这样，控制权由调用者转移到Spring容器，控制权发生了反转，这就是Spring的控制反转

DI是依赖注入，Spring在创建对象过程中，可以根据配置，对对象的属性进行设置（赋值），这个过程称之为依赖注入。DI实际上是IOC的一个步骤。就是对创建的对象的属性进行设置

依赖注入的类型：使用构造方法注入，使用属性的setter方法注入，如：

```java
Person p1 = new Person("果冻");
Person p2 = new Person();
p2.setName("白茶");
```

#### BeanFactory

Spring容器是生成Bean实例的地方，并管理容器中的Bean。`Spring IoC`容器的设计主要是基于`BeanFactory`和`ApplicationContext`两大核心接口，其中`ApplicationContext`是`BeanFactory`的子接口,它们都可以当做`SpringIOC`容器

`BeanFactory`是Spring容器的根接口。
Spring IOC容器的实现从根源来讲是`BeanFactory`接口，但真正可以作为一个可以独立使用的IOC容器还是`DefaultListableBeanFactory`，因此可以这么说，`DefaultListableBeanFactory` 是整个Spring IOC的鼻祖。
`BeanFactory`接口有多个实现类，其中`XmlBeanFactory`比较常用，`XmlBeanFactory`，继承自`DefaultListableBeanFactory`，重写了一些功能，使自己更强大,`XmlBeanFactory`根据XML配置文件中的定义来装配Bean。

创建`XmlBeanFactory`实例时，需要提供XML核心配置文件的绝对路径

```java
@Test
public void test02(){
       XmlBeanFactory context = new XmlBeanFactory(new FileSystemResource("E:/java/E64workspace/MyFirstSpring/src/applicationContext.xml"));
      //获取对象
     HelloSpring helloSpring = (HelloSpring)context.getBean("hello");
     //执行操作
    helloSpring.hello();
}
```

`ApplicationContext`接口是`BeanFactory`的子接口。也称为应用上下文，它能提供更多企业级的服务，例如解析配置文件的文本信息等。创建`ApplicationContext`接口实例通常有三种方法

- 通过`ClassPathXmlApplicationContext`创建

  `ClassPathXmlApplicationContext`将从类路径`classPath`目录（`src`根目录）寻找指定的XML配置文件

  ```java
  @Test
  public void test01(){
         //启动Spring容器，加载配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
       //获取对象
       HelloSpring helloSpring = (HelloSpring)context.getBean("hello");
       //执行操作
       helloSpring.hello();
  }
  ```

- 通过`FileSystemXmlApplicationContext`创建

  `FileSystemXmlApplicationContext`将从指定文件的**绝对路径**中寻找XML核心配置文件，找到并装载完成`ApplicationContext`的实例化工作

  ```java
  @Test
  public void test03(){
  //初始化Spring容器ApplicationContext，加载配置文件
  	ApplicationContext context = 
  	new FileSystemXmlApplicationContext("E:/java/E64workspace/MyFirstSpring/src/applicationContext.xml");
  	HelloSpring helloSpring = (HelloSpring)context.getBean("hello");//获取对象
  	helloSpring.hello();//执行操作
  }
  ```

- 通过Web服务器实例化`ApplicationContext`容器 (最终目的)

  一般使用基于`org.springframework.web.context.ContextLoaderListener`的实现方式（需要将`spring-web-5.0.2.RELEASE.jar`复制到`WEB-INF/lib`目录中）

  定义`web.xml`，由web容器自动加载配置文件，初始化`ApplicationContext`实例。通过`web.xml`配置，web容器会自动加载`context-param`中的配置文件,初始化`ApplicationContext`实例

  ```xml
  <context-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:applicationContext.xml</param-value>
    </context-param>
    <listener>
       <listener-class>
               org.springframework.web.context.ContextLoaderListener 
       </listener-class>
   </listener>
  ```



#### 依赖注入

##### 构造方法注入

Spring框架可以采用Java的反射机制，通过构造方法完成依赖注入。如果使用构造方法注入时，应该添加构造方法，但注意要先写无参构造

步骤：

先创建 `dao` 包，并创建一个接口和一个接口实现类。[见这里](#hello world) <!--[见这里](href=#springdao)-->

创建`dao`的目的是在service中使用构造方法依赖注入自己创建的接口对象

创建一个 service 包，创建 service 接口和实现类，注意先写无参构造。在实现类用构造方法依赖注入上文接口对象。如：

```java
package com.first.service;

public interface TestDIService {
    public void sayHello();
}
```

```java
package com.first.service;

import com.first.dao.HelloSpring;

public class TestDIServiceImpl implements TestDIService {
    private HelloSpring testDIDao;

    public TestDIServiceImpl() {
    }

    public TestDIServiceImpl(HelloSpring testDIDao) {
        this.testDIDao = testDIDao;
    }
    
    @Override
    public void sayHello() {
        testDIDao.hello();
    }
}
```

然后在 `src` 根目录创建Spring配置文件`applicationContext.xml`。在配置文件中，首先，将`dao`实现类托管给Spring，让Spring创建其对象。其次，将service实现类托管给Spring，让Spring创建其对象，同时给构造方法传递实参

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd ">
	<bean id="myTestDIDao" class="com.first.dao.HelloSpringImpl" />
	<bean id="testDIService"
		class="com.first.service.TestDIServiceImpl">
		<constructor-arg index="0" ref="myTestDIDao" />
	</bean>
</beans>
```

`constructor-arg` 是将 `dao` 那个 bean 注入到该类属性 `testDIDao` 上。用 index 也可以用 name，name 就参数名。前者更好维护。ref 也可以用 value，对应一般的值如整数，字符串等(当然都需要引号)。下setter同。注意到参数名必须与属性名一致，如 `setName` 的参数名应当是 `name` 其属性名是 `name`，参数名不能是 `myname`。具体见下一节 Bean。

创建一个 test 包，创建测试类：

```java
package com.first.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.first.service.TestDIService;
import org.junit.Test;

public class TestDI {
    @Test
    public void test01() {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        TestDIService ts = (TestDIService) context.getBean("testDIService");
        ts.sayHello();
    }
}
```



##### 属性setter注入

setter方法注入是Spring框架中最主流的注入方式，它利用Java Bean规范所定义的setter方法来完成注入，灵活且可读性高。setter方法注入，Spring框架也是使用Java的反射机制实现的。
setter方法注入的前提条件，为属性赋值时必须添加set方法，否则不能正确注入

重写一个service实现类：

```java
package com.first.service;

import com.first.dao.HelloSpring;

public class TestDIServiceImpl2 implements TestDIService {
    private HelloSpring testDIDao;

    public void setTestDIDao(HelloSpring testDIDao) {
        this.testDIDao = testDIDao;
    }

    @Override
    public void sayHello() {
        testDIDao.hello();
        System.out.println("setter注入");
    }
}
```

增加 XML：

```xml
<bean id="testDIService2"
      class="com.first.service.TestDIServiceImpl2">
    <property name="testDIDao" ref="myTestDIDao" />
</bean>
```

增加测试类一个方法：(那么运行时会先后跑所有带 `@Test` 的方法)

```java
@Test
public void test02() {
    @SuppressWarnings("resource")
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
    TestDIService ts = (TestDIService) context.getBean("testDIService2");
    ts.sayHello();
}
```



### Spring Bean

#### 属性

Spring可以看作一个大型工厂，生产和管理Spring容器中的Bean。如何使用这个工厂生产和管理Bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持XML和Properties两种格式的配置文件，在实际开发中，常用XML格式的配置文件。

`<bean>` 的属性的配置：

| 属性  | 描述                                |
| ----- | ----------------------------------- |
| id    | Bean在`BeanFactory`工厂中的唯一标记 |
| class | Bean的具体实现类，使用类的全名称    |
| scope | 制定Bean的作用域                    |

| 属性                | 描述                                 |
| ------------------- | ------------------------------------ |
| `<constructor-arg>` | 使用构造方法注入，指定构造方法的参数 |
| `<property>`        | 用于设置一个属性                     |
| `<list>`            | 用于封装List或数组类型的依赖注入     |
| `<map>`             | 用于封装Map类型的依赖注入            |
| `<set>`             | 用于封装set类型的依赖注入            |
| `<entry>`           | 用于设置一个键值对                   |

对 `constructor-arg` 子标签，可以用从 0 开始的下标 index，属性名 name，和值 value 或 bean 引用 ref。index 和 name 可以同时用。Java不会维护形参的名称,所以使用name属性进行注入时,会发生风险,所以建议用index进行。

Spring框架实例化Bean有三种方式：

- 构造方法实例化(最常用，即上文方法)
- 静态工厂实例化
- 实例工厂实例化

在Spring框架中，Spring容器可以调用Bean对应类中构造方法来实例化Bean，这种方式称为构造方法实例化。说明：使用构造方法注入，添加有参构造方法时，切记先添加无参构造

注入方式的分析：如果程序员自己写代码，set注入居多，如果是软件架构使用构造注入居多

如：

```java
package com.sec.pojo;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class User {
    private String name;
    private List<String> hobbyList;
    private Map<String, String> residencyMap;
    private Set<String> aliasSet;
    private String[] attrs;

    public User(String name, List<String> hobbyList, Map<String, String> residencyMap,
            Set<String> aliasSet, String[] attrs) {
        this.name = name;
        this.hobbyList = hobbyList;
        this.residencyMap = residencyMap;
        this.aliasSet = aliasSet;
        this.attrs = attrs;
    }

    @Override
    public String toString() {
        return "[uname=" + name + ", hobbyList=" + hobbyList + ", residencyMap=" + residencyMap
                + ", aliasSet=" + aliasSet + ", attrs=" + Arrays.toString(attrs) + "]";
    }
}
```

```xml
<bean id="user1" class="com.sec.pojo.User">
    <constructor-arg index="0" name="name" value="弥明" />
    <constructor-arg index="1" name="hobbyList">
        <list>
            <value>赚钱</value>
            <value>卖课</value>
            <value>科研</value>
        </list>
    </constructor-arg>
    <constructor-arg index="2" name="residencyMap">
        <map>
            <entry key="lx" value="蓝星" />
            <entry key="scnu" value="I栋114" />
        </map>
    </constructor-arg>
    <constructor-arg index="3" name="aliasSet">
        <set>
            <value>阿六</value>
            <value>小明</value>
        </set>
    </constructor-arg>
    <constructor-arg index="4" name="attrs">
        <array>
            <value>聪明</value>
            <value>勤劳</value>
        </array>
    </constructor-arg>
</bean>
```

注：也可以把 `constructor-arg` 全改成 `property`，去掉 `index`。对 `arg` 的 `name` 对应形参名，对 `property` 对应属性名。

```java
package com.sec.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.sec.pojo.User;

public class TestUser {
    @Test
    public void test01() {
        @SuppressWarnings("resource")
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        User user = (User) context.getBean("user1");
        System.out.println(user);
    }
}
```





#### 静态工厂实例化

抽象类和接口无构造函数，不能直接通过反射创建。静态工厂的本质是 `类名.静态方法`

使用静态工厂实例化Bean时，要求开发者在工厂类中创建一个静态方法来创建Bean的实例。配置Bean时，class属性指定静态工厂类，同时还需要使用`factory-method`属性指定工厂类中的静态方法

如：

##### 自定义类

###### 带无参构造

```java
package com.sec.instance;

public class Person {
    public String name;

    public Person() {
        name = "白茶";
    }

    public Person(String name) {
        this.name = name;
    }
}
```

```java
package com.sec.instance;

public class PersonStaticFactory {
    public PersonStaticFactory() {
        System.out.println("这是静态工厂");
    }

    private static Person personInstance = new Person("果冻");

    public static Person createInstance() {
        return personInstance;
    }
}
```

```xml
<bean id="personBaicha" class="com.sec.instance.Person" />
<bean id="personFactory"
      class="com.sec.instance.PersonStaticFactory"
      factory-method="createInstance" />
```

```java
package com.sec.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.sec.instance.Person;

public class TestPerson {
    @SuppressWarnings("resource")
    @Test
    public void test01() {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        Person baicha = (Person)context.getBean("personBaicha");
        System.out.println(baicha.name);
        Person guodong = (Person)context.getBean("personFactory");
        System.out.println(guodong.name);
    }
}
```

###### 不带无参构造

```java
package com.sec.instance;

public class Food {
    public String name;

    public Food(String name) {
        this.name = name;
    }
}
```

```java
package com.sec.instance;

public class FoodFactory {
    public static Food getFood() {
        return new Food("莉可炸弹");
    }
}
```

```xml
<bean id="food" class="com.sec.instance.FoodFactory"
      factory-method="getFood" />
```

```java
@Test
public void test03() {
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
    Food food = (Food)context.getBean("food");
    System.out.println(food.name);
}
```



##### 标准库类

```java
package com.sec.instance;

import java.util.Calendar;

public class CalendarFactory {
    public static Calendar getCalendar() {
        return Calendar.getInstance();
    }
}
```

```xml
<bean id="calendar" class="com.sec.instance.CalendarFactory"
		factory-method="getCalendar" />
```

```java
@SuppressWarnings("deprecation")
@Test
public void test02() {
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
    Calendar calendar = (Calendar)context.getBean("calendar");
    System.out.println(calendar.getTime().toLocaleString());
}
```



#### 实例工厂实例化

实例工厂也可解决类无法通过无参构造创建的问题。思路和静态工厂类似。使用实例工厂实例化Bean时，要求开发者在工厂类中创建一个实例方法来创建Bean的实例。配置Bean时，需要创建实例工厂对象，然后在创建Bean对象的时候使用`factory-bean`属性指定配置的实例工厂，同时还需要使用`factory-method`属性指定实例工厂中的实例方法。

如：(添加自静态工厂实例化的例子)

```java
package com.sec.instance;

public class PersonInstanceFactory {
    public PersonInstanceFactory() {
        System.out.println("工厂开工啦");
    } // 每次创建 context 时会调用一次
    
    public Person createPersonInstance() {
        return new Person("锦乐");
    }
}
```

```xml
<bean id="personFactory2"
      class="com.sec.instance.PersonInstanceFactory" />
<bean id="personJinle" factory-bean="personFactory2"
      factory-method="createPersonInstance" />
```

```java
@Test
public void test04() {
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
    System.out.println("现在开始召唤锦乐");
    Person jinle = (Person)context.getBean("personJinle");
    System.out.println(jinle.name);
}
```



#### 懒加载机制

Spring默认会在初始化容器的过程中，解析xml，并将单例的bean创建并保存到map中，这样的机制在bean比较少时问题不大，但一旦bean非常多时，spring启动的过程需要花费大量的时间来创建bean，并且花费大量的空间存储bean，但这些bean可能很久都用不上，这种在启动时因为创建bean而在时间和空间上导致的浪费显得非常的不值得。

所以Spring提供了懒加载机制。所谓的懒加载机制就是可以规定指定的bean不在启动时立即创建，而是在后续第一次用到时才创建，从而减轻在启动过程中对时间和内存的消耗。为这样的 bean 添加属性：`lazy-init="true"`。或者，在 `beans` 标签默认加 `default-lazy-init="true"`。若 `lazt-init` 取值 default 向全局配置看齐，佛足额设 true, false。

如上例可以改成：

```xml
<bean id="personFactory2"
      class="com.sec.instance.PersonInstanceFactory" lazy-init="true" />
<bean id="personJinle" factory-bean="personFactory2"
      factory-method="createPersonInstance" lazy-init="true"/>
```



#### 作用域

| 作用域名    | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| singleton   | 默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例。 |
| prototype   | Spring容器每次获取prototype定义的Bean，容器都将创建一个新的Bean实例。 |
| request     | 在一次HTTP请求中容器将返回一个Bean实例，不同的HTTP请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用。 |
| session     | 在一个HTTP Session中，容器将返回同一个Bean实例。仅在Web Spring应用程序上下文中使用。 |
| application | 为每个`ServletContext`对象创建一个实例，即同一个应用共享一个Bean实例。仅在Web Spring应用程序上下文中使用。 |
| `websocket` | 为每个`WebSocket`对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用。 |

使用：bean 加属性 `scope="上述域名"`。对 singleton，即无论用多少个变量 `getBean`，都是得到同一个引用。

若对象是 prototype，默认懒加载，设置为 false 也会懒加载。



#### 生命周期

Bean的生命周期整个过程如下：

1．根据Bean的配置情况，实例化一个Bean。
2．根据Spring上下文对实例化的Bean进行依赖注入，即对Bean的属性进行初始化。
3．如果Bean实现了`BeanNameAware`接口，将调用它实现的`setBeanName(String beanId)`方法，此处参数传递的是Spring配置文件中Bean的ID。
4．如果Bean实现了`BeanFactoryAware`接口，将调用它实现的`setBeanFactory()`方法，此处参数传递的是当前Spring工厂实例的引用。  有唯一一个`setBeanName()`方法
5．如果Bean实现了`ApplicationContextAware`接口，将调用它实现的`setApplicationContext(ApplicationContext)`方法，此处参数传递的是Spring上下文实例的引用。
6．如果Bean关联了`BeanPostProcessor`接口，将调用预初始化方法`postProcessBeforeInitialization(Object obj, String s)`对Bean进行操作。



#### 注解装配

Bean的装配可以理解为将Bean依赖注入到Spring容器中，Bean的装配方式即Bean依赖注入的方式。Spring容器支持基于XML配置的装配、基于注解的装配以及自动装配等多种装配方式。

基于 XML 可以用构造方式和属性setter方式注入。

> ##### 基于注解的装配
>

在Spring框架中，尽管使用XML配置文件可以装配Bean,但如果应用中有大量的Bean需要装配，会导致配置文件过于庞大，不方便升级和维护，因此更多的时候推荐开发者使用注解的方式去装配Bean。 

```java
package com.sec.anno;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

//表示交给Spring容器管理当前类
@Component
public class TimeSchedule {
    @Value("混吃等死摆大烂")
    public String item;
}
```

用 context 的 xml 头，写一行开启包扫描，指定要扫描哪个 package：(注：会一并扫描其下的所有子包)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd ">
	<context:component-scan
		base-package="com.sec.anno" />
</beans>
```

多个包，如：

```xml
<context:component-scan
		base-package="easymall.service,easymall.controller,easymall.controller.admin" />
```

确保导入了 `spring-aop-5.1.9.RELEASE.jar` 包(注意这点)。测试：

```java
@Test
public void test02() {
    @SuppressWarnings("resource")
    ApplicationContext context = new ClassPathXmlApplicationContext("spring2.xml");
    TimeSchedule timeSchedule = (TimeSchedule) context.getBean("timeSchedule");
    System.out.println(timeSchedule.item);
}
```

调用格式：原类名，但首字母小写。

原理：

1.当容器启动时，首先会加载spring的配置文件。

2.根据包扫描指定的包路径，spring会扫描当前包下的全部子孙包。

3.在扫描时如果发现类上含有@Component注解，则会根据spring的规则为其创建对象。将对象创建通过反射创建完成后，存入spring所维护的map中，key就是类名首字母小写。value就是生成的对象。

4.如果类中需要进行对象注入，则在创建对象的之后，自动的根据注解的匹配规则为其注入正确的对象，如果对象正确注入。则spring返回正确的对象如果注入有误，spring则会发出报错信息。容器启动失败

常用注解：

1. `@Component`

2. `@Repository`

   该注解用于将数据访问层（DAO）的类标识为Bean，即注解数据访问层Bean，其功能与@Component()相同

3. `@Service`

   该注解用于标注一个业务逻辑组件类（Service层），其功能与@Component()相同

4. `@Controller`

   该注解用于标注一个控制器组件类（Spring MVC的Controller），其功能与@Component()相同

5. `@Autowired`

   该注解可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 setter 和 getter 方法.默认按照Bean的类型进行装配

6. `@Resource`

   该注解与@Autowired功能一样。区别在于，该注解默认是按照名称来装配注入的，只有当找不到与名称匹配的Bean才会按照类型来装配注入；而@Autowired默认按照Bean的类型进行装配，如果想按照名称来装配注入，则需要结合@Qualifier注解一起使用。

   @Resource注解有两个属性：name和type。name属性指定Bean实例名称，即按照名称来装配注入；type属性指定Bean类型，即按照Bean的类型进行装配。

7. `@Qualifier`

   该注解与@Autowired注解配合使用。当@Autowired注解需要按照名称来装配注入，则需要结合该注解一起使用，Bean的实例名称由@Qualifier注解的参数指定。

其他注解：

- `@NotBlank`

  ```java
  @NotBlank(message = "商品名称不能为空")
  private String name; //POJO
  ```

  参数添加 `@Valid` 注解：

  ```java
  @RestController
  @RequestMapping("/test")
  public class TestController {
      @PostMapping(path = "/addTestDemo")
      public AjaxResult addTestDemo(@Valid @RequestBody TestDemo testDemo) {
          System.out.println("拿到的testDemo为："+testDemo);
          return AjaxResult.success();
      }
  }
  ```

  

上面几个注解中，虽然@Repository、@Service和 @Controller等注解的功能与@Component()相同，但为了使标注类的用途更加清晰（层次化），在实际开发中推荐使用@Repository标注数据访问层（DAO层）、使用@Service标注业务逻辑层（Service层）以及使用@Controller标注控制器层（控制层）。

如：

```java
package com.sec.anno;

public interface TestDao {
    public void save();
}

```

```java
package com.sec.anno;

import org.springframework.stereotype.Repository;

//命名是相当于bean的名字
@Repository("testDao1")
public class TestDaoImpl implements TestDao {
    @Override
    public void save() {
        System.out.println("test Dao save");
    }
}
```

```java
TestDao testDao = (TestDao) context.getBean("testDao1");
testDao.save();
```



```java
package com.sec.anno;

public interface TestService {
    public void save();
}
```

```java
package com.sec.anno;

import javax.annotation.Resource;
import org.springframework.stereotype.Service;

@Service("testService1")
public class TestServiceImpl implements TestService {
    @Resource(name = "testDao1")
    private TestDao testDao;
    public void save() {
        testDao.save();
        System.out.println("test Service save");
    }
}
```

```java
TestService testService = (TestService) context.getBean("testService1");
testService.save();
```



```java
package com.sec.anno;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class TestController {
    @Autowired
    private TestService testService;
    public void save() {
        testService.save();
        System.out.println("test Controller save");
    }
}
```

```java
TestController testController = (TestController) context.getBean("testController");
testController.save();
```

#### Pojo

entity: 严格一个字段对应一个 mysql 数据表属性的 java bean

![image-20230410205923798](img/image-20230410205923798.png)

![image-20230410205941832](img/image-20230410205941832.png)

domain: 具有一定业务意义的后台封装对象,一般代表具有关系的内容;例如:Order中封装一个orderItemList，一个订单可以包括多个商品。但是order表中设有orderItem字段

![image-20230410210035481](img/image-20230410210035481.png)

dto 数据传输对象Data Transfer Object 从页面传递给服务器的数据的格式对象，比如，京东商品输入，输入的信息特别细，比如说输入“TCL大彩电”，还会被要求输入尺寸，大小，长度高度，颜色，型号，重量等等信息，这些信息可以被封装在一个dto对象，但是这些数据将会被拆分开来，分别添加到不同的表格里面。

vo 后台传递给js解析的对象,vo是view object的简写

![image-20230410210259920](img/image-20230410210259920.png)

![image-20230410210306300](img/image-20230410210306300.png)

### Spring AOP

#### 概念

AOP Aspect Oriented Programming 即面向切面编程

![image-20220922100817421](img/image-20220922100817421.png)

在业务处理代码中，通常都有日志记录、性能统计、安全控制、事务处理、异常处理等操作。尽管使用OOP可以通过封装或继承的方式达到代码的重用，但仍然存在同样的代码分散到各个方法中。因此，采用OOP处理日志记录等操作，不仅增加了开发者的工作量，而且提高了升级维护的困难。
为了解决此类问题，出现AOP面向切面的编程思想。AOP采取横向抽取机制，即将分散在各个方法中的重复代码提取出来，然后在程序编译或运行阶段，再将这些抽取出来的代码应用到需要执行的地方。这种横向抽取机制，采用传统的OOP是无法办到的，因为OOP实现的是父子关系的纵向重用。

AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是他们经常发生在多处核心关注点上，而各处基本相似，比如权限认证、日志记录、事物处理等。AOP的作用在于将核心关注点和横切关注点分离开来。

![image-20220922101932237](img/image-20220922101932237.png)

切面（Aspect）是指封装横切到系统功能（如事务处理）的类。

连接点（Joinpoint）是指程序运行中的一些时间点，如方法的调用或异常的抛出。

切入点（Pointcut）是指那些需要处理的连接点。在Spring AOP 中，所有的方法执行都是连接点，而切入点是一个描述信息，它修饰的是连接点，通过切入点确定哪些连接点需要被处理。

通知（增强处理）由切面添加到特定的连接点（满足切入点规则）的一段代码，即在定义好的切入点处所要执行的程序代码。通知是切面的具体实现。

引入（Introduction）允许在现有的实现类中添加自定义的方法和属性。

目标对象（Target Object）是指需要被增强处理的对象,也就是所有被通知的对象。

代理（Proxy）对象是通知应用到目标对象之后，被动态创建的对象。

织入（Weaving）是将切面代码插入到目标对象上，从而生成代理对象的过程。Spring AOP框架默认采用动态代理织入，而AspectJ（基于Java语言的AOP框架）采用编译器织入和类装载期织入。

![image-20220922101912739](img/image-20220922101912739.png)

1\)   关注点concern是业务处理的主要流程。关注点可以被定义为：我们想实现以解决特定业务问题的方法。

2\)  横切关注点cross-cutting贯穿在整个应用程序的关注点中，像安全控制、日志记录、事务处理等，他们经常发生在多处核心关注点上，而各处的处理基本相似。



#### 代理模式

代理对象（中介）特征

1. 实现和被代理者相同的接口
2. 代替目标对象完成相应的功能。
3. 目标方法完成之后，会完成额外的操作

![image-20220922101854504](img/image-20220922101854504.png)

##### 静态代理

静态代理缺点：

1. 一个service对应一个代理类，那么100个service对应100个代理类
2. 代理类的每一个方法中都需要填写事务的开启和事务的提交，复用性不高
3. 代理类不具备通用性

![image-20220922102950217](img/image-20220922102950217.png)



静态代理：

![image-20220922102357396](img/image-20220922102357396.png)

切面代码：(类是切面，方法是通知)

![image-20220922102624397](img/image-20220922102624397.png)

目标对象：

![image-20220922103218427](img/image-20220922103218427.png)

代理对象：

![image-20220922103234275](img/image-20220922103234275.png)

![image-20220922103259516](img/image-20220922103259516.png)



##### 动态代理

目前，Spring AOP中常用JDK和CGLIB两种动态代理技术

![image-20220922103404400](img/image-20220922103404400.png)

JDK动态代理是`java.lang.reflect.*`包提供的方式，它必须借助一个接口才能产生代理对象。因此，对于使用业务接口的类，Spring默认使用JDK动态代理实现AOP。

`jdk`动态代理是由java内部的反射机制来实现的，`cglib`动态代理是通过继承来实现的。`jdk`代理对象实质上是目标对象接口的实现类，`Cglib`代理对象实质上是目标对象的子类。

一般情况下，使用JDK居多，特定环境下才使用`Cglib`。

如果目标对象有接口则采用JDK动态代理，如果目标对象没有接口采用`Cglib`动态代理，`Cglib`是备用方案。

JDK反射机制在创建代理对象的速度较快。`Cglib`在生成类之后的相关执行过程中比较高效。

对接口创建代理优于对类创建代理，因为更加松耦合，所以spring默认是使用JDK动态代理。

动态代理模式优缺点：

优点：

1. 实现了代码的分离
2. 实现了代码的重复利用，原来每个方法上都需要添加事务，现在只需添加一遍。

缺点：

1. 使用`jdk`的动态代理必须实现接口，否则不能生成代理对象。
2. 目标类的每个方法都经过判断降低性能。

###### JDK 代理

实例：(无需 Spring) 

```java
package com.dyn.jdk;

public interface TestDao {
    public void save();
    public void modify();
    public void delete();
}
```

```java
package com.dyn.jdk;

public class TestDaoImpl implements TestDao {
    @Override
    public void save() {
        System.out.println("保存");
    }
    
    @Override
    public void modify() {
        System.out.println("修改");
    }
    
    @Override
    public void delete() {
        System.out.println("删除");
    }
}
```

```java
package com.dyn.aspect;

public class NormalAspect {
    public void check() {
        System.out.println("模拟权限控制");
    }
    
    public void except() {
        System.out.println("模拟异常处理");
    }
    
    public void log() {
        System.out.println("模拟日志记录");
    }
    
    public void monitor() {
        System.out.println("模拟性能检测");
    }
}
```

```java
package com.dyn.jdk;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import com.dyn.aspect.NormalAspect;

public class JDKDynamicProxy implements InvocationHandler {
    private TestDao testDao;

    public Object createProxy(TestDao testDao) {
        this.testDao = testDao;
        ClassLoader cld = JDKDynamicProxy.class.getClassLoader();
        @SuppressWarnings("rawtypes")
        Class[] cla = testDao.getClass().getInterfaces();
        return Proxy.newProxyInstance(cld, cla, this);
    }

    /**
     * @proxy 被代理对象
     * @method 将要被执行的方法
     * @args 执行方法时需要的参数
     * @return 返回代理结果
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        NormalAspect aspect = new NormalAspect();
        aspect.check();
        aspect.except();
        Object obj = method.invoke(testDao, args);
        aspect.log();
        aspect.monitor();
        return obj;
    }
}
```

```java
package com.dyn.jdk;

import org.junit.Test;

public class JDKDynamicTest {
    @Test
    public void test01() {
        JDKDynamicProxy jdkProxy = new JDKDynamicProxy();
        TestDao testDao = new TestDaoImpl();
        TestDao testDaoAdvice = (TestDao)jdkProxy.createProxy(testDao);
        testDaoAdvice.save();
        System.out.println("--");
        testDaoAdvice.modify();
        System.out.println("--");
        testDaoAdvice.delete();
    }
}
```



###### CGLIB代理

CGLIB（Code Generation Library）是一个高性能开源的代码生成包，采用非常底层的字节码技术，对指定的目标类生成一个子类，并对子类进行增强。在Spring Core包中已经集成了CGLIB所需要的JAR包，不需要另外导入JAR包。
优点：不需要实现接口也可以生成代理对象，并且代理对象是目标类的子类

`Cglib`动态代理的原理：用Enhancer生成一个原有类的子类，并且设置好callback到proxy，则原有类的每个方法的调用都会转为调用实现了`MethodIntercept`接口的proxy的intercept()函数。

`Cglib`是针对类来实现代理的，对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。

一般情况下，使用JDK居多，特定环境下才使用`Cglib`
如果目标对象有接口则采用JDK动态代理，如果目标对象没有接口采用`Cglib`动态代理。
JDK创建代理对象的速度较快。代理对象的运行速度`cgLib`快。

```java
package com.dyn.cglib;

public class TestDao1 {
    public void save() {
        System.out.println("保存");
    }

    public void modify() {
        System.out.println("修改");
    }

    public void delete() {
        System.out.println("删除");
    }
}
```

```java
package com.dyn.aspect;

public class NormalAspect {
    public void check() {
        System.out.println("模拟权限控制");
    }
    
    public void except() {
        System.out.println("模拟异常处理");
    }
    
    public void log() {
        System.out.println("模拟日志记录");
    }
    
    public void monitor() {
        System.out.println("模拟性能检测");
    }
}
```

```java
package com.dyn.cglib;

import java.lang.reflect.Method;

import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;
import com.dyn.aspect.NormalAspect;

public class CglibDynamicProxy implements MethodInterceptor {
    private Object object;
    public Object createProxy(Object target) {
        this.object = target;
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(this.object.getClass());
        enhancer.setCallback(this);
        Object objProxy = enhancer.create();
        return objProxy;
    }
    
    @Override
    /**
     * @proxy CGLIB根据指定父类生成的目标对象
     * @method 目标对象中需要加强的方法(拦截方法)
     * @args 拦截方法参数数组
     * @methodProxy 方法的代理对象，用于执行父类的方法
     * @return 代理结果
     */
    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)
            throws Throwable {
        NormalAspect aspect = new NormalAspect();
        aspect.check();
        aspect.except();
        Object obj = methodProxy.invokeSuper(proxy, args);
        aspect.log();
        aspect.monitor();
        return obj;
    }
}
```

```java
package com.dyn.cglib;

import org.junit.Test;

public class Test02 {
    @Test
    public void test02() {
        CglibDynamicProxy cdp = new CglibDynamicProxy();
        TestDao1 testDao = new TestDao1();
        TestDao1 testDaoAdvice = (TestDao1) cdp.createProxy(testDao);
        testDaoAdvice.save();
        System.out.println("==");
        testDaoAdvice.modify();
        System.out.println("==");
        testDaoAdvice.delete();
    }
}
```



#### AOP实现

在Spring中默认使用JDK动态代理实现AOP编程。使用`org.springframework.aop.framework.ProxyFactoryBean`创建代理是Spring AOP实现的最基本方式。

Spring的通知类型。根据Spring中通知在目标类方法的连接点位置，可以分为6种如下类型：

（1）环绕通知
环绕通知（`org.aopalliance.intercept.MethodInterceptor`）是在目标方法执行前和执行后实施增强，可以应用于日志记录、事务处理等功能。
（2）前置通知
前置通知（`org.springframework.aop.MethodBeforeAdvice`）是在目标方法执行前实施增强，可应用于权限管理等功能。

（3）后置返回通知
   后置返回通知（`org.springframework.aop.AfterReturningAdvice`）是在目标方法成功执行后实施增强，可应用于关闭流、删除临时文件等功能

（4）后置（最终）通知
   后置通知（`org.springframework.aop.AfterAdvice`）是在目标方法执行后实施增强，与后置返回通知不同的是，不管是否发生异常都要执行该通知，可应用于释放资源。

（5）异常通知
异常通知（`org.springframework.aop.ThrowsAdvice`）是在方法抛出异常后实施增强，可以应用于处理异常、记录日志等功能。
（6）引入通知
引入通知（`org.springframework.aop.IntroductionInterceptor`）是在目标类中添加一些新的方法和属性，可以应用于修改目标类（增强类）。

`ProxyFactoryBean`是`org.springframework.beans.factory.FactoryBean`接口的实现类，`FactoryBean`负责实例化一个Bean实例，`ProxyFactoryBean`负责为其他Bean实例创建代理实例

初始化：需要 `aop` 包和下载 jar 包：[地址](https://mvnrepository.com/artifact/aopalliance/aopalliance/1.0)

##### ProxyFactoryBean

```java
package com.dyn.jdk;

public interface TestDao {
    public void save();
    public void modify();
    public void delete();
}
```

```java
package com.dyn.jdk;

public class TestDaoImpl implements TestDao {
    @Override
    public void save() {
        System.out.println("保存");
    }
    
    @Override
    public void modify() {
        System.out.println("修改");
    }
    
    @Override
    public void delete() {
        System.out.println("删除");
    }
}
```

创建切面：

```java
package com.dyn.proxybean;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class NorAspect implements MethodInterceptor {
    public void check() {
        System.out.println("模拟权限控制");
    }

    public void except() {
        System.out.println("模拟异常处理");
    }

    public void log() {
        System.out.println("模拟日志记录");
    }

    public void monitor() {
        System.out.println("模拟性能检测");
    }

    @Override
    public Object invoke(MethodInvocation method) throws Throwable {
        check();
        except();
        Object obj = method.proceed();
        log();
        monitor();
        return obj;
    }
}
```

写入 xml：

```xml
<bean id="testDao" class="com.dyn.jdk.TestDaoImpl" />
<bean id="normalAspect" class="com.dyn.proxybean.NorAspect" />
<bean id="testDaoProxy"
      class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="proxyInterfaces" value="com.dyn.jdk.TestDao" />
    <property name="target" ref="testDao" />
    <property name="interceptorNames" value="normalAspect" />
    <property name="proxyTargetClass" value="true" />
</bean>
```

测试：

```java
@SuppressWarnings("resource")
@Test
public void test03() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring2.xml");
    TestDao testDaoAdvice = (TestDao) context.getBean("testDaoProxy");
    testDaoAdvice.save();
    System.out.println("+++");
    testDaoAdvice.modify();
    System.out.println("+++");
    testDaoAdvice.delete();
}
```



AspectJ

AspectJ是一个基于Java语言的AOP框架。从Spring 2.0以后引入了AspectJ的支持。目前的Spring框架，建议开发者使用AspectJ实现Spring AOP。使用AspectJ实现Spring AOP的方式有两种：一是基于XML配置开发AspectJ，二是基于注解开发AspectJ。
基于XML配置开发AspectJ是指通过XML配置文件定义切面、切入点及通知，所有这些定义都必须在<aop:config>元素内。
下面通过一个实例演示基于XML配置开发AspectJ的过程

需要导入 `spring-aspects.jar` 和下载 [这个jar](http://mvnrepository.com/artifact/org.aspectj/aspectjweaver/1.8.13)



```java
package com.dyn.jdk;

public interface TestDao {
    public void save();
    public void modify();
    public void delete();
}

```

```java
package com.dyn.jdk;

public class TestDaoImpl2 implements TestDao {
    @Override
    public void save() {
        int n = 100 / 0;
        System.out.println(n);
    }

    @Override
    public void modify() {
        System.out.println("修改");
    }

    @Override
    public void delete() {
        System.out.println("删除");
    }
}
```

切面类：

```java
package com.dyn.aspect;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;

public class GeneralAspect {
    public void before(JoinPoint jp) {
        System.out.print("前置通知:模拟权限控制");
        System.out.println(",目标类对象:" + jp.getTarget() + ",被增强处理的方法:" + jp.getSignature().getName());
    }

    public void afterReturning(JoinPoint jp) {
        System.out.print("后置通知:模拟删除临时文件");
        System.out.println(",被增强方法:" + jp.getSignature().getName());
    }

    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("环绕开始,模拟开启事务:");
        Object obj = pjp.proceed();
        System.out.println("环绕结束,模拟关闭事务:");
        return obj;
    }

    public void except(Throwable e) {
        System.out.println("异常通知:程序执行异常" + e.getMessage());
    }

    public void after() {
        System.out.println("最终通知:模拟释放资源");
    }
}
```

xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd 
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd ">
	<bean id="testDao" class="com.dyn.jdk.TestDaoImpl2" />
	<bean id="generalAspect" class="com.dyn.aspect.GeneralAspect" />
	<aop:config>
		<aop:aspect ref="generalAspect">
			<aop:pointcut expression="execution(* dyn.jdk.*.*(..))"
				id="jdkPointCut" />
			<aop:before method="before" pointcut-ref="jdkPointCut" />
			<aop:after-returning method="afterReturning"
				pointcut-ref="jdkPointCut" />
			<aop:around method="around" pointcut-ref="jdkPointCut" />
			<aop:after-throwing method="except"
				pointcut-ref="jdkPointCut" throwing="e" />
			<aop:after method="after" pointcut-ref="jdkPointCut" />
		</aop:aspect>
	</aop:config>
</beans>
```

测试用例：

```java
@SuppressWarnings("resource")
@Test
public void test032() {
    ApplicationContext context = new ClassPathXmlApplicationContext("aspectj.xml");
    TestDao testDaoAdvice = (TestDao) context.getBean("testDao");
    testDaoAdvice.delete();
    System.out.println("===");
    testDaoAdvice.save();
}
```



##### 基于注解

| 注解名称        | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| @Aspect         | 用于定义一个切面，注解在切面类上                             |
| @Pointcut       | 用于定义切入点表达式。在使用时，需要定义一个切入点方法。该方法是一个返回值void，且方法体为空的普通方法 |
| @Before         | 用于定义前置通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式 |
| @AfterReturning | 用于定义后置返回通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式 |
| **@**Around     | 用于定义环绕通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式 |
| @AfterThrowing  | 用于定义异常通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式。另外，还有一个throwing属性用于访问目标方法抛出的异常，该属性值与异常通知方法中同名的形参一致 |
| @After          | 用于定义后置（最终）通知。在使用时，通常为其指定value属性值，该值可以是已有的切入点，也可以直接定义切入点表达式 |



```java
package com.dyn.jdk;

public interface TestDao {
    public void save();
    public void modify();
    public void delete();
}
```

```java
package com.dyn.jdk;

import org.springframework.stereotype.Repository;

@Repository("testDao3")
public class TestDaoImpl3 implements TestDao {
    @Override
    public void save() {
        int n = 100 / 0;
        System.out.println(n);
    }

    @Override
    public void modify() {
        System.out.println("修改");
    }

    @Override
    public void delete() {
        System.out.println("删除");
    }
}
```

```java
package com.dyn.aspect;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class GeneralAspect2 {
    @Pointcut("execution(* com.dyn.jdk.*.*(..))")
    private void defaultPointCut() {
    }

    @Before("defaultPointCut()")
    public void before(JoinPoint jp) {
        System.out.print("前置通知:模拟权限控制");
        System.out.println(",目标类对象:" + jp.getTarget() + ",被增强处理的方法:" + jp.getSignature().getName());
    }

    @AfterReturning("defaultPointCut()")
    public void afterReturning(JoinPoint jp) {
        System.out.print("后置通知:模拟删除临时文件");
        System.out.println(",被增强方法:" + jp.getSignature().getName());
    }

    @Around("defaultPointCut()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("环绕开始,模拟开启事务:");
        Object obj = pjp.proceed();
        System.out.println("环绕结束,模拟关闭事务:");
        return obj;
    }

    @AfterThrowing(value = "defaultPointCut()", throwing = "e")
    public void except(Throwable e) {
        System.out.println("异常通知:程序执行异常" + e.getMessage());
    }

    @After("defaultPointCut()")
    public void after() {
        System.out.println("最终通知:模拟释放资源");
    }
}
```

```xml
<context:component-scan base-package="com.dyn" />
<aop:aspectj-autoproxy />
```

```java
@SuppressWarnings("resource")
@Test
public void test033() {
    ApplicationContext context = new ClassPathXmlApplicationContext("aspectj2.xml");
    TestDao testDaoAdvice = (TestDao) context.getBean("testDao3");
    testDaoAdvice.delete();
    System.out.println("***");
    testDaoAdvice.save();
}
```



##### @Transactional

声明式事务

放接口实现类/接口实现方法，而不是接口类

访问权限：`public 的方法才起作用`。`@Transactional 注解应该只被应用到 public 方法上`，这是由 Spring [AOP](https://so.csdn.net/so/search?q=AOP&spm=1001.2101.3001.7020) 的本质决定的。

@Transactional注解只能在抛出RuntimeException或者Error时才会触发事务的回滚，常见的非RuntimeException是不会触发事务的回滚的。但是我们平时做业务处理时，需要捕获异常，所以可以手动抛出RuntimeException异常或者添加rollbackFor = Exception.class(也可以指定相应异常)

使用@Transactional的相比传统的我们需要手动开启事务

[参考](https://blog.csdn.net/jiangyu1013/article/details/84397366) [参考2](https://blog.csdn.net/qq_40813329/article/details/123254855)

```java
/*
 * 捕获异常时，要想使事务生效，需要手动抛出RuntimeException异常或者添加rollbackFor = Exception.class
*/
@Override
@Transactional
public Long addBook(Book book) {
    Long result = null;
    try {
        result = bookDao.addBook(book);
        int i = 1/0;
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    }
    return result;
}

@Override
@Transactional(rollbackFor = Exception.class)
public Long addBook(Book book) {
    Long result = null;
    try {
        result = bookDao.addBook(book);
        int i = 1/0;
    } catch (Exception e) {
        e.printStackTrace();
        throw e;
    }
    return result;
}
```





#### 切入点表达式

```java
Execution(返回值类型 包名.类名.方法名(参数列表))
```

如返回值为 `int`  包名类名 `service.UserServiceImpl`   方法为add()的匹配规则

```xml
<aop:pointcut expression=
"execution(int service.UserServiceImpl.add())" id="txPointcut"/>
```



返回值值任意， 包名service下子类的add(),只能包含一层，子孙类不行

```xml
<aop:pointcut expression="execution(* service.*.add())" id="txPointcut"/>
```



方法返回值任意， service包下的所有子孙类的add()

```xml
<aop:pointcut
expression="execution(* service..*.add())" id="txPointcut"/>
```



返回值的类型任意   service子孙包下的add方法参数类型为`int`,String

```xml
<aop:pointcut expression=
"execution(*  service..*.add(int,String))" id="txPointcut"/>
```



返回值类型任意   service下的所有子孙类.add方法() (参数任意)

```xml
<aop:pointcut expression="execution(* service..*.add(..))"  id="txPointcut"/>
```



要求返回值为任意的，service包下的全部类的全部方法的任意参数

```xml
execution(* service..*.*(..))
execution(* service..*(..))
```



### Spring 数据库

Spring框架为开发者提供了JDBC模板模式，即`jdbcTemplate`，它可以简化许多代码，但在实际应用中`jdbcTemplate`并不常用。工作更多的时候，用的是`Hibernate`框架和`MyBatis`框架进行数据库编程。

#### JDBC

##### 语法

本节Spring数据库编程主要使用Spring JDBC模块的core和`dataSource`包。core包包括常用的`JdbcTemplate`类；`dataSource`包是访问数据源的工具类包。使用Spring JDBC操作数据库，需要对其进行配置。

如：

```xml
<!-- 配置数据源 -->
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
    <!-- MySQL数据库驱动 -->
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <!-- 连接数据库的URL -->
    <property name="url" value="jdbc:mysql://localhost:3306/springtest?characterEncoding=utf8"/>
    <!-- 连接数据库的用户名 -->
    <property name="username" value="root"/>
    <!-- 连接数据库的密码 -->
    <property name="password" value="12345678"/>
</bean>
<!-- 配置JDBC模板 -->
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <property name="dataSource"  ref="dataSource"/>
</bean>
```

也可以进行分离，如 `src` 目录下：

```xml
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="${jdbc.driver}" />
    <property name="jdbcUrl" value="${jdbc.url}" />
    <property name="user" value="${jdbc.user}" />
    <property name="password" value="${jdbc.password}" />
</bean>
```

创建 `jdbc.properties`：

```properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/spring
jdbc.user=root
jdbc.password=87654321
```

上述示例代码中，配置JDBC模板时，需要将`dataSource`注入到`jdbcTemplate`，而在数据访问层（Dao类）需要使用`jdbcTemplate`时，也需要将`jdbcTemplate`注入到对应的Bean中。代码示例如下：(注意 xml 开启包扫描 `<context:component-scan base-package="com.db.*"/>`)

```java
@Repository("testDao")
public class TestDaoImpl implements TestDao{
	@Autowired  //使用配置文件中的JDBC模板
	private JdbcTemplate jdbcTemplate;
}
```

增删改示例：`public int update(String sql,Object args[])`

```java
String sql = "insert into user values(null,?,?)";
Object param1[] = {"chenheng1", "男"};
jdbcTemplate.update(sql, param1);
jdbcTemplate.update(sql,"chenheng1", "男");
```

```java
String sql = "delete from MyUser where id = ?";
jdbcTemplate.update(sql,3);
```

查询示例：`public List<T> query (String sql, RowMapper<T> rowMapper, Object args[])`

```java
String sql ="select * from MyUser";
RowMapper<MyUser> rowMapper=new BeanPropertyRowMapper<MyUser>(MyUser.class);
List<MyUser> list = jdbcTemplate.query(sql, rowMapper, null);
List<MyUser> list = jdbcTemplate.query(sql, rowMapper);
```

`RowMapper`将结果集映射到用户自定义的类中，类中的属性必须与数据表的字段对应

`public <T> queryForObject (String sql, RowMapper<T> rowMapper, Object args)`

```java
String sql ="select * from MyUser where id=?";
RowMapper<MyUser> rowMapper=new BeanPropertyRowMapper<MyUser>(MyUser.class);
MyUser = jdbcTemplate.queryForObject(sql, rowMapper, 123);
```

##### 示例

导入包 `spring-jdbc`，`mysql-connector-java`，`spring-tx`。

创建数据库：

```mysql
create database springtest;
use springtest;
create table MyUser(
uid int(11) not null auto_increment primary key,
uname varchar(20) default null,
usex varchar(10) default null
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
insert into MyUser values(null,'张三','男');
insert into MyUser values(null,'李四','女');
insert into MyUser values(null,'王五','男');
select * from MyUser;
```

根据上文内容写 xml。如：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd 
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd ">
	<context:component-scan base-package="com.db.*" />
	<!-- 配置数据源 -->
	<bean id="dataSource"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<!-- mysql8 新的包名 -->
		<property name="driverClassName"
			value="com.mysql.cj.jdbc.Driver" />
		<property name="url"
			value="jdbc:mysql://localhost:3306/springtest?serverTimezone=UTC" />
		<property name="username" value="root" />
		<property name="password" value="233" />
	</bean>
	<!-- 配置JDBC模板 -->
	<bean id="jdbcTemplate"
		class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource" />
	</bean>
</beans>
```

创建类：

```java
package com.db.pojo;

public class MyUser {
    private Integer uid;
    private String uname;
    private String usex;

    public Integer getUid() {
        return uid;
    }

    public void setUid(Integer uid) {
        this.uid = uid;
    }

    public String getUname() {
        return uname;
    }

    public void setUname(String uname) {
        this.uname = uname;
    }

    public String getUsex() {
        return usex;
    }

    public void setUsex(String usex) {
        this.usex = usex;
    }

    @Override
    public String toString() {
        return "uid=" + uid + ",uname=" + uname + ",usex=" + usex;
    }
}
```

```java
package com.db.dao;

import java.util.List;
import com.db.pojo.MyUser;

public interface UserDao {
    public int update(String sql, Object[] param);

    public List<MyUser> query(String sql, Object[] param);
}
```

```java
package com.db.dao;

import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;
import com.db.pojo.MyUser;

@Repository("userDao")
public class UserDaoImpl implements UserDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public int update(String sql, Object[] param) {
        return jdbcTemplate.update(sql, param);
    }

    @Override
    public List<MyUser> query(String sql, Object[] param) {
        RowMapper<MyUser> rowMapper = new BeanPropertyRowMapper<MyUser>(MyUser.class);
        return jdbcTemplate.query(sql, rowMapper, param);
    }
}
```



#### 编程式事务管理

在代码中显式调用`beginTransaction()`、`commit()`、`rollback()`等事务处理相关的方法，这就是编程式事务管理。当只有少数事务操作时，编程式事务管理才比较合适

基于底层API的编程式事务管理，就是根据`PlatformTransactionManager`、`TransactionDefinition` 和 `TransactionStatus` 三个核心接口，通过编程的方式来进行事务处理

添加：

```xml
<!—为数据源添加事务管理器 -->
<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">   
    <property name="dataSource" ref="dataSource" />
</bean>
<!-- 为事务管理器txManager创建transactionTemplate -->
<bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
    <property name="transactionManager" ref="txManager"/>
</bean>
```

创建类：

```java
package com.ch5.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;
//该类实际上是Dao
@Repository("codeTransaction")
public class CodeTransaction {
	@Autowired
	private JdbcTemplate jdbcTemplate;
	@Autowired
	private DataSourceTransactionManager txManager;	
	public String test(){
		//默认事务定义，例如隔离级别，传播行为，事务的超时时间，事务是否只读 等。
		TransactionDefinition tf=new DefaultTransactionDefinition();
		//开启事务ts
		TransactionStatus ts = txManager.getTransaction(tf);
		String message="执行成功，没有事务回滚！";
		try {
			String sql="select * from MyUser";
			String sql1="insert into MyUser values(?,?,?)";
			Object param[] = {1,"aa","nan"};
			jdbcTemplate.update(sql);
			jdbcTemplate.update(sql1,param);
			jdbcTemplate.update(sql1,param);
			txManager.commit(ts);
		} catch (Exception e) {
			txManager.rollback(ts);
			message="主键重复，事务回滚！";
			e.printStackTrace();
		}
		return message;
	}
}
```

测试：

```java
package com.test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.ch5.dao.CodeTransaction;

public class TestCodeTransaction {
	public static void main(String[] args) {
		ApplicationContext context = 
				new ClassPathXmlApplicationContext("applicationContext.xml");
		CodeTransaction ct=(CodeTransaction)context.getBean("codeTransaction");
		String test=ct.test();
		System.out.println(test);
	}
}
```

事务处理的代码散落在业务逻辑代码中，破坏了原有代码的条理性，并且每一个业务方法都包含了类似的启动事务、提交以及回滚事务的样板代码。
`TransactionTemplate`的execute()方法有一个`TransactionCallback`接口类型的参数，该接口中定义了一个`doInTransaction()`方法，通常以匿名内部类的方式实现`TransactionCallback` 接口，并在其`doInTransaction()`方法中书写业务逻辑代码。这里可以使用默认的事务提交和回滚规则，在业务代码中不需要显式调用任何事务处理的API。`doInTransaction()`方法有一个`TransactionStatus`类型的参数，可以在方法的任何位置调用该参数的`setRollbackOnly()`方法将事务标识为回滚，以执行事务回滚。
根据默认规则，如果在执行回调方法的过程中抛出了未检查异常，或者显式调用了`setRollbackOnly()`方法，则回滚事务；如果事务执行完成或者抛出了checked类型的异常，则提交事务。

基于`TransactionTemplate`的编程式事务管理的步骤如下：

- 为事务管理器添加事务模板
- 创建数据访问类



#### 声明式事务管理

Spring的声明式事务管理，是通过AOP技术实现的事务管理，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。
声明式事务管理最大的优点是不需要通过编程的方式管理事务，因而不需要在业务逻辑代码中掺杂事务处理的代码，只需相关的事务规则声明，便可以将事务规则应用到业务逻辑中。通常情况下，在开发中使用声明式事务处理，不仅因为其简单，更主要是因为这样使得纯业务代码不被污染，极大方便后期的代码维护。

Spring的声明式事务管理可以通过两种方式来实现，一是基于XML的方式，一是基于@Transactional注解的方式。
使用声明式事务处理，从此程序员，无需关注事务控制。

##### 基于XML

新修一个 beans 头，追加：

```xml
xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">
```

基于XML方式的声明式事务管理是通过在配置文件中配置事务规则的相关声明来实现的。Spring框架提供了tx命名空间来配置事务，`<tx:advice>`元素来配置事务的通知。配置`<tx:advice>`元素时，一般需要指定id和transaction-manager属性，其中id属性是配置文件中的唯一标识，transaction-manager属性指定事务管理器。另外，还需要`<tx:attributes>`子元素，该子元素可配置多个`<tx:method>`子元素指定执行事务的细节。

```xml
<!-- 配置事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <!-- 需要引入的数据源 -->
    <property name="dataSource" ref="dataSource"/>
</bean>
<!-- 定义事务通知  -->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
    ……
</tx:advice>
```

如：

```xml
<tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <tx:method name="add*" propagation="REQUIRED" rollback-for="java.sql.SQLException"/>
        <tx:method name="del*" propagation="REQUIRED"/>
        <tx:method name="update*" propagation="REQUIRED"/>
        <tx:method name="find*" propagation="SUPPORTS"/><!--查询不需要事务-->
        <tx:method name="*" read-only="true" />
    </tx:attributes>
</tx:advice>
```

方法以add开头的方法，都会添加事务 propagation="REQUIRED" 

当前方法必须添加事务操作 propagation="SUPPERS"  事务支持的，

如果原来有事务则共用一个事务，如果原来没有事务，不添加事务	 	

`rollback-for="java.sql.SQLException" `指定类型回滚

`no-rollback-for="java.lang.RuntimeException" `指定类型不回滚

当`<tx:advice>`元素配置了事务的增强处理后，就可以通过编写AOP配置，让Spring自动对目标对象生成代理。

```xml
<!-- 配置事务切面 -->
 <aop:config>
	<aop:pointcut expression="execution(* com.sta.service..*.*(..))" id="pc"/>
	<aop:advisor advice-ref="txAdvice" pointcut-ref="pc"/>
</aop:config>
```

> 完整 xml 示例：
>
> ```xml
> <?xml version="1.0" encoding="UTF-8"?>
> <beans xmlns="http://www.springframework.org/schema/beans"
> 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
> 	xmlns:context="http://www.springframework.org/schema/context"
> 	xmlns:aop="http://www.springframework.org/schema/aop"
> 	xmlns:tx="http://www.springframework.org/schema/tx" 
> 	xsi:schemaLocation="http://www.springframework.org/schema/beans 
> http://www.springframework.org/schema/beans/spring-beans.xsd 
> http://www.springframework.org/schema/context 
> http://www.springframework.org/schema/context/spring-context.xsd
> http://www.springframework.org/schema/aop
> http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd ">
> 	<context:component-scan base-package="com.stt.*" />
> 	<!-- 配置数据源 -->
> 	<bean id="dataSource"
> 		class="org.springframework.jdbc.datasource.DriverManagerDataSource">
> 		<!-- mysql8 新的包名 -->
> 		<property name="driverClassName"
> 			value="com.mysql.cj.jdbc.Driver" />
> 		<property name="url"
> 			value="jdbc:mysql://localhost:3306/springtest?serverTimezone=UTC" />
> 		<property name="username" value="root" />
> 		<property name="password" value="11" />
> 	</bean>
> 	<!-- 配置JDBC模板 -->
> 	<bean id="jdbcTemplate"
> 		class="org.springframework.jdbc.core.JdbcTemplate">
> 		<property name="dataSource" ref="dataSource" />
> 	</bean>
> 
> 	<!-- 配置事务管理器 -->
> 	<bean id="transactionManager"
> 		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
> 		<!-- 需要引入的数据源 -->
> 		<property name="dataSource" ref="dataSource" />
> 	</bean>
> 	<!-- 定义事务通知 -->
> 	<tx:advice id="txAdvice"
> 		transaction-manager="transactionManager">
> 		<tx:attributes>
> 			<tx:method name="add*" propagation="REQUIRED"
> 				rollback-for="java.sql.SQLException" />
> 			<tx:method name="del*" propagation="REQUIRED" />
> 			<tx:method name="update*" propagation="REQUIRED" />
> 			<tx:method name="find*" propagation="SUPPORTS" /><!--查询不需要事务 -->
> 			<tx:method name="*" read-only="true" />
> 		</tx:attributes>
> 	</tx:advice>
> 	<!-- 配置事务切面 -->
> 	<aop:config>
> 		<aop:pointcut
> 			expression="execution(* com.stt.service..*.*(..))" id="pc" />
> 		<aop:advisor advice-ref="txAdvice" pointcut-ref="pc" />
> 	</aop:config>
> </beans>
> ```

如：

```java
package com.stt.dao;

public interface UserDao {
    public int save(String sql, Object param[]);

    public int delete(String sql, Object param[]);
}
```

```java
package com.stt.dao;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository("userDao")
public class UserDaoImpl implements UserDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public int save(String sql, Object[] param) {
        return jdbcTemplate.update(sql, param);
    }

    @Override
    public int delete(String sql, Object[] param) {
        return jdbcTemplate.update(sql, param);
    }
}
```

```Java
package com.stt.service;

public interface UserService {
    public int save(String sql, Object param[]);

    public int delete(String sql, Object param[]);
}
```

```java
package com.stt.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.stt.dao.UserDao;

@Service("userService")
public class UserServiceImpl implements UserService {
    @Autowired
    private UserDao userDao;

    @Override
    public int save(String sql, Object[] param) {
        return userDao.save(sql, param);
    }

    @Override
    public int delete(String sql, Object[] param) {
        return userDao.delete(sql, param);
    }
}
```

```mysql
package com.stt.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import com.stt.service.UserService;

@Controller("statementController")
public class StatementController {
    @Autowired
    private UserService userService;

    public String test() {
        String message = "执行成功!";
        String delsql = "delete from MyUser";
        String insertsql = "insert into MyUser values(?,?,?)";
        Object param[] = { 1, "一二三", "女" };
        try {
            userService.delete(delsql, null);
            userService.save(insertsql, param);
            userService.save(insertsql, param);
        } catch (Exception e) {
            message = "主键重复，事件回滚!";
            e.printStackTrace();
        }
        return message;
    }
}
```

测试：

```java
package com.stt.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.stt.controller.StatementController;

public class XMLTest {
    @Test
    public void test01() {
        @SuppressWarnings("resource")
        ApplicationContext context = new ClassPathXmlApplicationContext("springjdbc.xml");
        StatementController statementController = (StatementController) context
                .getBean("statementController");
        System.out.println(statementController.test());
    }
}
```



##### 基于注解

@Transactional注解可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有public方法将都具有该类型的事务属性，同时，也可以在方法级别使用该注解来覆盖类级别的定义。
虽然@Transactional注解可以作用于接口、接口方法、类以及类方法上，但是Spring小组建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。

Spring的事务管理默认只对unchecked未检查异常(`java.lang.RuntimeException`及其子类)进行回滚，如果一个方法抛出Checked异常，Spring事务管理默认不进行回滚。
如果想改变默认规则：
让checked异常也回滚：在方法前加上` @Transactional(rollbackFor=Exception.class)`
让unchecked异常不回滚：`@Transactional(notRollbackFor=RunTimeException.class)`

在上例基础上删掉 `<tx:> ` 的 xml。添加：

```xml
<tx:annotation-driven transaction-manager="txManager" />
```

> 即：
>
> ```xml
> <bean id="txManager"
>       class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
>     <property name="dataSource" ref="dataSource" />
> </bean>
> <tx:annotation-driven
>                       transaction-manager="txManager" />
> ```



在 `UserServiceImpl` 类定义前添加：

```java
import org.springframework.transaction.annotation.Transactional;
@Transactional
```

测试不变。



### MyBatis

#### 基本

##### 概念

MyBatis本是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了google code，并且改名为MyBatis。
MyBatis 是一个基于Java的持久层框架。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和Java的 POJOs（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。
常见的持久层框架有Hibernate和Mybatis，Mybatis是半自动映射的，需要手动配置POJO、SQL和映射关系，Hibernate是全表映射的。

[下载地址](https://github.com/mybatis/mybatis-3/releases)，建议 3.5.3。其 jar 是核心包，lib 文件夹是依赖包，使用时都要引入。

工作原理：

![image-20221008094346654](img/image-20221008094346654.png)

##### 理论

与 JPA 对比：

ORM映射不同：

MyBatis是半自动的ORM(Object-Relationl Mapping)框架，提供数据库与结果集的映射；

JPA（默认采用Hibernate实现）是全自动的ORM框架，提供对象与数据库的映射。

可移植性不同：

JPA通过它强大的映射结构和HQL语言，大大降低了对象与数据库的耦合性；

MyBatis由于需要写SQL，因此与数据库的耦合性直接取决于SQL的写法，如果SQL不具备通用性而用了很多数据库的特性SQL的话，移植性就会降低很多，移植时成本很高。

日志系统的完整性不同：

JPA日志系统非常健全、涉及广泛，包括：SQL记录、关系异常、优化警告、缓存提示、脏数据警告等；

MyBatis除了基本的记录功能外，日志功能薄弱很多。

SQL优化上的区别：

由于Mybatis的SQL都是写在XML里，因此优化SQL比Hibernate方便很多。

而Hibernate的SQL很多都是自动生成的，无法直接维护SQL。虽有HQL，但功能还是不及SQL强大，见到报表等复杂需求时HQL就无能为力，也就是说HQL是有局限的Hhibernate虽然也支持原生SQL，但开发模式上却与ORM不同，需要转换思维，因此使用上不是非常方便。总之写SQL的灵活度上Hibernate不及Mybatis。



> parameterType：
>
> MyBatis支持多种输入输出类型，包括：
>
> 1. 简单的类型，如整数、小数、字符串等；
> 2. 集合类型，如Map等；
> 3. 自定义的JavaBean。
>
> 其中，简单的类型，其数值直接映射到参数上。对于Map或JavaBean则将其属性按照名称映射到参数上。
>
> 一对多映射有两种配置方式，都是使用collection标签实现的。在此之前，为了能够存储一对多的数据，需要在主表对应的实体类中增加集合属性，用于封装子表对应的实体类。
>
> 嵌套查询：
>
> 1. 通过select标签定义查询主表的SQL，返回结果通过reusltMap进行映射。
> 2. 在resultMap中，除了映射主表属性，还要通过collection标签映射子表属性，该标签需包含如下内容：
>    - 通过property属性指定子表属性名；
>    - 通过javaType属性指定封装子表属性的集合类型；
>    - 通过ofType属性指定子表的实体类型；
>    - 通过select属性指定查询子表所依赖的SQL，这个SQL需单独定义，内部包含查询子表的语句。
>
> 嵌套结果：
>
> 1. 通过select标签定义关联查询主表和子表的SQL，返回结果通过resultMap进行映射。
> 2. 在resultMap中，除了映射主表属性，还要通过collection标签映射子表属性，该标签需包含如下内容：
>    - 通过property属性指定子表属性名；
>    - 通过ofType属性指定子表的实体类型；
>    - 通过result子标签定义子表字段和属性的映射关系。
>
> 使用#设置参数时，MyBatis会创建预编译的SQL语句，然后在执行SQL时MyBatis会为预编译SQL中的占位符（?）赋值。预编译的SQL语句执行效率高，并且可以防止注入攻击。
>
> 使用$设置参数时，MyBatis只是创建普通的SQL语句，然后在执行SQL语句时MyBatis将参数直接拼入到SQL里。这种方式在效率、安全性上均不如前者，但是可以解决一些特殊情况下的问题。例如，在一些动态表格（根据不同的条件产生不同的动态列）中，我们要传递SQL的列名，根据某些列进行排序，或者传递列名给SQL都是比较常见的场景，这就无法使用预编译的方式了。
>
> 通过xml文件中，`<mapper>` 根标签的namespace属性进行绑定的，即namespace属性的值需要配置成接口的全限定名称，MyBatis内部就会通过这个值将这个接口与这个xml关联起来。
>
> 自己写的分页效率高。
>
> 在MyBatis中，我们可以通过分页插件实现分页，也可以通过分页SQL自己实现分页。其中，分页插件的原理是，拦截查询SQL，在这个SQL基础上自动为其添加limit分页条件。它会大大的提高开发的效率，但是无法对分页语句做出有针对性的优化，比如分页偏移量很大的情况，而这些在自己写的分页SQL里却是可以灵活实现的。
>
> MyBatis的缓存分为一级缓存和二级缓存。
>
> 一级缓存：
>
> 一级缓存也叫本地缓存，它默认会启用，并且不能关闭。一级缓存存在于SqlSession的生命周期中，即它是SqlSession级别的缓存。在同一个 SqlSession 中查询时，MyBatis 会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map对象中。如果同一个SqlSession 中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当Map 缓存对象中己经存在该键值时，则会返回缓存中的对象。
>
> 二级缓存：
>
> 二级缓存存在于SqlSessionFactory 的生命周期中，即它是SqlSessionFactory级别的缓存。若想使用二级缓存，需要在如下两处进行配置。
>
> 在MyBatis 的全局配置settings 中有一个参数cacheEnabled，这个参数是二级缓存的全局开关，默认值是true ，初始状态为启用状态。
>
> MyBatis 的二级缓存是和命名空间绑定的，即二级缓存需要配置在Mapper.xml 映射文件中。在保证二级缓存的全局配置开启的情况下，给Mapper.xml 开启二级缓存只需要在Mapper. xml 中添加如下代码：
>
> ```xml
> <cache />
> ```
>
> 二级缓存具有如下效果：
>
> - 映射语句文件中的所有SELECT 语句将会被缓存。
> - 映射语句文件中的所有时INSERT 、UPDATE 、DELETE 语句会刷新缓存。
> - 缓存会使用Least Rece ntly U sed ( LRU ，最近最少使用的）算法来收回。
> - 根据时间表（如no Flush Interval ，没有刷新间隔），缓存不会以任何时间顺序来刷新。
> - 缓存会存储集合或对象（无论查询方法返回什么类型的值）的1024 个引用。
> - 缓存会被视为read/write（可读／可写）的，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。

#### 入门例子

首先导入对应 jar 包，然后创建配置日志文件，在 `classpath` 路径即 `src/` 下：`log4j.properties` (可以从MyBatis使用手册中Logging小节复制，然后进行简单修改。)

```properties
# Global logging configuration
log4j.rootLogger=ERROR, stdout
# MyBatis logging configuration...
# 表示包 com.mybatis 下所有(含子孙)开启 debug, 则每次 CRUD 有输出详细内容
log4j.logger.com.mybatis=DEBUG
# Console output...
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n
```

创建类，其类名、属性与某个数据库表子段一致：

```java
package com.mybatis.pojo;

public class MyUser {
    private Integer uid;
    private String uname;
    private String usex;

    public Integer getUid() {
        return uid;
    }

    public void setUid(Integer uid) {
        this.uid = uid;
    }

    public String getUname() {
        return uname;
    }

    public void setUname(String uname) {
        this.uname = uname;
    }

    public String getUsex() {
        return usex;
    }

    public void setUsex(String usex) {
        this.usex = usex;
    }

    @Override
    public String toString() {
        return "uid=" + uid + ",uname=" + uname + ",usex=" + usex;
    }
}
```

在 `src\` 下，创建 `mybatis-config.xml` 配置数据库环境和映射文件位置：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<!-- 配置环境 -->
	<environments default="development">
		<environment id="development">
			<!-- 使用JDBC的事务管理 -->
			<transactionManager type="JDBC"/>
			<dataSource type="POOLED"><!-- 数据库连接池 -->
				<!-- MySQL数据库驱动 -->
                <!-- 若 mysql5 则 com.mysql.jdbc.Driver -->
				<property name="driver" value="com.mysql.cj.jdbc.Driver"/>
				<!-- 连接数据库的URL -->
				<property name="url" value="jdbc:mysql://localhost:3306/springtest?serverTimezone=UTC"/>
				<property name="username" value="root"/>
				<property name="password" value="12345678"/>
			</dataSource>
		</environment>
	</environments>
	
<mappers>
<!-- 映射文件的位置 -->
	<mapper resource="com/mybatis/mapper/UserMapper.xml"/>
</mappers>
</configuration>
```

创建一个 `com.mybatis.mapper` 包，目录下创建 `UserMapper.xml` 映射文件。根元素是 mapper，包含属性 namespace，设置为 `包名+SQL映射文件名`。子元素 select, insert, update, delete 是执行 CRUD 的操作配置。以 `#{}` 表示占位符 `?`，以 `#{uid}` 表示接受的参数为 `uid`。大括号一定要填东西。像基本数据类型填啥都行

如：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.mybatis.mapper.UserMapper">
	<select id="selectUserById" parameterType="Integer"
		resultType="com.mybatis.pojo.MyUser">
		select * from myuser where uid = #{id}
	</select>

	<select id="selectAllUser" resultType="com.mybatis.pojo.MyUser">
		select * from myuser
	</select>
	
	<!-- 添加一个用户，#{uname}为com.mybatis.pojo.MyUser的属性值 -->
	<insert id="addUser" parameterType="com.mybatis.pojo.MyUser">
		insert into myuser(uname,usex) values(#{uname},#{usex})
	</insert>

	<!-- 修改一个用户 -->
	<update id="updateUser" parameterType="com.mybatis.pojo.MyUser">
		update myuser set uname=#{uname},usex=#{usex} where uid=#{uid}
	</update>

	<!-- 删除一个用户 -->
	<delete id="deleteUser" parameterType="Integer">
		delete from MyUser where uid=#{uid}
	</delete>
	
</mapper>
```

开一个测试类，分别调用 CRUD：

```java
package com.mybatis.test;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import com.mybatis.pojo.MyUser;

public class MyBatisTest {
    public static void main(String[] args) {
        try {
            // 读取配置文件mybatis-config.xml
            InputStream config = Resources.getResourceAsStream("mybatis-config.xml");
            // 根据配置文件构建SqlSessionFactory
            SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config);
            // 通过SqlSessionFactory创建SqlSession
            SqlSession ss = ssf.openSession();
            // SqlSession执行映射文件中定义的SQL，并返回映射结果

            // 查询一个用户
            MyUser mu = ss.selectOne("com.mybatis.mapper.UserMapper.selectUserById", 1);
            System.out.println("查询id=1的用户：");
            System.out.println(mu);
            System.out.println();

            System.out.println("查询所有用户：");
            // 查询所有用户
            findAll(ss);

            // 添加一个用户
            System.out.println("添加一个用户:rerete,男");
            MyUser addmu = new MyUser();
            addmu.setUname("rerete");
            addmu.setUsex("男");
            ss.insert("com.mybatis.mapper.UserMapper.addUser", addmu);

            // 修改一个用户
            System.out.println("修改一个用户:将 id=1的姓名和性别，改为：‘雯雯，女’");
            MyUser updatemu = new MyUser();
            updatemu.setUid(1);
            updatemu.setUname("雯雯");
            updatemu.setUsex("女");
            ss.update("com.mybatis.mapper.UserMapper.updateUser", updatemu);

            // 查询一个用户
            System.out.println("查询id=1的用户：");
            mu = ss.selectOne("com.mybatis.mapper.UserMapper.selectUserById", 1);
            System.out.println(mu);

            // 删除一个用户
            System.out.println();
            System.out.println("删除id=2的用户");
            ss.delete("com.mybatis.mapper.UserMapper.deleteUser", 2);

            // 查询所有用户
            System.out.println("再次查询所有用户：");
            findAll(ss);
            // 提交事务
            ss.commit();
            // 关闭SqlSession
            ss.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public static void findAll(SqlSession ss) {
        // com.mybatis.mapper.UserMapper.selectAllUser为UserMapper.xml中的命名空间+select的id

        List<MyUser> listMu = ss.selectList("com.mybatis.mapper.UserMapper.selectAllUser");
        for (MyUser myUser : listMu) {
            System.out.println(myUser);
        }
    }
}
```



#### MyBatis工厂

以入门例子为基础，

下载并导入 mybatis 与 spring 整合的中间 jar 包(2.0.3) [地址](http://mvnrepository.com/artifact/org.mybatis/mybatis-spring/)

数据库驱动包，以及数据源所需 jar 包需要下载。数据源有 [commons-dbcp2-2.7.0](http://commons.apache.org/proper/commons-dbcp/download_dbcp.cgi) 和 [commons-pool2-2.7.0](http://commons.apache.org/proper/commons-pool/download_pool.cgi)

搞一个 bean：如 `springmybatis.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?><?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd 
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd ">
	<context:component-scan
		base-package="com.mybatis" />
	<bean id="dataSource"
		class="org.apache.commons.dbcp2.BasicDataSource">
		<property name="driverClassName"
			value="com.mysql.cj.jdbc.Driver" />
		<property name="url"
			value="jdbc:mysql://localhost:3306/springtest?serverTimezone=UTC" />
		<property name="username" value="root" />
		<property name="password" value="1" />
		<!-- 最大连接数 -->
		<property name="maxTotal" value="30" />
		<!-- 最大空闲连接数 -->
		<property name="maxIdle" value="10" />
		<!-- 初始化连接数 -->
		<property name="initialSize" value="5" />
	</bean>
	<bean id="txManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" />
	</bean>
	<tx:annotation-driven
		transaction-manager="txManager" />
	<!-- 配置MyBatis工厂，同时指定数据源，并与MyBatis整合 -->
	<bean id="sqlSessionFactory"
		class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />
		<!-- configLocation的属性值为MyBatis的核心配置文件 -->
		<property name="configLocation"
			value="classpath:com/mybatis/mybatis-config.xml" />
	</bean>
	<!--Mapper代理开发，使用Spring自动扫描MyBatis的接口并装配 -->
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<!-- mybatis-spring组件的扫描器 -->
		<!-- （Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口） -->
		<property name="basePackage" value="com.mybatis.dao" />
		<property name="sqlSessionFactoryBeanName"
			value="sqlSessionFactory" />
	</bean>
</beans>
```

对应的 `mybatis-config.xml` 在对应目录创建：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<!-- 告诉 MyBatis到哪里去找映射文件 -->
	<mappers>
		<mapper resource="com/mybatis/UserMapper.xml" />
	</mappers>
</configuration>
```

重建一个在 `com.pojo` 的与上文一样的 `MyUser` 类。

创建在 `com.mybatis` 的 `UserMapper.xml`，与上文类似，改一下 type  所在 `myuser` 路径和 namespace 为 `com.mybatis.dao.UserDao`。其他不变。

创建 dao，方法与 SQL 映射文件 xml 一致：

```java
package com.mybatis.dao;

import java.util.List;
import org.apache.ibatis.annotations.Mapper;
import org.springframework.stereotype.Repository;
import com.pojo.MyUser;

@Repository("userDao")
@Mapper
public interface UserDao {
    public MyUser selectUserById(Integer uid);

    public List<MyUser> selectAllUser();

    public int addUser(MyUser user);

    public int updateUser(MyUser user);

    public int deleteUser(Integer uid);
}
```

把这个类所在包的 log4j 日志增加 

创建 controller：

```java
package com.mybatis.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import com.mybatis.dao.UserDao;
import com.pojo.MyUser;

@Controller("userController")
public class UserController {

    @Autowired
    private UserDao userDao;

    public void test() {
        // 查询一个用户
        MyUser auser = userDao.selectUserById(1);
        System.out.println(auser);
        System.out.println("================");
        // 添加一个用户
        MyUser addmu = new MyUser();
        addmu.setUname("陈恒");
        addmu.setUsex("男");
        int add = userDao.addUser(addmu);
        System.out.println("添加了" + add + "条记录");
        System.out.println("================");
        // 修改一个用户
        MyUser updatemu = new MyUser();
        updatemu.setUid(1);
        updatemu.setUname("张三");
        updatemu.setUsex("女");
        int up = userDao.updateUser(updatemu);
        System.out.println("修改了" + up + "条记录");
        System.out.println("================");
        // 删除一个用户
        int dl = userDao.deleteUser(3);
        System.out.println("删除了" + dl + "条记录");
        System.out.println("================");
        // 查询所有用户
        List<MyUser> list = userDao.selectAllUser();
        for (MyUser myUser : list) {
            System.out.println(myUser);
        }
    }
}
```

创建测试类：

```java
package com.mybatis.controller;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestController {
    public static void main(String[] args) {
        @SuppressWarnings("resource")
        ApplicationContext appCon = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserController uc = (UserController) appCon.getBean("userController");
        uc.test();
    }
}
```



#### generator插件

使用MyBatis Generator插件自动生成MyBatis所需要的DAO接口、实体模型类、Mapping映射文件，将生成的代码复制到项目工程中即可，把更多精力放在业务逻辑上。MyBatis Generator有三种常用方法自动生成代码：命令行、Eclipse插件和Maven插件。本节使用比较简单的方法（命令行）自动生成相关代码。

[jar包下载](http://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core/1.3.7)

将 jar 包和 `mysql-connector-java-8.0.16.jar` 放在同一目录，且在该目录下创建 `src\`。

同目录创建 `generator.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
    <!--数据库驱动包位置-->
    <classPathEntry location="D:\_lr580\program\java\genxrs\mysql-connector-java-8.0.16.jar" />
    <context id="mysqlTables" targetRuntime="MyBatis3">
        <commentGenerator>
            <property name="suppressAllComments" value="true" />
        </commentGenerator>
        <!--数据库链接地址账号密码-->
        <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/springtest?serverTimezone=UTC" userId="root" password="1" />

        <!--生成Model类存放位置-->
        <javaModelGenerator targetPackage="com.pojo" targetProject="D:\_lr580\program\java\genxrs\src">
            <property name="enableSubPackages" value="true" />
            <property name="trimStrings" value="true" />
        </javaModelGenerator>

        <!--生成映射文件存放位置-->
        <sqlMapGenerator targetPackage="mybatis" targetProject="D:\_lr580\program\java\genxrs\src">
            <property name="enableSubPackages" value="true" />
        </sqlMapGenerator>
        <!--生成Dao类存放位置-->
        <javaClientGenerator targetPackage="com.mybatis.dao" targetProject="D:\_lr580\program\java\genxrs\src" type="XMLMAPPER">
            <property name="enableSubPackages" value="true" />
        </javaClientGenerator>
        <table tableName="myuser" domainObjectName="MyUser" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false" />
    </context>
</generatorConfiguration>
```

执行 jar：

```shell
java -jar mybatis-generator-core-1.3.7.jar -configfile generator.xml -overwrite
```

自动生成了 dao 接口，实体模型类 pojo 和 mapping 映射文件。

> 下面展示自动生成的所有文件：
>
> ```java
> package com.mybatis.dao;
> 
> import com.pojo.MyUser;
> 
> public interface MyUserMapper {
>     int deleteByPrimaryKey(Integer uid);
> 
>     int insert(MyUser record);
> 
>     int insertSelective(MyUser record);
> 
>     MyUser selectByPrimaryKey(Integer uid);
> 
>     int updateByPrimaryKeySelective(MyUser record);
> 
>     int updateByPrimaryKey(MyUser record);
> }
> ```
>
> ```java
> package com.pojo;
> 
> public class MyUser {
>     private Integer uid;
> 
>     private String uname;
> 
>     private String usex;
> 
>     public Integer getUid() {
>         return uid;
>     }
> 
>     public void setUid(Integer uid) {
>         this.uid = uid;
>     }
> 
>     public String getUname() {
>         return uname;
>     }
> 
>     public void setUname(String uname) {
>         this.uname = uname == null ? null : uname.trim();
>     }
> 
>     public String getUsex() {
>         return usex;
>     }
> 
>     public void setUsex(String usex) {
>         this.usex = usex == null ? null : usex.trim();
>     }
> }
> ```
>
> ```xml
> <?xml version="1.0" encoding="UTF-8"?>
> <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
> <mapper namespace="com.mybatis.dao.MyUserMapper">
>   <resultMap id="BaseResultMap" type="com.pojo.MyUser">
>     <id column="uid" jdbcType="INTEGER" property="uid" />
>     <result column="uname" jdbcType="VARCHAR" property="uname" />
>     <result column="usex" jdbcType="VARCHAR" property="usex" />
>   </resultMap>
>   <sql id="Base_Column_List">
>     uid, uname, usex
>   </sql>
>   <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
>     select 
>     <include refid="Base_Column_List" />
>     from myuser
>     where uid = #{uid,jdbcType=INTEGER}
>   </select>
>   <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
>     delete from myuser
>     where uid = #{uid,jdbcType=INTEGER}
>   </delete>
>   <insert id="insert" parameterType="com.pojo.MyUser">
>     insert into myuser (uid, uname, usex
>       )
>     values (#{uid,jdbcType=INTEGER}, #{uname,jdbcType=VARCHAR}, #{usex,jdbcType=VARCHAR}
>       )
>   </insert>
>   <insert id="insertSelective" parameterType="com.pojo.MyUser">
>     insert into myuser
>     <trim prefix="(" suffix=")" suffixOverrides=",">
>       <if test="uid != null">
>         uid,
>       </if>
>       <if test="uname != null">
>         uname,
>       </if>
>       <if test="usex != null">
>         usex,
>       </if>
>     </trim>
>     <trim prefix="values (" suffix=")" suffixOverrides=",">
>       <if test="uid != null">
>         #{uid,jdbcType=INTEGER},
>       </if>
>       <if test="uname != null">
>         #{uname,jdbcType=VARCHAR},
>       </if>
>       <if test="usex != null">
>         #{usex,jdbcType=VARCHAR},
>       </if>
>     </trim>
>   </insert>
>   <update id="updateByPrimaryKeySelective" parameterType="com.pojo.MyUser">
>     update myuser
>     <set>
>       <if test="uname != null">
>         uname = #{uname,jdbcType=VARCHAR},
>       </if>
>       <if test="usex != null">
>         usex = #{usex,jdbcType=VARCHAR},
>       </if>
>     </set>
>     where uid = #{uid,jdbcType=INTEGER}
>   </update>
>   <update id="updateByPrimaryKey" parameterType="com.pojo.MyUser">
>     update myuser
>     set uname = #{uname,jdbcType=VARCHAR},
>       usex = #{usex,jdbcType=VARCHAR}
>     where uid = #{uid,jdbcType=INTEGER}
>   </update>
> </mapper>
> ```



#### 映射文件

##### 概述

MyBatis的核心配置文件配置了很多影响MyBatis行为的信息，这些信息通常只会配置在一个文件中，并且不会轻易改动。
另外，与Spring框架整合后，MyBatis的核心配置文件信息将配置到Spring的配置文件中。因此，在实际开发中需要编写或修改MyBatis的核心配置文件的情况不多。

`mybatis-config.xml` 配置文件元素节点有先后顺序

![image-20221008111900661](img/image-20221008111900661.png)

映射器：

![image-20221008112016874](img/image-20221008112016874.png)

标签属性的 id 值是唯一标识符，`parameterType` 是传入参数类型，`resultType` 是返回值类型。标签内容是 SQL 语句。其 `#{值}` 的值填数据表的列名

##### select

select 元素属性：

![image-20221008112341096](img/image-20221008112341096.png)

参数如果不是单一类，可以用 map，如：

```xml
<select id="selectUserByMap"  resultType="com.po.MyUser" parameterType="map">
    select * from user 
    where uname like concat('%',#{u_name},'%')
    and usex = #{u_sex}
</select>
```

```java
Map<String,Object> map=new HashMap<>();
map.put("u_name","陈");
map.put("u_sex","男");
List<MyUser> list = userDao.selectUserByMap(map);
for (MyUser myUser : list) {
    System.out.println(myUser);
}
```

也可以用 bean，造一个 POJO 类：

```java
public class SelectUserParam {
	private String u_name;
	private String u_sex;
}
```

修改 Dao 接口 param：

```java
public List<MyUser> selectUserByBean(SelectUserParam param);
```

对应改 XML：

```xml
<select id="selectUserByBean"  resultType="com.po.MyUser" parameterType="com.pojo.SelectUserParam">
```

调用：(这里即上述入门例子写法)

```java
SelectUserParam userParam=new SelectUserParam();
userParam.setU_name("陈");
userParam.setU_sex("男");		
List<MyUser> listParam = userDao.selectUserByBean(userParam);
for (MyUser myUser : listParam) {
	System.out.println(myUser);
}
```



##### insert

`<insert>`元素用于映射插入语句，MyBatis执行完一条插入语句后，将返回一个整数表示其影响的行数(成功插入数目)。它的属性与`<select>`元素的属性大部分相同，在本节讲解它的几个特有属性。具体如下：
keyProperty：该属性的作用是将插入或更新操作时的返回值赋值给POJO类的某个属性，通常会设置为主键对应的属性。如果是联合主键，可以在多个值之间用逗号隔开。
keyColumn：该属性用于设置第几列是主键，当主键列不是表中的第一列时需要设置。如果是联合主键时，可以在多个值之间用逗号隔开。
useGeneratedKeys：该属性将使MyBatis使用JDBC的getGeneratedKeys()方法获取由数据库内部生产的主键，如MySQL、SQL Server等自动递增的字段，其默认值为false。

```xml
<insert id="addUserKey" parameterType="com.pojo.MyUser" 
        keyProperty="uid"  useGeneratedKeys="true">
    insert into myuser(uname,usex) values(#{uname},#{usex})
</insert>
```

```java
public int addUserKey(MyUser user);
```

```java
MyUser addus = new MyUser();
addus.setUname("陈小茜");
addus.setUsex("女");
int a = userDao.addUserKey(addus);
System.out.println("添加了" + a + "条记录，其主键为："+addus.getUid());
```

如果数据库不支持(Oracle)/取消主键自动递增，可以：(if 是 SQL 函数)

```xml
<insert id="insertUserSelectKey" parameterType="com.po.MyUser">
    <!-- 先使用selectKey元素定义主键，然后再定义SQL语句 -->
    <selectKey keyProperty="uid" resultType="Integer" order="BEFORE">
        select if(max(uid) is null, 1 , max(uid)+1) as newUid from user
    </selectKey>
    insert into user (uid,uname,usex) values(#{uid},#{uname},#{usex})
</insert>
```



##### update/delete

```xml
<update id="updateUser" parameterType="com.po.MyUser">
    update user set uname = #{uname},usex = #{usex} where uid = #{uid}
</update>
<delete id="deleteUser" parameterType="Integer"> 
    delete from user where uid = #{uid}
</delete>
```



##### sql

`<sql>`元素的作用在于可以定义SQL语句的一部分（代码片段），方便后面的SQL语句引用它，比如反复使用的列名。

```xml
<sql id="comColumns">uid,uname,usex</sql>
<select id="selectUser" resultType="com.po.MyUser">
    select <include refid="comColumns"/> from user
</select>
```



##### resultMap

`<resultMap>`元素表示结果映射集，是MyBatis中最重要也是最强大的元素。主要用来定义映射规则、级联的更新以及定义类型转化器等。

```xml
<resultMap type="" id="">
    <constructor><!-- 类在实例化时，用来注入结果到构造方法 -->
        <idArg/><!-- ID参数，结果为ID -->
        <arg/><!-- 注入到构造方法的一个普通结果 -->
    </constructor>
    <id/><!-- 用于表示哪个列是主键 -->
    <result/><!-- 注入到字段或JavaBean属性的普通结果 -->
    <association property=""/><!-- 用于一对一关联 -->
    <collection property=""/><!-- 用于一对多、多对多关联 -->
    <discriminator javaType=""><!-- 使用结果值来决定使用哪个结果映射 -->
        <case value=""/>	<!-- 基于某些值的结果映射 -->
    </discriminator>
</resultMap>
```

`<resultMap>`元素的type属性表示需要的POJO，id属性是resultMap的唯一标识。
子元素`<constructor>`用于配置构造方法（当POJO未定义无参数的构造方法时使用）。
子元素`<id>`用于表示哪个列是主键。
子元素`<result>`用于表示POJO和数据表普通列的映射关系。
子元素`<association>` 、`<collection>` 和`<discriminator>`是用在级联的情况下

任何select语句可以使用Map存储结果，示例代码如下：

```xml
<select id="selectAllUserMap"  resultType="map">
    select * from user 
</select>
```

转化为：

```java
public class MapUser { //POJO
     private Integer m_uid;
     private String m_uname;
     private String m_usex;
}
```

```xml
<!-- 使用自定义结果集类型 -->
<resultMap type="com.pojo.MapUser" id="myResult">
    <!-- property是com.pojo.MapUser类中的属性-->
    <!-- column是查询结果的列名，可以来自不同的表 -->
    <id property="m_uid" column="uid"/>
    <result property="m_uname" column="uname"/>
    <result property="m_usex" column="usex"/>
</resultMap>
<!-- 使用自定义结果集类型查询所有用户 -->
<select id="selectResultMap" resultMap="myResult">
    select * from user
</select>
```

```java
public List<MapUser> selectResultMap();
```

```java
List<MapUser> listResultMap = userDao.selectResultMap();
for (MapUser myUser : listResultMap) {
	System.out.println(myUser);
}
```



##### 级联关系

级联：如果表A中有一个外键引用了表B的主键，A表就是子表，B表就是父表。当查询表A的数据时，通过表A的外键，也将表B的相关记录返回，这就是级联查询。例如，查询一个人的信息时，同时根据外键（身份证号）也将他的身份证信息返回。

三种级联方式：一对一、一对多、多对多。

###### 一对一

在MyBatis中，通过`<resultMap>`元素的子元素`<association>`处理这种一对一级联关系。在`<association>`元素中，通常使用以下属性。
property：指定映射到实体类的对象属性。
column：指定表中对应的字段（即查询返回的列名）。
javaType：指定映射到实体对象属性的类型。
     select：指定引入嵌套查询的子SQL语句，该属性用于关联映射中的嵌套查询。

如有数据库：

```mysql
use springtest;
DROP TABLE IF EXISTS idcard;
CREATE TABLE idcard (
    id tinyint(2) NOT NULL AUTO_INCREMENT,
    code varchar(18) COLLATE utf8_unicode_ci  DEFAULT NULL,
    PRIMARY KEY (id)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

INSERT INTO idcard VALUES ('1', '123456789123456789');
select * from idcard;

DROP TABLE IF EXISTS person;
CREATE TABLE person (
    id tinyint(2) NOT NULL,
    name varchar(20) COLLATE utf8_unicode_ci DEFAULT NULL,
    age int(11) DEFAULT NULL,
    idcard_id  tinyint(2) DEFAULT NULL,
    PRIMARY KEY (id),
    KEY idcard_id (idcard_id),
    CONSTRAINT idcard_id FOREIGN KEY (idcard_id) REFERENCES idcard(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
INSERT INTO person VALUES ('1', '陈恒', '88', '1');
select * from person;
```

创建 POJO 对应的两个。注意创建时使用组合关系：

```java
package com.po;
public class Idcard {
	private Integer id;
	private String code;
}
```

```java
package com.po;
public class Person {
	private Integer id;
	private String name;
	private Integer age;
	private Idcard card;
}
```

XML mybatis\-config.xml 开启懒加载：(提高查询效率)

```xml
<settings>
    <!-- 打开懒加载的开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 将积极加载改为按需加载 -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

添加包含文件：

```xml
<mapper resource="com/mybatis/IdCardMapper.xml"/>
<mapper resource="com/mybatis/PersonMapper.xml"/>
```

创建两个对应的 xml：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.dao.IdCardDao">
    <select id="selectCodeById" parameterType="Integer"
            resultType="com.po.Idcard">
        select * from idcard where id=#{id}
    </select>
</mapper>
<!-- idcard mapper-->
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.dao.PersonDao">
    <!-- 一对一 根据id查询个人信息：第一种方法（嵌套查询） -->
    <resultMap type="com.po.Person" id="cardAndPerson1">
        <id property="id" column="id"/>
        <result property="name" column="name"/>
        <result property="age" column="age"/>
        <!-- 一对一关联查询   
  property:指定映射到实体类的对象属性
  column：指定表中对应的字段（即查询返回的列名）
  javaType：指定映射到实体对象属性的类型
  select：指定引入嵌套查询的子SQL语句，
  该属性用于关联映射中的嵌套查询
  -->
        <association property="card" column="idcard_id" 
                     javaType="com.po.Idcard"
                     select="com.dao.IdCardDao.selectCodeById"/>
    </resultMap>
    <select id="selectPersonById1" 
            parameterType="Integer" resultMap="cardAndPerson1">
        select * from person where id=#{id}
    </select>

    <!-- 一对一 根据id查询个人信息：第二种方法（嵌套结果） -->
    <resultMap type="com.po.Person" id="cardAndPerson2">
        <id property="id" column="id"/>
        <result property="name" column="name"/>
        <result property="age" column="age"/>
        <!-- 一对一关联查询 -->
        <association property="card" javaType="com.po.Idcard">
            <id property="id" column="idcard_id"/>
            <result property="code" column="code"/>
        </association>
    </resultMap>
    <select id="selectPersonById2" parameterType="Integer" 
            resultMap="cardAndPerson2">
        select p.*,ic.code 
        from person p, idcard ic 
        where p.idcard_id = ic.id and p.id=#{id}
    </select>


    <!-- 一对一 根据id查询个人信息：第三种方法（使用POJO存储结果） -->
    <select id="selectPersonById3" parameterType="Integer" resultType="com.pojo.SelectPersonById">
        select p.*,ic.code 
        from person p, idcard ic 
        where p.idcard_id = ic.id and p.id=#{id}
    </select>
</mapper>
```

创建一个 POJO(第三种方法)：

```java
package com.pojo;
public class SelectPersonById {
	private Integer id;
	private String name;
	private Integer age;
	private String code;
//自动生成set、get方法和toString方法
}
```

创建 DAO：(第一种 person 查询会用到)

```java
package com.dao;
import com.po.Idcard;
@Repository("idCardDao")
@Mapper
public interface IdCardDao {
	public Idcard selectCodeById(Integer i);
}
```

```java
package com.dao;
import com.po.Person;
import com.pojo.SelectPersonById;
@Repository("personDao")
@Mapper
public interface PersonDao {
	public Person selectPersonById1(Integer id);
	public Person selectPersonById2(Integer id);
	public SelectPersonById selectPersonById3(Integer id);
}
```

创建控制器类：

```java
@Controller("oneToOneController")
public class OneToOneController {
    @Autowired
    private PersonDao personDao;
    public void test() {
        Person p1 = personDao.selectPersonById1(1);
        System.out.println(p1);
       
        Person p2 = personDao.selectPersonById2(1);
        System.out.println(p2);
       
        SelectPersonById p3 = personDao.selectPersonById3(1);
        System.out.println(p3);
    }
}
```

然后用 `applicationcontext` 运行 `test()` 方法。



###### 一对多

如：

```mysql
use springtest;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (
    id tinyint(2) NOT NULL AUTO_INCREMENT,
    ordersn varchar(10) COLLATE utf8_unicode_ci DEFAULT NULL,
    user_id tinyint(2) DEFAULT NULL,
    PRIMARY KEY (id),
    KEY user_id (user_id),
    CONSTRAINT user_id FOREIGN KEY (user_id) REFERENCES user (uid)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
INSERT INTO orders VALUES ('1', '999999', '1');
INSERT INTO orders VALUES ('2', '88888', '1');
INSERT INTO orders VALUES ('3', '7777777', '31');
INSERT INTO orders VALUES ('4', '666666666', '31');
select * from orders;
```

创建 POJO：

```java
package com.po;
public class Orders {
	private Integer id;
	private String ordersn;
}
```

```java
package com.po;
import java.util.List;
public class MyUser {
    private Integer uid;
    private String uname;
    private String usex;
    private List<Orders> ordersList;
}
```

来一个 include：

```xml
<mapper resource="com/mybatis/OrdersMapper.xml"/>
```

来个 xml：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.dao.OrdersDao">
    <select id="selectOrdersById" parameterType="Integer" resultType="com.po.Orders">
        select * from orders where user_id=#{id}
    </select>
</mapper>
```

user 增加 xml：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.dao.UserDao">

    <!-- 一对多 根据uid查询用户及其关联的订单信息：第一种方法（嵌套查询） -->
    <resultMap type="com.po.MyUser" id="userAndOrders1">
        <id property="uid" column="uid"/>
        <result property="uname" column="uname"/>
        <result property="usex" column="usex"/>
        <!-- 一对多关联查询，ofType表示集合中的元素类型，将uid传递给selectOrdersById-->
        <collection property="ordersList" ofType="com.po.Orders" column="uid" 
                    select="com.dao.OrdersDao.selectOrdersById"/>
    </resultMap>
    <select id="selectUserOrdersById1" parameterType="Integer" resultMap="userAndOrders1">
        select * from myuser where uid = #{id}
    </select>

    <!-- 一对多 根据uid查询用户及其关联的订单信息：第二种方法（嵌套结果） -->
    <resultMap type="com.po.MyUser" id="userAndOrders2">
        <id property="uid" column="uid"/>
        <result property="uname" column="uname"/>
        <result property="usex" column="usex"/>
        <!-- 一对多关联查询，ofType表示集合中的元素类型 -->
        <collection property="ordersList" ofType="com.po.Orders" >
            <id property="id" column="id"/>
            <result property="ordersn" column="ordersn"/>
        </collection>
    </resultMap>
    <select id="selectUserOrdersById2" parameterType="Integer" resultMap="userAndOrders2">
        select u.*,o.id,o.ordersn from myuser u, orders o where u.uid = o.user_id and u.uid=#{id}
    </select>


    <!-- 一对多 根据uid查询用户及其关联的订单信息：第三种方法（使用POJO存储结果） -->
    <select id="selectUserOrdersById3" parameterType="Integer" resultType="com.pojo.SelectUserOrdersById">
        select u.*,o.id,o.ordersn from myuser u, orders o where u.uid = o.user_id and u.uid=#{id}
    </select>
</mapper>
```

第三种 POJO 为：

```java
package com.pojo;
public class SelectUserOrdersById {
	private Integer uid;
	private String uname;
	private String usex;
	private Integer id;
	private String ordersn;
}
```

DAO：

```java
package com.dao;
import java.util.List;
import org.apache.ibatis.annotations.Mapper;
import org.springframework.stereotype.Repository;
import com.po.Orders;
@Repository("ordersDao")
@Mapper
public interface OrdersDao {
	//根据用户uid查询订单信息
	public List<Orders> selectOrdersById(Integer uid);
}
```

```java
public MyUser selectUserOrdersById1(Integer uid);
public MyUser selectUserOrdersById2(Integer uid);
public List<SelectUserOrdersById> selectUserOrdersById3(Integer uid);
```



###### 多对多

多对多级联可以通过两个一对多级联进行替换。例如，一个订单可以有多种商品，一种商品可以对应多个订单，订单与商品就是多对多的级联关系。使用一个中间表订单记录表，就可以将多对多级联转换成两个一对多的关系。

如：

```mysql
use springtest;
DROP TABLE IF EXISTS orders_detail;
CREATE TABLE orders_detail (
    id tinyint(2) NOT NULL AUTO_INCREMENT,
    orders_id tinyint(2) DEFAULT NULL,
    product_id tinyint(2) DEFAULT NULL,
    PRIMARY KEY (id),
    KEY orders_id (orders_id),
    KEY product_id (product_id),
    CONSTRAINT orders_id FOREIGN KEY (orders_id) REFERENCES orders (id),
    CONSTRAINT product_id FOREIGN KEY (product_id) REFERENCES product (id)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
INSERT INTO orders_detail VALUES ('1', '1', '1');
INSERT INTO orders_detail VALUES ('2', '1', '2');
INSERT INTO orders_detail VALUES ('3', '2', '1');
INSERT INTO orders_detail VALUES ('4', '2', '2');
INSERT INTO orders_detail VALUES ('5', '3', '1');
select * from orders_detail;
```

创两个一对多的 POJO：

```java
package com.po;
import java.util.List;
public class Product {
	private Integer id;
	private String name;
	private Double price;
	private List<Orders> orders;
}
```

```java
package com.po;
import java.util.List;
public class Orders {
	private Integer id;
	private  String ordersn;
	private List<Product> products;
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.dao.OrdersDao">
    <!-- 根据用户uid查询订单信息 -->
    <select id="selectOrdersById" parameterType="Integer"
            resultType="com.po.Orders">
        select * from orders where user_id=#{id}
    </select>

    <!-- 多对多关联 查询所有订单以及每个订单对应的商品信息（嵌套结果） -->
    <resultMap type="com.po.Orders" id="allOrdersAndProducts">
        <id property="id" column="id" />
        <result property="ordersn" column="ordersn" />
        <!-- 多对多关联 -->
        <collection property="products" ofType="com.po.Product">
            <id property="id" column="pid" />
            <result property="name" column="name" />
            <result property="price" column="price" />
        </collection>
    </resultMap>
    <select id="selectallOrdersAndProducts" resultMap="allOrdersAndProducts">
        select
        o.*,p.id as pid,p.name,p.price
        from orders o,orders_detail od,product p
        where od.orders_id = o.id
        and od.product_id = p.id
    </select>
</mapper>
```

```java
public List<Orders> selectallOrdersAndProducts();
```

```java
@Controller("moreToMoreController")
public class MoreToMoreController {
    @Autowired
    private OrdersDao ordersDao;
    public void test() {
        List<Orders> os = ordersDao.selectallOrdersAndProducts();
        for (Orders orders : os) {
            System.out.println(orders);
        }
    }
}
```



> 例子2：一个用户多个订单，一个订单多个商品，给定用户名，查询它的每个订单以及每个商品(以订单列表+(每个订单内嵌商品列表)输出)
>
> ```xml
> <?xml version="1.0" encoding="UTF-8" ?>
> <!DOCTYPE mapper
> PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
> "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
> <mapper namespace="work7.dao.OrderDao">
> 	<resultMap type="work7.pojo.Order" id="OrderRM">
> 		<id property="id" column="order_id" />
> 		<result property="money" column="order_money" />
> 		<result property="receiverinfo" column="order_receiverinfo" />
> 		<result property="timestamp" column="order_time" />
> 		<result property="userid" column="user_id" />
> 		<collection property="orderItems" javaType="List"
> 			ofType="work7.pojo.OrderItem" column="order_id"
> 			select="queryOrderItems" />
> 	</resultMap>
> 	<select id="queryOrder" parameterType="String"
> 		resultMap="OrderRM">
> 		select * from t_order where user_id=#{uid}
> 	</select>
> 	<select id="queryOrderItems" parameterType="String"
> 		resultType="work7.pojo.OrderItem">
> 		select * from t_order_item where order_id=#{oid}
> 	</select>
> </mapper>
> ```
>
> 解析：先查到一个 list，代表所有 order，然后通过 collection，对每个 order 再调一次 select，查到 items，将 items 存入 orders 的属性里。且本例里 order 的属性名与数据库不一致，但 order item 一致。



#### 动态SQL

动态SQL通常要做的事情是有条件地包含where子句的一部分

##### if

所以在MyBatis中，`<if>`元素是最常用的元素。它类似于Java中的 if 语句。

如：

```xml
<select id="selectUserByIf"  resultType="com.po.MyUser" 
        parameterType="com.po.MyUser">
    select * from user where 1=1
    <if test="uname !=null and uname!=''">
        and uname like concat('%',#{uname},'%')
    </if>
    <if test="usex !=null and usex!=''">
        and usex = #{usex}
    </if>
</select>
```

意思是这个查询，有时候无条件，有时候只要姓名，有时候只要求性别，有时候都要求，那么写这个一个查询就可以满足所有分类。



##### choose

类似于switch+break(不用自己写break)。

```xml
<select id="selectUserByChoose"  resultType="com.po.MyUser" parameterType="com.po.MyUser">
    select * from user where 1=1
    <choose>
        <when test="uname !=null and uname!=''">
            and uname like concat('%',#{uname},'%')
        </when>
        <when test="usex !=null and usex!=''">
            and usex = #{usex}
        </when>
        <otherwise>
            and uid > 10
        </otherwise>
    </choose>
</select>
```

只能执行所有 when 的其一或 otherwise。



##### trim

`<trim>`元素的主要功能是可以在自己包含的内容前加上某些前缀，也可以在其后加上某些后缀，与之对应的属性是prefix和suffix；可以把包含内容的首部的某些内容覆盖，即忽略，也可以把尾部的某些内容覆盖，对应的属性是prefixOverrides和suffixOverrides；正因为`<trim>`元素有这样的功能，所以也可以非常简单地利用`<trim>`来代替`<where>`元素的功能。

```xml
<!-- 使用trim元素，根据条件动态查询用户信息 -->
<select id="selectUserByTrim"  resultType="com.po.MyUser" parameterType="com.po.MyUser">
    select * from user 
    <trim prefix="where" prefixOverrides="and |or"> 
        <if test="uname !=null and uname!=''">  
            and uname like concat('%',#{uname},'%')
        </if>  
        <if test="usex !=null and usex!=''">  
            and usex = #{usex} 
        </if>    
    </trim>  
</select>
```

即把上文的 `where 1=1` 略掉了。



##### where

`<where>`元素的作用是会在写入`<where>`元素的地方输出一个where语句，另外一个好处是不需要考虑`<where>`元素里面的条件输出是什么样子的，MyBatis将智能处理。如果所有的条件都不满足，那么MyBatis就会查出所有的记录，如果输出后是and 开头的，MyBatis会把第一个and忽略，当然如果是or开头的，MyBatis也会把它忽略；此外，在`<where>`元素中不需要考虑空格的问题，MyBatis将智能加上。

```xml
<!-- 使用where元素，根据条件动态查询用户信息 -->
<select id="selectUserByWhere"  resultType="com.po.MyUser" parameterType="com.po.MyUser">
    select * from user 
    <where>
        <if test="uname !=null and uname!=''">
            and uname like concat('%',#{uname},'%')
        </if>
        <if test="usex !=null and usex!=''">
            and usex = #{usex}
        </if>
    </where>
</select>
```

跟 trim 差不多



##### set

更新列

```xml
<!-- 使用set元素，动态修改一个用户 -->
<update id="updateUserBySet" parameterType="com.po.MyUser">
    update user 
    <set>
        <if test="uname != null">uname=#{uname},</if>
        <if test="usex != null">usex=#{usex}</if>
    </set>
    where uid = #{uid}
</update>
```

如果只有一个 if 满足，那个多余的逗号不会在最后生成的表达式出现



##### foreach

`<foreach>`元素主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach元素的属性主要有item，index，collection，open，separator，close。

item表示集合中每一个元素进行迭代时的别名，index指定一个名字，用于表示在迭代过程中，每次迭代到的位置，

open表示该语句以什么开始，

separator表示在每次进行迭代之间以什么符号作为分隔符，

close表示以什么结束。

在使用`<foreach>`时，最关键的也是最容易出错的是collection属性，该属性是必选的，但在不同情况下，该属性的值是不一样的，主要有以下3种情况：
    如果传入的是单参数且参数类型是一个List的时候，collection属性值为list。
    如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array。
    如果传入的参数是多个时，需要把它们封装成一个Map，当然单参数也可以封装成Map。Map的key是参数名，collection属性值是传入的List或array对象在自己封装的Map中的key。

如：

```xml
<!-- 使用foreach元素，查询用户信息 -->
<select id="selectUserByForeach" resultType="com.po.MyUser"  parameterType="List">
    select * from user where uid in
    <foreach item="item" index="index" collection="list" open="(" separator="," close=")">
        #{item}
    </foreach>
</select>
```

调用：

```java
public List<MyUser> selectUserByForeach(List<Integer> listId);
```



```java
List<Integer> listIds = new ArrayList<Integer>();
listIds.add(31);
listIds.add(32);
List<MyUser> listForeach = userDao.selectUserByForeach(listIds);
System.out.println("Foreach元素================");
for (MyUser myUser : listForeach) {
	System.out.println(myUser);
}
```



##### bind

在模糊查询时，如果使用“${}”拼接字符串，则无法防止SQL注入问题。如果使用字符串拼接函数或连接符号，但不同数据库的拼接函数或连接符号不同，如MySQL的concat函数、Oracle的连接符号“||”。这样，SQL映射文件就需要根据不同的数据库提供不同的实现，显然是比较麻烦，且不利于代码的移植

即实现字符串连接操作，如：

```xml
<!-- 使用bind元素进行模糊查询 -->
<select id="selectUserByBind" resultType="com.po.MyUser"  parameterType="com.po.MyUser">
    <!-- bind中uname是com.po.MyUser的属性名 -->
    <bind name="param_uname" value="'%' + uname + '%'"/>
    select * from user where uname like #{param_uname}
</select>
```



#### MyBatis-Plus

##### 概念

MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。已经封装好了一些crud方法，不需要再写xml了，直接调用这些方法就行

优点：

1. 无侵入：Mybatis-Plus 在 Mybatis 的基础上进行扩展，只做增强不做改变，引入 Mybatis-Plus 不会对您现有的 Mybatis 构架产生任何影响，而且 MP 支持所有 Mybatis 原生的特性
2. 依赖少：仅仅需要添加MyBatisPlus启动依赖,和添加mysql-connector-java依赖。
3. 损耗小：启动即会自动注入基本CRUD，性能基本无损耗，直接面向对象操作
4. 通用CRUD操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求
5. 多种主键策略：支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题
6. 支持ActiveRecord：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可实现基本 CRUD 操作。
7. 支持代码生成：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎。比 Mybatis 官方的 Generator 更加强大
8. 支持自定义全局通用操作：支持全局通用方法注入
9. 内置分页插件：基于Mybatis物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于写基本List查询。
10. 内置性能分析插件：可输出Sql语句以及其执行时间，建议开发测试时启用该功能，能有效解决慢查询
11. 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，预防误操作。



##### 案例

准备随便一个数据库：

```sql
drop database mybatisplus;
create database mybatisplus;
use mybatisplus;
DROP TABLE IF EXISTS user;
CREATE TABLE user  (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  name varchar(10) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  sex char(6) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  pwd varchar(20) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  email varchar(20) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  PRIMARY KEY (id) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 28 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

INSERT INTO user VALUES (null, '张三', '男', '123', '1230@qq.com');
INSERT INTO user VALUES (null ,'李丽', '女', '123', '1231@qq.com');
INSERT INTO user VALUES (null, '李四', '男', '123', '1232@qq.com');
INSERT INTO user VALUES (null, '陈梓诺', '男', '123', '1233@qq.com');
INSERT INTO user VALUES (null, '方德海', '男', '123', '1234@qq.com');
INSERT INTO user VALUES (null, '苏舒', '男', '123', '1235@qq.com');
INSERT INTO user VALUES (null, '苏红梅', '女', '123', '1236@qq.com');
INSERT INTO user VALUES (null, '苏筱雯', '女', '123', '1237@qq.com');
INSERT INTO user VALUES (null, 'test01', '女', '123', '1238@qq.com');
INSERT INTO user VALUES (null, 'test02', '女', '123', '1239@qq.com');
INSERT INTO user VALUES (null, 'test03', '女', '123', '12310@qq.com');
INSERT INTO user VALUES (null, 'test04', '女', '123', '12311@qq.com');
select * from user;
```

创建 maven quick start 工程，pom project 下添加：

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.9.RELEASE</version>
</parent>
```

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

```xml
<dependency>
	<groupId>com.baomidou</groupId>
	<artifactId>mybatis-plus-boot-starter</artifactId>
	<version>3.4.3.1</version>
</dependency>
```

以下是mybatis-plus代码生成器和mybatisPlus Freemarker 模版引擎，需要自动生成代码时引入，不需要的话，可以不引入。

```xml
<!-- mybatis-plus代码生成器 -->
<dependency>
	<groupId>com.baomidou</groupId>
	<artifactId>mybatis-plus-generator</artifactId>
	<version>3.5.1</version>
</dependency>
<!-- mybatisPlus Freemarker 模版引擎 -->
<dependency>
    <groupId>org.freemarker</groupId>
   	<artifactId>freemarker</artifactId>
</dependency>
```

集成mybatis-plus时要把mybatis、mybatis-spring去掉，避免冲突，加入这些：

```xml
<dependency>
	<groupId>mysql</groupId>
	<artifactId>mysql-connector-java</artifactId>
</dependency>

<!--简化代码的工具包 -->
<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
	<version>1.18.22</version>
	<scope>provided</scope>
</dependency>
<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
	<optional>true</optional>
</dependency>
```

创建配置文件：

```properties
mybatis-plus.configuration.logImpl=org.apache.ibatis.logging.stdout.StdOutImpl
mybatis-plus.configuration.mapUnderscoreToCamelCase=true 
spring.datasource.driverClassName=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql:///mybatisplus?useUnicode=true&useSSL=false&characterEncoding=UTF-8
spring.datasource.username=root
spring.datasource.password=12345678
```

启动类：

```java
package cn.edu.scnu;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan("cn.edu.scnu.mapper")
public class StarterMyBatisPlus {
    public static void main(String[] args) {
        SpringApplication.run(StarterMyBatisPlus.class, args);
    }
}
```

POJO：

```java
package cn.edu.scnu.pojo;

import java.io.Serializable;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Builder;
import lombok.Data;

@Data
@Builder
@TableName(value = "User")
public class User implements Serializable {
    private static final long serialVersionUID = -5644799954031156649L;
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;
    private String name;
    private String sex;
    private String pwd;
    private String email;
}//驼峰命名，即如数据库是user_id,这里是userId
```

mapper：

```java
package cn.edu.scnu.mapper;

import org.apache.ibatis.annotations.Mapper;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import cn.edu.scnu.pojo.User;

@Mapper
public interface UserMapper extends BaseMapper<User> {
}
```

service:

```java
package cn.edu.scnu.service;

import java.util.List;
import cn.edu.scnu.pojo.User;

public interface UserService {
    public List<User> queryAll();
}
```

```java
package cn.edu.scnu.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import cn.edu.scnu.mapper.UserMapper;
import cn.edu.scnu.pojo.User;

@Service
public class UserServiceImpl  extends ServiceImpl<UserMapper, User> implements UserService {
    @Autowired
    UserMapper userMapper;
    @Override
    public List<User> queryAll() {
        return userMapper.selectList(null);
    }
}
```

controller:

```java
package cn.edu.scnu.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import cn.edu.scnu.pojo.User;
import cn.edu.scnu.service.UserService;

@RestController
public class UserController {
    @Autowired
    private UserService userService;

    @RequestMapping("/queryAll")
    public List<User> queryAll() {
        List<User> userlist = userService.queryAll();
        userlist.forEach(System.out::println);
        return userlist;
    }
}
```

运行示例：`http://localhost:8080/queryAll` 可以看到返回了json对象数组，只有一个对象。



##### 数据库查询

###### 精确

根据姓名查询

```java
@Override
public List<User> queryByName1(String name) {
    QueryWrapper<User> userQueryWrapper = new QueryWrapper<>();
    userQueryWrapper.eq("name", name);//与数据库一致而不是与POJO
    return userMapper.selectList(userQueryWrapper);
}
```

```java
@RequestMapping("/queryByName1")
public List<User> queryByName1(String name) {
    List<User> userlist=userService.queryByName1(name);
    userlist.forEach(System.out::println);
    return userlist;
}
```

`127.0.0.1:8080/queryByName1?name=苏舒`，可以看到返回了json对象数组，只有一个对象。

同理有 `selectOne`，找不到返回 null。



###### 模糊

```java
userQueryWrapper.like("name", name);
```

`http://127.0.0.1:8080/queryByName2?name=苏`



###### ID

```java
@Override
public User queryById(User user) {
    return userMapper.selectById(user.getId());
}
```

```java
@RequestMapping("/queryId")
public User queryById(int id) {		
    User user = userService.queryById(User.builder().id(id).build());
    System.out.println(user);
    return user;
}
```

`http://127.0.0.1:8080/queryId?id=28`

批量查询：

```java
@Override
public List<User> queryByIds() {
    List<Integer> idList = new ArrayList<>();
    idList.add(30);
    idList.add(31);
    return userMapper.selectBatchIds(idList);
}
```

```java
@RequestMapping("/queryIds")
public List<User> queryById() {		
    List<User> users = userService.queryByIds();
    users.forEach(System.out::println);
    return users;
}
```

`http://127.0.0.1:8080/queryIds`



###### 自定义字段

```java
@Override
public List<User> queryByNameMap(String column, Object value) {
    Map<String, Object> map = new HashMap<>();
    map.put(column, value);
    return userMapper.selectByMap(map);
}
```

```java
@RequestMapping("/queryMap")
public List<User> queryMap(String column,String value){
    List<User> users = userService.queryByNameMap(column,(Object)value);
    users.forEach(System.out::println);
    return users;
}
```

`http://127.0.0.1:8080/queryMap?column=name&value=苏舒`



###### 多条件

```java
@Override
public List<User> queryBy(Map<String, Object> map) {
    return userMapper.selectByMap(map);
}
```

```java
@RequestMapping("/queryBy")
public List<User> queryBy(String column1,String value1,String column2,String value2){
    Map<String,Object> map=new HashMap<>();
    map.put(column1,(Object)value1);
    map.put(column2,(Object)value2);
    List<User> userlist=userService.queryBy(map);
    userlist.forEach(System.out::println);
    return userlist;
}
```

`http://localhost:8080/queryBy?column1=name&value1=苏舒&column2=sex&value2=男`



###### 记录数

```java
@Override
public int count() {
    QueryWrapper<User> userQueryWrapper = new QueryWrapper<>();
    return userMapper.selectCount(userQueryWrapper);
}
```

```java
@RequestMapping("/count")
public int count(){
    return userService.count();
}
```

`http://localhost:8080/count`



##### 数据库更新

###### 添加

一条：

```java
@Override
public int add(User user) {
    return userMapper.insert(user);
}
```

```java
@RequestMapping("/add")
public String add() {
    User user=User.builder().id(102).name("李世民").sex("男").pwd("123").email("12388@qq.com").build();
    userService.add(user);//id已经存在会报错,故可不指定id
    return "添加了一条记录";
}
```

多条：直接 for-add。



###### 修改

```java
@Override
public void changeUserById(User user) {
    int num = userMapper.updateById(user);
    System.out.println("影响行数：" + num);
}
```

```java
@RequestMapping("/changeById")
public void changeById(int id) {
    User user = userService.queryById(User.builder().id(id).build());
    user.setName("靳国立");
    userService.changeUserById(user);
}
```

查询-修改：

```java
@Override
public void changeBy(User user, String column, Object val) {
    QueryWrapper<User> userQueryWrapper = new QueryWrapper<>();
    userQueryWrapper.eq(column, val);
    int num = userMapper.update(user, userQueryWrapper);
    System.out.println("影响行数：" + num);   
}
```

```java
@RequestMapping("/change")
public void change() {
    User user1 = User.builder().sex("男").build();//将性别修改为男
    userService.changeBy(user1, "name", "test01");//条件是：name=test01
    user1 = User.builder().name("xsn").build();//将姓名修改为xsn
    userService.changeBy(user1, "name", "test01");//条件是姓名等于test01
}
```



###### 删除

通过 ID：

```java
@Override
public int deleteById(User user) {
    return userMapper.deleteById(user.getId());
}
```

```java
@RequestMapping("/deleteById")
public String delete(int id) {
    User user = User.builder().id(id).build();
    int n=userService.deleteById(user);
    return "删除了"+n+"条记录！";
}
```

删多个：

```java
@Override
public int deleteByIds(List<Integer> idList) {
    int num = userMapper.deleteBatchIds(idList);
    return num;
} 
```

```java
@RequestMapping("/deleteByIds")
public String deleteByIds() {
    List<Integer> idList = new ArrayList<>();
    idList.add(1);
    idList.add(2);
    idList.add(3);//找不到跳过
    int n=userService.deleteByIds(idList);
    return "删除了"+n+"条记录！";
}
```

条件删除：

```java
@Override
public int deleteBy(String column, Object val) {
    QueryWrapper<User> userQueryWrapper = new QueryWrapper<>();
    userQueryWrapper.eq(column, val);
    int num = userMapper.delete(userQueryWrapper);
    return num;
}
```

```java
@RequestMapping("/deleteByColumn")
public String deleteBy(String name,String value) {
    Object val=(Object)value;
    int n = userService.deleteBy(name,val);
    return "删除了"+n+"条记录！";
}
```





#### 其他

##### 数据库与POJO属性不一致

###### as

可以用 as 来重定义，如：

```mysql
use easydb;
DROP TABLE IF EXISTS t_order;
CREATE TABLE t_order (
  order_id char(36) NOT NULL DEFAULT '',
  order_money double DEFAULT '0',
  order_receiverinfo varchar(255) DEFAULT '',
  order_paystate int(11) DEFAULT '0',
  order_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  user_id char(36) DEFAULT NULL,
  PRIMARY KEY (order_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

```java
package work7.pojo;

import java.sql.Timestamp;

public class Order {
    private String id;
    private double money;
    private String receiverinfo;
    private int paystate;
    private Timestamp timestamp;
    private String userid;
    //adder and setter, tostring via source
```

```xml
<mapper namespace="work7.dao.OrderDao">
	<select id="findAll" resultType="work7.pojo.Order">
		select
		order_id as id,
		order_money as money,
		order_receiverinfo as receiverinfo,
		order_paystate as paystate,
		order_time as timestamp,
		user_id as userid
		from t_order;
	</select>
    <!-- select结尾有无分号无所谓 -->
</mapper>
```

```java
@Test
public void test01() {
    @SuppressWarnings("resource")
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
    OrderDao orderDao = (OrderDao) context.getBean("orderDao");
    List<Order> orders = orderDao.findAll();
    for (Order order : orders) {
        System.out.println(order);
    }
    System.out.println("Done");
}
```



###### resultMap

在上例，修改：

```xml
<resultMap type="work7.pojo.Order" id="OrderRM">
    <id property="id" column="order_id" />
    <result property="money" column="order_money" />
    <result property="receiverinfo" column="order_receiverinfo" />
    <result property="timestamp" column="order_time" />
    <result property="userid" column="user_id" />
    <result property="未知列名" column="未出现的列" />
    <!-- 上一行代码表明了无关多余列不会引起报错,即看成不必全用的map即可 -->
</resultMap>
<select id="findAll" resultMap="OrderRM">
    select * from t_order;
</select>
```



##### @Param

对 `#{}` 的一般数据类型进行约定定义，可以在 DAO 定义参数那里加上 `@Param("名字")`，如：

```java
import org.apache.ibatis.annotations.Param;
public List<Order> queryOrder(@Param("uid") String userid);
```

```xml
<select id="queryOrder" parameterType="String"
        resultMap="OrderRM">
    select * from t_order where user_id=#{uid}
</select>
```



##### public

如果 POJO 用了 public 属性，可以不用 getter 和 setter

```java
package work7.pojo;

public class OrderItem {
    public String product_id;
    public String product_name;
    public double product_price;
    public String product_category;
    public String product_imgurl;
    public int product_num;
    public String product_description;

    @Override
    public String toString() {
        return "OrderItem [product_id=" + product_id + ", product_name=" + product_name
                + ", product_price=" + product_price + ", product_category=" + product_category
                + ", product_imgurl=" + product_imgurl + ", product_num=" + product_num
                + ", product_description=" + product_description + "]";
    }
}
```

```mysql
DROP TABLE IF EXISTS t_order_item;
CREATE TABLE t_order_item (
  id bigint(20) NOT NULL AUTO_INCREMENT,
  order_id char(100) DEFAULT NULL,
  product_id char(36) DEFAULT NULL,
  num int(11) DEFAULT '0',
  product_image varchar(500) DEFAULT NULL,
  product_name varchar(100) DEFAULT NULL,
  product_price double DEFAULT NULL,
  PRIMARY KEY (id)
) ENGINE=InnoDB AUTO_INCREMENT=138 DEFAULT CHARSET=utf8;
```

```xml
<select id="queryOrderItems" parameterType="String"
    resultType="work7.pojo.OrderItem">
    select * from t_order_item where order_id=#{oid}
</select>
```

```java
public List<OrderItem> queryOrderItems(String orderid);
```



### Spring MVC

#### 概念

![image-20221013105245724](img/image-20221013105245724.png)

原理：

![image-20221013110012531](img/image-20221013110012531.png)

包含4个Spring MVC接口：DispatcherServlet、HandlerMapping、Controller和ViewResoler。

Spring MVC所有的请求都经过DispatcherServlet来统一分发。DispatcherServlet将请求分发给Controller之前，需要借助于Spring MVC提供的HandlerMapping定位到具体的Controller。

HandlerMapping接口负责完成客户请求到Controller映射。

Controller接口将处理用户请求，这和Java Servlet扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。

从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。

ViewResolver接口（视图解析器）在Web应用中负责查找View对象，从而将相应结果渲染给客户。



#### 程序例子

##### hello world

安装 tomcat，需要访问 [官网](https://tomcat.apache.org/download-90.cgi)，右方菜单栏点 tomcat9，下载 core 的 zip。然后解压，把 tomcat 解压目录的 bin 添加到全局目录。然后打开 bin 里面的 `setclasspath.bat`，添加代码：`set JAVA_HOME=D:\Program Files (x86)\java`，其中那个路径修改为自己的 java 根目录。需要保证 java 真的是 1.8 版本的。验证：shell 输入 `java -version`，如果不是就删一下全局路径等，然后重开 shell，直到可以为止。

在 [这里](https://sourceforge.net/projects/tomcatplugin/) 下载插件，解压，打开 plugins，选择与当前环境匹配的如 `9.1.2`，拉到 `eclipse/plugins`，重启 plugins。检验成功：preference 能看到 tomcat 项。

确保本地 eclipse **默认** java 版本是 1.8，否则会报错 `找不到或无法加载主类 org.apache.catalina.startup.Bootstrap`。

导入包，包括 `commons-logging` 和 `spring` 全家桶即 `aop,beans,context,core,expression,web,webmvc`。

右击项目，点property-deployment assembly-add-java build path entries-全选确认

如果跑动了，但 404，且断定无路径错误，出现 `The origin server did not find a current representation for the target...`，尝试看到栏目下方的 servers，右击close,clear, add and remove 净空，然后开到双击出来的页面，可以尝试把 server locations 调成 use tomcat installation。(不调好像也行)

跑动后，每次修改网页代码不需要重启，过几秒钟会自己更新的，但是有些代码(如 bean 这边的)需要重启。

找到 `webapp/WEB-INF/`(或 `?/WEB-INF/`)，部署 `web.xml` 和 `xxx-servlet.xml` 文件分别为：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns="http://xmlns.jcp.org/xml/ns/javaee" 
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" 
id="WebApp_ID" version="4.0">
<!--注意自己开的项目dynamic web project 的版本号，要对应上-->
<!--部署DispatcherServlet-->
<servlet>
    <servlet-name>xxx</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!-- 表示容器在启动时立即加载servlet -->
    <load-on-startup>1</load-on-startup>
</servlet> 
<servlet-mapping>
	<servlet-name>xxx</servlet-name>
	<!-- 处理所有URL-->
    <url-pattern>/</url-pattern>
</servlet-mapping>
</web-app>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
    	   http://www.springframework.org/schema/beans 
    	   http://www.springframework.org/schema/beans/spring-beans.xsd">                 
  <!--LoginController控制器类，映射到“/login”  -->  
  <bean name="/login" class="d1.controller.LoginController"/>
  <!--RegisterController控制器类，映射到“/register”  --> 
  <bean name="/register" class="d1.controller.RegisterController"/>
  <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
              id="internalResourceViewResolver">
       <!-- 前缀 -->
       <property name="prefix" value="/WEB-INF/jsp/" />
       <!-- 后缀 -->
       <property name="suffix" value=".jsp" />
  </bean>
    <!--根目录就是webapp-->
</beans>
```

如果路径不放这个地方，需要 `web.xml` 指定路径，如：

```xml
<init-params>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEN-INF/spring-config/springmvc-servlet.xml</param-value>  
</init-params>    
```

同目录创建 `jsp` 文件夹，在内创建两个文件 `login.jsp`, `register.jsp`，如：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
	登录页面。
</body>
</html>
```

在 `webapp/` 创建 `index.jsp`，即· `WEB-INF` 父目录。如：(注意没有第一行的话中文会乱码)

```jsp
<%@ page language="java" contentType="text/html; charset=utf-8"
    pageEncoding="utf-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
没注册的用户，请<a href="${pageContext.request.contextPath }/register">注册</a>！</br>
已注册的用户，去<a href="${pageContext.request.contextPath }/login">登录</a>！
</body>

</html>
```

创建两个对应 `xml` 的类：

```java
package d1.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

public class LoginController implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1)
            throws Exception {
        return new ModelAndView("login");
    }
}
```

这里 `login` 是根据上文 `xml` 自动补全了路径前后缀的。

运行：run as-run on server。

假设项目名是 `chn`，则打开：`http://localhost:8080/chn`



##### 登录

先连接一个数据库(见上文 `mybatis`)，如：

```mysql
USE easymall;
DROP TABLE IF EXISTS user;
CREATE TABLE user (
  id int(11) NOT NULL auto_increment,
  username varchar(20) default NULL,
  password varchar(40) default NULL,
  nickname varchar(100) default NULL,
  email varchar(60) default NULL,
  PRIMARY KEY  (id)
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

将 `easymall.po.User` 对应设置上这个数据表的 POJO，然后装配好 `easymall.mybatis `，包括 `easymall.dao.UserDao`，然后写一个 Service 实现类：

```java
package easymall.service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import easymall.dao.UserDao;
import easymall.po.User;
@Service("userService")
public class UserServiceImpl implements UserService {
    @Autowired
    private UserDao userDao;
    @Override
    public boolean login(User user) {
        return userDao.login(user) != null;
    }
}
```

然后到 `webapp` 根目录下，显然放一个 `index.jsp`，如：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
    <title>Ch10.2</title>
  </head>
  <body>
    没注册的用户，滚去<a href="${pageContext.request.contextPath }/index/register">注册</a>！<br>
    已注册的用户，滚去<a href="${pageContext.request.contextPath }/index/login">登录</a>！
  </body>
</html>
```

去到 `WEB-INF`，放 `web.xml`：

```xml
﻿<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns="http://xmlns.jcp.org/xml/ns/javaee" 
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>springmvc</display-name>
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>   
    <welcome-file>index.jsp</welcome-file>
  </welcome-file-list>
  <!-- 实例化application容器 -->
  <context-param>
  	<param-name>contextConfigLocation</param-name>
  	<param-value>classpath:applicationContext.xml</param-value>
  </context-param>
  <!-- 指定一ContextLoaderListener方式启动Spring容器 -->
  
  <listener>
  	<listener-class>
  		org.springframework.web.context.ContextLoaderListener
  	</listener-class>
  </listener>
  
  <!-- 配置 DispatcherServlet-->
  <servlet>
    <servlet-name>springmvc</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>springmvc</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
  
<!-- 避免中文乱码 -->
<filter>
    	<filter-name>characterEncodingFilter</filter-name>
    	<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    	<init-param>
      		<param-name>encoding</param-name>
      		<param-value>UTF-8</param-value>
    	</init-param>
    	<init-param>
     		 <param-name>forceEncoding</param-name>
      		<param-value>true</param-value>
    	</init-param>
  </filter>
  <filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>   

</web-app>
```

放 `springmvc-servlet.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:context="http://www.springframework.org/schema/context" 
xmlns:mvc="http://www.springframework.org/schema/mvc" 
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd 
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context.xsd 
http://www.springframework.org/schema/mvc 
http://www.springframework.org/schema/mvc/spring-mvc.xsd ">


<!-- 使用扫描机制，扫描控制器类 -->
<context:component-scan base-package="easymall.controller"/>     
 
    
<mvc:annotation-driven />
  <!-- annotation-driven用于简化开发的配置，
    注解DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter -->
    <!-- 使用resources过滤掉不需要dispatcher servlet的资源。
    使用resources时，必须使用annotation-driven，不然resources元素会阻止任意控制器被调用。
    如果不使用resources，则annotation-driven可以没有。 -->  
    
    <!-- 允许css目录下所有文件可见 -->
    <mvc:resources location="/WEB-INF/css/" mapping="/css/**"></mvc:resources> 
    <!-- 允许html目录下所有文件可见 -->
    <mvc:resources location="/WEB-INF/html/" mapping="/html/**"></mvc:resources> 
     <!--允许images目录下所有文件可见 -->
    <mvc:resources location="/WEB-INF/images/" mapping="/images/**"></mvc:resources> 
                  	
 <!-- 配置视图解析器 -->
  	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
            id="internalResourceViewResolver">
       <!-- 前缀 -->
       <property name="prefix" value="/WEB-INF/jsp/" />
       <!-- 后缀 -->
       <property name="suffix" value=".jsp" />
  </bean>
</beans>
```

加子目录 `css/common.css` 如：

```css
* {
	margin: 0px;
	padding: 0px;
}
body {
	font-family: Arial, Helvetica, sans-serif;
	font-size: 12px;
	margin: 0px auto;
	background-image: url(../images/bb.jpg)
}
a {
	color: #000000;
	text-decoration: none; 
}
a:hover {
	background-color: #006633; 
	color: #FFFFFF;
}
```

加子目录 `images/,html/`，加点图片。

加关键字目录 `jsp/`，里面有 `register.jsp`：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
	.textSize{
		width: 100pt;
		height: 15pt
	}
</style>
<title>注册画面</title>
<script type="text/javascript">
	//注册时检查输入项
	function allIsNull(){
		var name=document.registForm.username.value;
		var pwd=document.registForm.password.value;
		var repwd=document.registForm.repassword.value;
		if(name==""){
			alert("请输入姓名！");
			document.registForm.username.focus();
			return false;
		}
		if(pwd==""){
			alert("请输入密码！");
			document.registForm.password.focus();
			return false;
		}
		if(repwd==""){
			alert("请输入确认密码！");
			document.registForm.repassword.focus();
			return false;
		}
		if(pwd!=repwd){
			alert("2次密码不一致，请重新输入！");
			document.registForm.password.value="";
			document.registForm.repassword.value="";
			document.registForm.password.focus();
			return false;
		}
		document.registForm.submit();
		return true;
	}
</script>
</head>
<body>
<h1 align="center">请注册</h1>
	<form action="${pageContext.request.contextPath }/user/register" method="post" name="registForm">
		<table 
		border=1 
		bgcolor="lightblue" 
		align="center">
			<tr>
				<td>姓名：</td>
				<td>
					<input class="textSize" type="text" name="username" value="${user.username }"/>
				</td>
			</tr>
			
			<tr>
				<td>密码：</td>
				<td><input class="textSize" type="password" maxlength="20" name="password"/></td>
			</tr>
			
			<tr>
				<td>确认密码：</td>
				<td><input class="textSize" type="password" maxlength="20" name="repassword"/></td>
			</tr>
			
			<tr>
				<td colspan="2" align="center"><input type="button" value="注册" onclick="allIsNull()"/></td>
			</tr>

		</table>
		<h2 align="center">${user.username}</h2>
	</form>
</body>
</html>
```

 `login.jsp`：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>  
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>后台登录</title>
	<style type="text/css">
	table{
		text-align: center;
	}
	.textSize{
		width: 120px;
		height: 25px;
	}
	* {
		margin: 0px;
		padding: 0px;
	}
	body {
		font-family: Arial, Helvetica, sans-serif;
		font-size: 12px;
		margin: 10px 10px auto;
		background-image: url(${pageContext.request.contextPath }/images/bb.jpg);
	}
	</style>
	<script type="text/javascript">
	//确定按钮
	function gogo(){
		document.forms[0].submit();
	}
	//取消按钮
	function cancel(){
		document.forms[0].action = "";
	}
	</script>
  </head>
  <body>
  	<form action="${pageContext.request.contextPath }/user/login" method="post">
	<table>
		<tr>
			<td colspan="2"><img src="${pageContext.request.contextPath }/images/login.gif"></td>
		</tr>
		<tr>
			<td>姓名：</td>
			<td><input type="text" name="username"  class="textSize"></td>
		</tr>
		<tr>
			<td>密码：</td>
			<td><input type="password" name="password" class="textSize"></td>
		</tr>
		<tr>
			<td colspan="2">
				<input type="image" src="${pageContext.request.contextPath }/images/ok.gif" onclick="gogo()" >
				<input type="image" src="${pageContext.request.contextPath }/images/cancel.gif" onclick="cancel()" >
			</td>
		</tr>
	</table>
	${messageError }
	</form>
  </body>
</html>
```

`main.jsp`：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>主页面</title>
</head>
<body>
	欢迎${sessionScope.user.username }访问该系统。
</body>
</html>
```

然后做两个控制器：

```java
package easymall.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("/index")
public class IndexController {
    @RequestMapping("/login")
    private String login() {
        return "login";
    }

    @RequestMapping("/register")
    private String register() {
        return "register";
    }
}
```

```java
package easymall.controller;

import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import easymall.po.User;
import easymall.service.UserService;

@Controller
@RequestMapping("/user")
public class UserController {
    @Autowired
    private UserService userService;

    @RequestMapping("/login")
    private String login(String username, String password, HttpSession session, Model model) {
//        System.out.println(username + ", " + password);
        User user = new User();
        user.setUsername(username);
        user.setPassword(password);
        if (userService.login(user)) {
            session.setAttribute("user", user);
            return "main";
        } else {
            model.addAttribute("messageError", "用户名或密码错误");
            return "login";
        }
    }

    //暂时没用到
    @RequestMapping("/dologin")
    private String Login(User user, HttpSession session, Model model) {
        if (userService.login(user)) {
            session.setAttribute("user", user);
            return "main";
        } else {
            model.addAttribute("messageError", "用户名或密码错误");
            return "login";
        }
    }
}
```



##### 登录+maven

实现了：

- 基于 jsp 跳转 html 混用了 jsp,html

具体部署：

创建 quickstart，搞一个如下 pom：

```xml
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>1.3.0</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>jstl</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.tomcat.embed</groupId>
        <artifactId>tomcat-embed-jasper</artifactId>
    </dependency>
</dependencies>
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.9.RELEASE</version>
</parent>
```

配好配置：

```properties
spring.datasource.driverClassName=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql:///hw10?useSSL=false
spring.datasource.username=root
spring.datasource.password=1
mybatis.typeAliasesPackage=hw10.pojo
mybatis.mapperLocations=classpath:mapper/*.xml
mybatis.configuration.mapUnderscoreToCamelCase=true
spring.mvc.view.prefix=/WEB-INF/
spring.mvc.view.suffix=.jsp
```

随便建一个数据库：

```mysql
drop database if exists hw10;
create database if not exists hw10;
use hw10
create table t_user (
    username varchar(16) not null,
    psw varchar(16) not null
);
insert into t_user values ('baicha', 'bc1234');
```

写启动器：

```java
package hw10;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@MapperScan("hw10/mapper")
@SpringBootApplication
public class Starter {
    public static void main(String[] args) {
        SpringApplication.run(Starter.class, args);
    }
}
```

写 POJO，略。

写 mapper：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="hw10.mapper.UserMapper">
    <select id="queryUser" parameterType="string" resultType="hw10.pojo.User">
        select * from t_user where username=#{username} 
    </select>
</mapper>
```

写 DAO：

```java
package hw10.mapper;
import hw10.pojo.User;
public interface UserMapper {
    User queryUser(String username);
}
```

写 Service：

```java
package hw10.service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import hw10.mapper.UserMapper;
import hw10.pojo.User;
@Service
public class LoginDBO {
    @Autowired
    private UserMapper userMapper;
    public boolean login(String username, String psw) {
        User user2 = userMapper.queryUser(username);
        if (user2 == null || !psw.equals(user2.getPsw())) {
            return false;
        }
        return true;
    }
}
```

写 Controller：

```java
package hw10.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;
import hw10.service.LoginDBO;

@Controller
public class LoginValidate {
    @Autowired
    private LoginDBO loginDBO;

    @RequestMapping("tologin")
    @ResponseBody
    public ModelAndView login(String username, String psw) {
        boolean suc = loginDBO.login(username, psw);
        ModelAndView mv = new ModelAndView("returnMessage");
        if (suc) {
            mv.addObject("state", "登录成功。你好，" + username);
        } else {
            mv.addObject("state", "登陆失败");
        }
        return mv;
    }

    @RequestMapping("/")
    public String index() {
        return "index";
    }
}
```

去 `src/main/webapp` 写一个主页 `Login.html`：

```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:th="http://www.thymeleaf.org">
<head>
<meta http-equiv="Content-Type" 
content="text/html; charset=UTF-8" />
<title>主页</title>
</head>

<body>
    <form action="tologin" method="post">
        用户名：<input type="text" name="username" /><br/> 密码 <input type="password" name="psw" /> <br/>
        <input type="submit" value="登录" />
    </form>
</body>

</html>
```

写一个跳主页的 `WEB-INF/index.jsp`：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
    <title>主页</title>
  </head>
  <body>
    <div>
        <% response.sendRedirect("Login.html"); %>
    </div>
  </body>
</html>
```

同目录下写一个登陆成功反馈的 `returnMessage.jsp`：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
    <title>消息</title>
  </head>
  <body>
    <div>${state}</div>
  </body>
</html>
```





#### 控制器

##### 注解装配

###### 一般

上文例子里设了两个控制器。

使用基于注解的控制器，具有如下两个优点：
1．在基于注解的控制器类中，可以编写多个处理方法，进而可以处理多个请求（动作）。这就允许将相关的操作编写在同一个控制器类中，从而减少控制器类的数量，方便以后的维护。
2．基于注解的控制器不需要在配置文件中部署映射，仅需要使用`RequestMapping`注释类型注解一个方法进行请求处理。

在Spring MVC中，使用`org.springframework.stereotype.Controller`注解类型声明某类的实例是一个控制器

```java
package controller;
import org.springframework.stereotype.Controller;
/** “@Controller”表示IndexController的实例是一个控制器
 * @Controller相当于@Controller("indexController")
 * 或@Controller(value = "indexController")
 */
@Controller
public class IndexController {
	//处理请求的方法
}
```

显然可以在上文 `-servlet.xml` 开启包扫描如：

```xml
<context:component-scan base-package="controller"/>
```

在基于注解的控制器类中，可以为每个请求编写对应的处理方法，用 `org.springframework.web.bind.annotation.RequestMapping`

方法级：

```jsp
<body>
没注册的用户，请
<a href="${pageContext.request.contextPath }/index/register">注册</a>！
<br>
已注册的用户，去
<a href="${pageContext.request.contextPath }/index/login">登录</a>！
</body>
```

```java
@Controller
public class IndexController {
	@RequestMapping(value = "/index/login")
	public String login() {
	/**login代表逻辑视图名称，需要根据Spring MVC配置
	 * 文件中internalResourceViewResolver的前缀和后缀找到对应的物理视图 */
		return "login";    //      "/WEB-INF/jsp/login.jsp"
	}
	@RequestMapping(value = "/index/register")
	public String register() {
		return "register";    //      "/WEB-INF/jsp/register.jsp"
	}
}
```

类级别注解：

```java
@Controller
@RequestMapping("/index")
public class IndexController {
	@RequestMapping("/login")
	public String login() {
		return "login";
	}
	@RequestMapping("/register")
	public String register() {
		return "register";
	}
}
```

即进行路径拼接。



###### @Autowired

在Spring MVC中，为了能被作为依赖注入，类必须使用`org.springframework.stereotype.Service`注解类型注明为@Service（一个服务）。另外，还需要在配置文件中使用`<context:component-scan base-package="基本包"/>`元素来扫描依赖基本包。



##### 传入参数

###### 实体bean

例如上面一直使用的例子。

可以加 get/post 表单，如：

```java
public class UserForm {
	private String uname;//与请求参数名称相同
	private String upass;
	private String reupass;
}
```

```jsp
<td><input type="text" name="uname" class="textSize"></td>
<td><input type="password" name="upass" class="textSize"></td>
<td><input type="password" name="reupass" class="textSize"></td>
```

如 `register.jsp`：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
	.textSize{
		width: 100pt;
		height: 15pt
	}
</style>
<title>注册画面</title>
<script type="text/javascript">
	//注册时检查输入项
	function allIsNull(){
		var name=document.registForm.uname.value;
		var pwd=document.registForm.upass.value;
		var repwd=document.registForm.reupass.value;
		if(name==""){
			alert("请输入姓名！");
			document.registForm.uname.focus();
			return false;
		}
		if(pwd==""){
			alert("请输入密码！");
			document.registForm.upass.focus();
			return false;
		}
		if(repwd==""){
			alert("请输入确认密码！");
			document.registForm.reupass.focus();
			return false;
		}
		if(pwd!=repwd){
			alert("2次密码不一致，请重新输入！");
			document.registForm.upass.value="";
			document.registForm.reupass.value="";
			document.registForm.upass.focus();
			return false;
		}
		document.registForm.submit();
		return true;
	}
</script>
</head>
<body>
<h1 align="center">请注册</h1>
	<form action="${pageContext.request.contextPath }/user/register" method="post" name="registForm">
		<table 
		border=1 
		bgcolor="lightblue" 
		align="center">
			<tr>
				<td>姓名：</td>
				<td>
					<input class="textSize" type="text" name="uname" value="${user.uname }"/>
				</td>
			</tr>
			
			<tr>
				<td>密码：</td>
				<td><input class="textSize" type="password" maxlength="20" name="upass"/></td>
			</tr>
			
			<tr>
				<td>确认密码：</td>
				<td><input class="textSize" type="password" maxlength="20" name="reupass"/></td>
			</tr>
			
			<tr>
				<td colspan="2" align="center"><input type="button" value="注册" onclick="allIsNull()"/></td>
			</tr>

		</table>
		<h2 align="center">${user.uname}</h2>
	</form>
</body>
</html>
```

`login.jsp`：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>  
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>后台登录</title>
	<style type="text/css">
	table{
		text-align: center;
	}
	.textSize{
		width: 120px;
		height: 25px;
	}
	* {
		margin: 0px;
		padding: 0px;
	}
	body {
		font-family: Arial, Helvetica, sans-serif;
		font-size: 12px;
		margin: 10px 10px auto;
		background-image: url(${pageContext.request.contextPath }/images/bb.jpg);
	}
	</style>
	<script type="text/javascript">
	//确定按钮
	function gogo(){
		document.forms[0].submit();
	}
	//取消按钮
	function cancel(){
		document.forms[0].action = "";
	}
	</script>
  </head>
  <body>
  	<form action="${pageContext.request.contextPath }/user/login" method="post">
	<table>
		<tr>
			<td colspan="2"><img src="${pageContext.request.contextPath }/images/login.gif"></td>
		</tr>
		<tr>
			<td>姓名：</td>
			<td><input type="text" name="uname"  class="textSize"></td>
		</tr>
		<tr>
			<td>密码：</td>
			<td><input type="password" name="upass" class="textSize"></td>
		</tr>
		<tr>
			<td colspan="2">
				<input type="image" src="${pageContext.request.contextPath }/images/ok.gif" onclick="gogo()" >
				<input type="image" src="${pageContext.request.contextPath }/images/cancel.gif" onclick="cancel()" >
			</td>
		</tr>
	</table>
	${messageError }
	</form>
  </body>
</html>
```

在 `-servlet.xml` 可以添加：

```xml
<mvc:annotation-driven />
<!-- annotation-driven用于简化开发的配置，
    注解DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter -->
<!-- 使用resources过滤掉不需要dispatcher servlet的资源。
    使用resources时，必须使用annotation-driven，不然resources元素会阻止任意控制器被调用。
    如果不使用resources，则annotation-driven可以没有。 -->  

<!-- 允许css目录下所有文件可见 -->
<mvc:resources location="/css/" mapping="/css/**"></mvc:resources> 
<!-- 允许html目录下所有文件可见 -->
<mvc:resources location="/html/" mapping="/html/**"></mvc:resources> 
<!--允许images目录下所有文件可见 -->
<mvc:resources location="/images/" mapping="/images/**"></mvc:resources> 
```



###### 处理方法形参

对表单提交的信息，以参数形式在控制器列出：

```java
@RequestMapping("/register")
public String register(String uname,String upass,Model model){
    if("lisi".equals(uname) && "123456".equals(upass)){
        logger.info("成功");
        return "register";//返回register.jsp
    }else {
        logger.info("失败");
        model.addAttribute("uname", uname);
        return "register";//返回register.jsp
    }
}
```

还可以传入 `HttpSession session`。有 `session.getAttribute("属性名").toString()`。

可以 `model.addAttribute("属性","字符串")`。将值渲染到 `jsp` 的 `{}`。



###### get/post

通过`HttpServletRequest`接收请求参数，适用于get和post提交请求方式

```java
public String register(HttpServletRequest request, Model model) {
	String uname = request.getParameter("uname");
	String upass = request.getParameter("upass");
    if("chenxiao".equals(uname) 
       && "123456".equals(upass)){
        logger.info("成功");
        return "register";//返回register.jsp
    }else {
        logger.info("失败");
        model.addAttribute("uname", uname);
        return "register";//返回register.jsp
    }
}
```



###### URL

```java
@RequestMapping(value="/register/{uname}/{upass}", method=RequestMethod.GET)
public String register(@PathVariable String uname,@PathVariable String upass, Model model) {
	if("zhangsan".equals(uname) 
			&& "123456".equals(upass)){
		logger.info("成功");
		return "login";//返回register.jsp
	}else {
		logger.info("失败");
		model.addAttribute("uname", uname);
		return "register";//返回register.jsp
	}
}       //http://localhost:8080/Ch10.2.1/user/register/zhangsan/123456
```

对 POST，需要 `HttpServletRequest` 对象，`HttpServletResponse` 对象，后者有 `getWriter().print()` 方法。



###### @RequestParam

通过`@RequestParam`接收请求参数，适用于get和post提交请求方式。当请求参数与接收参数名不一致时，“通过处理方法的形参接收请求参数”不会报404错误，而“通过`@RequestParam`接收请求参数”会400错误

```java
@RequestMapping("/register")
public String register(@RequestParam String uname,@RequestParam String upass, Model model) {
    if("zhangsan".equals(uname) 
       && "123456".equals(upass)){
        logger.info("成功");
        return "login";//返回register.jsp
    }else {
        logger.info("失败");
        model.addAttribute("uname", uname);
        return "register";//返回register.jsp
    }
}
```



###### @ModelAttribute

`@ModelAttribute`注解放在处理方法的形参上时，用于将多个请求参数封装到一个实体对象，从而简化数据绑定流程，而且自动暴露为模型数据用于视图页面展示时使用。而10.2.1节中只是将多个请求参数封装到一个实体对象，并不能暴露为模型数据（需要使用`model.addAttribute`语句才能暴露为模型数据，数据绑定与模型数据展示，可参考第12章的内容）。
通过`@ModelAttribute`注解接收请求参数，适用于get和post提交请求方式

```java
@RequestMapping("/register")
public String register(@ModelAttribute("user") UserForm user) {
	if("zhangsan".equals(user.getUname()) && "123456".equals(user.getUpass())){
		logger.info("成功");
		return "login";//注册成功，跳转到login.jsp
	}else{
		logger.info("失败");
//使用@ModelAttribute("user")与  model.addAttribute("user", user)功能相同
 //在register.jsp页面上可以使用EL表达式${user.uname}取  出ModelAttribute的uname值
		return "register";//返回register.jsp
	}
}
```

上述代码中“`@ModelAttribute("user") UserForm user`”语句的功能有两个，
    一是将请求参数的输入封装到user对象中；
    一是创建`UserForm`实例，以“user”为键值存储在Model对象中，与“`model.addAttribute("user", user)`”语句功能一样。如果没有指定键值，即“`@ModelAttribute UserForm user`”，那么创建`UserForm`实例时，以“`userForm`”为键值存储在Model对象中，与“`model.addAttribute("userForm", user)`”语句功能一样。

被`@ModelAttribute`注解的方法，将在每次调用该控制器类的请求处理方法前被调用。这种特性可以用来控制登录权限，当然控制登录权限的方法很多，例如拦截器、过滤器等。

注解一个非请求处理方法

```java
package controller;
import javax.servlet.http.HttpSession;
import org.springframework.web.bind.annotation.ModelAttribute;
public class BaseController {
	@ModelAttribute
	public void isLogin(HttpSession session) throws Exception{
		if(session.getAttribute("user")==null){
			throw new Exception("没有权限");
		}
	}
}

```

```java
package controller;
import org.springframework.web.bind.annotation.RequestMapping;
public class ModelAttributeController extends BaseController{
	@RequestMapping("/add")
	public String add(){
		return "addSuccess";
	}
	@RequestMapping("/update")
	public String update(){
		return "updateSuccess";
	}	
	@RequestMapping("/delete")
	public String delete(){
		return "deleteSuccess";
	}
}
```

`ModelAttributeController`类中的add、update、delete请求处理方法执行时，先执行父类`BaseController`中的`isLogin`方法判断登录权限。



> 代码汇总：
>
> ```java
> package controller;
> import javax.servlet.http.HttpServletRequest;
> import javax.servlet.http.HttpSession;
> import org.apache.commons.logging.Log;
> import org.apache.commons.logging.LogFactory;
> import org.springframework.stereotype.Controller;
> import org.springframework.ui.Model;
> import org.springframework.web.bind.annotation.ModelAttribute;
> import org.springframework.web.bind.annotation.PathVariable;
> import org.springframework.web.bind.annotation.RequestMapping;
> import org.springframework.web.bind.annotation.RequestMethod;
> import org.springframework.web.bind.annotation.RequestParam;
> 
> import pojo.UserForm;
> @Controller
> @RequestMapping("/user")
> public class UserController {
> 	//得到一个用来记录日志的对象，这样打印信息的时候能够标记打印的是那个类的信息
> 	private static final Log logger = LogFactory.getLog(UserController.class);
> 	//处理登录
> 	@RequestMapping("/login")
> 	public String login(UserForm user, HttpSession session, Model model) {
> 		if("zhangsan".equals(user.getUname()) 
> 				&& "123456".equals(user.getUpass())){
> 			
> 			session.setAttribute("u", user);
> 			logger.info("成功");
> 			return "main";//登录成功，跳转到main.jsp
> 		}else{
> 			logger.info("失败");
> 			model.addAttribute("messageError", "用户名或密码错误");
> 			return "login";
> 		}	
> 	}
> /*
> 	//处理注册
> 	@RequestMapping("/register")
> 	public String register(UserForm user,Model model) {
> 		if("zhangsan".equals(user.getUname()) 
> 				&& "123456".equals(user.getUpass())){
> 			logger.info("成功");
> 			model.addAttribute("message", "注册成功，注册的用户名是："+user.getUname());
> 			//在register.jsp页面上可以使用EL表达式${message}取出
> 			return "register";//注册成功，跳转到register.jsp
> 		}else{
> 			logger.info("失败");
> 			return "register";//返回register.jsp
> 		}
> 	}
> 
> 	
> 	@RequestMapping("/register")
> 	public String register(String uname,String upass,Model model){
> 		if("lisi".equals(uname) && "123456".equals(upass)){
> 			logger.info("成功");
> 			
> 			model.addAttribute("message", "注册成功，注册的用户名是："+uname);
> 			return "register";//返回register.jsp
> 		}else {
> 			logger.info("失败");
> 			model.addAttribute("uname", uname);
> 			return "register";//返回register.jsp
> 		}
> 	}
> 
> 
> 	@RequestMapping("/register")
> 	public String register(HttpServletRequest request, Model model) {
> 		String uname = request.getParameter("uname");
> 		String upass = request.getParameter("upass");
> 		if("chenxiao".equals(uname) 
> 				&& "123456".equals(upass)){
> 			logger.info("成功");
> 			model.addAttribute("message", "注册成功，注册的用户名是："+uname);
> 			return "register";//返回register.jsp
> 		}else {
> 			logger.info("失败");
> 			model.addAttribute("uname", uname);
> 			return "register";//返回register.jsp
> 		}
> 	}
> 
> 	@RequestMapping(value="/register/{uname}/{upass}", method=RequestMethod.GET)
> 	public String register(@PathVariable String uname,@PathVariable String upass, Model model) {
> 		if("zhangsan".equals(uname) 
> 				&& "123456".equals(upass)){
> 			logger.info("成功");
> 			model.addAttribute("message", "注册成功，注册的用户名是："+uname);
> 			return "register";//返回register.jsp
> 		}else {
> 			logger.info("失败");
> 			model.addAttribute("uname", uname);
> 			return "register";//返回register.jsp
> 		}
> 	}
> 	
> 
> 	@RequestMapping("/register")
> 	public String register(@RequestParam String uname,@RequestParam String upass, Model model) {
> 		if("zs".equals(uname) 
> 				&& "123".equals(upass)){
> 			logger.info("成功");
> 
> 			model.addAttribute("message", "注册成功，注册的用户名是："+uname);
> 			return "register";//返回register.jsp
> 		}else {
> 			logger.info("失败");
> 			model.addAttribute("uname", uname);
> 			return "register";//返回register.jsp
> 		}
> 	}
> */
> 
> @RequestMapping("/register")
> public String register(@ModelAttribute("user") UserForm user) {
> 	if("zs1".equals(user.getUname()) && "123".equals(user.getUpass())){
> 		logger.info("成功");
> 		return "register";//注册成功，跳转到login.jsp
> 	}else{
> 		logger.info("失败");
> //使用@ModelAttribute("user")与  model.addAttribute("user", user)功能相同
>  //在register.jsp页面上可以使用EL表达式${user.uname}取  出ModelAttribute的uname值
> 		return "register";//返回register.jsp
> 	}
> }
> }
> ```



###### 动态地址

```java
package com.vm.controller;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
@Controller
public class FilmController {
    //  影片详情页
    @GetMapping("/detail/{type}/{path}")
    public String toDetail(@PathVariable("type")String type, @PathVariable("path")String path) {
        return "detail/"+type+"/"+path;
    }
}

```

则输入 `localhost:8080/detail/vip/1`，`vip,1` 分别是这个函数的两个参数



#### 重定向和转发

在Spring MVC框架中，控制器类中处理方法的return语句默认就是转发实现，只不过实现的是转发到视图。

```java
//转发到一个请求方法（同一个控制器类里，可省略/index/）
return "forward:/index/isLogin";
//重定向到一个请求方法
return "redirect:/index/isRegister";
//转发到一个视图
return "register";
```



#### EL与JSTL

Expression Language EL 表达是语言

JSTL（Java server pages standarded tag library，即JSP标准标签库）

##### 表达式语言

EL 基本语法 `${表达式}`，类似 JSP 的 `<%=表达式>`，EL语句中的表达式值会被直接送到浏览器显示。

1. `[]`, `.` 运算符，获取 JavaBean 的属性，获取数组中的元素以及获取对象中的元素，如：

   JSP `<%=user.getAge ()%>` 对应 EL `${user.age}`, `${user["age"]}`

   Servlet: `String dogs[] = {"lili","huahua","guoguo"};model.addAttribute("dogs", dogs);` 则 EL `${dogs[0]}`

   Servlet:

   ```java
   ArrayList<UserBean> users = new ArrayList<UserBean>();
   UserBean ub1 = new UserBean("zhang",20);
   UserBean ub2 = new UserBean("zhao",50);
   users.add(ub1);
   users.add(ub2);
   model.addAttribute("users", users);
   ```

   EL: `${users[0].name}`

2. 算术运算符 `+-*/%`，可以 `div mod`。除不是整除

   `${13/2}或${13 div 2}` 得到 `6.5`

3. 关系运算符 `== != < <= > >=`，或 `eq ne lt gt le ge`，得到 `true/false`。

4. 逻辑运算符 `&& || ! and or not`。得到同上。

5. `empty` 运算符检测是否为 `null`，返回布尔值

6. `${A ? B : C}` 三目条件运算符

##### EL隐含对象

共 11 个。

与作用范围有关的EL隐含对象有：`pageScope`、`requestScope`、`sessionScope`和`applicationScope`，分别可以获取JSP隐含对象`pageContext`、request、session和application中的数据。如果在EL中没有使用隐含对象指定作用范围，则会依次从page、request、session、application范围查找，找到就直接返回，不再继续找下去，如果所有范围都没有找到，就返回空字符串。获取数据的格式如下：

`${EL隐含对象.关键字对象.属性}或${EL隐含对象.关键字对象}`

如：

```c++
ArrayList<User> users=new ArrayList<User>();
User user1=new User("zs",20);
User user2=new User("ls",20);
users.add(user1);
users.add(user2);
request.setAttribute("users", users );
```

则 EL 为 `${requestScope.array[0].name}`。

与请求参数相关的EL隐含对象有`param`和`paramValues`。获取数据的格式：`${EL隐含对象.参数名}`

设有 `post` 表单里 `name='habit'` 的三个 `input` 标签的 `checkbox`，和输入框 `name='username'`。可以 `${param.username}, ${paramValue.habit[0]}`。



##### 例子

导包，除了 `commons-logging` 和 spring 全家桶 `aop,beans,context,core,expression,web,webmvc` 还有 `taglibs-standard-impl` 和 `taglibs-standard-spec`。初始化项目(不需要 `applicationContext.xml`)。要 `web.xml` 和 `-servlet.xml` 后者如

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd 
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context.xsd 
http://www.springframework.org/schema/mvc 
http://www.springframework.org/schema/mvc/spring-mvc.xsd ">
	<!-- 使用扫描机制，扫描控制器类 -->
	<context:component-scan
		base-package="d2.controller" />
	<!--LoginController控制器类，映射到“/login” -->
	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver"
		id="internalResourceViewResolver">
		<!-- 前缀 -->
		<property name="prefix" value="/WEB-INF/jsp/" />
		<!-- 后缀 -->
		<property name="suffix" value=".jsp" />
	</bean>
	<!--根目录就是webapp -->
</beans>
```

建两个 `input.jsp`, `show.jsp` 分别为：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
	pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>一个页面！
</body>
</html>
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
	pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
	${requestScope.name[0]}
	<br>${address[0]}
</body>
</html>
```

创建一个类：

```java
package d2.controller;

import javax.servlet.http.HttpServletRequest;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class InputController {
    @RequestMapping("/input")
    public String input(HttpServletRequest request, Model model) {
        String names[] = { "白茶", "禾枫", "弥明", "果冻" };
        request.setAttribute("name", names);
        String address[] = { "A区", "B区" };
        model.addAttribute("address", address);
        return "show";
    }
}
```



##### JSTL标签库

JSTL标准标签库由5个不同功能的标签库组成，包括Core、I18N、XML、SQL以及Functions

库：`taglibs-standard-impl-1.2.5.jar,taglibs-standard-spec-1.2.5.jar` 

如果使用Core标签库，首先需要在JSP页面中使用 `taglib` 标记定义前缀与`uri`引用，代码：`<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>`

​    如果使用Functions标签库，首先需要在JSP页面中使用 `taglib` 标记定义前缀与 `uri` 引用，代码：`<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions"%>`

###### out

`<c:out>`用来显示数据的内容，与 `<%= 表达式 %>` 或 `${表达式}` 类似。格式：`<c:out value="输出的内容" [default="defaultValue"]/>`或

```jsp
<c:out value="输出的内容">
    defaultValue
</c:out>
```

其中，value值可以是一个EL表达式，也可以是一个字符串；default可有可无，当value值不存在时，就输出`defaultValue`。也可以是属性如 `default="" />`。

###### set

设置作用域变量
可以使用 `<c:set>` 在page、request、session、application等范围内设置一个变量。格式：`<c:set value="value" var="varName" [scope="page|request|session|application"]/>`

如：`<c:set value="zhang" var="userName" scope="session"/>`

相当于：
`<% session.setAttribute("userName","zhang");%>`

使用 `<c:set>` 设置JavaBean的属性时，必须使用target属性进行设置。格式：`<c:set value="value" target="target"  property="propertyName"/>`

该代码将value值付给target对象(JavaBean对象)的`propertyName`属性。如果target为null或没有set方法则抛出异常。

###### remove

如果要删除某个变量，则可以使用`<c:remove>`标签。例如：
	`<c:remove var="userName" scope="session"/>`相当于：
`<%session.removeAttribute("userName") %>`

###### if

```jsp
<c:if test="条件表达式">
    主体内容
</c:if>
```

其中，条件表达式可以是EL表达式，也可以是JSP表达式。如果表达式的值为true，则会执行`<c:if>`的主体内容，但是没有相对应的`<c:else>`标签。如果想在条件成立时执行一块内容，不成立时执行另一块内容，则可以使用`<c:choose>`、`<c:when>`及`<c:otherwise>`标签。

```jsp
<c:choose>
    <c:when test="条件表达式1">
        主体内容1
    </c:when>
    <c:when test="条件表达式2">
        主体内容2
    </c:when>
    <c:otherwise>
        表达式都不正确时，执行的主体内容
    </c:otherwise>
</c:choose>
```

###### for

```jsp
<c:forEach var="变量名" items="数组或Collection对象">
    循环体
</c:forEach>
```

其中，items属性可以是数组或Collection对象，每次循环读取对象中的一个元素，并赋值给`var`属性指定的变量，之后就可以在循环体使用`var`指定的变量获取对象的元素。

```jsp
<c:forEach var="x" varStatus="status" begin="0" end="10">
    <tr>
        <td>${x }</td><td>${x * x }</td>
        <td>${status.index}</td>
    </tr>
</c:forEach>
```

`<c:forTokens>`用于迭代字符串中由分隔符分隔的各成员，它是通过`java.util.StringTokenizer`实例来完成字符串的分隔，属性items和`delims`作为构造`StringTokenizer`实例的参数。语法格式如下：

```jsp
<c:forTokens var="变量名" items="要迭代的String对象" delims="指定分隔字符串的分隔符">
    循环体
</c:forTokens>
```

例如：

```jsp
<c:forTokens items="a1:a2:a3" delims=":"  var="name">
    ${name}<br/>
</c:forTokens>
```

###### contains

判断一个字符串中是否包含指定的子字符串。如果包含，则返回true，否则返回false。其定义如下：`contains(string, substring)` 如 `${fn:contains("I am studying", "am") }`

不区分大小写的话：`containsIgnoreCase(string, substring)`

###### endsWith

该函数功能是判断一个字符串是否以指定的后缀结尾。其定义：`endsWith(string, suffix)`

###### indexOf

该函数功能是返回指定子字符串在某个字符串中第一次出现时的索引，找不到时，将返回-1。其定义 `indexOf(string, substring)`

###### join

该函数功能是将一个String数组中的所有元素合并成一个字符串，并用指定的分隔符分开。其定义如下：`join(array, separator)`

###### length

该函数功能是返回集合中元素的个数，或者字符串中的字符个数。其定义如下

###### replace

该函数功能是将字符串中出现的所有`beforestring`用`afterstring`替换，并返回替换后的结果 `replace(string, beforestring, afterstring)`

###### split

将一个字符串，使用指定的分隔符separator分离成一个子字符串数组 `split(string, separator)`

###### startsWith

判断一个字符串是否以指定的前缀开头。`startsWith(string, prefix)`

###### substring

返回一个字符串的子字符串，下标从 0 开始，范围是 $[begin,end)$

`substring(string, begin, end)`

###### toLowerCase

同理 Upper。

###### trim

将一个字符串开头和结尾的空白去掉



#### 常用对象

##### POJO

参数可以按顺序填入对象，作为对象使用，如下面等效：

```java
private String login(String username, String password, HttpSession session, Model model) {
        User user = new User();
        user.setUsername(username);
        user.setPassword(password);
    ...
```

```java
private String login(User user, HttpSession session, Model model) {
```



##### session

```java
import javax.servlet.http.HttpSession;
```



参数：`HttpSession session`

常用方法：

```java
session.setAttribute("键", 对象);
session.removeAttribute("键");
session.getAttribute("键");
session.invalidate();
```

##### HttpServletResponse

```java
import javax.servlet.http.HttpServletResponse;
```

注意别打成 request。



参数：`HttpServletResponse response`

常用方法：

```java
response.getWriter().print("恭喜您，用户名可以使用！");
```

示例：

```js
var url="${ pageContext.request.contextPath }/user/checkUser";
var username=$("input[name='username']").val();
$.post(url,{"username":username},
    function(data){
    	$("#username_msg").html(data);
	}
);
```



#### 数据绑定

在Spring MVC框架中，数据绑定有这样几层含义：绑定请求参数输入值到领域模型、模型数据到视图的绑定、模型数据到表单元素的绑定。

##### 表单标签库

表单标签库中包含了可以用在JSP页面中渲染HTML元素的标签。JSP页面使用Spring表单标签库时，必须在JSP页面开头处声明taglib指令，指令代码如下：

表单标签库中有form、input、password、hidden、textarea、checkbox、checkboxes、radiobutton、radiobuttons、select、option、options、errors。

> form：渲染表单元素。
> input：渲染<input type="text"/>元素。
> password：渲染<input type="password"/>元素。
> hidden：渲染<input type="hidden"/>元素。
> textarea：渲染textarea元素。
> checkbox：渲染一个<input type="checkbox"/>元素。
> checkboxes：渲染多个<input type="checkbox"/>元素。
> radiobutton：渲染一个<input type="radio"/>元素。
> radiobuttons：渲染多个<input type="radio"/>元素。
> select：渲染一个选择元素。
> option：渲染一个选项元素。
> options：渲染多个选项元素。
> errors：在span元素中渲染字段错误。

###### 表单

```jsp
<form:form modelAttribute="xxx" method="post" action="xxx">
</form:form>
```

modelAttribute：暴露form backing object的模型属性名称，属性值绑定一个JavaBean对象。假设，控制器类UserController的方法inputUser，是返回userAdd.jsp的请求处理方法。如：

```java
@RequestMapping(value = "/input")
public String inputUser(Model model) {
	model.addAttribute("user", new User());
	return "userAdd";
}
```

```jsp
<form:form modelAttribute="user"  method="post" action="user/save"></form:form>
```

注意：在inputUser方法中，如果没有Model属性user，userAdd.jsp页面就会抛出异常，因为表单标签无法找到在其modelAttribute属性中指定的form backing object。



###### input

```jsp
<form:form modelAttribute="user"  method="post" action="user/save">
    <form:input path="userName"/>
</form:form>
```

上述代码，将输入值绑定到user对象的userName属性。

password、hidden、textarea标签的用法与input标签基本一致。



###### checkbox

```jsp
<form:checkbox path="friends" value="张三"/>张三
<form:checkbox path="friends" value="李四"/>李四
```

上述示例代码中复选框的值绑定到一个字符串数组属性`friends（String[] friends)`

checkboxes标签渲染多个复选框，是一个选项组，等价于多个path相同的checkbox标签

- items：用于生成input元素的Collection、Map或Array。
- itemLabel：items属性中指定的集合对象的属性，为每个input元素提供label。
- itemValue：items属性中指定的集合对象的属性，为每个input元素提供value

如：

```jsp
<form:checkboxes items="${hobbys}"  path="hobby" />
```

上述示例代码，是将model属性hobbys的内容（集合元素）渲染为复选框。itemLabel和itemValue缺省情况下，如果集合是数组，复选框的label和value相同；如果是Map集合，复选框的Label是Map的值（value），复选框的value是Map的关键字（key）。



###### radiobutton

```jsp
<form:radiobutton path="xxx" value="xxx"/>
```

多个path相同的radiobutton标签，它们是一个选项组，只允许单选。

同理有 radiobuttons。



###### select

select标签的选项可能来自其属性items指定的集合，或者来自一个嵌套的option标签或options标签。语法格式如下：

```jsp
<form:select path="xxx" items="xxx" />
<form:select path="xxx" items="xxx" >
    <option value="xxx">xxx</option>
</form:select>
<form:select path="xxx">
    <form:options items="xxx"/>
</form:select>
```

```jsp
<label>职业:</label>
<form:select path="carrer"> 
    <option/>请选择职业
    <form:options items="${carrers }"/>
</form:select>
```

该标签的itemLabel和itemValue属性与checkboxes标签的itemLabel和itemValue属性完全一样。

options标签生成一个select标签的选项列表，需要和select标签一同使用。



###### errors

errors标签渲染一个或者多个span元素，每个span元素包含一个错误消息。它可以用于显示一个特定的错误消息，也可以显示所有错误消息。语法如下：

```jsp
<form:errors path="*"/>
<form:errors path="xxx"/>
```

其中，“*”表示显示所有错误消息；“xxx”表示显示由“xxx”指定的特定错误消息。



##### JSON数据交互

JSON（JavaScript Object Notation，JS对象标记）是一种轻量级的数据交换格式。与XML一样，JSON也是基于纯文本的数据格式。它有两种数据结构。

对象结构以“{”开始，以“}”结束。中间部分由0个或多个以英文“,”分隔的key/value对构成，key和value之间以英文“:”分隔。对象结构的语法结构如下。其中，key必须为String类型，value可以是String、Number、Object、Array等数据类型。

```json
{
	key1:value1,
	key2:value2,
	…
}
```

数组结构以“[”开始，以“]”结束。中间部分由0个或多个以英文“,”分隔的值的列表组成。数组结构的语法结构如下：

```json
[
	value1,
	value2,
	…
]
```

如：

```json
{
    "sno":"201802228888",
    "sname":"陈恒",
    "hobby":["篮球","足球"],
    "college":{
        "cname":"清华大学",
        "city":"北京"
    }
}
```

为实现浏览器与控制器类之间的JSON数据交互，Spring MVC提供了MappingJackson2HttpMessageConverter实现类默认处理JSON格式请求响应。该实现类利用Jackson开源包读写JSON数据，将Java对象转换为JSON对象和XML文档，同时也可以   将JSON对象和XML文档转换为Java对象。

- jackson-annotations-2.10.1.jar：JSON转换注解包。
- jackson-core-2.10.1.jar：JSON转换核心包。
- jackson-databind-2.10.1.jar：JSON转换的数据绑定包。

[下载地址](http://mvnrepository.com/artifact/com.fasterxml.jackson.core)

@RequestBody：用于将请求体中的数据绑定到方法的形参中，该注解应用在方法的形参上。
@ResponseBody：用于直接返回return对象，该注解应用在方法上



##### 举例

###### 用户注册和显示用户列表

```java
public class User {
	private String userName;
	private String[] hobby;//兴趣爱好
	private String[] friends;//朋友
	private String carrer;
	private String houseRegister;
	private String remark;
	//省略setter和getter方法
}
```

```java
@Service
public class UserServiceImpl implements UserService{	
	//使用静态集合变量users模拟数据库
	private static ArrayList<User> users = new ArrayList<User>();
	@Override
	public boolean addUser(User u) {
		if(!"IT民工".equals(u.getCarrer())){//不允许添加IT民工
			users.add(u);
			return true;
		}
		return false;
	}
	@Override
	public ArrayList<User> getUsers() {
		return users;
	}
}
```

```java
@Controller
@RequestMapping("/user")
public class UserController {
	// 得到一个用来记录日志的对象，这样打印信息的时候能够标记打印的是那个类的信息
	private static final Log logger = LogFactory.getLog(UserController.class);
	@Autowired
	private UserService userService;
	@RequestMapping(value = "/input")
	public String inputUser(Model model) {
		HashMap<String, String> hobbys = new HashMap<String, String>();
		hobbys.put("篮球", "篮球");
		hobbys.put("乒乓球", "乒乓球");
		hobbys.put("电玩", "电玩");
		hobbys.put("游泳", "游泳");
	    // 如果model中没有user属性，userAdd.jsp会抛出异常，因为表单标签无法找到
		// modelAttribute属性指定的form backing object
		model.addAttribute("user", new User());
		model.addAttribute("hobbys", hobbys);
		model.addAttribute("carrers", new String[] { "教师", "学生", "coding搬运工", "IT民工", "其它" });
		model.addAttribute("houseRegisters", new String[] { "北京", "上海", "广州", "深圳", "其它" });
		return "userAdd";
	}
	@RequestMapping(value = "/save")
	public String addUser(@ModelAttribute User user, Model model) {
		if (userService.addUser(user)) {
			logger.info("成功");
			return "redirect:/user/list";
		} else {
			logger.info("失败");
			HashMap<String, String> hobbys = new HashMap<String, String>();
			hobbys.put("篮球", "篮球");
			hobbys.put("乒乓球", "乒乓球");
			hobbys.put("电玩", "电玩");
			hobbys.put("游泳", "游泳");
			// 这里不需要model.addAttribute("user", new
			// User())，因为@ModelAttribute指定form backing object
			model.addAttribute("hobbys", hobbys);
			model.addAttribute("carrers", new String[] { "教师", "学生", "coding搬运工", "IT民工", "其它" });
			model.addAttribute("houseRegisters", new String[] { "北京", "上海", "广州", "深圳", "其它" });
			return "userAdd";
		}
	}
	@RequestMapping(value = "/list")
	public String listUsers(Model model) {
		List<User> users = userService.getUsers();
		model.addAttribute("users", users);
		return "userList";
	}
}
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><!--userAdd-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<form:form modelAttribute="user"  method="post" action=" ${pageContext.request.contextPath }/user/save">
    <fieldset>
        <legend>添加一个用户</legend>
        <p>
            <label>用户名:</label>
            <form:input path="userName"/>
        </p>
        <p>
            <label>爱好:</label>
            <form:checkboxes items="${hobbys}"  path="hobby" />
        </p>
        <p>
            <label>朋友:</label>
            <form:checkbox path="friends" value="张三"/>张三
            <form:checkbox path="friends" value="李四"/>李四
            <form:checkbox path="friends" value="王五"/>王五
            <form:checkbox path="friends" value="赵六"/>赵六
        </p>
        <p>
            <label>职业:</label>
            <form:select path="carrer"> 
                <option/>请选择职业
                <form:options items="${carrers }"/>
            </form:select>
        </p>
        <p>
            <label>户籍:</label>
            <form:select path="houseRegister">
                <option/>请选择户籍
                <form:options items="${houseRegisters }"/>
            </form:select>
        </p>
        <p>
            <label>个人描述:</label>
            <form:textarea path="remark" rows="5"/>
        </p>
        <p id="buttons">
            <input id="reset" type="reset">
            <input id="submit" type="submit" value="添加">
        </p>
    </fieldset>
</form:form>
</body>
</html>
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><!--userList-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
    <h1>用户列表</h1>
    <a href="<c:url value="${pageContext.request.contextPath }/user/input"/>">继续添加</a>
    <table>
        <tr>
            <th>用户名</th>
            <th>兴趣爱好</th>
            <th>朋友</th>
            <th>职业</th>
            <th>户籍</th>
            <th>个人描述</th>
        </tr>
        <!-- JSTL标签，请参考本书的相关内容 -->
        <c:forEach items="${users}" var="user">
            <tr>
                <td>${user.userName }</td>
                <td>
                	<c:forEach items="${user.hobby }" var="hobby">
                		${hobby }&nbsp;
                	</c:forEach>
                </td>
                <td>
                	<c:forEach items="${user.friends }" var="friend">
                		${friend }&nbsp;
                	</c:forEach>
                </td>
                <td>${user.carrer }</td>
                <td>${user.houseRegister }</td>
                <td>${user.remark }</td>
            </tr>
        </c:forEach>
    </table>
</body>
</html>
```

同时表单的method方法需指定为post来避免中文乱码问题。



###### JSON

```xml
<!-- 使用扫描机制，扫描控制器类 -->
<context:component-scan base-package="controller"/>  
<mvc:annotation-driven />
<!-- 配置静态资源，允许js目录下所有文件可见 -->
<mvc:resources location="/js/" mapping="/js/**"></mvc:resources>             	
<!-- 配置视图解析器 -->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
      id="internalResourceViewResolver">
    <!-- 前缀 -->
    <property name="prefix" value="/WEB-INF/jsp/" />
    <!-- 后缀 -->
    <property name="suffix" value=".jsp" />
</bean>
```

```java
package pojo;
public class Person {
	private String pname;
	private String password;
	private Integer page;
	//省略setter和getter方法
}
```

```java
@Controller
public class TestController {
	/**
	 * 接收页面请求的JSON数据，并返回JSON格式结果
	 */
	@RequestMapping("/testJson")
	@ResponseBody
	public Person testJson(@RequestBody Person user) {
		//打印接收的JSON格式数据
		System.out.println("pname=" + user.getPname() +
				", password=" + user.getPassword() + ",page=" + user.getPage());
		//返回JSON格式的响应
		return user;
	}
}
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
<script type="text/javascript" src="${pageContext.request.contextPath }/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript">
	function testJson() {
		//获取输入的值pname为id
		var pname = $("#pname").val();
		var password = $("#password").val();
		var page = $("#page").val();
		$.ajax({
			//请求路径
			url : "${pageContext.request.contextPath }/testJson",
			//请求类型
			type : "post",
			//data表示发送的数据
			data : JSON.stringify({pname:pname,password:password,page:page}),
			//定义发送请求的数据格式为JSON字符串
			contentType : "application/json;charset=utf-8",
			//定义回调响应的数据格式为JSON字符串，该属性可以省略
			dataType : "json",
			//成功响应的结果
			success : function(data){
				if(data != null){
					alert("输入的用户名:" + data.pname + "，密码：" + data.password + "，年龄：" +  data.page);
				}
			}

		});
	}
</script>
</head>
<body>
	<form action="">
		用户名：<input type="text" name="pname" id="pname"/><br>
		密码：<input type="password" name="password" id="password"/><br>
		年龄：<input type="text" name="page" id="page"/><br>
		<input type="button" value="测试" onclick="testJson()"/>
	</form>
</body>
</html>
```



#### 文件上传下载

Spring MVC框架文件上传是基于commons-fileupload组件的文件上传。只不过在原有的基础上做了进一步的封装，简化了文件上传的代码实现，取消不同上传组件上的编程差异。

依赖：commons-fileupload-1.4.jar和commons-io-2.6.jar
下载地址 [fileupload](http://commons.apache.org/proper/commons-fileupload/
), [io](http://commons.apache.org/proper/commons-io/)

##### 基于表单

基于表单的文件上传，用enctype属性，并将它的值设置为multipart/form-data。表单的提交方式设置为post

表单的enctype属性指定的是表单数据的编码方式，该属性有如下三个值：
    application/x-www-form-urlencoded：这是默认的编码方式，它只处理表单域里的value属性值。
    multipart/form-data：该编码方式以二进制流的方式来处理表单数据，并将文件域指定文件的内容封装到请求参数里。
    text/plain：该编码方式当表单的action属性为mailto:URL的形式时才使用，主要适用于直接通过表单发送邮件的方式。

在Spring MVC框架中，上传文件时，将文件相关信息及操作封装到MultipartFile对象中。因此，开发者只需要使用MultipartFile类型声明模型类的一个属性，即可以对被上传文件进行操作。该接口具有如下方法：
    byte[] getBytes()：以字节数组的形式返回文件的内容。
    String getContentType()：返回文件的内容类型。
    InputStream getInputStream()：返回一个InputStream，从中读取文件的内容。
    String getName()：返回请求参数的名称。
    String getOriginalFilename()：返回客户端提交的原始文件名称。
    long getSize()：返回文件的大小，单位为字节。
    boolean isEmpty()：判断被上传文件是否为空。
    void transferTo(File destination)：将上传文件保存到目标目录下。
    上传文件时，需要在配置文件中使用Spring的org.springframework.web.multipart.commons.CommonsMultipartResolver类配置MultipartResolver 用于文件上传。

为了防止中文乱码，需要在web.xml文件中添加字节编码过滤器



##### 单文件上传

单文件上传例子：

```jsp
<form action="${pageContext.request.contextPath }/onefile" method="post" enctype="multipart/form-data">  
    选择文件:<input type="file" name="myfile">  <br>
    文件描述:<input type="text" name="description"> <br>
 <input type="submit" value="提交">   
</form> 
```

```java
package pojo;
import org.springframework.web.multipart.MultipartFile;
public class FileDomain {
	private String description;
	private MultipartFile myfile;
	//省略setter和getter方法
}
```

```java
@Controller
public class FileUploadController {
    private static final Log logger = LogFactory.getLog(FileUploadController.class);
    @RequestMapping("/onefile")
    public String oneFileUpload(@ModelAttribute FileDomain fileDomain, HttpServletRequest request){
        String realpath = request.getServletContext().getRealPath("uploadfiles");
        String fileName = fileDomain.getMyfile().getOriginalFilename(); 
        File targetFile = new File(realpath, fileName); 
        if(!targetFile.exists()){  
            targetFile.mkdirs();  
        } 
        try {   //上传 
            fileDomain.getMyfile().transferTo(targetFile);
            logger.info("成功");
        } catch (Exception e) {    		 
            e.printStackTrace();      
        }
        return "showOne";
    }
}
```

配置文件：

```xml
xmlns:p="http://www.springframework.org/schema/p"
```

```xml
<!--使用Spring的CommosMultipartResolver，配置MultipartResolver 用于文件上传 -->  
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"  
      p:defaultEncoding="UTF-8"  
      p:maxUploadSize="5400000"  
      p:uploadTempDir="fileUpload/temp" 
      > 
    <!--E:\java workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\fileUpload  -->  
</bean> 
<!-- defaultEncoding="UTF-8" 是请求的编码格式，默认为iso-8859-1
maxUploadSize="5400000" 是允许上传文件的最大值，单位为字节
uploadTempDir="fileUpload/temp" 为上传文件的临时路径 --> 
```

```jsp
<body>
    ${fileDomain.description }<br>
    <!-- fileDomain.getMyfile().getOriginalFilename() -->
    ${fileDomain.myfile.originalFilename }
</body>
```

> 如：
>
> ```jsp
> <%@ page language="java" import="java.util.*" pageEncoding="utf-8"%>
> <%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
> <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
> <!DOCTYPE HTML>
> <html>
> 	<head>
> 		<title>添加商品</title>
> 		<meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
> 		<link href="${ pageContext.request.contextPath }/css/managestyle.css" rel="stylesheet" type="text/css">
> 	</head>
> 	<body>
> 	<div class="top">
> 		<h1>&nbsp;&nbsp;EasyMall商城管理后台</h1>
> 	</div>	
> 	<div class="content">
> 		<div class="left">			
> 			<%@ include file = "_left.jsp" %>
> 		</div>
> 	<div class="right">	
> 	<div class="addprod">
> 	<jsp:useBean id="myproducts"  class="easymall.pojo.MyProducts" scope="request" ></jsp:useBean>
> 	<form:form modelAttribute="myproducts" onsubmit="return formobj.checkForm();" method="POST" 
> 	  enctype="multipart/form-data" action="${ pageContext.request.contextPath }/admin/save">			
> 		<fieldset>
> 		<legend>添加一件商品</legend>			
> 		<p>
>             <label>商品名:</label>
>             <form:input path="name"/>
>         </p><p>
>             <label>商品价格:</label>
>             <form:input path="price"/>
>         </p><p>
>             <label>商品类别:</label>
>             <form:select path="category">
>             <!-- 通过循环语句将所有商品类别显示在下拉列表中 -->
> 			<c:forEach items="${categories}" var="name">
> 				<option value="${name}">${name}</option>
> 			</c:forEach>
> 			</form:select>
>         </p><p>
>             <label>库存:</label>
>             <form:input path="pnum"/>
>         </p><p>
>             <label>图片:</label>
>             <input type="file" name="imgurl"/>
>         </p><p>
>             <label>商品描述:</label>
>             <form:input path="description"/>
>         </p><p id="buttons">
>             <input id="submit" type="submit" value="添加">
>         </p>
>     	</fieldset>
>     	<!-- 取出所有验证错误 -->
>     	<form:errors path="*"/>
> 	</form:form>
> 	</div>
> 	</div><!-- right结束 -->
> 	</div><!-- content束 -->		
> 	
> 	</body>
> </html>
> ```





##### 多文件上传

```jsp
<form action="${pageContext.request.contextPath }/multifile" method="post" enctype="multipart/form-data">  
    选择文件1:<input type="file" name="myfile">  <br>
    文件描述1:<input type="text" name="description"> <br>
    选择文件2:<input type="file" name="myfile">  <br>
    文件描述2:<input type="text" name="description"> <br>
    选择文件3:<input type="file" name="myfile">  <br>
    文件描述3:<input type="text" name="description"> <br>
    <input type="submit" value="提交">   
</form> 
```

```java
package pojo;
import java.util.List;
import org.springframework.web.multipart.MultipartFile;
public class MultiFileDomain {
	private List<String> description;
	private List<MultipartFile> myfile;
	//省略setter和getter方法
}
```

```java
@RequestMapping("/multifile")
public String multiFileUpload(@ModelAttribute MultiFileDomain multiFileDomain, 
                              HttpServletRequest request){
    String realpath = request.getServletContext().getRealPath("uploadfiles");
    //String realpath = "D:/spring mvc workspace/ch7/WebContent/uploadfiles";  
    File targetDir = new File(realpath); 
    if(!targetDir.exists()){  
        targetDir.mkdirs();     } 
    List<MultipartFile> files = multiFileDomain.getMyfile();
    for (int i = 0; i < files.size(); i++) {
        MultipartFile file = files.get(i);
        String fileName = file.getOriginalFilename();
        File targetFile = new File(realpath,fileName); 
        try { //上传 
            file.transferTo(targetFile);  
        } catch (Exception e) {   e.printStackTrace();    }  
    }
    logger.info("成功");
    return "showMulti";
}
```

```jsp
<body>
    <table>
        <tr><td>详情</td><td>文件名</td></tr>
        <!-- 同时取两个数组的元素 -->
        <c:forEach items="${multiFileDomain.description}" var="description" varStatus="loop">
            <tr>
                <td>${description}</td>
                <td>${multiFileDomain.myfile[loop.count-1].originalFilename}</td>
            </tr>
        </c:forEach>
        <!-- fileDomain.getMyfile().getOriginalFilename() -->
    </table>
</body>
```



##### 文件下载

利用程序实现下载需要设置两个报头：
 1．Web服务器需要告诉浏览器其所输出内容的类型不是普通文本文件或HTML文件，而是一个要保存到本地的下载文件。设置Content-Type 的值为：application/x-msdownload。
 2．Web服务器希望浏览器不直接处理相应的实体内容，而是由用户选择将相应的实体内容保存到一个文件中，这需要设置Content-Disposition报头。该报头指定了接收程序处理数据内容的方式，在HTTP应用中只有attachment是标准方式，attachment表示要求用户干预。在attachment后面还可以指定filename参数，该参数是服务器建议浏览器将实体内容保存到文件中的文件名称。

```java
response.setHeader("Content-Type", "application/x-msdownload" );
response.setHeader("Content-Disposition", "attachment; filename=" + filename);
```

如从 `workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\ch7\uploadfiles` 下载文件。

```java
@Controller
public class FileDownController {
	// 得到一个用来记录日志的对象，这样打印信息的时候能够标记打印的是那个类的信息
	private static final Log logger = LogFactory.getLog(FileDownController.class);
	/**
	 * 显示要下载的文件
	 */
	@RequestMapping("showDownFiles")
	public String show(HttpServletRequest request, Model model){
		//从workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\ch7\下载
		String realpath = request.getServletContext().getRealPath("uploadfiles");
		File dir = new File(realpath);
		File files[] = dir.listFiles();
		//获取该目录下的所有文件名
		ArrayList<String> fileName = new ArrayList<String>();
		for (int i = 0; i < files.length; i++) {
			fileName.add(files[i].getName());
		}
		model.addAttribute("files", fileName);
		return "showDownFiles";
	}
	/**
	 * 执行下载
	 */
	@RequestMapping("down")
	public String down(@RequestParam String filename, HttpServletRequest request, HttpServletResponse response){
		String aFilePath = null; //要下载的文件路径
		FileInputStream in = null; //输入流
		ServletOutputStream out = null; //输出流
		try {
			//从workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps下载
			aFilePath = request.getServletContext().getRealPath("uploadfiles");
			//设置下载文件使用的报头
			response.setHeader("Content-Type", "application/x-msdownload" );
			response.setHeader("Content-Disposition", "attachment; filename="
					+ toUTF8String(filename));
			// 读入文件
			in = new FileInputStream(aFilePath + "\\"+ filename); 
			//得到响应对象的输出流，用于向客户端输出二进制数据
			out = response.getOutputStream();
			out.flush();
			int aRead = 0;
			byte b[] = new byte[1024];
			while ((aRead = in.read(b)) != -1 & in != null) {
				out.write(b,0,aRead);
			}
			out.flush();
			in.close();
			out.close();
		} catch (Throwable e) {
			e.printStackTrace();
		} 
		logger.info("下载成功");
		return null;
	}
	/**
	 * 下载保存时中文文件名字符编码转换方法
	 */
	public  String toUTF8String(String str){
		StringBuffer sb = new StringBuffer();
		int len = str.length();
		for(int i = 0; i < len; i++){
			//取出字符中的每个字符
			char c = str.charAt(i);
			//Unicode码值在0-255之间，不作处理
			if(c >= 0 && c <= 255){
				sb.append(c);
			}else{//转换UTF-8编码
				byte b[];
				try {
					b = Character.toString(c).getBytes("UTF-8");
				} catch (UnsupportedEncodingException e) {
					e.printStackTrace();
					b = null;
				}
				//转换为%HH的字符串形式
				for(int j = 0; j < b.length; j ++){
					int k = b[j];
					if(k < 0){
						k &= 255;
					}
					sb.append("%" + Integer.toHexString(k).toUpperCase());
				}
			}
		}
		return sb.toString();
	}
}
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body> 
	<table>
		<tr>
			<td>被下载的文件名</td>
		</tr>
		<!-- 遍历model中的files -->
		<c:forEach items="${files}" var="filename">
			<tr>
				<td><a href="${pageContext.request.contextPath }/down?filename=${filename}">${filename}</a></td>
			</tr>
		</c:forEach>
	</table>
</body>
</html>
```

> 前端的一种下载方式(chatGPT,验证可用)
>
> ```js
> fetch("/download")
>   .then(response => response.blob())
>   .then(blob => {
>     const url = window.URL.createObjectURL(blob);
>     const a = document.createElement("a");
>     a.style.display = "none";
>     a.href = url;
>     a.download = "file.txt";
>     document.body.appendChild(a);
>     a.click();
>     window.URL.revokeObjectURL(url);
>   })
>   .catch(error => console.error(error));
> ```
>
> 





#### 其他例子

##### 验证码

主要知识是图片的 I/O 交互，如何输出出去

```java
package easymall.controller;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Random;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * 验证码
 */
@Controller
public class ValiImage {
    // {"宋体", "华文楷体", "黑体", "华文新魏", "华文隶书", "微软雅黑", "楷体_GB2312"}
    private static String[] fontNames = { "宋体", "华文楷体", "黑体", "微软雅黑", "楷体_GB2312" };
    // 可选字符
    // "23456789abcdefghjkmnopqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ";
    private static String codes = "23456789abcdefghjkmnopqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ";
    // 背景色
    private Color bgColor = new Color(255, 255, 255);
    // 基数(一个文字所占的空间大小)
    private int base = 30;
    // 图像宽度
    private int width = base * 4;
    // 图像高度
    private int height = base;
    // 文字个数
    private int len = 4;
    // 设置字体大小
    private int fontSize = 22;

    private BufferedImage img = null;
    private Graphics2D g2 = null;

    @RequestMapping("/index/valiImage")
    public void validateCode(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // TODO Auto-generated method stub
        // 设置响应报头信息
        response.setHeader("Pragma", "No-cache");
        response.setHeader("Cache-Control", "no-cache");
        response.setDateHeader("Expires", 0);
        // 设置响应的MIME类型
        response.setContentType("image/jpeg");

        // 1.创建图片缓冲区对象, 并设置宽高和图像类型
        img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        // 2.得到绘制环境
        g2 = (Graphics2D) img.getGraphics();
        // 3.开始画图
        // 设置背景色
        g2.setColor(bgColor);
        g2.fillRect(0, 0, width, height);

        StringBuffer sb = new StringBuffer();// 用来装载验证码上的文本

        for (int i = 0; i < len; i++) {
            // 设置画笔颜色 -- 随机
            // g2.setColor(new Color(255, 0, 0));
            g2.setColor(new Color(getRandom(0, 150), getRandom(0, 150), getRandom(0, 150)));

            // 设置字体
            g2.setFont(new Font(fontNames[getRandom(0, fontNames.length)], Font.BOLD, fontSize));

            // 旋转文字(-45~+45)
            int theta = getRandom(-45, 45);
            g2.rotate(theta * Math.PI / 180, 7 + i * base, height - 8);

            // 写字
            String code = codes.charAt(getRandom(0, codes.length())) + "";
            g2.drawString(code, 7 + i * base, height - 8);
            sb.append(code);
            g2.rotate(-theta * Math.PI / 180, 7 + i * base, height - 8);
        }

        // 画干扰线
        for (int i = 0; i < len + 2; i++) {
            // 设置画笔颜色 -- 随机
            // g2.setColor(new Color(255, 0, 0));
            g2.setColor(new Color(getRandom(0, 150), getRandom(0, 150), getRandom(0, 150)));
            g2.drawLine(getRandom(0, 120), getRandom(0, 30), getRandom(0, 120), getRandom(0, 30));
        }
        g2.setColor(Color.gray);
        g2.drawRect(0, 0, width - 1, height - 1);

        HttpSession se = request.getSession();
        se.setAttribute("code", null);
        se.setAttribute("code", sb.toString());

        // 释放图形资源
        g2.dispose();
        try {
            OutputStream os = response.getOutputStream();
            // 输出图像到页面
            ImageIO.write(img, "JPEG", os);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /*
     * 生成随机数的方法
     */
    private static int getRandom(int start, int end) {
        Random random = new Random();
        return random.nextInt(end - start) + start;
    }
}
```

```jsp
<img id="img"  src="${ pageContext.request.contextPath }/index/valiImage"/>
```

点击切换：

> ```js
> $("#img").click(function(){
>     $(this).attr("src","${ pageContext.request.contextPath }/index/valiImage?time="+new Date().getTime());
> });
> ```



### Maven

#### 基本

##### 概念

项目管理工具，Maven 项目对象模型 POM，通过描述信息管理项目的构建，报告和文档的项目管理工具软件。

库：在maven运行过程中，所有的命令执行都是基于插件完成的，引入依赖等内容，这些都称为maven的资源，资源的来源是maven社区中央库，在使用过程中可以通过远程库代理，获取资源并存储在本地库。

中央库：maven社区（community）中心服务器，所有的maven资源都存储在这个服务器中。

远程库(私服)：除了中央库之外，中国有很多代理的远程库（镜像连接），例如：网易，阿里；每个公司还可以自己搭建自己的远程库，供公司人员使用。

本地库：所有经过代理，经过中央库使用的资源都会下载到本地库中。

![image-20221108141226158](img/image-20221108141226158.png)

定位坐标：对于库中资源的使用，使用到中央信息片段定位的，主要用到3个内容 

`<groupId>` 一般是域名倒写，代表大型项目，`org.springframework`

`<artifactId>`表示项目中不同模块，`spring-beans,spring-aop,springexpression`等 

`<version>`表示模块、项目的版本号，`4.3.7.RELEASE 4.3.9.RELEASE`等

这些坐标可以在本地库寻找

```xml
<groupId>org.springframework</groupId> 
<artifactId>spring-beans</artifactId> 
<version>4.3.7.RLELEASE</version>
```

本地库对应定位资源：

`groupId`对应一个文件夹结构：`\org\springframework `
`artifactId`对应本地库一个文件夹名称：`\org\springframework\spring-beans `
`version`对应一个文件夹名称：`\org\springframework\spring-beans\4.3.7.RELEASE`

资源的内容：

![image-20221108142057270](img/image-20221108142057270.png)

##### 安装/配置

[官网](https://maven.apache.org/download.cgi) 下载并解压 maven 3.6 到无中文和空格的路径

配置 windows 环境变量，首先确保 cmd 输入 `java -version` 是 `1.8.0`，然后配置全局 `MAVEN_HOME` 为刚刚解压的根目录如 `D:\Temps\maven3.6`，且增加 PATH 变量加 bin 如 `D:\Temps\maven3.6\bin`，测试配置完毕，cmd 输入 `mvn -v`。

新建本地库文件夹如 `D:\Temps\mavenrepo`，在 maven 根目录的 `conf\settings.xml` 修改：(`\` 要转义， `/` 不用)

```xml
<localRepository>d:\\Temps\\mavenrepo</localRepository>
```

镜像配置，再次修改上文配置文件：

```xml
<mirrors>
    <mirror>
        <id>nexus-aliyun</id>
        <mirrorOf>central</mirrorOf>
        <name>Nexus aliyun</name>
 <url>http://maven.aliyun.com/nexus/content/groups/public</url>
    </mirror>
</mirrors>
```

> 对 eclipse，windows-preferences-java-installed jres，如果自己的 java 版本有更新

然后 window-preferences-maven -installations-add-用自己的,apply。绑定 settings.xml，找到 user-settings，也改成自己的。



##### 项目创建

new project-maven project(没有的话other找找)，第一页默认，第二页找到webapp，第三页自己填。

右击 new - source folder 时会发现输入不了 `src/main/java`，则右击 build path- configure build path，发现已经有了，但 missing。那么看到默认引入的是 JRE 1.5，改成 1.8 就行了。此时发现有三个 source folder。

修改 eclipse 校验报错，preferences-validation-disable all。

添加下文的两个编译插件(main和source)。

```xml
<build>
	<plugins>
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-compiler-plugin</artifactId>
			<configuration>
				<source>1.8</source>
				<target>1.8</target>
				<encoding>UTF-8</encoding>
			</configuration>
		</plugin>
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-source-plugin</artifactId>
			<configuration>
				<attach>true</attach>
			</configuration>
			<executions>
				<execution>
					<phase>compile</phase>
					<goals>
						<goal>jar</goal>
					</goals>
				</execution>
			</executions>
		</plugin>
	</plugins>
</build>
```

添加 tomcat 插件：

```xml
<plugin>
    <groupId>org.apache.tomcat.maven</groupId>
    <artifactId>tomcat7-maven-plugin</artifactId>
    <version>2.2</version>
    <!-- tomcat启动的配置 -->
    <configuration>
        <!-- 端口号访问路径默认8080端口 -->
        <port>8080</port>
        <!-- 应用程序的访问路径 -->
        <path>/</path>
        <!-- 接收数据编解码格式utf-8 -->
        <uriEncoding>utf-8</uriEncoding>
        <useBodyEncodingForURI>utf-8</useBodyEncodingForURI>
    </configuration>
</plugin>
```

右击项目，maven-update project (或alt+f5)

下方栏 overview 能看到项目视图。

在 `pom` 添加一个 dependency

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
    <version>5.1.9.RELEASE</version>
</dependency>
```

也可以引用 spring-jdbc，那么因为依赖传递，会把 beans, aop, context 都引入进来。



右击项目有 run as- maven xxx 一系列指令。其中 `mvn install`,`mvn test` 不完全等于 shell 的。其底层运行其他命令的封装,例如对依赖包的管理，生成报告文件以外的一些操作也封装了。

执行 run as - maven build..., goals 填 `tomcat7:run` 或， user settings 填自己的路径，如 `D:\Temps\maven3.6\conf\settings.xml`。然后访问 `http://localhost:8080/` 就能看到 hello world 了。之后运行maven build就可以用历史参数来跑了。



##### 完整项目

在上文项目创建的基础上

###### 包依赖

一般而言，需要引入 mybatis 等一系列东西，如：

```xml
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.3</version><!--3.4.5-->
</dependency>

<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis-spring</artifactId>
    <version>1.3.1</version>
</dependency>

<!-- mysql5 用 5.0.8 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.47</version>
</dependency>

<!-- datasource pool c3p0-->
<dependency>
    <groupId>com.mchange</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.5.2</version>
</dependency>

<!-- datasource pool druid-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.0.14</version>
</dependency>

<!-- 事务处理 -->       	
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-tx</artifactId>
    <version>5.1.9.RELEASE</version>
</dependency>

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
</dependency>
```

web 相关依赖：

```xml
<!-- SPRING MVC 相关依赖 / 4.3.7 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.1.9.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.1.9.RELEASE</version>
</dependency>

<!-- spring messageconvert jackson  -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <version>2.8.8</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.8.8</version>
</dependency>  

<!-- 添加javax.servlet-api -->  
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.0.1</version>
    <scope>provided</scope>
</dependency>

<!-- jstl表达式依赖 -->   
<dependency>
    <groupId>javax.servlet.jsp.jstl</groupId>
    <artifactId>jstl</artifactId>
    <version>1.2</version>
</dependency>
<dependency>
    <groupId>org.apache.taglibs</groupId>
    <artifactId>taglibs-standard-impl</artifactId>
    <version>1.2.5</version>
</dependency>
<dependency>
    <groupId>org.apache.taglibs</groupId>
    <artifactId>taglibs-standard-spec</artifactId>
    <version>1.2.5</version>
</dependency>

<!-- 文件上传 -->
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.3.1</version>
</dependency>
<dependency>  
    <groupId>org.hibernate</groupId>  
    <artifactId>hibernate-validator</artifactId>  
    <version>5.2.4.Final</version>  
</dependency>  
```

###### pom.xml

懒人版：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>cn.edu.scnu</groupId>
	<artifactId>EasyMall-Maven</artifactId>
	<packaging>war</packaging>
	<version>0.0.1-SNAPSHOT</version>
	<name>EasyMall-Maven Maven Webapp</name>
	<url>http://maven.apache.org</url>
	<dependencies>

		<!-- spring框架的基础依赖spring-context -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-jdbc</artifactId>
			<version>4.3.7.RELEASE</version>
		</dependency>


		<!-- MYBATIS MYBATIS-SPRING -->
		<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis</artifactId>
			<version>3.4.5</version>
		</dependency>

		<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis-spring</artifactId>
			<version>1.3.1</version>
		</dependency>

		<!-- mysql -->
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.47</version>
		</dependency>

		<!-- datasource pool c3p0 -->
		<dependency>
			<groupId>com.mchange</groupId>
			<artifactId>c3p0</artifactId>
			<version>0.9.5.2</version>
		</dependency>

		<!-- datasource pool druid -->
		<dependency>
			<groupId>com.alibaba</groupId>
			<artifactId>druid</artifactId>
			<version>1.0.14</version>
		</dependency>

		<!-- 事务处理 -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-tx</artifactId>
			<version>4.3.7.RELEASE</version>
		</dependency>

		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>3.8.1</version>
			<scope>test</scope>
		</dependency>

		<!-- SPRING MVC 相关依赖 -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-web</artifactId>
			<version>4.3.7.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>4.3.7.RELEASE</version>
		</dependency>

		<!-- spring messageconvert jackson -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-core</artifactId>
			<version>2.8.8</version>
		</dependency>
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.8.8</version>
		</dependency>

		<!-- 添加javax.servlet-api -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.0.1</version>
			<scope>provided</scope>
		</dependency>

		<!-- jstl表达式依赖 -->
		<dependency>
			<groupId>javax.servlet.jsp.jstl</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
		<dependency>
			<groupId>org.apache.taglibs</groupId>
			<artifactId>taglibs-standard-impl</artifactId>
			<version>1.2.5</version>
		</dependency>
		<dependency>
			<groupId>org.apache.taglibs</groupId>
			<artifactId>taglibs-standard-spec</artifactId>
			<version>1.2.5</version>
		</dependency>

		<!-- 文件上传 -->
		<dependency>
			<groupId>commons-fileupload</groupId>
			<artifactId>commons-fileupload</artifactId>
			<version>1.3.1</version>
		</dependency>


		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>5.2.4.Final</version>
		</dependency>
	</dependencies>

	<build>
		<finalName>EasyMall-Maven</finalName>
		<plugins>
			<!-- 添加编译插件 -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
					<encoding>UTF-8</encoding>
				</configuration>
			</plugin>
			<!-- 添加source生成插件 -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-source-plugin</artifactId>
				<configuration>
					<attach>true</attach>
				</configuration>
				<executions>
					<execution>
						<phase>compile</phase>
						<goals>
							<goal>jar</goal>
						</goals>
					</execution>
				</executions>
			</plugin>
			<!-- tomcat插件 -->
			<plugin>
				<groupId>org.apache.tomcat.maven</groupId>
				<artifactId>tomcat7-maven-plugin</artifactId>
				<version>2.2</version>
				<!-- tomcat启动的配置 -->
				<configuration>
					<!-- 端口号访问路径默认80端口 -->
					<port>8080</port>
					<!-- 应用程序的访问路径 -->
					<path>/</path>
					<!-- 接收数据编解码格式utf-8 -->
					<uriEncoding>utf-8</uriEncoding>
					<useBodyEncodingForURI>utf-8</useBodyEncodingForURI>
				</configuration>
			</plugin>

		</plugins>
	</build>
</project>
```



###### web.xml

找到 `WEB-INF/web.xml`，修改为：(或 4.0)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
	version="3.0">

</web-app>
```

完整版本为：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                             http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
         version="3.0">
    <!-- 实例化application容器 -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>
    <!-- 指定一ContextLoaderListener方式启动Spring容器 -->

    <listener>
        <listener-class>
            org.springframework.web.context.ContextLoaderListener
        </listener-class>
    </listener> 


    <!-- 配置 DispatcherServlet-->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc-servlet.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>


    <!-- 避免中文乱码 -->
    <filter>
        <filter-name>characterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>characterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
</web-app>
```

###### applicationContext.xml

在 `src/main/resources` 配置 `applicationContext.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:util="http://www.springframework.org/schema/util"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="
                           http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop 
                           http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/tx 
                           http://www.springframework.org/schema/tx/spring-tx.xsd
                           http://www.springframework.org/schema/util 
                           http://www.springframework.org/schema/util/spring-util.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/mvc
                           http://www.springframework.org/schema/mvc/spring-mvc.xsd">

	<!-- 开启包扫描 -->
	<context:component-scan
		base-package="easymall.service" />
	<!-- datasource -->
	<!-- alibaba -->
	<bean id="dataSource"
		class="com.alibaba.druid.pool.DruidDataSource">
		<!-- 4个属性,driver,url,username,password mysql8也不需.cj.jdbc -->
		<property name="driverClassName"
			value="com.mysql.jdbc.Driver" />
		<property name="url"
			value="jdbc:mysql:///easymall?characterEncoding=utf8" />
        <!-- jdbc:mysql://localhost:3306/easymall?serverTimezone=UTC -->
		<property name="username" value="root" />
		<property name="password" value="12345678" />
	</bean>

	<!-- 添加事务支持 -->
	<bean id="txManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" />
	</bean>

	<!-- 为事务管理器注册注解驱动器 -->
	<tx:annotation-driven
		transaction-manager="txManager" />


	<!-- 配置sqlSession,动态代理实现持久层接口抽象方法实现的对象 -->
	<bean id="sqlSessionFactory"
		class="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 绑定数据源 -->
		<property name="dataSource" ref="dataSource" />
		<!-- 如果有mybatis的独立配置文件,可以加载 -->
		<property name="configLocation"
			value="classpath:mybatis-config.xml" />
		<!-- 扫描一下映射文件 resources/mapper文件夹 -->
		<property name="mapperLocations"
			value="classpath:mapper/*.xml"></property>
	</bean>
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<!-- mybatis-spring组件的扫描器 -->
		<property name="basePackage" value="easymall.dao" />
		<property name="sqlSessionFactoryBeanName"
			value="sqlSessionFactory" />
	</bean>
</beans>
```

###### springmvc-servlet.xml

`src/main/resources` 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:util="http://www.springframework.org/schema/util"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop 
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx 
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/util 
        http://www.springframework.org/schema/util/spring-util.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd">

	<!-- 使用扫描机制，扫描控制器类 -->
	<context:component-scan
		base-package="easymall.controller" />

	<!-- springmvc开启所有注解功能 -->
	<mvc:annotation-driven />

	<!-- 静态资源html js css访问 -->
	<!-- 允许css目录下所有文件可见 -->
	<mvc:resources location="/css/" mapping="/css/**"></mvc:resources>
	<!--允许img目录下所有文件可见 -->
	<mvc:resources location="/img/" mapping="/img/**"></mvc:resources>
	<!--允许js目录下所有文件可见 -->
	<mvc:resources location="/js/" mapping="/js/**"></mvc:resources>
	<!--允许upload目录下所有文件可见 -->
	<mvc:resources location="/WEB-INF/upload/"
		mapping="/upload/**" />

	<!-- 配置视图解析器 -->
	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver"
		id="internalResourceViewResolver">
		<!-- 前缀 -->
		<property name="prefix" value="/WEB-INF/jsp/" />
		<!-- 后缀 -->
		<property name="suffix" value=".jsp" />
	</bean>

	<!-- 托管MyExceptionHandler -->
	<bean class="easymall.exception.MyExceptionHandler" />

	<!-- 文件上传 -->
	<bean id="multipartResolver"
		class="org.springframework.web.multipart.commons.CommonsMultipartResolver"
		p:defaultEncoding="UTF-8" p:maxUploadSize="5400000"
		p:uploadTempDir="fileUpload/temp">
	</bean>
</beans>
```

###### mybatis-config.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<!--添加缓存 引入第三方二级缓存 -->
</configuration>
```

由于我们在`applicationContext.xml`中已经配置了mapper映射文件的位置，所以`mybatis-config.xml`只需要头信息的空配置

###### mapper/*.xml

根据在`applicationContext.xml`中配置了mapper映射文件的位置，在对应路径创建映射文件，这里如：`mapper/`，下放如：

`UserMapper.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="easymall.dao.UserDao">

	<!-- 用户登录功能，返回User类对象 -->
	<select id="login" parameterType="String"
		resultType="easymall.po.User">
		select * from user where username = #{username}
	</select>

	<insert id="regist" parameterType="easymall.po.User"
		keyProperty="id" useGeneratedKeys="true">
		insert into user(username,password,nickname,email)
		values(#{username},#{password},#{nickname},#{email})
	</insert>

</mapper>
```

`ProductsMapper.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="easymall.dao.ProductsDao">
	<select id="allcategories" resultType="String">
		select name from category
	</select>

	<select id="prodlist" resultType="easymall.po.Products"
		parameterType="map">
		select * from products where status=1 and (price between #{minPrice}
		and #{maxPrice})
		<if test="name!=null and name!=''">
			and name like concat('%',#{name},'%')
		</if>
		<if test="category!=null and category!=''">
			and category=#{category}
		</if>
	</select>

	<select id="prodInfo" resultType="easymall.po.Products"
		parameterType="String">
		select *from products where id = #{pid}
	</select>

	<select id="prodclass" resultType="easymall.po.Products"
		parameterType="String">
		select *from products where status=1 and category=#{category}
	</select>

	<select id="oneProduct" resultType="easymall.po.Products"
		parameterType="String">
		select *from products where id=#{product_id}
	</select>

	<insert id="save" parameterType="easymall.po.Products">
		insert into products(id,name,price,category,pnum,imgurl,description)
		values(#{id},#{name},#{price},#{category},#{pnum},#{imgurl},#{description});
	</insert>

	<select id="findByImgurl" parameterType="String"
		resultType="easymall.po.Products">
		select * from products where imgurl=#{imgurl}
	</select>

	<select id="allprods" resultType="easymall.po.Products">
		select * from products
	</select>
	<update id="updateSaleStauts" parameterType="map">
		update products set status=#{status} where id=#{id}
	</update>
	<update id="updateSoldNum" parameterType="map">
		update products set soldNum=soldNum+#{buynum},pnum=pnum-#{buynum}
		where id=#{pid}
	</update>
</mapper>
```

`OrderMapper.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="easymall.dao.OrderDao">

	<insert id="addOrder" parameterType="easymall.po.Orders">
		insert into Orders(id,money,receiverinfo,paystate,ordertime,user_id)
		values(#{id},#{money},#{receiverinfo},#{paystate},#{ordertime},#{user_id})
	</insert>
	<select id="findOrderByUserId" parameterType="Integer"
		resultType="easymall.po.Orders">
		select * from orders where user_id=#{user_Id}
	</select>
	<delete id="delorder" parameterType="String">
		delete from orders where id=#{id}
	</delete>
	<update id="payorder" parameterType="String">
		update orders set paystate=1 where id=#{id}
	</update>
</mapper>
```

`OrderItemMapper.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="easymall.dao.OrderItemDao">

	<insert id="addOrderItem" parameterType="easymall.po.OrderItem">
		insert into OrderItem(order_id,product_id,buynum)
		values(#{order_id},#{product_id},#{buynum})
	</insert>

	<select id="orderitem" parameterType="String"
		resultType="easymall.po.OrderItem">
		select * from orderitem where order_id=#{order_id}
	</select>
	<delete id="delorderitem" parameterType="String">
		delete from orderitem where order_id=#{id}
	</delete>
</mapper>
```

`CartMapper.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="easymall.dao.CartDao">

	<select id="findCart" parameterType="easymall.po.Cart"
		resultType="easymall.po.Cart">
		select * from cart where user_id=#{user_id} and pid=#{pid}
	</select>

	<insert id="addCart" parameterType="easymall.po.Cart">
		insert into cart(user_id,pid,num) values(#{user_id},#{pid},#{num})
	</insert>

	<update id="updateCart" parameterType="easymall.po.Cart">
		update cart set num=num+#{num} where cartID=#{cartID}
	</update>

	<select id="showcart" parameterType="Integer"
		resultType="easymall.pojo.MyCart">
		select cartID,pid,num,name,price,imgurl from cart,products
		where user_id=#{user_id} and cart.pid=products.id
	</select>

	<update id="updateBuyNum" parameterType="easymall.po.Cart">
		update cart set num=#{num} where cartID=#{cartID}
	</update>

	<delete id="delCart" parameterType="Integer">
		delete from cart where cartID=#{cartID}
	</delete>
	<select id="findByCartID" parameterType="Integer"
		resultType="easymall.pojo.MyCart">
		select cartID,pid,num,name,price,imgurl from cart,products
		where cartID=#{cartID} and cart.pid=products.id
	</select>
</mapper>
```

###### 其他

自己准备好 `css/,img/,js/,index.jsp` 放到 `src/main/webapp`，把网页 `jsp/`,`upload/` 放到 `src/main/webapp/WEB-INF`。

自己写好 `easymall` 包下的子包 `po,pojo,dao,controller,service,admin,exception` 和下的各 java 文件，放到 `src/main/java`。

#### 项目继承

Maven继承

##### 概念

项目进行纵向拆分和横向拆分，搭建的项目越来越多，由于很可能多个项目是为同一个系统提供服务，他们之间的资源管理就成了问题

![image-20221110094327420](img/image-20221110094327420.png)

##### 例子

创建一个新 maven 项目作为父项目，还是选 quickstart，groupID 与之前相同，且配置 pom 的 `packaging` 标签为 `pom，`artifact ID 如 `maven-parent`：

```xml
<packaging>pom</packaging>
```

然后对于子项目，

- groupId:可以使用父工程,也可以覆盖
- versionId:继承父工程,也可以覆盖(一般要统一版本，所以不覆盖)，父项目
- properties中定义的变量名称和值可以被子工程继承;
- dependency可以直接继承,一旦父工程依赖了一些资源,子工程在继承之后直接传递过来;
- dependencyManagement:声明式的依赖继承,子工程中只要不做依赖的指的话，groupId artifactId就不会继承给子工程,一旦子工程继承，会把父工程定义的版本一并继承,版本号可以覆盖，但为了同意版本，一般不覆盖。有需要的话套在 dependencies 标签外边
- build中的所有插件可以继承:例如父工程定义了所有子工程打包打源码包
- organization:组织者,也可以继承

创建一个 maven 子项目。pom 改成这个样子：

```xml
<artifactId>maven-child01</artifactId>
<packaging>jar</packaging>

<parent>
    <groupId>cn.edu.scnu</groupId>
    <artifactId>maven-parent</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</parent>
```

在父工程的 properties 标签里定义变量标签：

```xml
<spring.version>5.1.9.RELEASE</spring.version>
```

那么在子工程里可以：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
    <version>${spring.version}</version>
</dependency>
```

保存后项目点开 maven dependencies 能看到引入了 beans 等包的对应版本。且可以看到因为父项目有 junit 依赖，所以即使子项目 pom 里删掉了这个依赖，还是能传过来

父项目可以添加：

```xml
<dependencyManagement>
    <dependencies>
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.8.8</version>
		</dependency>
	</dependencies>
</dependencyManagement>
```

发现保存后子项目不会添加上这个依赖，但是如果把 dependency 拉到外边的 dependencies 一保存子项目马上添加了这些依赖(当然删掉后马上又删掉了)

> 可以点 overview 去导入，继承不成功可以看看是不是 pom 什么地方对着抄抄错了
>
> 子项目别填 group id 一级标签



#### 命令

maven项目生命周期从项目创建到项目最终使用（发布到服务器运行，运行jar/war包)过程，需要使用一系列的maven命令。

新建一个空文件夹，作为 workspace。cd 到里面去执行命令：

##### 项目创建

```shell
mvn archetype:generate
```

> 执行选择：
>
> 1.archetype：maven工程的骨架；maven作为项目管理工具可以创建不同语言，不同的结构的项目，maven准备了为创建不同结构项目生成的资源骨架；在互联网阶段常用的2种骨架资源：webapp（web应用骨架，维护一个webapps文件夹就是tomcat中webapps里的各种web资源文件夹），quickstart（java简单工程骨架） 
> 2.groupId：cn.edu.scnu 
> 3.artifactId:maven-test01 
> 4.version:默认值1.0-SNAPSHOT 
> 5.package：工程中存在的默认包名称，根据创建的groupId自动生成一个默认的包 
> 6.同意以上配置

第一次需要输入时直接按回车，然后依次输入 `groupId` 如 `com.baicha`，`artifactId` 如 `maven-test01`，`version` 和 `package` 直接回车，然后输入 `y`。

接着发现自动生成了一个 java 项目，结构为：

1.src/main/java：管理源码编写的文件夹，下一级是包路径+**.java文件 

2.src/test/java：管理测试代码的文件夹 

3.src/main/resources：管理项目的所有配置文件，spring.xml,mapper.xml,mybatis.xml等 

4.src/test/resources：测试代码可能加载的配置文件。



##### 清空

对于maven的生命周期管理过程会不断根据项目的变动去执行各种mvn命令，会产生各种文件，为了解决由于前后执行命令而产生的文件冲突问题，一般在执行其他任何命令之前都会先执行clean的清空命令

cd 到项目文件夹里执行：

```shell
cd maven-test01
mvn clean
```

清空的是target文件夹中的内容（编译，打包，安装所有执行过程都会在target文件夹中生成对应文件）



##### 编译

项目文件夹里：

```shell
mvn compile
```

> 遇到报错：`[ERROR] No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK?`
>
> 开报错模式看看：`mvn compile -e`。考虑自己的真的是 JRE 而不是 JDK，则考虑重装 java8，下载 JDK。验证：`shell` 输入 `javac` 有反应。

会将当前工程的所有源码和配置文件，编译输出到项目根目录target/classes中，test包中所有内容在编译，打包，安装过程都不参加，但是会运行测试



##### 测试

> 在 `test` 写一个测试类如：
>
> ```java
> package com.baicha;
> 
> import org.junit.*;
> 
> public class MavenTest {
> 
>   @Test
>   public void test01() {
>     System.out.println("Hell world!");
>   }
> }
> ```

修改 `pom.xml` 把 `junit` version 改为 `4.12`。

执行测试：`mvn test`，将会依次执行 `test` 里的每个类的 `@Test` 方法，并输出结果。

编写项目过程，需要不断的执行测试内容，可以利用mvn test测试命令完成所有测试代码的执行。 

执行命令后，会形成测试报告，测试报告会打印到target文件夹中，生成报告文件。在 `surefire-reports` 能看到。



##### 打包

将当前项目的所有运行资源包装成一个java工程的包，打成jar还是war包，根据核心管理配置文件pom.xml的定义。在 `packaging` 里定义。

项目打包之前，需要先clean,因为package命令包含了之前的所有生命周期过程，包括编译、测试，为了避免冲突，先clean清空。

```shell
mvn clean package
```

打包后的结果在 `target` 文件夹能看到 `jar` 包。



##### 安装

maven项目作为maven管理的资源，不仅仅表示一个运行的工程，还可以作为别人使用的资源。但必须经过maven的安装过程，生成maven库可以使用的资源文件。

安装后，可以在 `repo` 看到自己的 `jar` 包，那么这个包就可以给其他项目用了。根据包 `package` 路径在本地库文件夹能找到自己的 `jar` 包。

```shell
mvn clean install
```



##### 发布

一般是发布到私服，用 `mvn deploy`。



##### 依赖

```sh
mvn dependency:tree
```





#### 插件

maven在pom文件中可以管理当前项目的基本信息，引入当前项目使用的所有资源，其中包含插件资源；

例如，打包时，可以利用插件指定main方法所在的类路径，这样jar包就可以运行； 

需要在pom文件中的`<build><plugins></plugins></build>`

##### main方法插件

在打包、安装时生成的jar文件中，指定配置文件指向可以运行的入口类

例如指定默认生成的 `hello world`：将下面代码放到 `project` 标签里

```xml
<build>
	<plugins>
		<plugin>
		<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-jar-plugin</artifactId>
			<configuration>
				<archive>
					<manifest>
<addClasspath>true</addClasspath>
<mainClass>com.baicha.App</mainClass> <!-- 主入口-->
					</manifest>
				</archive>
			</configuration>
		</plugin>
	</plugins>
</build>
```

再次打包：

```shell
mvn clean package
```

这时候就可以运行自己的 jar 了，如：

```shell
java -jar target\maven-test01-1.0-SNAPSHOT.jar
```



##### 源码包插件

将项目在build构建过程时，除了生成jar包的class文件之外，还绑定生成source源码.jar 

在上文结构上，添加：

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-source-plugin</artifactId>
    <configuration>
        <attach>true</attach>
    </configuration>
    <executions>
        <execution>
            <phase>compile</phase>
            <goals>
                <goal>jar</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

那么会在生成一般 jar 包的同时，顺便生成一个源码 jar 包。以压缩文件方式打开，可以看到其里面只有 java 文件，没有 class 文件。



##### tomcat插件

```xml
<plugin>
    <groupId>org.apache.tomcat.maven</groupId>
    <artifactId>tomcat7-maven-plugin</artifactId>
    <version>2.2</version>
    <!-- tomcat启动的配置 -->
    <configuration>
        <!-- 端口号访问路径默认8080端口 -->
        <port>8080</port>
        <!-- 应用程序的访问路径 -->
        <path>/</path>
        <!-- 接收数据编解码格式utf-8 -->
        <uriEncoding>utf-8</uriEncoding>
        <useBodyEncodingForURI>utf-8</useBodyEncodingForURI>
    </configuration>
</plugin>
```

#### pom

##### java版本

```xml
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>my-app</artifactId>
    <version>1.0-SNAPSHOT</version>
    
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>1.8</java.version>
    </properties>
    
    <!-- 其他元素 -->
</project>

```



##### 依赖

gpt:

<dependencyManagement> 元素中声明的依赖库版本号可以被子模块继承和覆盖，而 <dependencies> 元素中声明的依赖库版本号则不能被继承和覆盖，子模块需要显式地声明依赖库的版本号。后者可以放前者里边，也可以不放，可以都有。

前者只是声明依赖，并不实现依赖的引入，因此，没有jar包的引入，maven项目就不会显示Maven Dependencies文件 [参考](https://blog.csdn.net/m0_67393039/article/details/123986866)



### Nginx

#### 基本

##### 概念

系统:就是用户可以访问web应用系统(淘宝,京东,美团)
单体系统:一个系统的所有功能(用户相关功能,商品展示,购物车,订单),全都启动加载到一个web应用中

单体系统无法应对高并发场景，并发瓶颈集中在tomcat上(tomcat的瞬间并发200-500,性能较高的cpu支持2000左右)

![image-20221109142212373](img/image-20221109142212373.png)

单体系统每次都要启动静态页面

单独启动一个tomcat维护静态页面(浪费tomcat动态数据处理的性能)。

可以使用nginx实现动静分离



Nginx:早期由俄国团队开发的可以处理动静分离,处理负载均衡的HTTP反向代理服务器

**反向代理:**反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定

Nginx作用:动静分离,动态资源访问tomcat,静态资源.html,.js,.css等可以存储在nginx中

负载均衡:通过nginx决定访问的后端服务器



##### 安装

[官网](http://nginx.org/en/download.html) 下载 nginx。如 1.9.9。解压到无中文和空格的路径。配置文件在 `conf/nginx.conf`。

双击start启动:启动任务管理器中,查看nginx进程数2个,如果没有发现nginx进程(nginx.exe),打开logs中error.log，会有错误提示，具体到第几行。

双击 stop 关闭。查看进程是否消失,确定消失之后再运行start,否则会出现多个nginx的进程相互冲突.也可以在任务管理器中停止进程。



##### 域名跳转

先准备一个上文跑得动的 maven 项目。然后修改器 `http` 内的内容：

```nginx
server {
    listen 80;
    server_name www.baicha.cn;
    location /{
        proxy_pass http://127.0.0.1:8888;
    }
    #www.baicha.cn 转发到 127.0.0.1:8888
}
server {
    listen 80;
    server_name www.guodong.cn;
    location /{
        proxy_pass http://127.0.0.1:8889;
    }
}
```

修改自己 C 盘 `C:\Windows\System32\drivers\etc\hosts`，追加：

```hosts
127.0.0.1 www.baicha.cn
127.0.0.1 www.guodong.cn
```

启动 nginx，启动 maven 项目，测试：输入 `www.baicha.cn`，发现跳转到了自己的项目(注意如果不输入 `www.` 真的会跳转到别人的 `baicha.cn`)

注意到 maven 可以同时启动多个项目，我们再任意启动一个项目，然后输入 `www.guodong.cn`，发现跳转到了这个项目去。

基本原理：先通过 hosts 让 `www.baicha.cn` 指向 `127.0.0.1:80`，然后再通过 nginx 将 `127.0.0.1:80` 分到 `127.0.0.1:8888`。

解释配置文件：`location /` 的 `/` 表示 `/` 后面加任意内容都符合匹配逻辑，只要符合逻辑，就将它转发到这个地址去。

![image-20221109150651514](img/image-20221109150651514.png)



##### 负载均衡

负载:服务器承受的访问量压力;
均衡: 物理均衡(平均分配访问压力),逻辑均衡(根据服务器的性能决定访问的占比,性能越低占比越低,反之亦然);

开三个 web 应用，设置：

```nginx
upstream mytomcluster {
    ip_hash;
    server 127.0.0.1:8888;
    server 127.0.0.1:8889;
    server 127.0.0.1:8899;
}
server {
    listen 80;
    server_name www.baicha.cn;
    location /{
        proxy_pass http://mytomcluster;
    }
}
```

也可以设加权如(占比，或永不访问)：

```nginx
upstream mytomcluster {
    server 127.0.0.1:8888 weight=2;
    server 127.0.0.1:8889 weight=1;
    server 127.0.0.1:8899 down;
}
```

重启 nginx。此时，可以发现，每次刷新后以固定两次 8888 一次 8889 的周期得到不同的结果。

![image-20221109152455730](img/image-20221109152455730.png)

`ip_hash` 对用户的 IP 地址做 hash 计算，只要 ip 地址不变，访问的就是同一个 tomcat。这种不变性使得用户不用重新登陆，因为 session 不变。



##### 动静分离

动静分离:主要指的是前后端分离,前端的静态页面文件,交给独立运行服务器处理,后端的tomcat只处理请求的动态数据;

nginx作为http服务器,不能处理jsp,但是可以处理所有静态文件访问;可以将所有静态文件存放到nginx保存,提供访问的响应,如果有动态的路径需要服务器处理,再转发交给后端服务器tomcat

静态网页部署的例子：

例：任意创建一个 `D:\Temps\html\index.html`，然后配置：

```nginx
server {
	listen 80;
	server_name www.hefeng.cn; #到hosts配一下
	location /{
		root D://Temps//html;
        index index.html;
	}
}
```

如果不用绝对路径，那么 `root` 后接以 `nginx` 根目录为根的相对路径。

![image-20221109153450432](img/image-20221109153450432.png)

具体例子：

```nginx
server {
    listen 80;
    server_name www.osstatic.com;
    location /user {
        proxy_pass http://127.0.0.1:8090/user;
    }
    location /order {
        proxy_pass http://127.0.0.1:8090/order;
    }
    location /{
        root D://Temps//html//orderuser;
        index index.html;
    }
}
```

然后跑一个 web 项目即可。

自动加头如：

```nginx
server {
    listen 80;
    server_name www.osstatic.com;
    location /user {
        proxy_pass http://127.0.0.1:8090/user;
        add_header 'Access-Control-Allow-Origin' '*'; 
        add_header 'Access-Control-Allow-Credentials' 'true'; 
    }
    location /order {
        proxy_pass http://127.0.0.1:8090/order;
        add_header 'Access-Control-Allow-Origin' '*'; 
        add_header 'Access-Control-Allow-Credentials' 'true'; 
    }
    location /{
        root D://Temps//html//orderuser;
        index index.html;
    }
}
```

如果修改页面后刷新没变化，可能是浏览器缓存使用 ctrl+f5 强制刷新。



### Spring Boot

#### 基本

##### 概念

功能的强耦合：因为需求的变动,一个系统的功能变得越来越复杂;所以一旦某些功能在系统中存在强耦合.会造成开发人员必须精通了解多个业务逻辑.多个领域之间的知识,也不利于项目的扩展;

只需要将不同的功能和业务进行拆分;order-user系统为例,我某一个模块只关心订单的业务逻辑,不关心用户业务逻辑.某一个模块只关心用户业务逻辑.不关心订单---功能的纵向拆分

横向拆分：根据项目的三个结构层次，控制层依赖业务层依赖持久层,进行分模块的开发(多个人,有的开发控制层,有的开发业务层,有的开发持久层)

![image-20221110084544401](img/image-20221110084544401.png)

纵向拆分:可以解决功能强耦合的问题

单体系统所有的功能都在一个系统中，所有的数据都在一个数据库中，数据库很容易达到瓶颈，例如双十一，订单数据很容易就达到上亿条数据，而用户也许就几十万条数据，因为它们在同一个数据库中，就会出现由于订单数据达到瓶颈而导致用户数据不能使用。

纵向拆分就是根据业务功能将系统的不同部分切分成独立运行的系统,相互间有数据调用则根据接口定义进行访问，定义好之间传递数据的接口类型接口文件，根据定义，把数据传递给下一个功能。

例如订单和用户，纵向拆分为两个独立的系统，订单系统和用户系统，不仅代码拆开，数据库也拆开。

![image-20221110084651578](img/image-20221110084651578.png)

当所有的功能就集中到一个系统中完成最终发布启动,很多功能都会由于一个功能瓶颈导致不可用(比如出现数据库瓶颈),比如双十一，淘宝购买商品时，有时候会出现订单无法提交，说明订单系统已经崩了，但是依然可以浏览商品、注册登录、添加订单。

Nginx虽然解决了并发问题,但是没有解决并发集中,功能强耦合问题。为了解决这些问题，还需要对功能进行纵向拆分,不同功能搭建不同的系统。

纵向拆分搭建的项目越来越多,而搭建项目的步骤中存在非常多个重复操作(spring.xml,spring-mvc.xml配置等);在这种情况下,一种方便的工具框架应运而生--springboot

springboot:一种基于spring框架,能独立运行,自动配置的一种工具框架

针对web应用的特点：

- 独立运行的 spring 项目

  springboot封装了spring所有的启动过程,可以通过简单的方法实现启动一个具备所有spring框架功能的进程.如果不做web应用,不需要tomcat这种外部容器来加载spring配置文件从而生成spring容器;Spring4.x之后，几乎将所有的配置内容都转换为注解，只要通过代码加载注解，就不需要配置文件了

- 创建的 web 应用内嵌了 servlet

  不用配置任何tomcat插件.不用将项目发布到任何外部tomcat容器运行;直接在依赖中完成了默认的servlet容器整合.一旦启动了spring的独立运行的机制,可以加载内嵌的servlet实现web应用的独立运行

- 提供简化依赖

  根据开发人员依赖的不同内容,早就封装了简化依赖,实现依赖的传递性,例如,当开发一个web应用时,不考虑持久层,只需要依赖spring-boot-starter-web，就会给你传递过来tomcat-embed,jackson,log4j,其他非常多的jar包;

- springboot 自动配置

  默认自动的扫描范围:启动springboot工程,所有在扫描范围内的

  @Controller,@Service,@Autowired都会加载到内存中

  根据依赖完成相关自动配置

  springboot可以根据在项目中完成的依赖资源引入,自动配置相关内容(根本看不到xml文件了);例如:引入了spring-boot-starter-web,springboot的自动配置就会判断是需要开发一个web应用,完成tomcat的自动加载,自动启动默认端口8080,例如:引入了spring-boot-starter-jdbc,mybatis等,springboot自动配置数据源(提供必要的条件 driverClass,url,username,password等)

##### 其他理论

> 从本质上来说，Spring Boot就是Spring，它做了那些没有它你自己也会去做的Spring Bean配置。Spring Boot使用“习惯优于配置”的理念让你的项目快速地运行起来，使用Spring Boot很容易创建一个能独立运行、准生产级别、基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。
>
> 简而言之，Spring Boot本身并不提供Spring的核心功能，而是作为Spring的脚手架框架，以达到快速构建项目、预置三方配置、开箱即用的目的。Spring Boot有如下的优点：
>
> - 可以快速构建项目；
> - 可以对主流开发框架的无配置集成；
> - 项目可独立运行，无需外部依赖Servlet容器；
> - 提供运行时的应用监控；
> - 可以极大地提高开发、部署效率；
> - 可以与云计算天然集成。
>
> Starter: Spring Boot通过提供众多起步依赖（Starter）降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型（Project Object Model, POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。(作用：导入包)
>
> Spring Boot 启动流程:
>
> 首先，Spring Boot项目创建完成会默认生成一个名为 *Application 的入口类，我们是通过该类的main方法启动Spring Boot项目的。在main方法中，通过SpringApplication的静态方法，即run方法进行SpringApplication类的实例化操作，然后再针对实例化对象调用另外一个run方法来完成整个项目的初始化和启动。
>
> SpringApplication调用的run方法的大致流程，如下图：
>
> <img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694256551/4ECC3AECD1D8D2B62421E2D3453DC465" alt="img" style="zoom: 67%;" />
>
> 其中，SpringApplication在run方法中重点做了以下操作：
>
> - 获取监听器和参数配置；
> - 打印Banner信息；
> - 创建并初始化容器；
> - 监听器发送通知。
>
> 当然，除了上述核心操作，run方法运行过程中还涉及启动时长统计、异常报告、启动日志、异常处理等辅助操作。
>
> 使用Spring Boot时，我们只需引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷、简单的形式对第三方软件进行集成，这便是Spring Boot的自动配置功能。Spring Boot实现该运作机制锁涉及的核心部分如下图所示：
>
> <img src="img/4C6D51AEA1E10E3717A8BE4AE88B6F79.jpeg" alt="img" style="zoom:80%;" />
>
> 整个自动装配的过程是：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。
>
> @SpringBootApplication注解：
>
> 在Spring Boot入口类中，唯一的一个注解就是@SpringBootApplication。它是Spring Boot项目的核心注解，用于开启自动配置，准确说是通过该注解内组合的@EnableAutoConfiguration开启了自动配置。
>
> @EnableAutoConfiguration注解：
>
> @EnableAutoConfiguration的主要功能是启动Spring应用程序上下文时进行自动配置，它会尝试猜测并配置项目可能需要的Bean。自动配置通常是基于项目classpath中引入的类和已定义的Bean来实现的。在此过程中，被自动配置的组件来自项目自身和项目依赖的jar包中。
>
> @Import注解：
>
> @EnableAutoConfiguration的关键功能是通过@Import注解导入的ImportSelector来完成的。从源代码得知@Import(AutoConfigurationImportSelector.class)是@EnableAutoConfiguration注解的组成部分，也是自动配置功能的核心实现者。
>
> @Conditional注解：
>
> @Conditional注解是由Spring 4.0版本引入的新特性，可根据是否满足指定的条件来决定是否进行Bean的实例化及装配，比如，设定当类路径下包含某个jar包的时候才会对注解的类进行实例化操作。总之，就是根据一些特定条件来控制Bean实例化的行为。
>
> @Conditional衍生注解：
>
> 在Spring Boot的autoconfigure项目中提供了各类基于@Conditional注解的衍生注解，它们适用不同的场景并提供了不同的功能。通过阅读这些注解的源码，你会发现它们其实都组合了@Conditional注解，不同之处是它们在注解中指定的条件（Condition）不同。
>
> - @ConditionalOnBean：在容器中有指定Bean的条件下。
> - @ConditionalOnClass：在classpath类路径下有指定类的条件下。
> - @ConditionalOnCloudPlatform：当指定的云平台处于active状态时。
> - @ConditionalOnExpression：基于SpEL表达式的条件判断。
> - @ConditionalOnJava：基于JVM版本作为判断条件。
> - @ConditionalOnJndi：在JNDI存在的条件下查找指定的位置。
> - @ConditionalOnMissingBean：当容器里没有指定Bean的条件时。
> - @ConditionalOnMissingClass：当类路径下没有指定类的条件时。
> - @ConditionalOnNotWebApplication：在项目不是一个Web项目的条件下。
> - @ConditionalOnProperty：在指定的属性有指定值的条件下。
> - @ConditionalOnResource：类路径是否有指定的值。
> - @ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个或者有多个但是指定了首选的Bean时。
> - @ConditionalOnWebApplication：在项目是一个Web项目的条件下。

##### 项目创建

eclipse windows-perspective-customize perspective-shortcuts-java，多选class,interface,java project, java working set, package (作用是右击new文件时能看到这些勾选的内容)。然后 new 一个 java working set，随便命名。

创建一个新的 maven，且选择 quickstart maven 骨架。创建时第一步将其拉入 working set。(如果不记得拉入了那么windows-perspective-open perspective-other-java,然后项目右击assgin working set)然后在 pom 里写入：(父标签是 project)

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.9.RELEASE</version>
</parent>
```

引入依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

引入插件：

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```



properties 加上：

```xml
<java.version>1.8</java.version>
```

开点 java 代码：

```java
package cn.edu.scnu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class StarterXu {
    public static void main(String[] args) {
        SpringApplication.run(StarterXu.class, args);
    }
}
```

```java
package cn.edu.scnu.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import cn.edu.scnu.service.HelloService;

//spring 3.x 组合注解，若 controller所有方法都无序添加 responsebody 注解，这里用 @RestController 来简写
@Controller
public class HelloController {
    @Autowired
    private HelloService helloService;

    @RequestMapping("hello")
    @ResponseBody
    // @responseBody注解的作用是将controller中的方法返回的对象通过适当的转换器转换为
    // 指定的格式之后，写入到response对象的body区，
    // 通常用来返回JSON数据或者是XML数据，需要注意的是，在使用此注解之后不会再走视图处理器，
    // 而是直接将数据写入到输入流中
    public String sayHello(String name) {
        return helloService.sayHello(name);
    }
}
```

```java
package cn.edu.scnu.service;

import org.springframework.stereotype.Service;

@Service
public class HelloService {
    public String sayHello(String name) {
        return "hallo " + name + ",您滚啊";
    }
}
```

然后直接跑 main (run as-java application / 跟一般java文件跑main方法一样)就行。然后键入：`http://localhost:8080/hello?name=baicha`，发现能跑。





#### 注解

- @ComponentScan

  前提是程序能扫描加载这个注解,可以代替xml中`<context:component-scan base-package="cn.edu.scnu">`标签, 这个注解所在的类所在包就是base-package的值

- @Configuration

  前提是程序能扫描加载这个注解，将一个spring的xml配置文件的内容转化成代码内容完成的配置类注解;代替一个独立的xml,在xml中所需要配置的所有`<bean>`,可以在这个类以@Bean表示

  > 如：
  >
  > ```java
  > package cn.edu.scnu.bean.test;
  > public class BeanTest01 {
  >     public BeanTest01(){
  >         System.out.println("beanTest01被记加载了");
  >     }
  > }
  > ```
  >
  > ```java
  > package cn.edu.scnu.config;
  > import org.springframework.context.annotation.Bean;
  > import org.springframework.context.annotation.Configuration;
  > import cn.edu.scnu.bean.test.BeanTest01;
  > /**
  >  * 对应生成spring容器中需要加载的一个xml配置文件 spring.xml
  >  */
  > @Configuration
  > public class BeanConfig {
  >     // 想办法创建一个BeanTest01的IOC控制反转对象
  >     @Bean // 一般配合configuration注解的
  >     // 方法的返回对象,就是需要创建的bean对象,由容器维护管理
  >     // id值默认是方法名称
  >     public BeanTest01 intiBeanTest01() {
  >         // 各种属性赋值
  >         return new BeanTest01();
  >     }
  > }//跑一下能发现日志里输出了syso那行
  > ```

- @ConfigurationProperties

  前提是被容器扫描加载到,可以根据这个注解的配置读取properties文件中的key=value的数据内容;一般配合Component注解实现加载

  > 在 `src/main/resources` 写 `application.properties`：
  >
  > ```properties
  > cn.edu.scnu.username=baicha
  > cn.edu.scnu.password=1235813
  > ```
  >
  > 然后写一个类：
  >
  > ```java
  > package cn.edu.scnu.bean.test;
  > 
  > import org.springframework.boot.context.properties.ConfigurationProperties;
  > import org.springframework.stereotype.Component;
  > 
  > @Component // 容器一旦扫描,对象创建
  > @ConfigurationProperties(prefix = "cn.edu.scnu") // 读取内存中所有properties
  > //文件加载过来的key=value值,对属性进行set赋值
  > public class ConfigProperties {
  >     public ConfigProperties() {
  >         System.out.println("configProperties加载了"); // 此行加断点
  >     }
  > 
  >     private String username;
  >     private String password;
  > 
  >     public String getUsername() {
  >         return username;
  >     }
  > 
  >     public void setUsername(String username) {
  >         this.username = username;
  >     }
  > 
  >     public String getPassword() {
  >         return password;
  >     }
  > 
  >     public void setPassword(String password) {
  >         this.password = password;
  >     }
  > 
  >     @Override
  >     public String toString() {
  >         return "ConfigProperties [username=" + username + ", password=" + password + "]";
  >     }
  > }
  > ```
  >
  > 修改controller：
  >
  > ```java
  > package cn.edu.scnu.controller;
  > 
  > import org.springframework.beans.factory.annotation.Autowired;
  > import org.springframework.stereotype.Controller;
  > import org.springframework.web.bind.annotation.RequestMapping;
  > import org.springframework.web.bind.annotation.ResponseBody;
  > 
  > import cn.edu.scnu.bean.test.ConfigProperties;
  > import cn.edu.scnu.service.HelloService;
  > 
  > @Controller
  > public class HelloController {
  >     @Autowired
  >     private ConfigProperties configProperties;
  >     @Autowired
  >     private HelloService helloService;
  > 
  >     @RequestMapping("hello")
  >     @ResponseBody
  >     // @responseBody注解的作用是将controller中的方法返回的对象通过适当的转换器转换为
  >     // 指定的格式之后，写入到response对象的body区，
  >     // 通常用来返回JSON数据或者是XML数据，需要注意的是，在使用此注解之后不会再走视图处理器，
  >     // 而是直接将数据写入到输入流中
  >     public String sayHello(String name) {
  >         return helloService.sayHello(name) + configProperties;
  >     }
  > }
  > ```
  >
  > 再次访问网页，能发现确实能看到输出 `baicha` 等。
  >
  > 进一步地，假设该类有一个 `public static class ConfigProperties02` 且有属性 `String level` 及其 getter, setter，且有该静态内部类自己的 getter, setter，然后有一个内部类变量 `configPro02`，则用：
  >
  > ```properties
  > cn.edu.scnu.configPro02.level=1
  > ```

- @ConditionalOnClass({A.class,B.class})

  spring4.x出现的一个重要的自动配置的衍生注解,条件注解,前提扫描到条件注解时,根据加载的A.class,B.class判断当前配·置是否生效,配合@Configuration完成

  测试案例:根据当前环境中存在的不同条件类,创建不同的bean对象

  > ```java
  > package cn.edu.scnu.bean.test;
  > public class ConditionCreateBeanA {
  >     public ConditionCreateBeanA() {
  >         System.out.println("A 的条件bean创建了");
  >     }
  > }
  > ```
  >
  > ```java
  > package cn.edu.scnu.bean.test;
  > public class ConditionalA {}
  > ```
  >
  > ```java
  > package cn.edu.scnu.config;
  > import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
  > import org.springframework.context.annotation.Bean;
  > import org.springframework.context.annotation.Configuration;
  > import cn.edu.scnu.bean.test.ConditionalA;
  > import cn.edu.scnu.bean.test.ConditionCreateBeanA;
  > //一旦加入一个条件注解,当前配置类是否配置,
  > //需要根据条件注解的条件判断,条件中指定的类
  > //如果存在于当前环境中(包路径可以扫描),才加载
  > //反之不加载
  > @Configuration
  > @ConditionalOnClass({ConditionalA.class})
  > public class ConditionConfig {
  >     @Bean
  >     public ConditionCreateBeanA initA(){
  >         return new ConditionCreateBeanA();
  >     }
  > }
  > ```



#### 配置

##### 文件格式

###### properties

即 `application.properties`

springboot 工程全局配置文件,所有可以使用的key-value值都可以在这个文件中配置,扫描路径classpath的根目录,maven工程src/main/resources

例如修改默认加载的端口号和默认访问的路径：

```properties
server.port=8081
server.contextPath=/hello
```

鉴于根目录改了，那么上文的访问路径会变成 `http://localhost:8081/hello/hello?name=baicha`



###### yml

> yml 可能是语法不熟悉，有神奇问题，不建议使用

即 `application.yml`

和application.properties的唯一区别就是数据的格式不同,使用方式,意义完全一样的(有yml不能有properties,反之亦然);读取数据的底层都是key-value;yml格式面向数据结构的;例如将测试中用到的(注意 yml 格式，用空格，不能用 tab，注意对齐)

```yaml
cn:
 edu:
  scnu:
   username: baicha
   password: 1235813
server:
 port: 8081
```

注：插件安装-help-eclipse marketplace，搜索 yaml，安装 yaml editor，成功重启发现可以编辑 yml 了。



##### 配置项

###### 数据库

```properties
#datasource config
spring.datasource.driverClassName=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql:///microtest?useSSL=false
spring.datasource.username=root
spring.datasource.password=1
```

```yaml
spring:
 datasource:
  driver-class-name: com.mysql.jdbc.Driver
  url: jdbc:mysql://localhost:3306/easymall?userSSL=false
  username: root
  password: 1
```

###### 持久层

```properties
mybatis.typeAliasesPackage=cn.edu.scnu.pojo
mybatis.mapperLocations=classpath:mapper/*.xml
mybatis.configuration.mapUnderscoreToCamelCase=true
```

```yaml
mabatis:
 type-aliases-package: cn.edu.scnu.pojo
 mapper-locations: classpath:mapper/*.xml
 configuration:
  map-underscore-to-camel-case: true
```

###### jsp前后缀

```properties
spring.mvc.view.prefix=/WEB-INF/
spring.mvc.view.suffix=.jsp
```





##### banner.txt

横幅,作为企业,公司,项目启动的标识;可以在classpath下配置banner.txt的文本,文本中的内容,会自动成为项目启动的横幅字符串,如果没有,就按照默认的横幅启动

效果：运行时会在控制台最先输出 banner.txt 中的内容。



##### 注解导入xml

springboot准备了非常丰富自动配置环境,应对多样性的开发场景;但是不能100%满足所有的需求,所以有的时候开发人员还是需要通过配置xml文件来解决spring容器中需要加载的一些特殊内容;只能通过手动导入xml配置文件完成xml的读取;需要自定义配置一个导入xml文件的配置类

案例实现需求:将一个在扫描范围之外的bean对象创建到xml的bean标签

```java
package org.child.application;
public class ChildInfoBean {
    public ChildInfoBean(){
        System.out.println("ChildInfoBean 被加载了！");
    }
}
```

```java
package cn.edu.scnu.config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ImportResource;
import cn.edu.scnu.bean.test.BeanTest01;
/**
 * 对应生成spring容器中需要加载的一个xml配置文件 spring.xml
 */
@Configuration
@ImportResource(value={"classpath:spring.xml"})
public class BeanConfig {
    // 想办法创建一个BeanTest01的IOC控制反转对象
    @Bean // 一般配合configuration注解的
    // 方法的返回对象,就是需要创建的bean对象,由容器维护管理
    // id值默认是方法名称
    public BeanTest01 intiBeanTest01() {
        // 各种属性赋值
        return new BeanTest01();
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:util="http://www.springframework.org/schema/util" 
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="
                           http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop 
                           http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/tx 
                           http://www.springframework.org/schema/tx/spring-tx.xsd
                           http://www.springframework.org/schema/util 
                           http://www.springframework.org/schema/util/spring-util.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/mvc
                           http://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <bean class="org.child.application.ChildInfoBean"></bean>
</beans>
```



##### 配置类

参考：

```java
package cn.edu.scnu.config;
import javax.sql.DataSource;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import com.alibaba.druid.pool.DruidDataSource;
@Configuration
@ConfigurationProperties("spring.datasource")
public class DataSourceInitConfig {
	private String driverClassName;
	private String url;
	private String username;
	private String password;
	private Integer maxActive; //最大连接数
	private Integer maxIdle;   //最大空闲连接数
	private Integer initialSize; //初始化连接数量
	private Integer minIdle;   //最大空闲数
	//自定义创建的DruidDatasource对象返回给框架使用
	@Bean
	@Primary//当容器中存在多个同类对象时,以Primary所在的优先级最高
	public DataSource initDruidDataSource(){
		DruidDataSource datasource=new DruidDataSource();
		datasource.setDriverClassName(driverClassName);
		datasource.setUrl(url);
		datasource.setUsername(username);
		datasource.setPassword(password);
		//连接池初始化参数
		datasource.setInitialSize(initialSize);//5
		datasource.setMaxActive(maxActive);//200
		datasource.setMaxIdle(maxIdle);//8
		datasource.setMinIdle(minIdle);//3
		return datasource;
	}
	public String getDriverClassName() {
		return driverClassName;
	}
	public void setDriverClassName(String driverClassName) {
		this.driverClassName = driverClassName;
	}
	public String getUrl() {
		return url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public String getUsername() {
		return username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public Integer getMaxActive() {
		return maxActive;
	}
	public void setMaxActive(Integer maxActive) {
		this.maxActive = maxActive;
	}
	public Integer getMaxIdle() {
		return maxIdle;
	}
	public void setMaxIdle(Integer maxIdle) {
		this.maxIdle = maxIdle;
	}
	public Integer getInitialSize() {
		return initialSize;
	}
	public void setInitialSize(Integer initialSize) {
		this.initialSize = initialSize;
	}
	public Integer getMinIdle() {
		return minIdle;
	}
	public void setMinIdle(Integer minIdle) {
		this.minIdle = minIdle;
	}
	
}
```





#### 持久层整合

##### 案例

依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<!-- mysql -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
<!-- 整合mybatis需要的依赖资源 -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>1.3.0</version>
</dependency>
```

数据库配置参见上文，如

```properties
spring.datasource.driverClassName=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql:///test
spring.datasource.username=root
spring.datasource.password=root
```

mybatis 配置：

```properties
mybatis.typeAliasesPackage=cn.edu.scnu.pojo
mybatis.mapperLocations=classpath:mapper/*.xml
mybatis.configuration.mapUnderscoreToCamelCase=true
```

写一个 POJO：

```java
package cn.edu.scnu.pojo;
public class User {
	//驼峰命名的封装规则
	private String userId;
	private String userPassword;
	private String userName;
	private Integer lev;
	private Integer points;
//setter&getter
}
```

```java
package cn.edu.scnu.mapper;
import cn.edu.scnu.pojo.User;
public interface UserMapper {
    User queryUser(String userId);
}
```

在 `resources/mapper/UserMapper.xml` 添加：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.edu.scnu.mapper.UserMapper">
    <select id="queryUser" parameterType="string" resultType="cn.edu.scnu.pojo.User">
        select * from t_user where user_id=#{userId} 
    </select>
</mapper>
```

设置 UserController, UserService：

```java
package cn.edu.scnu.service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import cn.edu.scnu.pojo.User;
import cn.edu.scnu.mapper.UserMapper;
@Service
public class UserService {
    @Autowired
    private UserMapper userMapper;
    public User queryUser(String userId) {
        // 调用持久层mapper,访问数据库返回user查询对象
        return userMapper.queryUser(userId);
    }
}
```

```java
package cn.edu.scnu.controller;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;
import cn.edu.scnu.pojo.User;
import cn.edu.scnu.service.UserService;
@RestController
public class UserController {
    @Autowired
    private UserService userService;
    //用户查询
    @RequestMapping("/user/query")
    @ResponseBody
    public User queryUser(String userId){
        return userService.queryUser(userId);
    }
}
```

修改 main 函数：

```java
package cn.edu.scnu;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
@SpringBootApplication //springboot启动的核心注解
@MapperScan("cn.edu.scnu.mapper")
public class StarterXu {
    public static void main(String[] args) {
        SpringApplication.run(StarterXu.class, args);
    }
}
```

测试访问：`localhost:8081/user/query?userId=1`

> 如果跑不动试试换一个 xml 的：
>
> ```xml
> cn.edu.scnu.username=xsn
> cn.edu.scnu.password=123456
> cn.edu.scnu.configPro02.level=1
> 
> #tom port contextPath
> server.port=8081
> server.context-path=/
> 
> #datasource config
> spring.datasource.driverClassName=com.mysql.jdbc.Driver
> spring.datasource.url=jdbc:mysql:///microtest?useSSL=false
> spring.datasource.username=root
> spring.datasource.password=14
> 
> #mybatis config
> mybatis.typeAliasesPackage=cn.edu.scnu.pojo
> mybatis.mapperLocations=classpath:mapper/*.xml
> mybatis.configuration.mapUnderscoreToCamelCase=true
> ```



#### jsp解析

jsp本质是需要tomcat容器翻译成.java文件的servlet代码的,而 springboot内嵌的tomcat无法直接解析jsp文件,需要添加一些支持jsp的依赖资源,解决这个不能直接对接的问题

添加依赖：

```xml
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>jstl</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-jasper</artifactId>
    <version>8.5.11</version>
</dependency> 
```

添加配置：

```properties
spring.mvc.view.prefix=/WEB-INF/
spring.mvc.view.suffix=.jsp
```

测试：在新建 `src/main/webapp/WEB-INF/index.jsp` 键入：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<h1>这是一个网页</h1>	
```

随便哪个 Controller 加一个方法：

```java
@RequestMapping("hi")
public String sayHi() {
    return "index";
}
```

测试浏览：`http://localhost:8081/hi`



#### 发布

springboot由于独立运行的spring容器,可以直接在jdk环境调用java命令运行,打成jar包,在jdk调用java -jar **.jar就可以直接运行

添加插件：(当然按理来说上文已经添加过了)

```xml
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
```

直接 `mvn clean package`，然后直接用 `java -jar ...` 跑即可。



#### 纵向拆分

根据系统功能，将系统拆成若干个独立运行的系统。

##### RestTemplace

RestTemplate 是从 Spring3.0 开始支持的一个 HTTP 请求工具，它提供了常见的REST请求方案的模版，例如 GET 请求、POST 请求

该对象是`springmvc`底层实现的一个支持http协议的,封装了多个http协议方法的对象;

```java
package cn.edu.scnu.test;
import org.junit.Test;
import org.springframework.web.client.RestTemplate;
public class TestRestTemplate {
	@Test
	public void test01() {
		RestTemplate client = new RestTemplate();
		// 访问京东,get请求
		String bodyStr = client.getForObject("https://www.jd.com", String.class);
		System.out.println(bodyStr);
	}
}
```

如上得到一个网页的 HTML 文本

常用方法 API：

```java
getForObject(uri,responseType)
postForObejct(uri,Object request,responseType)
```

uri:请求发起的目标url地址,例如`http://localhost:8092/user/updatePoint`

responseType:接收的响应体的数据类型,如果返回的是String,就是String.class,如果返回的是User的json字符串可以使用String直接接收字符串,也可以使用RestTemplate直接对字符串解析User来接收。

request类型Object;
普通类型,例如user,product,order,将会以对象的全部数据拼接到请求体中,作为请求体的参数发送;
HttpEntity,表示一个可以使用restTemplate发送的整个request对象.除了可以封装请求体的body数据,还关心发送请求时headers等内容

```java
package cn.edu.scnu.service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import cn.edu.scnu.entity.Order;
import cn.edu.scnu.mapper.OrderMapper;
@Service
public class OrderService {
	@Autowired
	private OrderMapper orderMapper;
	public void orderPay(String orderId) {
		// 打印支付金额,打印支付订单id,先得查询订单信息
		Order order = orderMapper.queryOrder(orderId);
		System.out.println("订单:" + orderId + ".已支付:" + order.getOrderMoney());		
		// 支付查询出来的订单金额已经完成
		//将数据传递给user做积分逻辑
		RestTemplate client = new RestTemplate();
		try {
			Integer success = client.getForObject(
					"http://localhost:8091/user/updatePoint?orderMoney="+ order.getOrderMoney()+"&userId="+order.getUserId(), Integer.class);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```



##### 基本原理

同时运行多个 springboot 项目，这些项目维护的子功能加起来刚好是整个系统的功能。如将用户与订单分离为两个项目。然后用 mybatis 静态页面分离做前端，后端提供且仅提供接口，不实现任何页面显示相关的代码，这些接口通过 controller 暴露，且其业务功能主要通过 service 及其下面的 dao 层即 mapper 实现(因此需要 `resources/mapper/` 和 DAO 接口)，以及 POJO 对象(entity 包)及其 getter, setter。整个 java 端只提供接口功能。配置文件里，只需要 `application.properties` 和 `mapper/`。分别配置端口号、数据库等，和数据库具体查询语句。

多个子系统需要交互，如购买订单时需要修改用户金额信息。这时，可以通过上文的 `RestTemplace` ，仿照前端调用的方法，直接 get/post 另一个子系统暴露的端口，即可实现交互。

部署时，同时运行这几个子系统在不同的端口(eclipse 直接 run 即可，console 里有个可以下拉的按钮可以看到不同的 running 并可以随时结束任意一个子系统)，然后配 hosts 和 nginx 即可。



#### 杂项

##### @Value

读取 `application.properties`，如：

```java
@Value("${server.port}")
private String port;
```

如文件写着：

```properties
server.port=9001
```





> ### 杂项
>

### Lombok

##### 概念与安装

lombok是一个可以通过简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 Java 代码的工具，简单来说，比如我们新建了一个类，通常情况下我们需要自动生成getter和setter方法、构造函数等，显得代码很臃肿，lombok的作用就是为了省略这些代码，它能够在编译源码时自动帮我们生成这些方法。

优点：

1) 能通过注解的形式自动生成构造器、getter / setter、equals、hashcode、toString 等方法，提高了一定的开发效率，让代码变得简洁，不用过多的去关注相应的方法。

2) 属性做修改时，也简化了维护为这些属性所生成的 getter / setter 方法等。

缺点：

1) 不支持多种参数构造器的重载。

2) 虽然省去了手动创建一系列方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度。

[下载地址](https://projectlombok.org/download)，安装就 `java -jar lombok.jar`，时会自动找到自己的 eclipse 路径，直接install/update，重启IDE。事实上这个安装过程就是将lombok.jar复制到eclipse目录下，并且在 eclipse.ini 中添加配置：`-javaagent:D:\Program Files\eclipse\eclipse-cloud\lombok.jar`

在 pom 添加依赖：

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.22</version>
    <scope>provided</scope>
</dependency>
```

##### 常用注解

| **注解**  | **作用**                                                     |
| --------- | ------------------------------------------------------------ |
| @Data     | 类注解，综合注解，包含 ：@Getter,  @Setter, @ToString , @RequiredArgsConstructor, @EqualsAndHashCode（自动实现model类的equals方法和hashcode方法）。 |
| @Value    | 类注解，综合注解，包含：@Getter,  @ToString, @RequiredArgsConstructor, @EqualsAndHashCode。 |
| @Builder  | 生成当前类的字段构建方法。生成  builder() 方法，并且直接根据字段名称方法进行字段赋值，最后使用  build() 方法构建出一个实体对象 |
| @Getter   | 类注解，代替 getter 方法。                                   |
| @Setter   | 类注解，代替 setter 方法。                                   |
| @ToString | 类注解，生成 toString 方法。                                 |
| @Log4j    | org.apache.log4j.Logger                                      |

##### 例子

```java
package cn.edu.scnu.pojo;
import java.io.Serializable;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Builder;
import lombok.Data;
@Data
@Builder
@TableName(value = "User")//数据库user表和 JavaBean(User类） 进行映射
public class User implements Serializable {
    private static final long serialVersionUID = -5644799954031156649L;
    //value与数据库主键列名一致，若实体类属性名与表主键列名一致可省略value
    @TableId(value = "id", type = IdType.AUTO)//指定自增策略
    private Integer id;
    private String name;
    private String sex;
    private String pwd;
    private String email;
}
```

这样就完成了mybatis-plus与springboot的整合。首先是把mybatis和mybatis-spring依赖换成mybatis-plus的依赖，然后把sqlsessionfactory换成mybatis-plus的，然后实体类中添加@TableName、@TableId等注解，最后mapper继承BaseMapper即可。



### Redis

#### 概念

##### 安装

找个地方 [下载](https://pan.baidu.com/s/1ug6tN060YE9EYchxgdeW0w ) redis，解压后将 `redis-x64-3.2.100.zip` 解压，而 `desktop-manager` 是可视化客户端。检验方法：双击解压后的 `redis-server` 能跑。默认端口号 6379。安装客户端。打开后点右下角 connect to redis server，选 `127.0.0.1:6379`，在没关 server 时能连上。

> 提示说要更新，但是不更新也行，客户端。

##### 理论

Redis（Remote Dictionary Server )，即远程字典服务

一个支持nosql，key-value数据类型、内存、缓存、分布式的、可持久化、非关系型数据库。

作用：

1. Redis最常用来做缓存，是实现分布式缓存的首先中间件；
2. Redis可以作为数据库，实现诸如点赞、关注、排行等对性能要求极高的互联网需求；
3. Redis可以作为计算工具，能用很小的代价，统计诸如PV/UV(page view访问量;unique visitor独立访客)、用户在线天数等数据；
4. Redis还有很多其他的使用场景，例如：可以实现分布式锁，可以作为消息队列使用。

与传统数据库比较：

Redis是一种基于键值对的NoSQL数据库，而键值对的值是由多种数据结构和算法组成的。Redis的数据都存储于内存中，因此它的速度惊人，读写性能可达10万/秒，远超关系型数据库。

关系型数据库是基于二维数据表来存储数据的，它的数据格式更为严谨，并支持关系查询。关系型数据库的数据存储于磁盘上，可以存放海量的数据，但性能远不如Redis。

数据类型：

1. Redis支持5种核心的数据类型，分别是字符串、哈希、列表、集合、有序集合；

   set：

   - 集合中的元素是无序、不可重复的，一个集合最多能存储$2^{32}-1$个元素；
   - 集合除了支持对元素的增删改查之外，还支持对多个集合取交集、并集、差集。

   zset：

   - 有序集合保留了集合元素不能重复的特点；
   - 有序集合会给每个元素设置一个分数，并以此作为排序的依据；
   - 有序集合不能包含相同的元素，但是不同元素的分数可以相同。

   有序集合对象有2种编码方案，当同时满足以下条件时，集合对象采用ziplist编码，否则采用skiplist编码：

   - 有序集合保存的元素数量不超过128个；
   - 有序集合保存的所有元素的成员长度都小于64字节。

   其中，ziplist编码的有序集合采用压缩列表作为底层实现，skiplist编码的有序集合采用zset结构作为底层实现。

   其中，zset是一个复合结构，它的内部采用字典和跳跃表来实现。其中，dict保存了从成员到分支的映射关系，zsl则按分值由小到大保存了所有的集合元素。这样，当按照成员来访问有序集合时可以直接从dict中取值，当按照分值的范围访问有序集合时可以直接从zsl中取值，采用了空间换时间的策略以提高访问效率。

   综上，zset对象的底层数据结构包括：压缩列表、字典、跳跃表。

   列表是线性有序的数据结构，它内部的元素是可以重复的，并且一个列表最多能存储$2^{32}-1$个元素。列表包含如下的常用命令：

   - lpush/rpush：从列表的左侧/右侧添加数据；
   - lrange：指定索引范围，并返回这个范围内的数据；
   - lindex：返回指定索引处的数据；
   - lpop/rpop：从列表的左侧/右侧弹出一个数据；
   - blpop/brpop：从列表的左侧/右侧弹出一个数据，若列表为空则进入阻塞状态。

   哈希对象有两种编码方案，当同时满足以下条件时，哈希对象采用ziplist编码，否则采用hashtable编码：

   - 哈希对象保存的键值对数量小于512个；
   - 哈希对象保存的所有键值对中的键和值，其字符串长度都小于64字节。

   其中，ziplist编码采用压缩列表作为底层实现，而hashtable编码采用字典作为底层实现。

   压缩列表：

   压缩列表（ziplist），是Redis为了节约内存而设计的一种线性数据结构，它是由一系列具有特殊编码的连续内存块构成的。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。

   压缩列表的结构如下图所示：

   ![img](img/EDE489BFD41B30C6C8215C25B8BF2BCB.png)

   该结构当中的字段含义如下表所示：

   | **属性** | **类型** | **长度** | **说明**                                                     |
   | -------- | -------- | -------- | ------------------------------------------------------------ |
   | zlbytes  | uint32_t | 4字节    | 压缩列表占用的内存字节数；                                   |
   | zltail   | uint32_t | 4字节    | 压缩列表表尾节点距离列表起始地址的偏移量（单位字节）；       |
   | zllen    | uint16_t | 2字节    | 压缩列表包含的节点数量，等于UINT16_MAX时，需遍历列表计算真实数量； |
   | entryX   | 列表节点 | 不固定   | 压缩列表包含的节点，节点的长度由节点所保存的内容决定；       |
   | zlend    | uint8_t  | 1字节    | 压缩列表的结尾标识，是一个固定值0xFF；                       |

   其中，压缩列表的节点由以下字段构成：

   ![img](img/F7C97822E36907700FB5DF3F51154ED1.png)

   previous_entry_length（pel）属性以字节为单位，记录当前节点的前一节点的长度，其自身占据1字节或5字节：

   1. 如果前一节点的长度小于254字节，则“pel”属性的长度为1字节，前一节点的长度就保存在这一个字节内；
   2. 如果前一节点的长度达到254字节，则“pel”属性的长度为5字节，其中第一个字节被设置为0xFE，之后的四个字节用来保存前一节点的长度；

   基于“pel”属性，程序便可以通过指针运算，根据当前节点的起始地址计算出前一节点的起始地址，从而实现从表尾向表头的遍历操作。

   content属性负责保存节点的值（字节数组或整数），其类型和长度则由encoding属性决定，它们的关系如下：

   | **encoding**                   | **长度** | **content**                                     |
   | ------------------------------ | -------- | ----------------------------------------------- |
   | 00 xxxxxx                      | 1字节    | 最大长度为26 -1的字节数组；                     |
   | 01 xxxxxx bbbbbbbb             | 2字节    | 最大长度为214-1的字节数组；                     |
   | 10 **__** bbbbbbbb ... ... ... | 5字节    | 最大长度为232-1的字节数组；                     |
   | 11 000000                      | 1字节    | int16_t类型的整数；                             |
   | 11 010000                      | 1字节    | int32_t类型的整数；                             |
   | 11 100000                      | 1字节    | int64_t类型的整数；                             |
   | 11 110000                      | 1字节    | 24位有符号整数；                                |
   | 11 111110                      | 1字节    | 8位有符号整数；                                 |
   | 11 11xxxx                      | 1字节    | 没有content属性，xxxx直接存[0,12]范围的整数值； |

   跳跃表：

   跳跃表的查找复杂度为平均O(logN)，最坏O(N)，效率堪比红黑树，却远比红黑树实现简单。跳跃表是在链表的基础上，通过增加索引来提高查找效率的。

   有序链表插入、删除的复杂度为O(1)，而查找的复杂度为O(N)。例：若要查找值为60的元素，需要从第1个元素依次向后比较，共需比较6次才行，如下图：

   ![img](img/A9479F35483A8972592990CA58C20FBE.png)

   跳跃表是从有序链表中选取部分节点，组成一个新链表，并以此作为原始链表的一级索引。再从一级索引中选取部分节点，组成一个新链表，并以此作为原始链表的二级索引。以此类推，可以有多级索引，如下图：

   ![img](img/F932B58F002C5A2CA2E94B2FC5DCEF17.png)

   跳跃表在查找时，优先从高层开始查找，若next节点值大于目标值，或next指针指向NULL，则从当前节点下降一层继续向后查找，这样便可以提高查找的效率了。

   跳跃表的实现主要涉及2个结构体：zskiplist、zskiplistNode，它们的关系如下图所示：

   ![img](img/478F1C196356F6F3651356CE0C66B7E2.png)

   其中，蓝色的表格代表zskiplist，红色的表格代表zskiplistNode。zskiplist有指向头尾节点的指针，以及列表的长度，列表中最高的层级。zskiplistNode的头节点是空的，它不存储任何真实的数据，它拥有最高的层级，但这个层级不记录在zskiplist之内。

   字典（dict）又称为散列表，是一种用来存储键值对的数据结构。C语言没有内置这种数据结构，所以Redis构建了自己的字典实现。

   Redis字典的实现主要涉及三个结构体：字典、哈希表、哈希表节点。其中，每个哈希表节点保存一个键值对，每个哈希表由多个哈希表节点构成，而字典则是对哈希表的进一步封装。这三个结构体的关系如下图所示：

   ![img](img/970CB95850BF97354D08E8B5223CBAA7.png)

   其中，dict代表字典，dictht代表哈希表，dictEntry代表哈希表节点。可以看出，dictEntry是一个数组，这很好理解，因为一个哈希表里要包含多个哈希表节点。而dict里包含2个dictht，多出的哈希表用于REHASH。当哈希表保存的键值对数量过多或过少时，需要对哈希表的大小进行扩展或收缩操作，在Redis中，扩展和收缩哈希表是通过REHASH实现的，执行REHASH的大致步骤如下：

   1. 为字典的ht[1]哈希表分配内存空间

      如果执行的是扩展操作，则ht[1]的大小为第1个大于等于ht[0].used*2的2n。如果执行的是收缩操作，则ht[1]的大小为第1个大于等于ht[0].used的2n。

   2. 将存储在ht[0]中的数据迁移到ht[1]上

      重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。

   3. 将字典的ht[1]哈希表晋升为默认哈希表

      迁移完成后，清空ht[0]，再交换ht[0]和ht[1]的值，为下一次REHASH做准备。

   当满足以下任何一个条件时，程序会自动开始对哈希表执行扩展操作：

   1. 服务器目前没有执行bgsave或bgrewriteof命令，并且哈希表的负载因子大于等于1；
   2. 服务器目前正在执行bgsave或bgrewriteof命令，并且哈希表的负载因子大于等于5。

   为了避免REHASH对服务器性能造成影响，REHASH操作不是一次性地完成的，而是分多次、渐进式地完成的。渐进式REHASH的详细过程如下：

   1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表；
   2. 在字典中的索引计数器rehashidx设置为0，表示REHASH操作正式开始；
   3. 在REHASH期间，每次对字典执行添加、删除、修改、查找操作时，程序除了执行指定的操作外，还会顺带将ht[0]中位于rehashidx上的所有键值对迁移到ht[1]中，再将rehashidx的值加1；
   4. 随着字典不断被访问，最终在某个时刻，ht[0]上的所有键值对都被迁移到ht[1]上，此时程序将rehashidx属性值设置为-1，标识REHASH操作完成。

   REHSH期间，字典同时持有两个哈希表，此时的访问将按照如下原则处理：

   1. 新添加的键值对，一律被保存到ht[1]中；
   2. 删除、修改、查找等其他操作，会在两个哈希表上进行，即程序先尝试去ht[0]中访问要操作的数据，若不存在则到ht[1]中访问，再对访问到的数据做相应的处理。

2. Redis还提供了Bitmap、HyperLogLog、Geo类型，但这些类型都是基于上述核心数据类型实现的；

3. Redis在5.0新增加了Streams数据类型，它是一个功能强大的、支持多播的、可持久化的消息队列。



布隆过滤器可以用很低的代价，估算出数据是否真实存在。例如：给用户推荐新闻时，要去掉重复的新闻，就可以利用布隆过滤器，判断该新闻是否已经推荐过。

布隆过滤器的核心包括两部分：

1. 一个大型的位数组；
2. 若干个不一样的哈希函数，每个哈希函数都能将哈希值算的比较均匀。

布隆过滤器的工作原理：

1. 添加key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置，并将位数组中这个位置的值设置为1。
2. 询问key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置。然后对比这些哈希函数在位数组中对应位置的数值：
   - 如果这几个位置中，有一个位置的值是0，就说明这个布隆过滤器中，不存在这个key。
   - 如果这几个位置中，所有位置的值都是1，就说明这个布隆过滤器中，极有可能存在这个key。之所以不是百分之百确定，是因为也可能是其他的key运算导致该位置为1。



单线程但快的原因：

1. 对服务端程序来说，线程切换和锁通常是性能杀手，而单线程避免了线程切换和竞争所产生的消耗；
2. Redis的大部分操作是在内存上完成的，这是它实现高性能的一个重要原因；
3. Redis采用了IO多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。

关于 Redis 的单线程架构实现，如下图：

![img](img/7D358C4626AF51725C251A2611C5DD65.png)

Redis是单线程的，主要是指Redis的网络IO和键值对读写是由一个线程来完成的。而Redis的其他功能，如持久化、异步删除、集群数据同步等，则是依赖其他线程来执行的。所以，说Redis是单线程的只是一种习惯的说法，事实上它的底层不是单线程的。(Redis在持久化时fork出一个子进程，这时已经有两个进程了)

watch命令：

很多时候，要确保事务中的数据没有被其他客户端修改才执行该事务。Redis提供了watch命令来解决这类问题，这是一种乐观锁的机制。客户端通过watch命令，要求服务器对一个或多个key进行监视，如果在客户端执行事务之前，这些key发生了变化，则服务器将拒绝执行客户端提交的事务，并向它返回一个空值。

> 乐观锁举例：A,B同时想要修改一条数据，取当前数据版本，在修改成功前，查看当前版本是否还是修改前版本，是的话允许修改，避免了上锁。

过期时间：

1. 热点数据不设置过期时间，使其达到“物理”上的永不过期，可以避免缓存击穿问题；

2. 在设置过期时间时，可以附加一个随机数，避免大量的key同时过期，导致缓存雪崩。

   > [参考](https://blog.csdn.net/qq_45637260/article/details/125866738) 缓存穿透，缓存雪崩，缓存击穿
   >
   > 缓存穿透：
   >
   > 问题描述：
   >
   > 客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。
   >
   > 解决方案：
   >
   > 1. 缓存空对象：存储层未命中后，仍然将空值存入缓存层，客户端再次访问数据时，缓存层会直接返回空值。
   >
   > 2. 布隆过滤器：将数据存入布隆过滤器，访问缓存之前以过滤器拦截，若请求的数据不存在则直接返回空值。
   >
   >    (布隆过滤器有点像多重哈希)
   >
   > 缓存击穿：
   >
   > 问题描述：
   >
   > 一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。
   >
   > 解决方案：
   >
   > 1. 永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。或者为每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。
   > 2. 加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。
   >
   > 缓存雪崩：
   >
   > 问题描述：
   >
   > 在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成数据库宕机。可能是缓存中有大量数据同时过期，也可能是Redis节点发生故障，导致大量请求无法得到处理。
   >
   > 解决方案：
   >
   > 1. 避免数据同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。
   > 2. 启用降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息/空值/错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是直接返回。
   > 3. 构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。

缓存与数据库双写一致：

想要保证缓存与数据库的双写一致，一共有4种方式，即4种同步策略：

1. 先更新缓存，再更新数据库；
2. 先更新数据库，再更新缓存；
3. 先删除缓存，再更新数据库；
4. 先更新数据库，再删除缓存。

从这4种同步策略中，我们需要作出比较的是：

1. 更新缓存与删除缓存哪种方式更合适？
2. 应该先操作数据库还是先操作缓存？

更新缓存还是删除缓存：

下面，我们来分析一下，应该采用更新缓存还是删除缓存的方式。

- 更新缓存

  优点：每次数据变化都及时更新缓存，所以查询时不容易出现未命中的情况。

  缺点：更新缓存的消耗比较大。如果数据需要经过复杂的计算再写入缓存，那么频繁的更新缓存，就会影响服务器的性能。如果是写入数据频繁的业务场景，那么可能频繁的更新缓存时，却没有业务读取该数据。

- 删除缓存

  优点：操作简单，无论更新操作是否复杂，都是将缓存中的数据直接删除。

  缺点：删除缓存后，下一次查询缓存会出现未命中，这时需要重新读取一次数据库。

从上面的比较来看，一般情况下，删除缓存是更优的方案。

经过对比会发现，先更新数据库、再删除缓存是影响更小的方案。如果第二步出现失败的情况，则可以采用重试机制解决问题。

> 上面我们提到，如果是先删缓存、再更新数据库，在没有出现失败时可能会导致数据的不一致。如果在实际的应用中，出于某些考虑我们需要选择这种方式，那有办法解决这个问题吗？答案是有的，那就是采用延时双删的策略，延时双删的基本思路如下：
>
> 1. 删除缓存；
> 2. 更新数据库；
> 3. sleep N毫秒；
> 4. 再次删除缓存。
>
> 阻塞一段时间之后，再次删除缓存，就可以把这个过程中缓存中不一致的数据删除掉。而具体的时间，要评估你这项业务的大致时间，按照这个时间来设定即可。
>
> 如果数据库采用的是读写分离的架构，那么又会出现新的问题，如下图：
>
> ![img](img/49BCF6CB1360234D0D9040255E0C0B0C.png)
>
> 进程A先删除缓存，再更新主数据库，然后主库将数据同步到从库。而在主从数据库同步之前，可能会有进程B访问了缓存，发现数据不存在，进而它去访问从库获取到旧的数据，然后同步到缓存。这样，最终也会导致缓存与数据库的数据不一致。这个问题的解决方案，依然是采用延时双删的策略，但是在评估延长时间的时候，要考虑到主从数据库同步的时间。
>
> 第二次删除失败了怎么办？
>
> 如果第二次删除依然失败，则可以增加重试的次数，但是这个次数要有限制，当超出一定的次数时，要采取报错、记日志、发邮件提醒等措施。



过期策略：

Redis支持如下两种过期策略：

惰性删除：客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key。

定期删除：Redis会将设置了过期时间的key放到一个独立的字典中，并对该字典进行每秒10次的过期扫描，

过期扫描不会遍历字典中所有的key，而是采用了一种简单的贪心策略。该策略的删除逻辑如下：

1. 从过期字典中随机选择20个key；
2. 删除这20个key中已过期的key；
3. 如果已过期key的比例超过25%，则重复步骤1。

缓存淘汰策略：

当写入数据将导致超出maxmemory限制时，Redis会采用maxmemory-policy所指定的策略进行数据淘汰，该策略一共包含如下8种选项：

| **策略**        | **描述**                                                 | **版本** |
| --------------- | -------------------------------------------------------- | -------- |
| noeviction      | 直接返回错误；                                           |          |
| volatile-ttl    | 从设置了过期时间的键中，选择过期时间最小的键，进行淘汰； |          |
| volatile-random | 从设置了过期时间的键中，随机选择键，进行淘汰；           |          |
| volatile-lru    | 从设置了过期时间的键中，使用LRU算法选择键，进行淘汰；    |          |
| volatile-lfu    | 从设置了过期时间的键中，使用LFU算法选择键，进行淘汰；    | 4.0      |
| allleys-random  | 从所有的键中，随机选择键，进行淘汰；                     |          |
| allkeys-lru     | 从所有的键中，使用LRU算法选择键，进行淘汰；              |          |
| allkeys-lfu     | 从所有的键中，使用LFU算法选择键，进行淘汰；              | 4.0      |

其中，volatile前缀代表从设置了过期时间的键中淘汰数据，allkeys前缀代表从所有的键中淘汰数据。关于后缀，ttl代表选择过期时间最小的键，random代表随机选择键，需要我们额外关注的是lru和lfu后缀，它们分别代表采用lru算法和lfu算法来淘汰数据。

LRU（Least Recently Used）是按照最近最少使用原则来筛选数据，即最不常用的数据会被筛选出来

- 标准LRU：把所有的数据组成一个链表，表头和表尾分别表示MRU和LRU端，即最常使用端和最少使用端。刚被访问的数据会被移动到MRU端，而新增的数据也是刚被访问的数据，也会被移动到MRU端。当链表的空间被占满时，它会删除LRU端的数据。
- 近似LRU：Redis会记录每个数据的最近一次访问的时间戳（LRU）。Redis执行写入操作时，若发现内存超出maxmemory，就会执行一次近似LRU淘汰算法。近似LRU会随机采样N个key，然后淘汰掉最旧的key，若淘汰后内存依然超出限制，则继续采样淘汰。可以通过maxmemory_samples配置项，设置近似LRU每次采样的数据个数，该配置项的默认值为5。

LRU算法的不足之处在于，若一个key很少被访问，只是刚刚偶尔被访问了一次，则它就被认为是热点数据，短时间内不会被淘汰。

LFU算法正式用于解决上述问题，LFU（Least Frequently Used）是Redis4新增的淘汰策略，它根据key的最近访问频率进行淘汰。LFU在LRU的基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用LFU策略淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出内存。如果两个数据的访问次数相同，LFU再比较这两个数据的访问时间，把访问时间更早的数据淘汰出内存。

setnx与实现分布式锁：

setnx命令返回整数值，当返回1时表示设置值成果，当返回0时表示设置值失败（key已存在）。

一般我们不建议直接使用setnx命令来实现分布式锁，因为为了避免出现死锁，我们要给锁设置一个自动过期时间。而setnx命令和设置过期时间的命令不是原子的，可能加锁成果而设置过期时间失败，依然存在死锁的隐患。对于这种情况，Redis改进了set命令，给它增加了nx选项，启用该选项时set命令的效果就会setnx一样了。

采用Redis实现分布式锁，就是在Redis里存一份代表锁的数据，通常用字符串即可。

持久化策略：

Redis支持RDB持久化、AOF持久化、RDB-AOF混合持久化这三种持久化方式。

RDB：

RDB(Redis Database)是Redis默认采用的持久化方式，它以快照的形式将进程数据持久化到硬盘中。RDB会创建一个经过压缩的二进制文件，文件以“.rdb”结尾，内部存储了各个数据库的键值对数据等信息。RDB持久化的触发方式有两种：

- 手动触发：通过SAVE或BGSAVE命令触发RDB持久化操作，创建“.rdb”文件；
- 自动触发：通过配置选项，让服务器在满足指定条件时自动执行BGSAVE命令。

其中，SAVE命令执行期间，Redis服务器将阻塞，直到“.rdb”文件创建完毕为止。而BGSAVE命令是异步版本的SAVE命令，它会使用Redis服务器进程的子进程，创建“.rdb”文件。BGSAVE命令在创建子进程时会存在短暂的阻塞，之后服务器便可以继续处理其他客户端的请求。总之，BGSAVE命令是针对SAVE阻塞问题做的优化，Redis内部所有涉及RDB的操作都采用BGSAVE的方式，而SAVE命令已经废弃！

BGSAVE命令的执行流程，如下图：

![img](img/939F2BF55AFF0E48184628AE3B19BB67.png)

![img](img/7195949B05E80D8EEBFE084774FF8753.png)

RDB持久化的优缺点如下：

- 优点：RDB生成紧凑压缩的二进制文件，体积小，使用该文件恢复数据的速度非常快；

- 缺点：BGSAVE每次运行都要执行fork操作创建子进程，属于重量级操作，不宜频繁执行，

  所以RDB持久化没办法做到实时的持久化。

AOF：

AOF（Append Only File），解决了数据持久化的实时性，是目前Redis持久化的主流方式。AOF以独立日志的方式，记录了每次写入命令，重启时再重新执行AOF文件中的命令来恢复数据。AOF的工作流程包括：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load），如下图：

![img](img/72D05C716050D5C022C41B7911FAED6D.png)

AOF默认不开启，需要修改配置项来启用它。以文本协议格式写入命令，如：

```
*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n
```

文本协议格式具有如下的优点：

1. 文本协议具有很好的兼容性；
2. 直接采用文本协议格式，可以避免二次处理的开销；
3. 文本协议具有可读性，方便直接修改和处理。

AOF持久化的文件同步机制：

为了提高程序的写入性能，现代操作系统会把针对硬盘的多次写操作优化为一次写操作。

1. 当程序调用write对文件写入时，系统不会直接把书记写入硬盘，而是先将数据写入内存的缓冲区中；
2. 当达到特定的时间周期或缓冲区写满时，系统才会执行flush操作，将缓冲区中的数据冲洗至硬盘中；

这种优化机制虽然提高了性能，但也给程序的写入操作带来了不确定性。

1. 对于AOF这样的持久化功能来说，冲洗机制将直接影响AOF持久化的安全性；
2. 为了消除上述机制的不确定性，Redis向用户提供了appendfsync选项，来控制系统冲洗AOF的频率；
3. Linux的glibc提供了fsync函数，可以将指定文件强制从缓冲区刷到硬盘，上述选项正是基于此函数。

appendfsync选项的取值和含义如下：

![img](img/4C081F8534BED6D701B6F23A7E3AE995.png)

AOF持久化的优缺点如下：

- 优点：与RDB持久化可能丢失大量的数据相比，AOF持久化的安全性要高很多。通过使用everysec选项，用户可以将数据丢失的时间窗口限制在1秒之内。
- 缺点：AOF文件存储的是协议文本，它的体积要比二进制格式的”.rdb”文件大很多。AOF需要通过执行AOF文件中的命令来恢复数据库，其恢复速度比RDB慢很多。AOF在进行重写时也需要创建子进程，在数据库体积较大时将占用大量资源，会导致服务器的短暂阻塞。

RDB-AOF混合持久化：

Redis从4.0开始引入RDB-AOF混合持久化模式，这种模式是基于AOF持久化构建而来的。用户可以通过配置文件中的“aof-use-rdb-preamble yes”配置项开启AOF混合持久化。Redis服务器在执行AOF重写操作时，会按照如下原则处理数据：

- 像执行BGSAVE命令一样，根据数据库当前的状态生成相应的RDB数据，并将其写入AOF文件中；
- 对于重写之后执行的Redis命令，则以协议文本的方式追加到AOF文件的末尾，即RDB数据之后。

通过使用RDB-AOF混合持久化，用户可以同时获得RDB持久化和AOF持久化的优点，服务器既可以通过AOF文件包含的RDB数据来实现快速的数据恢复操作，又可以通过AOF文件包含的AOF数据来将丢失数据的时间窗口限制在1s之内。

> Redis存的快是因为它的数据都存放在内存里，并且为了保证数据的安全性，Redis还提供了三种数据的持久化机制。若服务器断电，那么我们可以利用持久化文件，对数据进行恢复。理论上来说，AOF/RDB-AOF持久化可以将丢失数据的窗口控制在1S之内。

实现Redis的高可用，主要有哨兵和集群两种方式。

哨兵：

Redis Sentinel（哨兵）是一个分布式架构，它包含若干个哨兵节点和数据节点。每个哨兵节点会对数据节点和其余的哨兵节点进行监控，当发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它就会与其他的哨兵节点进行协商，当多数哨兵节点都认为主节点不可达时，它们便会选举出一个哨兵节点来完成自动故障转移的工作，同时还会将这个变化实时地通知给应用方。整个过程是自动的，不需要人工介入，有效地解决了Redis的高可用问题！

一组哨兵可以监控一个主节点，也可以同时监控多个主节点，两种情况的拓扑结构如下图：

![img](img/7973F150721F816D3E2548C1F02CED35.png)

哨兵节点包含如下的特征：

1. 哨兵节点会定期监控数据节点，其他哨兵节点是否可达；
2. 哨兵节点会将故障转移的结果通知给应用方；
3. 哨兵节点可以将从节点晋升为主节点，并维护后续正确的主从关系；
4. 哨兵模式下，客户端连接的是哨兵节点集合，从中获取主节点信息；
5. 节点的故障判断是由多个哨兵节点共同完成的，可有效地防止误判；
6. 哨兵节点集合是由多个哨兵节点组成的，即使个别哨兵节点不可用，整个集合依然是健壮的；
7. 哨兵节点也是独立的Redis节点，是特殊的Redis节点，它们不存储数据，只支持部分命令。

集群：

Redis集群采用虚拟槽分区来实现数据分片，它把所有的键根据哈希函数映射到0-16383整数槽内，计算公式为slot=CRC16(key)&16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。虚拟槽分区具有如下特点：

1. 解耦数据和节点之间的关系，简化了节点扩容和收缩的难度；
2. 节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据；
3. 支持节点、槽、键之间的映射查询，用于数据路由，在线伸缩等场景。

Redis集群中数据的分片逻辑如下图：

![img](img/2B3170169B19552123C5487746142DF6.png)

> Redis集群的功能限制：
>
> Redis集群方案在扩展了Redis处理能力的同时，也带来了一些使用上的限制：
>
> 1. key批量操作支持有限。如mset、mget，目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key由于执行mset、mget等操作可能存在于多个节点上所以不被支持。
> 2. key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。
> 3. key作为数据分区的最小粒度，因此不能将一个大的键值对象（如hash、list等）映射到不同的节点。
> 4. 不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模式下只能使用一个数据库空间，即DB0。
> 5. 复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。
>
> Redis集群的通信方案：
>
> 在分布式存储中需要提供维护节点元数据信息的机制，所谓元数据是指：节点负责哪些数据，是否出现故障等状态信息。常见的元数据维护方式分为：集中式和P2P方式。
>
> Redis集群采用P2P的Gossip（流言）协议，Gossip协议的工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播。通信的大致过程如下：
>
> 1. 集群中每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口号上加10000；
> 2. 每个节点再固定周期内通过特定规则选择几个节点发送ping消息；
> 3. 接收ping消息的节点用pong消息作为响应。
>
> 其中，Gossip协议的主要职责就是信息交换，而信息交换的载体就是节点彼此发送的Gossip消息，Gossip消息分为：meet消息、ping消息、pong消息、fail消息等。
>
> - meet消息：用于通知新节点加入，消息发送者通知接受者加入到当前集群。meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。
> - ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消息封装了自身节点和一部分其他节点的状态数据。
> - pong消息：当接收到meet、ping消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内封装了自身状态数据，节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。
> - fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。
>
> 虽然Gossip协议的信息交换机制具有天然的分布式特性，但它是有成本的。因为Redis集群内部需要频繁地进行节点信息交换，而ping/pong消息会携带当前节点和部分其他节点的状态数据，势必会加重带宽和计算的负担。所以，Redis集群的Gossip协议需要兼顾信息交换的实时性和成本的开销。
>
> - 集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过PING消息的节点发送PING消息，以此来检测被选中的节点是否在线。
> - 如果节点A最后一次收到节点B发送的PONG消息的时间，距离当前时间已经超过了节点A的超时选项设置时长的一半（cluster-node-timeout/2），那么节点A也会向节点B发送PING消息，这可以防止节点A因为长时间没有随机选中节点B作为PING消息的发送对象而导致对节点B的信息更新滞后。
> - 每个消息主要的数据占用：slots槽数组（2KB）和整个集群1/10的状态数据（10个节点状态数据约1KB）。

主从同步：

从2.8版本开始，Redis使用psync命令完成主从数据同步，同步过程分为全量复制和部分复制。全量复制一般用于初次复制的场景，部分复制则用于处理因网络中断等原因造成数据丢失的场景。psync命令需要以下参数的支持：

1. 复制偏移量：主节点处理写命令后，会把命令长度做累加记录，从节点在接收到写命令后，也会做累加记录；从节点会每秒钟上报一次自身的复制偏移量给主节点，而主节点则会保存从节点的复制偏移量。
2. 积压缓冲区：保存在主节点上的一个固定长度的队列，默认大小为1M，当主节点有连接的从节点时被创建；主节点处理写命令时，不但会把命令发送给从节点，还会写入积压缓冲区；缓冲区是先进先出的队列，可以保存最近已复制的数据，用于部分复制和命令丢失的数据补救。
3. 主节点运行ID：每个Redis节点启动后，都会动态分配一个40位的十六进制字符串作为运行ID；如果使用IP和端口的方式标识主节点，那么主节点重启变更了数据集（RDB/AOF），从节点再基于复制偏移量复制数据将是不安全的，因此当主节点的运行ID变化后，从节点将做全量复制。

psync命令的执行过程以及返回结果，如下图：

![img](img/6771D78AF7BCF3E4907366DDE0D79259.png)

全量复制：

![img](img/946920CB89AE5D191202B12E9FE9F4F7.png)

部分复制：

![img](img/38A020497C3D4B30EF561E8415EAFAB1.png)

集群：

优势：

Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。

劣势：

Redis集群方案在扩展了Redis处理能力的同时，也带来了一些使用上的限制：

1. key批量操作支持有限。如mset、mget，目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key由于执行mset、mget等操作可能存在于多个节点上所以不被支持。
2. key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。
3. key作为数据分区的最小粒度，因此不能将一个大的键值对象（如hash、list等）映射到不同的节点。
4. 不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模式下只能使用一个数据库空间，即DB0。
5. 复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。



在web开发中，我们会把用户的登录信息存储在session里。而session是依赖于cookie的，即服务器创建session时会给它分配一个唯一的ID，并且在响应时创建一个cookie用于存储这个SESSIONID。当客户端收到这个cookie之后，就会自动保存这个SESSIONID，并且在下次访问时自动携带这个SESSIONID，届时服务器就可以通过这个SESSIONID得到与之对应的session，从而识别用户的身。如下图：

![img](img/CA7048A5EBAF2E130CF3FE273EFC4C7E.png)

现在的互联网应用，基本都是采用分布式部署方式，即将应用程序部署在多台服务器上，并通过nginx做统一的请求分发。而服务器与服务器之间是隔离的，它们的session是不共享的，这就存在session同步的问题了，如下图：

![img](img/4E14165FD661832ACE8D2E4DA5449627.png)

如果客户端第一次访问服务器，请求被分发到了服务器A上，则服务器A会为该客户端创建session。如果客户端再次访问服务器，请求被分发到服务器B上，则由于服务器B中没有这个session，所以用户的身份无法得到验证，从而产生了不一致的问题。

解决这个问题的办法有很多，比如可以协调多个服务器，让他们的session保持同步。也可以在分发请求时做绑定处理，即将某一个IP固定分配给同一个服务器。但这些方式都比较麻烦，而且性能上也有一定的消耗。更合理的方式就是采用类似于Redis这样的高性能缓存服务器，来实现分布式session。

从上面的叙述可知，我们使用session保存用户的身份信息，本质上是要做两件事情。第一是保存用户的身份信息，第二是验证用户的身份信息。如果利用其它手段实现这两个目标，那么就可以不用session，或者说我们使用的是广义上的session了。

具体实现的思路如下图，我们在服务端增加两段程序：

第一是创建令牌的程序，就是在用户初次访问服务器时，给它创建一个唯一的身份标识，并且使用cookie封装这个标识再发送给客户端。那么当客户端下次再访问服务器时，就会自动携带这个身份标识了，这和SESSIONID的道理是一样的，只是改由我们自己来实现了。另外，在返回令牌之前，我们需要将它存储起来，以便于后续的验证。而这个令牌是不能保存在服务器本地的，因为其他服务器无法访问它。因此，我们可以将其存储在服务器之外的一个地方，那么Redis便是一个理想的场所。

第二是验证令牌的程序，就是在用户再次访问服务器时，我们获取到了它之前的身份标识，那么我们就要验证一下这个标识是否存在了。验证的过程很简单，我们从Redis中尝试获取一下就可以知道结果。



何时需要分布式锁？

在分布式的环境下，当多个server并发修改同一个资源时，为了避免竞争就需要使用分布式锁。那为什么不能使用Java自带的锁呢？因为Java中的锁是面向多线程设计的，它只局限于当前的JRE环境。而多个server实际上是多进程，是不同的JRE环境，所以Java自带的锁机制在这个场景下是无效的。

如何实现分布式锁？

采用Redis实现分布式锁，就是在Redis里存一份代表锁的数据，通常用字符串即可。实现分布式锁的思路，以及优化的过程如下：

1. 加锁：

   第一版，这种方式的缺点是容易产生死锁，因为客户端有可能忘记解锁，或者解锁失败。

   ```
   setnx key value
   ```

   第二版，给锁增加了过期时间，避免出现死锁。但这两个命令不是原子的，第二步可能会失败，依然无法避免死锁问题。

   ```
   setnx key value expire key seconds
   ```

   第三版，通过“set...nx...”命令，将加锁、过期命令编排到一起，它们是原子操作了，可以避免死锁。

   ```
   set key value nx ex seconds 
   ```

2. 解锁：

   解锁就是删除代表锁的那份数据。

   ```
   del key
   ```

3. 问题：

   看起来已经很完美了，但实际上还有隐患，如下图。进程A在任务没有执行完毕时，锁已经到期被释放了。等进程A的任务执行结束后，它依然会尝试释放锁，因为它的代码逻辑就是任务结束后释放锁。但是，它的锁早已自动释放过了，它此时释放的可能是其他线程的锁。

![img](img/FA50B540AA89E335450F3E163D445451.png)

想要解决这个问题，我们需要解决两件事情：

1. 在加锁时就要给锁设置一个标识，进程要记住这个标识。当进程解锁的时候，要进行判断，是自己持有的锁才能释放，否则不能释放。可以为key赋一个随机值，来充当进程的标识。
2. 解锁时要先判断、再释放，这两步需要保证原子性，否则第二步失败的话，就会出现死锁。而获取和删除命令不是原子的，这就需要采用Lua脚本，通过Lua脚本将两个命令编排在一起，而整个Lua脚本的执行是原子的。

基于RedLock算法的分布式锁：

上述分布式锁的实现方案，是建立在单个主节点之上的。它的潜在问题如下图所示，如果进程A在主节点上加锁成功，然后这个主节点宕机了，则从节点将会晋升为主节点。若此时进程B在新的主节点上加锁成果，之后原主节点重启，成为了从节点，系统中将同时出现两把锁，这是违背锁的唯一性原则的。

![img](img/F150CA3203F1CD8A39BB004C990FCB1C.png)

总之，就是在单个主节点的架构上实现分布式锁，是无法保证高可用的。若要保证分布式锁的高可用，则可以采用多个节点的实现方案。这种方案有很多，而Redis的官方给出的建议是采用RedLock算法的实现方案。该算法基于多个Redis节点，它的基本逻辑如下：

- 这些节点相互独立，不存在主从复制或者集群协调机制；
- 加锁：以相同的KEY向N个实例加锁，只要超过一半节点成功，则认定加锁成功；
- 解锁：向所有的实例发送DEL命令，进行解锁；

RedLock算法的示意图如下，我们可以自己实现该算法，也可以直接使用Redisson框架。

![img](img/5B9C19EC2AFBB10977147566DF33BE03.png)



#### 分布式理论

##### 基本概念

###### CAP定理

CAP定理又称CAP原则，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），最多只能同时三个特性中的两个，三者不可兼得。

- Consistency (一致性)：

  “all nodes see the same data at the same time”，即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。

- Availability (可用性)：

  可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。

- Partition Tolerance (分区容错性)：

  即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。



###### 高并发

1\. 如何理解高并发？

高并发意味着大流量，需要运用技术手段抵抗流量的冲击，这些手段好比操作流量，能让流量更平稳地被系统所处理，带给用户更好的体验。我们常见的高并发场景有：淘宝的双11、春运时的抢票、微博大V的热点新闻等。除了这些典型事情，每秒几十万请求的秒杀系统、每天千万级的订单系统、每天亿级日活的信息流系统等，都可以归为高并发。很显然，上面谈到的高并发场景，并发量各不相同，那到底多大并发才算高并发呢？

1. 不能只看数字，要看具体的业务场景。不能说10W QPS(Query Per Second)的秒杀是高并发，而1W QPS的信息流就不是高并发。信息流场景涉及复杂的推荐模型和各种人工策略，它的业务逻辑可能比秒杀场景复杂10倍不止。因此，不在同一个维度，没有任何比较意义。
2. 业务都是从0到1做起来的，并发量和QPS只是参考指标，最重要的是：在业务量逐渐变成原来的10倍、100倍的过程中，你是否用到了高并发的处理方法去演进你的系统，从架构设计、编码实现、甚至产品方案等维度去预防和解决高并发引起的问题？而不是一味的升级硬件、加机器做水平扩展。

此外，各个高并发场景的业务特点完全不同：有读多写少的信息流场景、有读多写多的交易场景，那是否有通用的技术方案解决不同场景的高并发问题呢？另外，由于软硬件环境、技术栈、以及产品逻辑都没法做到完全一致，这些都会导致同样的业务场景，就算用相同的技术方案也会面临不同的问题

2\. 高并发系统设计的目标是什么？

2.1 宏观目标

高并发绝不意味着只追求高性能，从宏观角度看，高并发系统设计的目标有三个：高性能、高可用，以及高可扩展。

1. 高性能：性能体现了系统的并行处理能力，在有限的硬件投入下，提高性能意味着节省成本。同时，性能也反映了用户体验，响应时间分别是100毫秒和1秒，给用户的感受是完全不同的。
2. 高可用：表示系统可以正常服务的时间。另外，如果系统只能做到90%可用，也会大大拖累业务。
3. 高扩展：表示系统的扩展能力，流量高峰时能否在短时间内完成扩容，更平稳地承接峰值流量，比如双11活动、热点事件。

这3个目标是需要通盘考虑的，因为它们互相关联、甚至也会相互影响。比如说：考虑系统的扩展能力，会将服务设计成无状态的，这种集群设计保证了高扩展性，其实也间接提升了系统的性能和可用性。再比如说：为了保证可用性，通常会对服务接口进行超时设置，以防大量线程阻塞在慢请求上造成系统雪崩，那超时时间设置成多少合理呢？一般，我们会参考依赖服务的性能表现进行设置。

2.2 微观目标

再从微观角度来看，高性能、高可用和高扩展又有哪些具体的指标来衡量？为什么会选择这些指标呢？

2.2.1 性能指标

通过性能指标可以度量目前存在的性能问题，同时作为性能优化的评估依据。一般来说，会采用一段时间内的接口响应时间作为指标。

1. 平均响应时间：最常用，但是缺陷很明显，对于慢请求不敏感。比如1万次请求，其中9900次是1ms，100次是100ms，则平均响应时间为1.99ms，虽然平均耗时仅增加了0.99ms，但是1%请求的响应时间已经增加了100倍。

2. TP90、TP99等分位值：将响应时间按照从小到大排序，TP90表示排在第90(不同时间去重)分位的响应时间， 分位值越大，对慢请求越敏感。

   ![img](img/E4A27CD7006DDBB775A1A6D059F56C9D.png)

3. 吞吐量：和响应时间呈反比，比如响应时间是1ms，则吞吐量为每秒1000次。

通常，设定性能目标时会兼顾吞吐量和响应时间，比如这样表述：在每秒1万次请求下，AVG控制在50ms以下，TP99控制在100ms以下。对于高并发系统，AVG和TP分位值必须同时要考虑。另外，从用户体验角度来看，200毫秒被认为是第一个分界点，用户感觉不到延迟，1秒是第二个分界点，用户能感受到延迟，但是可以接受。因此，对于一个健康的高并发系统，TP99应该控制在200毫秒以内，TP999或者TP9999应该控制在1秒以内。

2.2.2 可用性指标

高可用性是指系统具有较高的无故障运行能力，可用性 = 平均故障时间 / 系统总运行时间，一般使用几个9来描述系统的可用性。

![img](img/4674A6558CBAD1F7AFE79A85D6BCCBA3.png)

对于高并发系统来说，最基本的要求是：保证3个9或者4个9。如果只能做到2个9，意味着有1%的故障时间，像一些大公司每年动辄千亿以上的GMV(商品交易总额Gross Merchandise Volume)或者收入，1%就是10亿级别的业务影响。

2.2.3 可扩展性指标

面对突发流量，不可能临时改造架构，最快的方式就是增加机器来线性提高系统的处理能力。

对于业务集群或者基础组件来说，扩展性 = 性能提升比例 / 机器增加比例，理想的扩展能力是：资源增加几倍，性能提升几倍。通常来说，扩展能力要维持在70%以上。

但是从高并发系统的整体架构角度来看，扩展的目标不仅仅是把服务设计成无状态就行了，因为当流量增加10倍，业务服务可以快速扩容10倍，但是数据库可能就成为了新的瓶颈。

像MySQL这种有状态的存储服务通常是扩展的技术难点，如果架构上没提前做好规划（垂直和水平拆分），就会涉及到大量数据的迁移。

因此，高扩展性需要考虑：服务集群、数据库、缓存和消息队列等中间件、负载均衡、带宽、依赖的第三方等，当并发达到某一个量级后，上述每个因素都可能成为扩展的瓶颈点。

3.1 通用的设计方法

通用的设计方法主要是从「纵向」和「横向」两个维度出发，俗称高并发处理的两板斧：纵向扩展和横向扩展。

3.1.1 纵向扩展（scale-up）

它的目标是提升单机的处理能力，方案又包括：

1. 提升单机的硬件性能：通过增加内存、CPU核数、存储容量、或者将磁盘升级成SSD等堆硬件的方式来提升。
2. 提升单机的软件性能：使用缓存减少IO次数，使用并发或者异步的方式增加吞吐量。

3.1.2 横向扩展（scale-out）

因为单机性能总会存在极限，所以最终还需要引入横向扩展，通过集群部署以进一步提高并发处理能力，又包括以下2个方向：

1. 做好分层架构：这是横向扩展的提前，因为高并发系统往往业务复杂，通过分层处理可以简化复杂问题，更容易做到横向扩展。

   ![img](img/0642E848F1056357569BEE416AC6D160.png)

   上面这种图是互联网最常见的分层架构，当然真实的高并发系统架构会在此基础上进一步完善。比如会做动静分离并引入CDN，反向代理层可以是LVS(Linux virtual server)+Nginx，Web层可以是统一的API网关，业务服务层可进一步按垂直业务做微服务化，存储层可以是各种异构数据库。

2. 各层进行水平扩展：无状态水平扩容，有状态做分片路由。业务集群通常能设计成无状态的，而数据库和缓存往往是有状态的，因此需要设计分区键做好存储分片，当然也可以通过主从同步、读写分离的方案提升读性能。

3.2.1 高性能的实践方案

1. 集群部署，通过负载均衡减轻单机压力。
2. 多级缓存，包括静态数据使用CDN、本地缓存、分布式缓存等，以及对缓存场景中的热点key、缓存穿透、缓存并发、数据一致性等问题的处理。
3. 分库分表和索引优化，以及借助搜索引擎解决复杂查询问题。
4. 考虑NoSQL数据库的使用，比如HBase、TiDB等，但是团队必须熟悉这些组件，且有较强的运维能力。
5. 异步化，将次要流程通过多线程、MQ、甚至延时任务进行异步处理。
6. 限流，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、Nginx接入层的限流、服务端的限流。
7. 对流量进行削峰填谷，通过MQ承接流量。
8. 并发处理，通过多线程将串行逻辑并行化。
9. 预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。
10. 缓存预热，通过异步任务提前预热数据到本地缓存或者分布式缓存中。
11. 减少IO次数，比如数据库和缓存的批量读写、RPC的批量接口支持、或者通过冗余数据的方式干掉RPC调用。
12. 减少IO时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存key的大小、压缩缓存value等。
13. 程序逻辑优化，比如将大概率阻断执行流程的判断逻辑前置、For循环的计算逻辑优化，或者采用更高效的算法。
14. 各种池化技术的使用和池大小的设置，包括HTTP请求池、线程池（考虑CPU密集型还是IO密集型设置核心参数）、数据库和Redis连接池等。
15. JVM优化，包括新生代和老年代的大小、GC算法的选择等，尽可能减少GC频率和耗时。
16. 锁选择，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突。

上述方案无外乎从计算和 IO 两个维度考虑所有可能的优化点，需要有配套的监控系统实时了解当前的性能表现，并支撑你进行性能瓶颈分析，然后再遵循二八原则，抓主要矛盾进行优化。

3.2.2 高可用的实践方案

1. 对等节点的故障转移，Nginx和服务治理框架均支持一个节点失败后访问另一个节点。
2. 非对等节点的故障转移，通过心跳检测并实施主备切换（比如redis的哨兵模式或者集群模式、MySQL的主从切换等）。
3. 接口层面的超时设置、重试策略和幂等设计。
4. 降级处理：保证核心服务，牺牲非核心服务，必要时进行熔断；或者核心链路出问题时，有备选链路。
5. 限流处理：对超过系统处理能力的请求直接拒绝或者返回错误码。
6. MQ场景的消息可靠性保证，包括producer端的重试机制、broker侧的持久化、consumer端的ack机制等。
7. 灰度发布，能支持按机器维度进行小流量部署，观察系统日志和业务指标，等运行平稳后再推全量。
8. 监控报警：全方位的监控体系，包括最基础的CPU、内存、磁盘、网络的监控，以及Web服务器、JVM、数据库、各类中间件的监控和业务指标的监控。
9. 灾备演练：类似当前的“混沌工程”，对系统进行一些破坏性手段，观察局部故障是否会引起可用性问题。

高可用的方案主要从冗余、取舍、系统运维3个方向考虑，同时需要有配套的值班机制和故障处理流程，当出现线上问题时，可及时跟进处理。

3.2.3 高扩展的实践方案

1. 合理的分层架构：比如上面谈到的互联网最常见的分层架构，另外还能进一步按照数据访问层、业务逻辑层对微服务做更细粒度的分层（但是需要评估性能，会存在网络多一跳的情况）。
2. 存储层的拆分：按照业务维度做垂直拆分、按照数据特征维度进一步做水平拆分（分库分表）。
3. 业务层的拆分：最常见的是按照业务维度拆（比如电商场景的商品服务、订单服务等），也可以按照核心接口和非核心接口拆，还可以按照请求源拆（比如To C和To B，APP和H5）。



###### 分布式存储

分布式存储是一个大的概念，其包含的种类繁多，除了传统意义上的分布式文件系统、分布式块存储和分布式对象存储外，还包括分布式数据库和分布式缓存等。下面我们探讨一下分布式文件系统等传统意义上的存储架构，实现这种存储架构主要有三种通用的形式，其它存储架构也基本上基于上述架构，并没有太大的变化。

中间控制节点架构（HDFS）

分布式存储最早是由谷歌提出的，其目的是通过廉价的服务器来提供使用与大规模，高并发场景下的Web访问问题。下图是谷歌分布式存储（HDFS）的简化的模型。在该系统的整个架构中将服务器分为两种类型，一种名为namenode，这种类型的节点负责管理管理数据（元数据），另外一种名为datanode，这种类型的服务器负责实际数据的管理。

![img](img/311677CDB344795DDEB4DB6FE099F1BE.png)

上图分布式存储中，如果客户端需要从某个文件读取数据，首先从namenode获取该文件的位置（具体在哪个datanode），然后从该位置获取具体的数据。在该架构中namenode通常是主备部署，而datanode则是由大量节点构成一个集群。由于元数据的访问频度和访问量相对数据都要小很多，因此namenode通常不会成为性能瓶颈，而datanode集群可以分散客户端的请求。因此，通过这种分布式存储架构可以通过横向扩展datanode的数量来增加承载能力，也即实现了动态横向扩展的能力。

完全无中心架构---计算模式（Ceph）

下图是Ceph存储系统的架构，在该架构中与HDFS不同的地方在于该架构中没有中心节点。客户端是通过一个设备映射关系计算出来其写入数据的位置，这样客户端可以直接与存储节点通信，从而避免中心节点的性能瓶颈。

![img](img/EEAE8A5145E2A0EAAB9234770C19DFCB.png)

在Ceph存储系统架构中核心组件有Mon服务、OSD服务和MDS服务等。对于块存储类型只需要Mon服务、OSD服务和客户端的软件即可。其中Mon服务用于维护存储系统的硬件逻辑关系，主要是服务器和硬盘等在线信息。Mon服务通过集群的方式保证其服务的可用性。OSD服务用于实现对磁盘的管理，实现真正的数据读写，通常一个磁盘对应一个OSD服务。 客户端访问存储的大致流程是，客户端在启动后会首先从Mon服务拉取存储资源布局信息，然后根据该布局信息和写入数据的名称等信息计算出期望数据的位置（包含具体的物理服务器信息和磁盘信息），然后该位置信息直接通信，读取或者写入数据。

完全无中心架构---一致性哈希（Swift）

与Ceph的通过计算方式获得数据位置的方式不同，另外一种方式是通过一致性哈希的方式获得数据位置。一致性哈希的方式就是将设备做成一个哈希环，然后根据数据名称计算出的哈希值映射到哈希环的某个位置，从而实现数据的定位。

![img](img/40DCD31CFC545AD5B2C537EAB66FD5CA.png)

上图是一致性哈希的基本原理，为了绘制简单，本文以一个服务器上的一个磁盘为例进行介绍。为了保证数据分配的均匀性及出现设备故障时数据迁移的均匀性，一致性哈希将磁盘划分为比较多的虚拟分区，每个虚拟分区是哈希环上的一个节点。整个环是一个从0到32位最大值的一个区间，并且首尾相接。当计算出数据（或者数据名称）的哈希值后，必然落到哈希环的某个区间，然后以顺时针，必然能够找到一个节点。那么，这个节点就是存储数据的位置。 Swift存储的整个数据定位算法就是基于上述一致性哈希实现的。在Swift对象存储中，通过账户名/容器名/对象名三个名称组成一个位置的标识，通过该唯一标识可以计算出一个整型数来。而在存储设备方面，Swift构建一个虚拟分区表，表的大小在创建集群是确定（通常为几十万），这个表其实就是一个数组。这样，根据上面计算的整数值，以及这个数组，通过一致性哈希算法就可以确定该整数在数组的位置。而数组中的每项内容是数据3个副本（也可以是其它副本数量）的设备信息（包含服务器和磁盘等信息）。也就是经过上述计算，可以确定一个数据存储的具体位置。这样，Swift就可以将请求重新定向到该设备进行处理。

![img](img/F5CE91A9435EDF1090A358B6344B14D2.png)

上述计算过程是在一个名为Proxy的服务中进行的，该服务可以集群化部署。因此可以分摊请求的负载，不会成为性能瓶颈。



###### 分布式事务

分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

要实现分布式事务，有如下几种常见的解决方案：

2PC

说到2PC就不得不聊数据库分布式事务中的 XA Transactions。

![img](img/9BCB810ED358F53D7754885D1CB1055B.png)

如上图，在XA协议中分为两阶段：

第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。

第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。

优点：

- 尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。

缺点：

- 单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。
- 同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。
- 数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。

总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发依然是其最大的弱点。

TCC

关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC事务机制相比于上面介绍的XA，解决了其几个缺点：

1. 解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。
2. 同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。
3. 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性。

对于TCC做出如下的解释：

- Try阶段：尝试执行,完成所有业务检查（一致性），预留必须业务资源（准隔离性）。
- Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。
- Cancel阶段：取消执行，释放Try阶段预留的业务资源 Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。

举个简单的例子如果你用100元买了一瓶水，在Try阶段你需要向你的钱包检查是否够100元并锁住这100元，水也是一样的。如果有一个失败，则进行cancel(释放这100元和这一瓶水)，如果cancel失败不论什么失败都进行重试cancel，所以需要保持幂等。如果都成功，则进行confirm,确认这100元扣，和这一瓶水被卖，如果confirm失败无论什么失败则重试(会依靠活动日志进行重试)。

对于TCC来说适合以下场景：

- 强隔离性，严格一致性要求的活动业务。
- 执行时间较短的业务。

本地消息表

本地消息表这个方案最初是ebay提出的，此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。

![img](img/71A4AA06EE7171E79BA7E04D10F80904.png)

对于本地消息队列来说核心是把大事务转变为小事务，还是举上面用100元去买一瓶水的例子：

1. 当你扣钱的时候，你需要在你扣钱的服务器上新增加一个本地消息表，你需要把你扣钱和写入减去水的库存到本地消息表放入同一个事务(依靠数据库本地事务保证一致性。
2. 这个时候有个定时任务去轮询这个本地事务表，把没有发送的消息，扔给商品库存服务器，叫他减去水的库存，到达商品服务器之后这个时候得先写入这个服务器的事务表，然后进行扣减，扣减成功后，更新事务表中的状态。
3. 商品服务器通过定时任务扫描消息表或者直接通知扣钱服务器，扣钱服务器本地消息表进行状态更新。
4. 针对一些异常情况，定时扫描未成功处理的消息，进行重新发送，在商品服务器接到消息之后，首先判断是否是重复的，如果已经接收，在判断是否执行，如果执行在马上又进行通知事务，如果未执行，需要重新执行需要由业务保证幂等，也就是不会多扣一瓶水。

本地消息队列是BASE理论，是最终一致模型，适用于对一致性要求不高的场景，实现这个模型时需要注意重试的幂等。

MQ事务

在RocketMQ中实现了分布式事务，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部，下面简单介绍一下MQ事务。

![img](img/360D14E23FDE7483BC35747BAFCDA839.png)

基本流程如下：

第一阶段Prepared消息，会拿到消息的地址。

第二阶段执行本地事务。

第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。消息接受者就能使用这个消息。

如果确认消息失败，在RocketMq Broker中提供了定时扫描没有更新状态的消息，如果有消息没有得到确认，会向消息发送者发送消息，来判断是否提交，在rocketmq中是以listener的形式给发送者，用来处理。

![img](img/8E1ADD01FCEF60CB4E1E6F06841EC91F.png)

如果消费超时，则需要一直重试，消息接收端需要保证幂等。如果消息消费失败，这个就需要人工进行处理，因为这个概率较低，如果为了这种小概率时间而设计这个复杂的流程反而得不偿失。

Saga事务

Saga是30年前一篇数据库伦理提到的一个概念。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。 Saga的组成：

每个Saga由一系列sub-transaction Ti 组成 每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果,这里的每个T，都是一个本地事务。 可以看到，和TCC相比，Saga没有“预留 try”动作，它的Ti就是直接提交到库。

Saga的执行顺序有两种：

- T1, T2, T3, ..., Tn
- T1, T2, ..., Tj, Cj,..., C2, C1，其中0 < j < n

Saga定义了两种恢复策略：

向后恢复，即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。 向前恢复，适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, ..., Tj(失败), Tj(重试),..., Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci。这里要注意的是，在saga模式中不能保证隔离性，因为没有锁住资源，其他事务依然可以覆盖或者影响当前事务。

还是拿100元买一瓶水的例子来说，这里定义：

- T1=扣100元，T2=给用户加一瓶水，T3=减库存一瓶水；
- C1=加100元，C2=给用户减一瓶水，C3=给库存加一瓶水；

我们一次进行T1，T2，T3如果发生问题，就执行发生问题的C操作的反向。 上面说到的隔离性的问题会出现在，如果执行到T3这个时候需要执行回滚，但是这个用户已经把水喝了(另外一个事务)，回滚的时候就会发现，无法给用户减一瓶水了。这就是事务之间没有隔离性的问题。

可以看见saga模式没有隔离性的影响还是较大，可以参照华为的解决方案:从业务层面入手加入一 Session 以及锁的机制来保证能够串行化操作资源。也可以在业务层面通过预先冻结资金的方式隔离这部分资源， 最后在业务操作的过程中可以通过及时读取当前状态的方式获取到最新的更新。

###### 一致性保证

国际开放标准组织Open Group定义了DTS（分布式事务处理模型），模型中包含4种角色：应用程序、事务管理器、资源管理器和通信资源管理器。事务管理器是统管全局的管理者，资源管理器和通信资源管理器是事务的参与者。

JEE（Java企业版）规范也包含此分布式事务处理模型的规范，并在所有AppServer中进行实现。在JEE规范中定义了TX协议和XA协议，TX协议定义应用程序与事务管理器之间的接口，XA协议则定义事务管理器与资源管理器之间的接口。在过去使用 AppServer如WebSphere、 WebLogic、JBoss等配置数据源时会看见类似XADatasource的数据源，这就是实现了分布式事务处理模型的关系型数据库的数据源。在企业级开发JEE中，关系型数据库、JMS服务扮演资源管理器的角色，而EJB容器扮演事务管理器的角色。

下面我们介绍两阶段提交协议、三阶段提交协议及阿里巴巴提出的 TCC，它们都是根据DTS这一思想演变而来的。

两阶段提交协议

两阶段提交协议把分布式事务分为两个阶段，一个是准备阶段，另一个是提交阶段。准备阶段和提交阶段都是由事务管理器发起的，为了接下来讲解方便，我们将事务管理器称为协调者，将资源管理器称为参与者。

两阶段提交协议的流程如下所述。

- 准备阶段：协调者向参与者发起指令，参与者评估自己的状态，如果参与者评估指令可以完成，则会写redo或者undo日志（Write-Ahead Log的一种），然后锁定资源，执行操作，但是并不提交。
- 提交阶段：如果每个参与者明确返回准备成功，也就是预留资源和执行操作成功，则协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；如果任何一个参与者明确返回准备失败，也就是预留资源或者执行操作失败，则协调者向参与者发起中止指令，参与者取消已经变更的事务，执行undo日志，释放锁定的资源。两阶段提交协议的成功场景如下图所示。

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645696166158/DD2810FD54913000BDA42162BBA99891)

我们看到两阶段提交协议在准备阶段锁定资源，这是一个重量级的操作，能保证强一致性，但是实现起来复杂、成本较高、不够灵活，更重要的是它有如下致命的问题。

- 阻塞：从上面的描述来看，对于任何一次指令都必须收到明确的响应，才会继续进行下一步，否则处于阻塞状态，占用的资源被一直锁定，不会被释放。
- 单点故障：如果协调者宕机，参与者没有协调者指挥，则会一直阻塞，尽管可以通过选举新的协调者替代原有协调者，但是如果协调者在发送一个提交指令后宕机，而提交指令仅仅被一个参与者接收，并且参与者接收后也宕机，则新上任的协调者无法处理这种情况。
- 脑裂：协调者发送提交指令，有的参与者接收到并执行了事务，有的参与者没有接收到事务就没有执行事务，多个参与者之间是不一致的。

上面的所有问题虽然很少发生，但都需要人工干预处理，没有自动化的解决方案，因此两阶段提交协议在正常情况下能保证系统的强一致性，但是在出现异常的情况下，当前处理的操作处于错误状态，需要管理员人工干预解决，因此可用性不够好，这也符合CAP协议的一致性和可用性不能兼得的原理。



三阶段提交协议

三阶段提交协议是两阶段提交协议的改进版本。它通过超时机制解决了阻塞的问题，并且把两个阶段增加为以下三个阶段。

- 询问阶段：协调者询问参与者是否可以完成指令，协调者只需要回答是或不是，而不需要做真正的操作，这个阶段超时会导致中止。
- 准备阶段：如果在询问阶段所有参与者都返回可以执行操作，则协调者向参与者发送预执行请求，然后参与者写redo和undo日志，执行操作但是不提交操作；如果在询问阶段任意参与者返回不能执行操作的结果，则协调者向参与者发送中止请求，这里的逻辑与两阶段提交协议的准备阶段是相似的。
- 提交阶段：如果每个参与者在准备阶段返回准备成功，也就是说预留资源和执行操作成功，则协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；如果任何参与者返回准备失败，也就是说预留资源或者执行操作失败，则协调者向参与者发起中止指令，参与者取消已经变更的事务，执行 undo 日志，释放锁定的资源，这里的逻辑与两阶段提交协议的提交阶段一致。

三阶段提交协议的成功场景示意图如下图所示：

![img](img/CA0B65BF2004537005DF9D857B03C80A.png)

三阶段提交协议与两阶段提交协议主要有以下两个不同点：

- 增加了一个询问阶段，询问阶段可以确保尽可能早地发现无法执行操作而需要中止的行为，但是它并不能发现所有这种行为，只会减少这种情况的发生。
- 在准备阶段以后，协调者和参与者执行的任务中都增加了超时，一旦超时，则协调者和参与者都会继续提交事务，默认为成功，这也是根据概率统计超时后默认为成功的正确性最大。

三阶段提交协议与两阶段提交协议相比，具有如上优点，但是一旦发生超时，系统仍然会发生不一致，只不过这种情况很少见，好处是至少不会阻塞和永远锁定资源。



TCC

签名讲解了两阶段提交协议和三阶段提交协议，实际上它们能解决常见的分布式事务的问题，但是遇到极端情况时，系统会产生阻塞或者不一致的问题，需要运营或者技术人员解决。两阶段及三阶段方案中都包含多个参与者、多个阶段实现一个事务，实现复杂，性能也是一个很大的问题，因此，在互联网的高并发系统中，鲜有使用两阶段提交和三阶段提交协议的场景。

后来有人提出了TCC协议，TCC协议将一个任务拆分成Try、Confirm、Cancel三个步骤，正常的流程会先执行Try，如果执行没有问题，则再执行Confirm，如果执行过程中出了问题，则执行操作的逆操作Cancel。从正常的流程上讲，这仍然是一个两阶段提交协议，但是在执行出现问题时有一定的自我修复能力，如果任何参与者出现了问题，则协调者通过执行操作的逆操作来Cancel之前的操作，达到最终的一致状态。

可以看出，从时序上来说，如果遇到极端情况，则TCC会有很多问题，例如，如果在取消时一些参与者收到指令，而另一些参与者没有收到指令，则整个系统仍然是不一致的。对于这种复杂的情况，系统首先会通过补偿的方式尝试自动修复，如果系统无法修复，则必须由人工参与解决。

从TCC的逻辑上看，可以说TCC是简化版的三阶段提交协议，解决了两阶段提交协议的阻塞问题，但是没有解决极端情况下会出现不一致和脑裂的问题。然而，TCC通过自动化补偿手段，将需要人工处理的不一致情况降到最少，也是一种非常有用的解决方案。某著名的互联网公司在内部的一些中间件上实现了TCC模式。

我们给出一个使用TCC的实际案例，在秒杀的场景中，用户发起下订单请求，应用层先查询库存，确认商品库存还有余量，则锁定库存，此时订单状态为待支付，然后指引用户去支付，由于某种原因用户支付失败或者支付超时，则系统会自动将锁定的库存解锁以供其他用户秒杀。

TCC协议的使用场景如下图所示：

![img](img/470E55DC6DD312AFAD8FBAF760EF5B20.png)

在大规模、高并发服务化系统中，一个功能被拆分成多个具有单一功能的子功能，一个流程会有多个系统的多个单一功能的服务组合实现，如果使用两阶段提交协议和三阶段提交协议，则确实能解决系统间的一致性问题。除了这两个协议的自身问题，其实现也比较复杂、成本比较高，最重要的是性能不好，相比来看，TCC协议更简单且更容易实现，但是TCC协议由于每个事务都需要执行Try，再执行Confirm，略显臃肿，因此，现实系统的底线是仅仅需要达到最终一致性，而不需要实现专业的、复杂的一致性协议。实现最终一致性有一些非常有效、简单的模式，下面就介绍这些模式及其应用场景。

查询模式

任何服务操作都需要提供一个查询接口，用来向外部输出操作执行的状态。服务操作的使用方可以通过查询接口得知服务操作执行的状态，然后根据不同的状态来做不同的处理操作。

为了能够实现查询，每个服务操作都需要有唯一的流水号标识，也可使用此次服务操作对应的资源ID来标识，例如：请求流水号、订单号等。首先，单笔查询操作是必须提供的，也鼓励使用单笔订单查询，这是因为每次调用需要占用的负载是可控的。批量查询则根据需要来提供，如果使用了批量查询，则需要有合理的分页机制，并且必须限制分页的大小，以及对批量查询的吞吐量有容量评估、熔断、隔离和限流等措施。

补偿模式

有了上面的查询模式，在任何情况下，我们都能得知具体的操作所处的状态，如果整个操作都处于不正常的状态，则我们需要修正操作中有问题的子操作，这可能需要重新执行未完成的子操作，后者取消已经完成的子操作，通过修复使整个分布式系统达到一致。为了让系统最终达到一致状态而做的努力都叫作补偿。

对于服务化系统中同步调用的操作，若业务操作发起方还没有收到业务操作执行方的明确返回或者调用超时，业务发起方需要及时地调用业务执行方来获得操作执行的状态，这里使用在前面学习的查询模式。在获得业务操作执行方的状态后，如果业务执行方已经完成预设工作，则业务发起方向业务的使用方返回成功；如果业务操作执行方的状态为失败或者未知，则会立即告诉业务使用方失败，也叫作快速失败策略，然后调用业务操作的逆向操作，保证操作不被执行或者回滚已经执行的操作，让业务使用方、业务操作发起方和业务操作执行方最终达到一致状态。

异步确保模式

异步确保模式是补偿模式的一个典型案例，经常应用到使用方对响应时间要求不太高的场景中，通常把这类操作从主流程中摘除，通过异步的方式进行处理，处理后把结果通过通知系统通知给使用方。这个方案的最大好处是能够对高并发流量进行消峰，例如：电商系统中的物流、配送，以及支付系统中的计费、入账等。

在实践中将要执行的异步操作封装后持久入库，然后通过定时捞取未完成的任务进行补偿操作来实现异步确保模式，只要定时系统足够健壮，则任何任务最终都会被成功执行。

异步确保模式如下图所示：

![img](img/D84A5EA6BA47E034D1245B594903A2F3.png)

定期校对模式

系统在没有达到一致之前，系统间的状态是不一致的，甚至是混乱的，需要通过补偿操作来达到最终一致性的目的，但是如何来发现需要补偿的操作呢？

在操作主流程中的系统间执行校对操作，可以在事后异步地批量校对操作的状态，如果发现不一致的操作，则进行补偿，补偿操作与补偿模式中的补偿操作是一致的。

另外，实现定期校对的一个关键就是分布式系统中需要有一个自始至终唯一的ID，生成全局唯一ID有以下两种方法：

- 持久型：使用数据库表自增字段或者Sequence生成，为了提高效率，每个应用节点可以缓存一个批次的ID，如果机器重启则可能会损失一部分ID，但是这并不会产生任何问题。
- 时间型：一般由机器号、业务号、时间、单节点内自增ID组成，由于时间一般精确到秒或者毫秒，因此不需要持久就能保证在分布式系统中全局唯一、粗略递增等。

可靠消息模式

在分布式系统中，对于主流程中优先级比较低的操作，大多采用异步的方式执行，也就是前面提到的异步确保模型，为了让异步操作的调用方和被调用方充分解耦，也由于专业的消息队列本身具有可伸缩、可分片、可持久等功能，我们通常通过消息队列实现异步化。对于消息队列，我们需要建立特殊的设施来保证可靠的消息发送及处理机的幂等性。

缓存一致性模式

在大规模、高并发系统中的一个常见的核心需求就是亿级的读需求，显然，关系型数据库并不是解决高并发读需求的最佳方案，互联网的经典做法就是使用缓存来抗住读流量。

- 如果性能要求不是非常高，则尽量使用分布式缓存，而不要使用本地缓存。
- 写缓存时数据一定要完整，如果缓存数据的一部分有效，另一部分无效，则宁可在需要时回源数据库，也不要把部分数据放入缓存中。
- 使用缓存牺牲了一致性，为了提高性能，数据库与缓存只需要保持弱一致性，而不需要保持强一致性，否则违背了使用缓存的初衷。
- 读的顺序是先读缓存，后读数据库，写的顺序要先写数据库，后写缓存。

###### 单点问题

无状态服务的单点问题

对于无状态的服务，单点问题的解决比较简单，因为服务是无状态的，所以服务节点很容易进行平行扩展。比如，在分布式系统中，为了降低各进程通信的网络结构的复杂度，我们会增加一个代理节点，专门做消息的转发，其他的业务进行直接和代理节点进行通信，类似一个星型的网络结构。

![img](img/11B2FC0CCD95BB21BEC4FBFA9F8CB180.png)

参考上面两个图，图中proxy是一个消息转发代理，业务进程中的消息都会经过该代理，这也是比较场景的一个架构。在上图中，只有一个proxy，如果该节点挂了，那么所有的业务进程之间都无法进行通信。由于proxy是无状态的服务，所以很容易想到第二个图中的解决方案，增加一个proxy节点，两个proxy节点是对等的。增加新节点后，业务进程需要与两个Proxy之间增加一个心跳的机制，业务进程在发送消息的时候根据proxy的状态，选择一个可用的proxy进行消息的传递。从负载均衡的角度来看，如果两个proxy都是存活状态的话，业务进程应当随机选择一个proxy。

那么该解决方案中会存在什么问题呢？主要存在的问题是消息的顺序性问题。一般来说，业务的消息都是发送、应答，再发送、再应答这样的顺序进行的，在业务中可以保证消息的顺序性。但是，在实际的应用中，会出现这样一个情况：在业务进程1中，有个业务需要给业务进程3发送消息A和消息B，根据业务的特性，消息A必须要在消息B之前到达。如果业务进程1在发送消息A的时候选择了proxy1，在发送消息B的时候选择了proxy2，那么在分布式环境中，我们并不能确保先发送的消息A一定就能比后发送的消息B先到达业务进程3。那么怎么解决这个问题？其实方案也比较简单，对于这类对消息顺序有要求的业务，我们可以指定对应的proxy进行发送，比如消息A和消息B都是使用proxy1进行发送，这样就可以保证消息A比消息B先到达业务进程3。

整体来说，对于无状态的服务的单点问题的解决方案还是比较简单的，只要增加对应的服务节点即可。

有状态服务的单点问题

相对无状态服务的单点问题，有状态服务的单点问题就复杂多了。如果在架构中，有个节点是单点的，并且该节点是有状态的服务，那么首先要考虑的是该节点是否可以去状态，如果可以，则优先选择去除状态的方案（比如说把状态存储到后端的可靠DB中，可能存在性能的损耗），然后就退化成了一个无状态服务的单点问题了，这就可以参考上一方案了。 但是，并不是所有的服务都是可以去状态的，比如说对于一些业务它只能在一个节点中进行处理，如果在不同的节点中处理的话可能会造成状态的不一致，这类型的业务是无法去除状态的。对于这种无法去除状态的单点的问题的解决方案也是有多种，但是越完善的方案实现起来就越复杂，不过整体的思路都是采用主备的方式。

![img](img/1C4C5279C90DDDD490C75ED8B04E47FC.png)

第一个方案就是就是增加一个备用节点，备用节点和业务进程也可以进行通信，但是所有的业务消息都发往Master节点进行处理。Master节点和Slave节点之间采用ping的方式进行通信。Slave节点会定时发送ping包给Master节点，Master节点收到后会响应一个Ack包。当Slave节点发现Master节点没有响应的时候，就会认为Master节点挂了，然后把自己升级为Master节点，并且通知业务进程把消息转发给自己。该方案看起来也是挺完美的，好像不存在什么问题，Slave升级为Master后所有的业务消息都会发给它。但是，如果在Master内部有一些自己的业务逻辑，比如说随机生成一些业务数据，并且定时存档。那么当Master和Slave之间的网络出现问题的时候，Slave会认为Master挂了，就会升级为Master，同样会执行Master的相应的业务逻辑，同样也会生成一些业务数据回写到DB。但是，其实Master是没有挂的，它同样也在运行对应的业务逻辑（即使业务进程的消息没有发给旧的Master了），这样就会出现两个Master进行写同一份数据了，造成数据的混乱。所以说，该方案并不是一个很好的方案。

那怎么解决可能会出现多个Master的问题？换个角度看，该问题其实就是怎么去裁决哪个节点是Master的问题。

方案一：引入第三方的服务进行裁决。

我们可以引入ZooKeeper，由ZooKeeper进行裁决。同样，我们启动两个主节点，“节点A”和节点B。它们启动之后向ZooKeeper去注册一个节点，假设节点A注册的节点为master001，节点B注册的节点为master002，注册完成后进行选举，编号小的节点为真正的主节点。那么，通过这种方式就完成了对两个Master进程的调度。

![img](img/EE08EFD476498683FC4869FA3682EE53.png)

方案二： 通过选举算法和租约的方式实现Master的选举。

对于方案一的缺点主要要多维护一套ZooKeeper的服务，如果原本业务上并没有部署该服务的话，要增加该服务的维护也是比较麻烦的事情。这个时候我们可以在业务进程中加入Master的选举方案。目前有比较成熟的选举算法，比如Paxos和Raft。然后再配合租约机制，就可以实现Master的选举，并且确保当前只有一个Master的方案。但是，这些选举算法理解起来并不是那么地容易，要实现一套完善的方案也是挺难的。所以不建议重复造轮子，业内有很多成熟的框架或者组件可以使用，比如微信的PhxPaxos。

![img](img/C828533DED54454DDA40C9CC8B43E601.png)

比如上图的方案中，三个节点其实都是对等的，通过选举算法确定一个Master。为了确保任何时候都只能存在一个Matster，需要加入租约的机制。一个节点成为Master后，Master和非Master节点都会进行计时，在超过租约时间后，三个节点后可以发起“我要成为Master”的请求，进行重新选举。由于三个节点都是对等的，任意一个都可以成为Master，也就是说租期过后，有可能会出现Master切换的情况，所以为了避免Master的频繁切换，Master节点需要比另外两个节点先发起自己要成为Master的请求（续租），告诉其他两个节点我要继续成为Master，然后另外两个节点收到请求后会进行应答，正常情况下另外两个节点会同意该请求。关键点就是，在租约过期之前，非Master节点不能发起“我要成为Master”的请求，这样就可以解决Master频繁切换的问题。

###### HTTP协议

Remote Procedure Call Protocol RPC

传输协议

- RPC，可以基于TCP协议，也可以基于HTTP协议。
- HTTP，基于HTTP协议。

传输效率

- RPC，使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率。
- HTTP，如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装一下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理。

性能消耗

- RPC，可以基于thrift实现高效的二进制传输。
- HTTP，大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能。

负载均衡

- RPC，基本都自带了负载均衡策略。
- HTTP，需要配置Nginx，HAProxy来实现。

服务治理

- RPC，能做到自动通知，不影响上游。
- HTTP，需要事先通知，修改Nginx/HAProxy配置。

总之，RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。

#### 例子

##### CRUD

Jedis中的方法名称和redis的命令名称几乎一样

开一个 quick start maven, parent 继承下文 spring cloud 的 easymall parent。增加依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-redis</artifactId>
    <version>1.4.7.RELEASE</version>
</dependency>
```

测试：

```java
package cn.edu.scnu.test;

import org.junit.Test;
import redis.clients.jedis.Jedis;

public class Test01 {
    @Test
    public void test01() {
        // 10s超时,默认2000ms(GPT)
        Jedis jedis = new Jedis("192.168.126.128", 6379, 10000);
        jedis.set("num1", "100");
        //setex(stringkey,int sec extime, stringvalue)
        System.out.println(jedis.get("num1"));
        System.out.println(jedis.decr("num1"));
        System.out.println(jedis.decrBy("num1", 10));
        /*Long leftTime = jedis.ttl(ticket);
            if (leftTime < 60 * 10L) 
                jedis.expire(ticket, (int) (leftTime + 60 * 5));*/
    }
}
```

```java
jedis.hset("user", "username", "aa");
jedis.hset("user", "psw", "123");
System.out.println(jedis.hget("user", "username"));
System.out.println(jedis.hget("user", "psw"));
```

```java
import redis.clients.jedis.BinaryClient;
jedis.flushDB();
jedis.lpush("list01", "10", "20", "30", "40");
// List<String>返回
System.out.println(jedis.lrange("list01", 0, -1));
jedis.rpush("list01", "200", "300");
System.out.println(jedis.lrange("list01", 0, -1));
jedis.linsert("list01", BinaryClient.LIST_POSITION.BEFORE, "200", "100");
jedis.linsert("list01", BinaryClient.LIST_POSITION.AFTER, "300", "400");
System.out.println(jedis.lrange("list01", 0, -1));
System.out.println(jedis.sort("list01"));// 临时排序输出
System.out.println(jedis.lrange("list01", 0, -1));
```

```java
jedis.sadd("favor", "sleeping", "gaming", "gambling");
// Set<String>
System.out.println(jedis.smembers("favor"));
System.out.println(jedis.scard("favor"));
jedis.srem("favor", "gaming");
System.out.println(jedis.smembers("favor"));
```

```java
import redis.clients.jedis.Tuple;
jedis.zadd("english", 90, "baicha");
jedis.zadd("english", 70, "guodong");
jedis.zadd("english", 95, "hefeng");
// Set<String>
System.out.println(jedis.zrange("english", 0, -1));
// Set<>
System.out.println(jedis.zrangeByScoreWithScores("english", 60, 100));
Set<Tuple> elements = jedis.zrevrangeWithScores("english", 0, -1);
//现在是字符串了
for (Tuple tuple : elements) {
    System.out.println(tuple.getElement() + " : " + tuple.getScore());
}
```

##### 序列化

逻辑:

1）判断缓存是否存在某个数据库数据

2）如果存在,读取出来.直接封装返回,不再调用持久层

3）如果不存在,调用持久层获取数据,并存储一份在redis供后续使用。

4）存储数据时,key值的设计规则:根据业务意义设计key

例如,某个商品的key="product\_"+productId;

某个用户的key="user\_"+userId;

将一个对象转化为 String 放进 redis，使用序列化，参考：

```java
package cn.edu.scnu.test;

import org.junit.Test;
import com.fasterxml.jackson.databind.ObjectMapper;

class TmpObject {
    public int v, i;
    public String name;

    // 反序列化必用
    public TmpObject() {
    }

    public TmpObject(int v, int i, String name) {
        this.v = v;
        this.i = i;
        this.name = name;
    }
}

public class Test02 {
    @Test
    public void test02() {
        ObjectMapper mapper = new ObjectMapper();
        TmpObject obj = new TmpObject(1, 2, "pwp");
        try {
            // {"v":1,"i":2,"name":"pwp"}
            String res = mapper.writeValueAsString(obj);
            System.out.println(res);
            TmpObject obj2 = mapper.readValue(res, TmpObject.class);
            System.out.println(obj2.name);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

列表：(GPT)

```java
ObjectMapper objectMapper = new ObjectMapper();
List<TmpObject> tmpObjectList = new ArrayList<>();
tmpObjectList.add(new TmpObject(1, 2, "pwp"));
tmpObjectList.add(new TmpObject(3, 4, "test"));

// Convert Java object list to JSON string
String jsonString = objectMapper.writeValueAsString(tmpObjectList);
System.out.println("JSON string: " + jsonString);

// Convert JSON string back to Java object list
List<TmpObject> tmpObjectList2 = objectMapper.readValue(jsonString, new TypeReference<List<TmpObject>>() {});
for (TmpObject tmpObject : tmpObjectList2) {
    System.out.println("Java object: " + tmpObject.v + ", " + tmpObject.i + ", " + tmpObject.name);
}
```

##### 分片

单个redis的内存容量上限.很容易达到瓶颈,即使配置数据时使用超时逻辑，也会因为单机down掉导致系统无法登录。

可以利用redis的分布式集群;

分布式技术引入项目之后.要考虑一个问题.数据如何划分

在分布式结构中,如何将数据划分给不同的节点.进行分布式处理的过程—也就是数据分片的计算过程

下面引入一个分布式简单算法完成

当前引入的算法:hash取余算法(利用hashCode完成)

即：先取 `String.hashCode()`，再取正，即与 `Integer.MAX_VALUE` 按位与，然后取模，保证结果必然为正的。

```java
public void test06() {
    // 模拟海量数据生成 key=value
    Jedis jedis1 = new Jedis("192.168.243.133", 6379);
    Jedis jedis2 = new Jedis("192.168.243.133", 6380);
    Jedis jedis3 = new Jedis("192.168.243.133", 6381);
    for (int i = 0; i < 10000; i++) {
        String key = UUID.randomUUID().toString();
        String value = "value_" + i;
        // 根据计算划分数据逻辑代码调用不同的jedis
        // 将数据存储在不同的redis服务端,定义的计算逻辑
        // 需要在存取,判断存在等方法中完全一致;
        // 利用hash取余的公式,每一个key都能得到0,1,2
        Integer result = (key.hashCode() & Integer.MAX_VALUE) % 3;
        if (result == 0) {
            jedis1.set(key, value);
        }
        if (result == 1) {
            jedis2.set(key, value);
        }
        if (result == 2) {
            jedis3.set(key, value);
        }
    }
}
```

> 逐步解析上述过程：
>
> ```java
> Integer hashResult = "4900e409-4873-4c25-8f37-11d6a3d33e64".hashCode();
> System.out.println("hashResult-bin:");
> System.out.println(Integer.toBinaryString(hashResult));
> System.out.println(Integer.toBinaryString(Integer.MAX_VALUE));
> Integer result = hashResult & Integer.MAX_VALUE;		
> System.out.println(Integer.toBinaryString(result));
> System.out.println(result);
> ```

jedis实现底层的hash一致性算法,利用一个对象收集多个节点信息,通过底层hash一致性算法封装,可以跟jedis对象调用方法一样.实际上已经做了hash一致性计算。

我们只要获取一个封装了算法的对象ShardedJedis分片对象即可;

hash一致性算法优点远远大于hash取余算法

按哈希取一个插入：

```java
@Test
public void test08() {
    // 收集所有节点信息
    List<JedisShardInfo> infoList = new ArrayList<JedisShardInfo>();
    // 将3个节点信息.add到infoList总
    infoList.add(new JedisShardInfo("192.168.243.133", 6379));
    infoList.add(new JedisShardInfo("192.168.243.133", 6380));
    infoList.add(new JedisShardInfo("192.168.243.133", 6381));
    ShardedJedis sJedis = new ShardedJedis(infoList);
    sJedis.set("name", "白茶");
    System.out.println(sJedis.get("name"));
}
```

分片链接池：

```java
@Test
public void test09() {
    // 收集节点信息
    List<JedisShardInfo> infoList = new ArrayList<JedisShardInfo>();
    // 将3个节点信息.add到infoList总
    infoList.add(new JedisShardInfo("10.9.100.26", 6379));
    infoList.add(new JedisShardInfo("10.9.100.26", 6380));
    infoList.add(new JedisShardInfo("10.9.100.26", 6381));
    // 创建一个连接池的配置对象,定义最大连接数
    // 最小空闲,最大空闲,最大等待时长
    GenericObjectPoolConfig config = new GenericObjectPoolConfig();
    config.setMaxTotal(200);
    config.setMaxIdle(8);
    config.setMinIdle(2);
    // 配置对象.收集对象创建连接池
    ShardedJedisPool pool = new ShardedJedisPool(config, infoList);
    // 每次操作redis集群时,从pool来获取资源
    ShardedJedis sJedis = pool.getResource();
    // sJedis.set("location", "华南师范大学南海校区");
    System.out.println(sJedis.get("location"));
    pool.returnResource(sJedis);
}
```

Jedis客户端生成连接池，ShardedJedis分片对象通过hash一致性算法进行数据操作

##### 哨兵集群

```java
package cn.edu.scnu.test;

import java.util.HashSet;
import java.util.Set;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import redis.clients.jedis.HostAndPort;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisSentinelPool;

public class Test {
    @org.junit.Test
    public void test10() {
        Set<String> sentinelSet = new HashSet<>();
        for (int port = 26379; port <= 26381; ++port) {
            sentinelSet.add(new HostAndPort("192.168.126.128", port).toString());
        }
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(200);
        JedisSentinelPool pool = new JedisSentinelPool("mymaster", sentinelSet, config);
        Jedis jedis = pool.getResource();
        System.out.println("正在服役的主节点:" + pool.getCurrentHostMaster());
        //查询redis,获取key为name的数据
        System.out.println("name: " + jedis.get("name"));
        pool.close();
    }
}
```

##### cluster集群

假设已经部署好了一个集群，集群的某个端口号为 8005：

```java
package cn.edu.scnu.test;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import redis.clients.jedis.HostAndPort;
import redis.clients.jedis.JedisCluster;

public class Test2 {
    @org.junit.Test
    public void test02() {
        Set<HostAndPort> clusterSet = new HashSet<>();
        clusterSet.add(new HostAndPort("192.168.126.128", 8005));
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(200);
        JedisCluster cluster = new JedisCluster(clusterSet, config);
        cluster.set("gender", "male");
        System.out.println(cluster.get("gender"));
        try {
            cluster.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

##### cluster集成

新建项目，导依赖，设配置项如：(跟 spring cloud 综合例子一起用)

```properties
server.port=8095
#redis config
spring.redis.cluster.nodes=192.168.126.128:8000,192.168.126.128:8001,192.168.126.128:8002
spring.redis.cluster.maxTotal=200
spring.redis.cluster.maxIdle=8
spring.redis.cluster.minIdle=2
spring.application.name=redisservice
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
```

写一个 config 类：

```java
package cn.edu.scnu.config;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import redis.clients.jedis.HostAndPort;
import redis.clients.jedis.JedisCluster;

@Configuration
@ConfigurationProperties(prefix = "spring.redis.cluster")
public class RedisClusterConfig {
    private List<String> nodes;
    private Integer maxTotal;
    private Integer maxIdle;
    private Integer minIdle;

    @Bean
    public JedisCluster initJedisCluster() {
        Set<HostAndPort> set = new HashSet<>();
        for (String node : nodes) {
            String host = node.split(":")[0];
            Integer port = Integer.parseInt(node.split(":")[1]);
            set.add(new HostAndPort(host, port));
        }
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(maxTotal);
        config.setMaxIdle(maxIdle);
        config.setMinIdle(minIdle);
        return new JedisCluster(set, config);
    }
    //getter &&setter
}
```

偷懒将启动器类和控制器类合并：

```java
package cn.edu.scnu;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import redis.clients.jedis.JedisCluster;

@SpringBootApplication
@RestController
public class StarterRedis {
    @Autowired
    private JedisCluster cluster;

    public static void main(String[] args) {
        SpringApplication.run(StarterRedis.class, args);
    }

    @RequestMapping("cluster")
    public String setAndGet(String key, String value) {
        cluster.set(key, value);
        return cluster.get(key);
    }
}
```

测试：`http://localhost:8095/cluster?key=test&value=abc`

高可用测试：kill/shutdown掉存储`test`的主节点，刷新页面，发现报错然后继续刷新看到能刷出来。可以反复测试，对3主3从最多kill三个，还能继续工作。

![image-20230502163237374](img/image-20230502163237374.png)

![image-20230502163253809](img/image-20230502163253809.png)

### Spring Security

#### 概念

Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。Spring Security的底层主要是 基于 Spring AOP 和 Servlet 过滤器 来实现安全控制，它提供了全面的安全解决方案，同时授权粒度可以在 Web请求级和方法调用级 来处理身份确认和授权。
Spring Security是Spring家族针对项目的安全管理提供了安全框架，它是一个基于Spring生态圈的，用于提供安全访问控制的框架。
Spring Security的安全管理有两个重要概念，分别是Authentication（认证）和Authorization（授权）

Java Web 应用中安全框架使用率较高的莫过于 Spring Security 与 Apache Shiro。
Spring Security 是 Spring家族中的一个安全管理框架。相比Shiro框架，它提供了更丰富的功能，社区资源也比Shiro丰富。
一般来说中大型的项目都是使用SpringSecurity来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。

Spring Security作为安全管理的框架，一直以来都因为重量级，配置繁琐,门槛高困扰着我们的开发者，让很多的初学者望而却步。但是随着Spring Boot的出世和普及，这些问题都得到了解决。
Spring Security 是 Spring Boot 底层安全模块默认的技术选型，可以实现强大的 web 安全控制，我们仅需要引入 spring-boot-starter-security 依赖，进行少量配置，即可实现强大的安全管理

一般Web应用的需要进行认证和授权。
认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户
授权：经过认证后判断当前用户是否有权限进行某个操作
而认证和授权也是SpringSecurity作为安全框架的核心功能



#### 项目例子

##### 初始页面

创建项目。pom 如下：

```xml
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>3.8.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.22</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.9.RELEASE</version>
</parent>
```

在 `src/main/resources/templates/detail` 放 `common,vip` 两个文件夹及其 `1.html, 2.html`，写一个支持动态链接的请求：

```java
package com.vw.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@Controller
public class FilmController {
    @GetMapping("/detail/{type}/{path}")
    public String toDetail(@PathVariable("type") String type, @PathVariable("path") String path) {
        return "detail/" + type + "/" + path;
    }
    
    @RequestMapping("/index")
    public String toIndex() {
        return "index";
    }
    
    @RequestMapping("/")
    public String toIndex2() {
        return "index";
    }
}
```

其中 `getmapping` 是弱化版 `requetmapping`，只能处理 `get` 不能处理 `post`。

> 准备对应的文件：
>
> `templates/index.html`
>
> ```html
> <!DOCTYPE html>
> <html xmlns="http://www.w3.org/1999/xhtml"
> 	xmlns:th="http://www.thymeleaf.org">
> <head>
> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
> 
> <title>影视直播厅</title>
> </head>
> <body>
> 	<h1 align="center">欢迎进入电影网站首页</h1>
> 	<hr />
> 	<h3>普通电影</h3>
> 	<ul>
> 		<li><a th:href="@{/detail/common/1}">飞驰人生</a></li>
> 		<li><a th:href="@{/detail/common/2}">夏洛特烦恼</a></li>
> 	</ul>
> 
> 	<h3>VIP专享</h3>
> 	<ul>
> 		<li><a th:href="@{/detail/vip/1}">速度与激情</a></li>
> 		<li><a th:href="@{/detail/vip/2}">猩球崛起</a></li>
> 	</ul>
> </body>
> </html>
> ```
>
> common 1.html
>
> ```html
> <!DOCTYPE html>
> <html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
> <head>
> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
> 
> <title>影片详情</title>
> </head>
> <body>
> 	<a th:href="@{/}">返回</a>
> 	<h1>飞驰人生</h1>
> 	<p style="width: 550px">简介：曾经在赛车界叱咤风云、如今却只能经营炒饭大排档的赛车手张驰（沈腾饰）决定重返车坛挑战年轻一代的天才。
> 		然而没钱没车没队友，甚至驾照都得重新考，这场笑料百出不断被打脸的复出之路，还有更多哭笑不得的窘境在等待着这位过气车神……
> 	</p>
> </body>
> </html>
> ```
>
> common 2.html
>
> ```html
> <!DOCTYPE html>
> <html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
> <head>
> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
> <title>影片详情</title>
> </head>
> <body>
> 	<a th:href="@{/}">返回</a>
> 	<h1>夏洛特烦恼</h1>
> 	<p style="width: 550px">简介：《夏洛特烦恼》是开心麻花2012年首度推出的话剧，由闫非和彭大魔联合编剧、执导。
> 		2013、2014、2015年仍在上演。该作讲述了一个普通人在穿越重回到高中校园并实现了种种梦想的不可思议的经历……</p>
> </body>
> </html>
> ```
>
> vip 1.html
>
> ```html
> <!DOCTYPE html>
> <html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
> <head>
> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
> <title>影片详情</title>
> </head>
> <body>
> 	<a th:href="@{/}">返回</a>
> 	<h1>速度与激情</h1>
> 	<p style="width: 550px">简介：《速度与激情》是罗伯·科恩等执导，于2001年至2017年范·迪塞尔、保罗·沃克（已故）、
> 		乔丹娜·布鲁斯特、米歇尔·罗德里格兹等主演的赛车题材的动作犯罪类电影，截至2018年，一共拍了八部。之后两部续集正式定档，
> 		《速度与激情9》和《速度与激情10》分别于2020年4月10日和2021年4月2日上映……</p>
> </body>
> </html>
> ```
>
> vip 2.html
>
> ```html
> <!DOCTYPE html>
> <html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
> <head>
> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
> <title>影片详情</title>
> </head>
> <body>
> 	<a th:href="@{/}">返回</a>
> 	<h1>猩球崛起</h1>
> 	<p style="width: 550px">简介：《猩球崛起》是科幻片《人猿星球》的前传，由鲁伯特·瓦耶特执导，詹姆斯·弗兰科，汤姆·费尔顿，
> 		芙蕾达·平托，布莱恩·考克斯等主演。剧情主要讲述人猿进化为高级智慧生物、进而攻占地球之前的种种际遇，主题是带有警世性质的——人类疯狂的野心所产生的恶果。
> 		影片获得了第39届安妮奖最佳真人电影角色动画奖等奖项，同时获得了奥斯卡最佳特效奖提名，但很遗憾，并没有获奖……</p>
> </body>
> </html>
> ```

随便写一个启动类：

```java
package com.vw;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Starter {
    public static void main(String[] args) {
        SpringApplication.run(Starter.class, args);
    }
}
```

就能跑了。开进去就是 index，即默认位于 `src/main/resoureces/templates` 目录。然后根据 href 能访问到这几个子页面。controller 提供了服务。



##### 访问密码

开依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

那么启动时后台会输出一个密码。访问网站时要以 `user` 为用户名登录。

这种默认安全管理方式存在诸多问题，例如：只有唯一的默认登录用户user、密码随机生成且过于暴露、登录页面及错误提示页面不是我们想要的等 

使用Spring Boot与Spring MVC进行Web开发时，如果项目引入spring-boot-starter-security依赖启动器，MVC Security安全管理功能就会自动生效，其默认的安全配置是在SecurityAutoConfiguration和UserDetailsServiceAutoConfiguration中实现的。其中，SecurityAutoConfiguration会导入SpringBootWebSecurityConfiguration并自动化配置，用于启动Web安全管理。UserDetailsServiceAutoConfiguration则用于配置用户身份信息。

要完全关闭Security提供的Web应用默认安全配置，可以自定义WebSecurityConfigurerAdapter类型的Bean组件以及自定义UserDetailsService、AuthenticationProvider或AuthenticationManager类型的Bean组件。

另外，可以通过自定义WebSecurityConfigurerAdapter类型的Bean组件来覆盖默认访问规则。

WebSecurityConfigurerAdapter类的主要方法及说明：

![image-20221208112051997](img/image-20221208112051997.png)



#### 用户认证

##### 内存身份认证

内存身份认证是最简单的身份认证方式，主要用于Security安全认证体验和测试。自定义内存身份认证时，只需要重写configure(AuthenticationManagerBuilder auth)方法中定义测试用户即可。

创建配置类：

```java
package com.vw.config;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
@EnableWebSecurity  // 开启MVC security安全支持
public class SecurityConfig extends WebSecurityConfigurerAdapter {

}

```



@EnableWebSecurity注解是一个组合注解，效果等同于@Configuration注解、@Import({WebSecurityConfiguration.class, SpringWebMvcImportSelector.class})注解和@EnableGlobalAuthentication注解的组合用法。



##### 账号密码用户组

在上面的类添加方法：

```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    //  密码需要设置编码器
    BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
    // 1、使用内存用户信息，作为测试使用
    auth.inMemoryAuthentication().passwordEncoder(encoder)
        .withUser("shitou").password(encoder.encode("123456")).roles("common")
        .and()
        .withUser("李四").password(encoder.encode("123456")).roles("vip");
}

```

上面重写了configure方法，并在该方法中使用内存身份认证自定义了认证用户信息，设置了两个用户，包括用户名、密码和角色的设置。

1）	从 Spring5.0 开始，密码必须要加密，必须设置密码编码器用于保护密码。
2）	Spring Security提供多种密码编码器。
3）	自定义用户认证时，可以定义用户角色roles，也可以定义用户权限authorities。在通行赋值时，权限通常是在角色值的基础上添加”ROLE_”前缀。例如authorities(“ROLE_common”)和roles(“common”)是等效的。
4）	自定义用户认证时，可以为某个用户一次指定多个角色和权限。

测试发现可以登陆。



##### JDBC身份认证

导入输入库如下：

```sql
# 选择使用数据库
DROP database IF EXISTS `springbootdata`;
create database `springbootdata`;
USE springbootdata;
# 创建表t_customer并插入相关数据
DROP TABLE IF EXISTS `t_customer`;
CREATE TABLE `t_customer` (
    `id` int(20) NOT NULL AUTO_INCREMENT,
    `username` varchar(200) DEFAULT NULL,
    `password` varchar(200) DEFAULT NULL,
    `valid` tinyint(1) NOT NULL DEFAULT '1',
    PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
INSERT INTO `t_customer` VALUES ('1', 'shitou', '$2a$10$5ooQI8dir8jv0/gCa1Six.GpzAdIPf6pMqdminZ/3ijYzivCyPlfK', '1');
INSERT INTO `t_customer` VALUES ('2', '李四', '$2a$10$5ooQI8dir8jv0/gCa1Six.GpzAdIPf6pMqdminZ/3ijYzivCyPlfK', '1');
# 创建表t_authority并插入相关数据
DROP TABLE IF EXISTS `t_authority`;
CREATE TABLE `t_authority` (
    `id` int(20) NOT NULL AUTO_INCREMENT,
    `authority` varchar(20) DEFAULT NULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

INSERT INTO `t_authority` VALUES ('1', 'ROLE_common');
INSERT INTO `t_authority` VALUES ('2', 'ROLE_vip');
# 创建表t_customer_authority并插入相关数据
DROP TABLE IF EXISTS `t_customer_authority`;
CREATE TABLE `t_customer_authority` (
    `id` int(20) NOT NULL AUTO_INCREMENT,
    `customer_id` int(20) DEFAULT NULL,
    `authority_id` int(20) DEFAULT NULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
INSERT INTO `t_customer_authority` VALUES ('1', '1', '1');
INSERT INTO `t_customer_authority` VALUES ('2', '2', '2');

# 记住我功能中创建持久化Token存储的数据表
USE springbootdata;
DROP TABLE IF EXISTS `persistent_logins`;
create table persistent_logins 
(username varchar(64) not null,
 series varchar(64) primary key,
 token varchar(64) not null,
 last_used timestamp not null);
```

其中的`t_authority`表权限authority值必须带有`ROLE_`前缀。而且默认的用户角色值则是对应权限值去掉`ROLE_`前缀

来点数据库依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```

写配置文件：

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/springbootdata?serverTimezone=UTC&useSSL=false
spring.datasource.username=root
spring.datasource.password=12345678
```

修改配置类：

```java
//import javax.sql.DataSource;
@Autowired
private DataSource dataSource;
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    //  密码需要设置编码器
    BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
    // 使用JDBC进行身份认证
    String userSQL ="select username,password,valid from t_customer " +
        "where username = ?";
    String authoritySQL="select c.username,a.authority from t_customer c,t_authority a,"+"t_customer_authority ca where ca.customer_id=c.id " +
        "and ca.authority_id=a.id and c.username =?";
    auth.jdbcAuthentication().passwordEncoder(encoder).dataSource(dataSource)
        .usersByUsernameQuery(userSQL)
        .authoritiesByUsernameQuery(authoritySQL);
}
```



##### UserDetailsService

对于浏览大的项目来说，频繁的使用JDBC进行数据查询验证不仅麻烦，而且会降低网站的响应速度，对于一个完善的项目来说，如果某些业务已经实现了用户信息查询，就没必要使用JDBC进行身份验证了。
下面假设当前项目中已经有用户信息查询的业务方法，这里，在已有的用户信息服务的基础上选择使用UserDetailsService进行自定义用户身份验证。

安装 redis，并搞依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

JPA 是Spring 在ORM框架、JPA规范的基础上整合的一套JPA框架

添加配置：

```properties
spring.redis.host=127.0.0.1
spring.redis.port=6379
spring.redis.password=
```

搞两个 POJO 类 `Customer,Authority`，开头为：

```java
package com.vw.domain;
import javax.persistence.*;
@Entity(name = "t_customer")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
```

创建配置类：

```java
package com.vw.config;
import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
import java.time.Duration;
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<Object, Object> template = new RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        // 使用JSON格式序列化对象，对缓存数据key和value进行转换
        Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class);
        // 解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jacksonSeial.setObjectMapper(om);
        // 设置RedisTemplate模板API的序列化方式为JSON
        template.setDefaultSerializer(jacksonSeial);
        return template;
    }

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
        // 分别创建String和JSON格式序列化对象，对缓存数据key和value进行转换
        RedisSerializer<String> strSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class);
        // 解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jacksonSeial.setObjectMapper(om);
        // 定制缓存数据序列化方式及时效
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofDays(1))   // 设置缓存有效期为1天
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(strSerializer))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jacksonSeial))
                .disableCachingNullValues();   // 对空数据不进行缓存
        RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(config).build();
        return cacheManager;
    }
}
```

> 报错导包的话，改一下 parent 版本，如：(或2.7.6)
>
> ```xml
> <parent>
>     <groupId>org.springframework.boot</groupId>
>     <artifactId>spring-boot-starter-parent</artifactId>
>     <version>2.6.7</version>
> </parent>
> ```



创建持久层接口：

```java
package com.vw.repository;
import com.vw.domain.Customer;
import org.springframework.data.jpa.repository.JpaRepository;
public interface CustomerRepository extends JpaRepository<Customer,Integer> {
    Customer findByUsername(String username);
}
```

```java
package com.vw.repository;
import com.vw.domain.Authority;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import java.util.List;
public interface AuthorityRepository extends JpaRepository<Authority,Integer> {
    @Query(value = "select a.* from t_customer c,t_authority a,t_customer_authority ca where ca.customer_id=c.id and ca.authority_id=a.id and c.username =?",nativeQuery = true)
    public List<Authority> findAuthoritiesByUsername(String username);
}
```

创建一个CustomerService业务处理类，用来结合Redis缓存定义了通过用户名username获取用户信息及权限信息的方法。服务层：

```java
package com.vw.service;
import com.vw.domain.Authority;
import com.vw.domain.Customer;
import com.vw.repository.AuthorityRepository;
import com.vw.repository.CustomerRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.List;
@Service
public class CustomerService {
    @Autowired
    private CustomerRepository customerRepository;
    @Autowired
    private AuthorityRepository authorityRepository;
    @Autowired
    private RedisTemplate redisTemplate;
    // 业务控制：使用唯一用户名查询用户信息
    public Customer getCustomer(String username){
        Customer customer=null;
        Object o = redisTemplate.opsForValue().get("customer_"+username);
        if(o!=null){
            customer=(Customer)o;
        }else {
            customer = customerRepository.findByUsername(username);
            if(customer!=null){
                redisTemplate.opsForValue().set("customer_"+username,customer);
            }
        }
        return customer;
    }
    // 业务控制：使用唯一用户名查询用户权限
    public List<Authority> getCustomerAuthority(String username){
        List<Authority> authorities=null;
        Object o = redisTemplate.opsForValue().get("authorities_"+username);
        if(o!=null){
            authorities=(List<Authority>)o;
        }else {
            authorities=authorityRepository.findAuthoritiesByUsername(username);
            if(authorities.size()>0){
                redisTemplate.opsForValue().set("authorities_"+username,authorities);
            }
        }
        return authorities;
    }
}
```

UserDetailsService是Security提供的进行认证用户信息封装的接口，该接口提供的loadUserByUsername(String s)方法用于通过用户名加载用户信息。使用UserDetailsService进行身份认证的时，自定义一个UserDetailsService接口的实现类，通过loadUserByUsername(String s)方法调用用户业务处理类中已有的方法进行用户详情封装，返回一个UserDetails封装类，来供Security认证使用。
下面自定义一个接口实现类UserDetailsServiceImpl，进行用户认证信息UserDetailsService封装，重写了UserDetailsService接口的loadUserByUsername(String s)方法，在该方法中，使用CustomerService业务处理类获取用户的用户信息和权限信息，并通过UserDetails进行认证用户信息封装。

持久层实现类：

```java
package com.vw.service;
import com.vw.domain.Authority;
import com.vw.domain.Customer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.stream.Collectors;
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
@Autowired
private CustomerService customerService;
@Override
public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        // 通过业务方法获取用户及权限信息
    Customer customer = customerService.getCustomer(s);
    List<Authority> authorities = customerService.getCustomerAuthority(s);
        // 对用户权限进行封装
        List<SimpleGrantedAuthority> list = authorities.stream().map(authority -> new SimpleGrantedAuthority(authority.getAuthority())).collect(Collectors.toList());
        // 返回封装的UserDetails用户详情类
    if(customer!=null){
    	UserDetails userDetails= new User(customer.getUsername(),customer.getPassword(),list);
      	return userDetails;
    } else {
            // 如果查询的用户不存在（用户名不存在），必须抛出此异常
            throw new UsernameNotFoundException("当前用户不存在！");
    }
}
}
```

需要注意的是，CustomerService业务处理类获取的User实体类时，必须对当前用户进行非空判断，这里使用throw进行异常处理。如果查询的用户为空，throw会抛出UsernameNotFoundException的异常。如果没有使用异常处理，Security将无法识别，导致程序整体报错。

接下来在SecurityCongfig类的configure(AuthenticationManagerBuilder auth)方法中使用UserDetailService身份认证的方式进行自定义身份认证。

```java
package com.vw.config;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import javax.sql.DataSource;
@EnableWebSecurity  // 开启MVC security安全支持
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private DataSource dataSource;
    @Autowired
    private UserDetailsServiceImpl userDetailsService;
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        //  密码需要设置编码器
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        // 使用UserDetailsService进行身份认证
        auth.userDetailsService(userDetailsService).passwordEncoder(encoder);
    }
}
```



使用测试：把redis开了，登录后在可视化端刷新一下，能看到redis多了一条登录记录。



#### 用户授权

一个系统建立后，通常需要适当作一些权限控制，使得不同用户具有不同的权限，通常一个项目都会作一些简单的登录功能，只有特定用户才能登录访问。下面我们针对Web应用场景的自定义用户授权管理进行介绍。

##### 访问控制

修改配置类 SecurityConfig 重写方法：

```java
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
        .antMatchers("/").permitAll()
        .antMatchers("/detail/common/**").hasRole("common")
        .antMatchers("/detail/vip/**").hasRole("vip")
        .anyRequest().authenticated()
        .and()
        .formLogin();
}
```

上述代码中，configure方法设置了用户访问权限，其中路径为“/”的请求直接放行；路径`“/detail/common/**”`的请求，只有用户角色为common(即ROLE_common权限)才允许访问；`“/detail/vip/**”`的请求，只有用户角色为vip(即ROLE_vip权限)才允许访问；其他请求则要求用户必须先进行登录认证。

使用测试：主页能打开，进普通电影要登录，进vip电影403。



##### 自定义登录

`templates/login/login.html`

```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>用户登录界面</title>
    <link th:href="@{/login/css/bootstrap.min.css}" rel="stylesheet">
    <link th:href="@{/login/css/signin.css}" rel="stylesheet">
</head>
<body class="text-center">
    <form class="form-signin" th:action="@{/userLogin}" th:method="post" >
        <img class="mb-4" th:src="@{/login/img/login.jpg}" width="72px" height="72px">
        <h1 class="h3 mb-3 font-weight-normal">请登录</h1>
        <!-- 用户登录错误信息提示框 -->
        <div th:if="${param.error}" style="color: red;height: 40px;text-align: left;font-size: 1.1em">
            <img th:src="@{/login/img/loginError.jpg}" width="20px">用户名或密码错误，请重新登录！
        </div>
        <input type="text" name="name" class="form-control" placeholder="用户名" required="" autofocus="">
        <input type="password" name="pwd" class="form-control" placeholder="密码" required="">
        <button class="btn btn-lg btn-primary btn-block" type="submit" >登录</button>
        <p class="mt-5 mb-3 text-muted">Copyright© 2019-2020</p>
    </form>
</body>
</html>
```

新建对应的 css 等：`resources/static/login` 里放 `css/` 下：(图片自己准备，那个 `bootstrap` 也自己准备)

> ```css
> html,
> body {
>     height: 100%;
> }
> 
> body {
>     display: -ms-flexbox;
>     display: -webkit-box;
>     display: flex;
>     -ms-flex-align: center;
>     -ms-flex-pack: center;
>     -webkit-box-align: center;
>     align-items: center;
>     -webkit-box-pack: center;
>     justify-content: center;
>     padding-top: 40px;
>     padding-bottom: 40px;
>     /*background-color: #f5f5f5;*/
> }
> 
> .form-signin {
>     width: 100%;
>     max-width: 330px;
>     padding: 15px;
>     margin: 0 auto;
> }
> .form-signin .checkbox {
>     font-weight: 400;
> }
> .form-signin .form-control {
>     position: relative;
>     box-sizing: border-box;
>     height: auto;
>     padding: 10px;
>     font-size: 16px;
> }
> .form-signin .form-control:focus {
>     z-index: 2;
> }
> .form-signin input[type="email"] {
>     margin-bottom: -1px;
>     border-bottom-right-radius: 0;
>     border-bottom-left-radius: 0;
> }
> .form-signin input[type="password"] {
>     margin-bottom: 10px;
>     border-top-left-radius: 0;
>     border-top-right-radius: 0;
> }
> ```

自己补一个登录控制器方法：

```java
@GetMapping("/userLogin")
public String toLoginPage() {
    return "login/login";
}
```

重写方法：

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
        .antMatchers("/").permitAll()
        .antMatchers("/login/**").permitAll()
        .antMatchers("/detail/common/**").hasRole("common")
        .antMatchers("/detail/vip/**").hasRole("vip")
        .anyRequest().authenticated();
    //自定义用户登录控制
    http.formLogin()
        .loginPage("/userLogin").permitAll()
        .usernameParameter("name").passwordParameter("pwd")
        .defaultSuccessUrl("/")
        .failureUrl("/userLogin?error");
}
```

（1）	loginPage(“/userLogin”)方法指定向自定义登录页面跳转的请求路径，也是前面toLoginPage()方法的@GetMapping注解拦截的路径。并使用pertmitAll()方法对进行登录跳转的请求进行放行。
（2）	usernameParameter("name")和passwordParameter("pwd")方法用来接收登录时提交的用户名和密码。这里的参数name和pwd必须和login.html中的用户名、面的name属性值保持一直。如果login.html中的name属性默认是username和password，这个两个方法就可以省略
（3）	defaultSuccessUrl("/")方法指定了用户登录成功后默认跳转到项目首页。
（4）	failureUrl("/userLogin?error")方法用来控制用户登录认证失败后的跳转路径，该方法默认参数是“/login?error”,其中，参数中的 “/userLogin”为向登录页面跳转的映射，error是一个错误标识，作用是登录失败后再登录页面进行接收判断，在login.html中的${param.error}，就是显示error标识。
（5）	antMatchers("/login/**").permitAll()方法的作用是对项目static文件夹下login包及其子包中的静态资源文件进行统一放行处理。如果没有对静态资源放行，未登录的用户访问项目首页时无法加载页面关联的静态资源文件。



##### 退出登录

`index.html` 添加：

```html
<form th:action="@{/mylogout}" method="post">
	<input th:type="submit" th:value="注销" />
</form>
```

Spring Boot项目中引入Spring Security框架后会自动开启CSRF防护功能，用户退出时必须使用POST请求；如果关闭了CSRF防护功能，那么可以使用任意方式的HTTP请求进行用户注销。

configure 方法多一行：

```java
http.logout()
	.logoutUrl("/mylogout")
	.logoutSuccessUrl("/");
```



##### 获取登录信息

###### HttpSession

控制类新加方法。在该方法中通过获取当前HttpSession的相关方法，遍历并获取了会话中的用户信息。
在获取认证用户信息时，使用了Authentication的getPrincipal()方法，默认返回的也是一个Object对象，其本质是封装用户信息的UserDetails封装类，其中包括有用户名、密码、权限、是否过期等。

```java
@GetMapping("/getuserBySession")
@ResponseBody
public String getUser(HttpSession session) {
    // 从当前HttpSession获取绑定到此会话的所有对象的名称
    Enumeration<String> names = session.getAttributeNames();
    String str="";
    while (names.hasMoreElements()){
        // 获取HttpSession中会话名称
        String element = names.nextElement();
        // 获取HttpSession中的应用上下文
        SecurityContextImpl attribute = (SecurityContextImpl) session.getAttribute(element);
        System.out.println("element: "+element);
        System.out.println("attribute: "+attribute);
        // 获取用户相关信息
        Authentication authentication = attribute.getAuthentication();
        UserDetails principal = (UserDetails)authentication.getPrincipal();
        System.out.println(principal);
        System.out.println("username: "+principal.getUsername());
        str = str+"element: "+element+"---"+"username: "+principal.getUsername();
    }
    return str;
}

```

以上代码中，getUser(HttpSession session)方法通过获取当前HttpSession的相关的所有对象名称，通过遍历获取会话中的用户名称。其中getAttribute(element)获取会话对象时，返回的是一个Object对象，其本质是一个SecurityContextImpl类，为了方便获取对象数据，将其强转为SecurityContextImpl；
在获取用户信息时，使用Authentication的getPrincipal()方法，默认返回一个Object对象，其本质是封装用户信息的UserDetails类，包含用户名、密码、权限、是否过期等。
以Debug模式重启项目(直接跑也行)，浏览器访问`http://localhost:8080/`随意查看一个影片详情进行用户登录。登录成功后，在保证当前浏览器未关闭的情况下，使用同一浏览器执行`http://localhost:8080/getuserBySession`来获取用户详情。在控制台查看输出的信息。



###### SecutiryContextHolder

Spring Security针对拦截的登录用户专门提供一个SecurityContextHolder类，来获取Spring Security的应用上下文SecurityContext，进而获取封装的用户信息。下面我们通过SecurityContextHolder来获取用户信息。
在FilmController类中新增一个获取当前会话用户信息的getUser2()方法。

```java
@GetMapping("/getuserByContext")
@ResponseBody
public String getUser2() {
    SecurityContext context = SecurityContextHolder.getContext();
    System.out.println("userDetails: "+context);
    Authentication authentication = context.getAuthentication();
    UserDetails principal = (UserDetails)authentication.getPrincipal();
    System.out.println(principal);
    System.out.println("username: "+principal.getUsername());
    return "userDetails: "+context+"----------username: "+principal.getUsername();
}
```

上述代码中，通过Security提供的SecurityContextHolder类先获取应用上下文对象SecurityContext，并通过相关方法获取当前用户的登录信息。通过与HttpSession方法获取用户信息的实例对比可以发现，这两种方法的区别就是获取SecurityContext的方法不同，其他后续方法一致。

上面介绍了Spring Boot整合Spring Security拦截获取登录用户信息的两种方法，第一种方法需要引入HttpSession对象，第二种方法Security提供的SecurityContextHolder则相对简单，也是Security项目比较推荐的使用方法。



##### 自动登录

在实际开发中项目为了用户登录方便还会提供记住我功能。如果用户登录是勾选了记住我选项，那么在一段有效的时间内，会默认自动登录，并允许访问相关的页面，这就免去了重复登录操作的麻烦。

​    Spring Security提供了用户登录控制的同时。也提供了对应记住我的功能，HttpSecurity类的rememberMe()方法就是用来处理记住我功能的。

​    Spring Security针对记住我功能提供了两种实现：一种是简单使用加密来保证基于Cookie中Token的安全；另外一种是通过数据库或其他持久化机制来保存生成的Token

###### 简单加密Token

改 

```html
<label>
	<input type="checkbox" name="rememberme"> 记住我
</label>
```

记住我的勾选框的name的属性值为rememberme，而Security提供的记住我功能额name属性值默认为remember-me

打开SecurityConfig类，重写configure(HttpSecurity http)方法进行记住我功能配置

```java
http.rememberMe().rememberMeParameter("rememberme").tokenValiditySeconds(200);
```

上述代码在configure(HttpSecurity http)方法中使用rememberMe()及相关方法实现了记住我的功能。其中rememberMeParameter("rememberme")方法指定了记住我勾选框的name属性值，如果页面中勾选框的name属性值使用默认的“remember-me”则该方法可以省略；tokenValiditySeconds(200)方法设置了记住我功能中的Token有效期为200s

测试登录后200s内重启浏览器可以免登录

###### 持久化Token

持久化Token方式和简单加密Token方式在实现【记住我】功能上大体相同。都是在用户勾上【记住我】并成功登录后，将生成的Token存入Cookie中并发送到客户端浏览器，在下次用户通过同个客户端访问系统时，系统将直接从客户端Cookie中读取Token进行认证。
	两者的区别在于：基于简单加密的Token方式生成的Token将在客户端保存一段时间，如果用户不退出登录，或者不修改密码，那么Cookie失效之前，任何人都可以无限制地使用该Token进行自动登录；而基于持久化Token的方式如下的实现逻辑

（1）	用户选择【记住我】成功登录后，Security会把username、随机产生的序列号、生成的Token进行持久化存储（例如存在一个数据表中），同时将它们的组合生成一个Cookie发送到客户端浏览器
（2）	当用户再次访问系统时，首先检查客户端携带的Cookie,如果对应Cookie中包含的username、序列号和Token与数据库中保存的一致，则通过验证并自动登录，同时系统将重新生成一个新的Token替换数据库旧的Token，并将新的Cookie再次发送给客户端。
（3）	如果Cookie中的Token不匹配，则很可能是用户的Cookie被盗用了。由于盗用者使用初次生成的Token进行登录时会生成一个新的Tokon，当用户在不知情时再次登录就会出现Token不匹配的情况，这时就需要重新登录。并生成新的Token和Cookie，同时Spring Security就可以发现Cookie可能被盗用的情况，他将删除数据库中与当前用户相关的所有Token记录。这样盗用者使用原有的Cookie就不能再次登录了
（4）	如果用户访问系统没有携带Cookie，或者包含的username和序列号与数据库中保存的不一致，那么将会引导用户到登录页面。

从以上实现逻辑可以看出，持久化Token的方式比简单加密Token的方式更加安全，使用简单加密Token的方式，一旦用户的Cookie被盗用，在Token的有效期内，盗用者可以无需安装地自动登录进行恶意操作，直到用户本人发现并修改密码才会避免这种问题；而使用持久化Token的方式相对较安全，用户每次登录都会生成新的Token和Cookie,但还是给盗用者留下在用户第二次登录前进行而已操作的机会，只有在用户进行第2次登录并更新Token和Cookie时，才会避免这种问题。因此，总体来讲，对安全要求很高的应用，不推荐使用【记住我】功能。

使用上文的数据表：

```mysql
create table persistent_logins (
	username varchar(64) not null,
	series varchar(64) primary key,
	token varchar(64) not null,
	last_used timestamp not null);
```

重写记住我功能：

```java
http.rememberMe()
	.rememberMeParameter("rememberme")
	.tokenValiditySeconds(200)
	.tokenRepository(tokenRepository());
```

同类添加方法：

```java
@Bean
public JdbcTokenRepositoryImpl tokenRepository(){
	JdbcTokenRepositoryImpl jr=new JdbcTokenRepositoryImpl();
	jr.setDataSource(dataSource);
	return jr;
}
```

述代码中，与基于简单加密的Token方式相比，在持久化Token方式的rememberMe()中加入了tokenRepository(tokenRepository())对Cookie信息进行持久化管理。其中的参数会返回一个设置dataSource数据源的JdbcTokenRepositoryImpl实现类对象，该对象包含操作Token的各种方法。

登录后查数据库能看到记录，点注销后记录也会清除。



#### CSRF防护功能

##### 基本介绍

CSRF称为跨站请求伪造(Cross-site request forgery),也称为了一键攻击（One Click Attack）或者会话控制（Session Riding），通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。与传统的XSS攻击也叫跨站脚本攻击（Cross-site Scripting）相比，CSRF攻击更加难以防范，被认为比XSS更具危险性。CSRF攻击可以在受害者毫不知情的情况下以受害者的名义伪造请求发送给攻击页面，从而在用户未授权的情况下执行在权限保护之下的操作。
例如，用户小明登录银行站点服务器准备进行转账操作，在此用户信息有效期内，小明被诱导查看了一个黑客恶意网站，该网站就会获取到小明登录后的浏览器与银行网站之间尚未过期的session信息，而小明浏览器的Cookie中含有小明银行账户的认证信息，此时黑客就会伪装小明认证后的合法身份在小明毫不知情的情况下对银行账户进行非法操作。
在讨论如何抵御CSRF攻击之前，要先明确CSRF攻击的对象，也就是要保护的对象。从上面的例子可知，CSRF攻击是黑客借助受害者的Cookie骗取服务器的信任，但是黑客并不能获取Cookie,也看不到Cookie的具体内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客无法进行解析。黑客所能做的就是伪造正常身份给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。因此，针对CSRF攻击要保护的对象是那些可以直接产生数据变化的服务，而对于读取数据的服务，可以不进行CSRF保护。例如，银行转账操作会改变账号金额，需要进行CSRF保护，而获取银行卡等级信息时读取操作，不会改变数据，可以不需要保护。
在业界目前防御CSRF攻击主要有以下3种策略。

（1）	验证HTTP Referer字段
（2）	在请求地址中添加Token并验证
（3）	在HTTP头中自定义属性并验证。

Spring Boot 整合Spring Security默认开启了CSRF防御功能，并要求数据修改的请求方法（Patch、POST、PUT和DELETE）都需要经过Security配置的安全认证后方可正常访问，否则无法正常发送请求，这里我们为了演示Security的CSRF实际默认防护效果，编写一个页面进行演示说明。

来一个控制器：

```java
package com.vw.controller;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import javax.servlet.http.HttpServletRequest;
@Controller
public class CSRFController {
    // 向用户修改页跳转
    @GetMapping("/toUpdate")
    public String toUpdate() {
        return "csrf/csrfTest";
    }
    // 用户修改提交处理
    @ResponseBody
    @PostMapping(value = "/updateUser")
    public String updateUser(@RequestParam String username, @RequestParam String password,HttpServletRequest request) {
        System.out.println(username);
        System.out.println(password);
        String csrf_token = request.getParameter("_csrf");
        System.out.println(csrf_token);
        return "ok";//没有真的做修改
    }
}
```

浏览器请求访问`http://localhost:8080/toUpdate`,此时请求地址跟@GetMapping("/toUpdate")匹配，跳转到csrf/csrfTest页面。在csrfTest.html页面中按修改按钮，提交到 /updateUser, updateUser()只是演示了获取请求参数，并没有做真正的修改业务的实现。

> 前端：`csrf/csrfTest.html`
>
> ```html
> <!DOCTYPE html>
> <html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
> 
> <head>
>     <meta charset="UTF-8">
>     <title>用户修改</title>
> </head>
> 
> <body>
>     <div align="center">
>         <form action="/updateUser" method="post">
>             用户名： <input type="text" name="username" /> <br/> 密码： <input type="password" name="password" /> <br/>
>             <button type="submit">修改</button>
>         </form>
>     </div>
> </body>
> 
> </html>
> ```

可以发现无法做到修改数据。

通过上述示例可以看出，在整合Spring Security安全框架后，项目默认启用了CSRF安全防护功能，项目中所有涉及数据修改方式的请求都会被拦截，如果不进行处理，对于真实用户发出修改数据的请求，也会通通被拦截，真实用户也不能去修改用户信息，针对这种情况，可以有两种处理方式，一种是直接关闭Security默认开启的CSRF防护功能；另一种方式就是配置Security需要的CSRF Token，具有CSRF Token才可以进入修改数据。

如果是直接关闭Security默认开启的CSRF防护功能的话，配置起来非常简单，打开配置类SecurityConfig，再重写config(HttpSession session http)方法中进行关闭配置即可。关闭代码如下：

```java
protected void configure(HttpSecurity http) throws Exception {
	http.csrf().disable();
}
```

上面展示了关闭CSRF防护功能的的配置方式，非常简单，其他代码都不用变动。但是这种直接关闭CSRF防护的方式简单粗暴，不太推荐使用，因为强行关闭后，网站可能面临CSRF攻击的危险。



##### CSRF Token

针对Form表单类型的数据修改请求，Security支持Form表单中提供了一个携带CSRF Token信息的隐藏域，与其他修改数据一起提交，这后台就可以获取并验证该请求是否为安全的，示例代码表单里添加如下：

```html
<input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
```

上述代码中，Form表单中的`<input>`隐藏标签携带了Security提供的CSRF Token信息，其中`th:name="${_csrf.parameterName}" `会获取Security默认提供的CSRF Token对应的key值，`csf=rf,th:value="${_csrf.token}"/>`会获取Security会随机生成CSRF Token对应的value值。
	在Form表单中添加上述CSRF配置后，无需其他配置就可以正常实现数据修改请求，后台配置的Security会自动获取并识别请求中的CSRF Token信息并进行用户信息验证，从而判断是否安全。
需要说明的是，针对Thymeleaf模板页中的Form表单数据修改请求，除了可以使用上述示例方式显示配置CSRF Token信息提交数据修改请求之外，还可以使用Thymeleaf模板的`th:action`属性配置CSRF Token信息，示例代码如下：

```html
<form method="post" th:action="@{/updateUser}">
```

对于Ajax类型的数据修改请求来说，Security提供了通过添加Http header头信息的方式携带CSRF Token信息进行请求验证。

```html
<html>
<head>
	<meta name="_csrf" th:content="${_csrf.token}"/>
	<meta name="_csrf_header" th:content="${_csrf.headerName}"/>
</head>
```

上述代码中，在`<head>`标签中添加两个`<meta>`子标签，分别用来设置CSRF Token信息的属性头和具体生成的Security Token值信息。其中，在Http header头信息中携带的CSRF请求头header参数的默认值为X-CSRF-TOKEN，而请求头CSRF header对应的CSRF Token值是随机生成的。然后在具体的Ajax请求中获取`<meta>`子标签中设置的CSRF Token信息，并绑定在http请求头中进行请求验证，示例代码如下：

```js
$(function () {
    var token = $("meta[name='_csrf']").attr("content");
    var header = $("meta[name='_csrf_header']").attr("content");
    $(document).ajaxSend(function(e, xhr, options) {
        xhr.setRequestHeader(header, token);
    });
});
```

上述代码首先获取`<meta>`标签中设置的CSRF Token信息，然后通过HTTP请求将CSRF Token信息给后台进行验证



#### 前端管理

加依赖

```xml
<dependency>
    <groupId>org.thymeleaf.extras</groupId>
    <artifactId>thymeleaf-extras-springsecurity5</artifactId>
</dependency>
```

给 HTML 标签加一条属性

```html
xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5"
```

使用sec:authorize="isAnonymous()"属性来判断用户是否已登录，未登录的用户才会显示请登录连接

```xml
<div sec:authorize="isAnonymous()">
   <h2 align="center">游客您好，如果想查看电影<a th:href="@{/userLogin}">请登录</a></h2>
</div>
```

使用sec:authorize="isAuthenticated()"属性来判断用户是否已登录，只有已经登录的用户才会显示登录用户信息及注销链接等。

如果用户已经登录，则使用sec:authentication="name"和sec:authentication="principal.authorities"两个属性分别显示用户名和权限。

```html
<div sec:authorize="isAuthenticated()">
   <h2 align="center"><span sec:authentication="name" style="color: #007bff"></span>
      您好，您的用户权限为<span sec:authentication="principal.authorities" style="color:darkkhaki"></span>，您有权观看以下电影</h2>
   <form th:action="@{/mylogout}" method="post">
      <input th:type="submit" th:value="注销" />
   </form>
</div>
```

使用sec:authorize="hasRole('common')"属性定义了只有角色为common且登录的用户才会显示普通电影列表信息

```html
<div sec:authorize="hasRole('common')">
   <h3>普通电影</h3>
   <ul>
      <li><a th:href="@{/detail/common/1}">飞驰人生</a></li>
      <li><a th:href="@{/detail/common/2}">夏洛特烦恼</a></li>
   </ul>
</div>
<div sec:authorize="hasAuthority('ROLE_vip')">
   <h3>VIP专享</h3>
   <ul>
      <li><a th:href="@{/detail/vip/1}">速度与激情</a></li>
      <li><a th:href="@{/detail/vip/2}">猩球崛起</a></li>
   </ul>
</div>
```



#### JWT

##### 概念

JWT（json web token），它并不是一个具体的技术实现，而更像是一种标准。

JWT规定了数据传输的结构，一串完整的JWT由三段落组成，每个段落用英文句号连接（.）连接，他们分别是：Header、Payload、Signature，所以，常规的JWT内容格式是这样的：`AAA.BBB.CCC` (token)

并且，这一串内容会base64加密。一个在线的加解密参考：[网址](https://jwt.io/)，而且通常内容本身也会经过加密。

头部的作用是声明，例如token的类型，加密算法名字。如原文：(不确定换行和空格)

```json
{'typ': 'JWT','alg': 'HS256'}
```

载荷的作用是 JWT 本体的数据信息，通常表示这是一个什么(谁)的 token，以及身份组等。一般不放置敏感信息，除非经过加密。

签名的作用是保证 header, payload 未被修改，因为如果被修改以这两个为原文的一次加解密结果会不一致(即安全学字面意义的签名，而不是生活意义的标明作者的签名)。

服务端给客户端发送 JWT (即 `AAA.BBB.CCC`)，客户端收到后，以后每次发送 HTTP 请求时，在 header 的 authorization 添加 `Bearer AAA.BBB.CCC`。

常用于跨域的鉴权。如前后端分离。

![image-20230108233711007](img/image-20230108233711007.png)

- 一个Token就是一些信息的集合；
- 在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率；



##### 生成与解析例子

###### 写法一

```xml
<!--引入jwt-->
<dependency>
  <groupId>com.auth0</groupId>
  <artifactId>java-jwt</artifactId>
  <version>3.4.0</version>
</dependency>
```

写一个测试类，在线生成和解析 JWT：

```java
package ts;

import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;

import org.junit.Test;
import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;

public class testJWT0 {
    @Test
    public void test() {
        HashMap<String, Object> map = new HashMap<>();
        Calendar instance=Calendar.getInstance();
        instance.add(Calendar.SECOND,200);
        //获取token
        String token = JWT.create().withHeader(map)  //header，默认，可以不写
            .withClaim("userId", 23)
            .withClaim("username", "xpp") //palyload
            .withExpiresAt(instance.getTime())  //指定令牌的过期时间
            .sign(Algorithm.HMAC256("xpp@ll"));//签名，指定秘钥
        System.out.println(token);
        
        // 创建验证对象
        JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256("xpp@ll")).build();
        // 验证token
        DecodedJWT verify = jwtVerifier.verify(token);
        // 获取存入palyload的信息
        Date expiresAt = verify.getExpiresAt();
        System.out.println(expiresAt);
        System.out.println(verify.getClaim("userId").asInt());
    }
}
```

那么原理上，把上述内容封装一下，后端就做完了，再给个前端 post 的例子(参见 `后端.md`)，就通了。

> 常见异常：
>
> - `SignatureVerificationException`: 签名不一致异常
> - `TokenExpiredException`: 令牌过期异常
> - `AlgorithmMismatchException`: 算法不匹配异常
> - `InvalidClaimException`: 失效的payload异常

###### 写法二

```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.2</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.2</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId> <!-- or jjwt-gson if Gson is preferred -->
    <version>0.11.2</version>
    <scope>runtime</scope>
</dependency>
```

```js
package ts;

import java.security.Key;
import org.junit.Test;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;

public class testJWT1 {
    @Test
    public void test() {
        Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);
        String jws = Jwts.builder().setSubject("普通文本").signWith(key).compact();
        System.out.println(jws);
        
        String raw = Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(jws).getBody().getSubject();
        System.out.println(raw);
    }
}
```



##### 项目例子

> 所用 pom 如下：
>
> ```xml
> <properties>
>     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
>     <java.version>1.8</java.version>
> </properties>
> <parent>
>     <groupId>org.springframework.boot</groupId>
>     <artifactId>spring-boot-starter-parent</artifactId>
>     <version>1.5.9.RELEASE</version>
> </parent>
> <dependencies>
>     <dependency>
>         <groupId>junit</groupId>
>         <artifactId>junit</artifactId>
>         <scope>test</scope>
>     </dependency>
>     <dependency>
>         <groupId>org.springframework.boot</groupId>
>         <artifactId>spring-boot-starter-web</artifactId>
>     </dependency>
>     <!-- 
>     <dependency>
>         <groupId>io.jsonwebtoken</groupId>
>         <artifactId>jjwt-api</artifactId>
>         <version>0.11.2</version>
>     </dependency>
>     <dependency>
>         <groupId>io.jsonwebtoken</groupId>
>         <artifactId>jjwt-impl</artifactId>
>         <version>0.11.2</version>
>         <scope>runtime</scope>
>     </dependency>
>     <dependency>
>         <groupId>io.jsonwebtoken</groupId>
>         <artifactId>jjwt-jackson</artifactId> 
>         <version>0.11.2</version>
>         <scope>runtime</scope>
>     </dependency> -->
>     <dependency>
>         <groupId>com.auth0</groupId>
>         <artifactId>java-jwt</artifactId>
>         <version>3.4.0</version>
>     </dependency>
> </dependencies>
> <build>
>     <plugins>
>         <plugin>
>             <groupId>org.springframework.boot</groupId>
>             <artifactId>spring-boot-maven-plugin</artifactId>
>         </plugin>
>     </plugins>
> </build>
> ```

实现目标：服务器给用户下发 JWT token，不同用户 token 不一样且都有有效期，然后客户端用该 token 访问一个需要 token 的资源。

![image-20230109002209008](img/image-20230109002209008.png)

为了简单起见，忽略数据库(即用户登录验证，一般来说只有登录成功才能获取 token，这里假设无论如何都能获取)，我们先写一个 token 生成和获取的类：

```java
package ts.utils;

import java.util.Calendar;
import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;

public class TokenUtils {
    public static final Algorithm psw = Algorithm.HMAC256("baicha_1437581");

    public static String encode(String raw) {
        Calendar timelimc = Calendar.getInstance();
        timelimc.add(Calendar.SECOND, 20);//不能static,每秒都不一样
        return JWT.create().withClaim("userinfo", raw).withExpiresAt(timelimc.getTime()).sign(psw);
    }

    public static final JWTVerifier jwtVerifier = JWT.require(psw).build();

    public static String decode(String token) {
        DecodedJWT verify = jwtVerifier.verify(token);
//        Date expiresAt = verify.getExpiresAt();
        return verify.getClaim("userinfo").asString();
    }

    public static boolean check(String token) {
        try {
            return decode(token) != null;
        } catch (Exception e) {//无效或过期
//            e.printStackTrace();
            return false;
        }
    }
}
```

注：一般为了防止用户盗用，我们还需要验证 decode 出来的字符串是不是真的是本人 username。这里略去了这一步骤。

然后写一个拦截逻辑：(只使用拦截前的切面)

```java
package ts.config;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import ts.utils.TokenUtils;

public class TokenInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
            Object handler) throws Exception {
        // 前端 axios 对于复杂请求会先发送 OPTIONS，此时没有 header
        if ("OPTIONS".equals(request.getMethod())) {
            return true;
        }
        String token = request.getHeader("Authorization");
        token = token.substring(7);//exclude "Bearer "
        if (!TokenUtils.check(token)) {
            // token 已过期或不正确
            return false;
        }
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
            ModelAndView modelAndView) throws Exception {   
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
            Object handler, Exception ex) throws Exception {   
    }
}
```

将该拦截器在所有除了 `/login/` 开头外的路径生效：

```java
package ts.config;

import ... //略

@Configuration
public class InterceptorConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new TokenInterceptor()).addPathPatterns("/**")
        .excludePathPatterns("/login/**");
    }
    //下面还有若干个 override 都不使用，留空
}
```

然后写一个登录的接口，和一个普通接口：

```java
@RestController
public class IndexController {
	@PostMapping("/index")
    public String index0() {
        return "你好?";
    }
    
    @PostMapping("/login/test")
    public String login(@RequestParam("username") String username) {
        return TokenUtils.encode(username);
    }
}
```

写一个测试的前端代码：

```js
function next(token,fb){
    $.ajax({
        url:'http://localhost:8080/index',            
        type:'post',
        headers:{
            'Authorization': 'Bearer '+token,
        },
        success:(data)=>{
            //如果过期，得到空的data
            console.log(fb,data);
        }, 
        error:(xhr,status,error)=>{console.log("err", error);}
    });
}
$.ajax({
    url:'http://localhost:8080/login/test',            
    type:'post',
    data:{username:'张三'},
    success:(data)=>{
        let token = data;
        console.log(token);
        next(token,"suc:");
    }, 
    error:(xhr,status,error)=>{console.log("err", error);}
});
next('eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2NzMyODMwNjcsInVzZXJpbmZvIjoi5byg5LiJIn0.VTrtx9BPsNrh-H1jIrnIxgtqdUFinTHdRKOVsQc4FVk',"expire:");//尝试用过期的token
```

运行后端，然后运行前端代码(随便套进一个 html 的 script 标签里)，我们发现，用先 post 再尝试去 index 的能成功返回消息，而使用无效 token 直接越界访问 index 的输出空的 success data。



### POI

#### 基本

##### 概念

Apache POI是Apache软件基金会的开源项目，POI提供API给Java程序对Microsoft Office格式档案读和写的功能。[参考](https://zhuanlan.zhihu.com/p/365814275)

HSSF提供读写Microsoft Excel XLS格式档案的功能。

**XSSF**提供读写Microsoft Excel OOXML XLSX格式档案的功能。

HWPF提供读写Microsoft Word DOC格式档案的功能。

HSLF提供读写Microsoft PowerPoint格式档案的功能。

HDGF提供读Microsoft Visio格式档案的功能。

HPBF提供读Microsoft Publisher格式档案的功能。

HSMF提供读Microsoft Outlook格式档案的功能。

##### 导包

```xml
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi</artifactId>
    <version>4.0.1</version>
</dependency>
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>4.0.1</version>
</dependency>
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml-schemas</artifactId>
    <version>4.0.1</version>
</dependency>
```



#### Excel

##### 基本

注意导包都选带 `ss` 的包

```java
//1.创建工作薄Workbook
Workbook wb = new XSSFWorkbook();
//2.创建表单Sheet
Sheet sheet = wb.createSheet("港港的工作空间");
//创建行对象，从0开始
Row row = sheet.createRow(1);
row.createCell(1).setCellValue(false);// 设置单元格内容,重载
row.createCell(2).setCellValue(new Date());// 设置单元格内容,重载
row.createCell(3).setCellValue(12.345);// 设置单元格内容,重载
//创建单元格对象，从0开始
Cell cell = row.createCell(0);//修改就ge而不是create
//单元格写入数据
cell.setCellValue("港港");
//3.创建文件流
FileOutputStream fos =
    new FileOutputStream("D:\\a\\demo02.xlsx");
//4.写出文件
wb.write(fos);
//5.关闭流
fos.close();
```

然后将这个文件用文件下载的办法搞起来就好了

默认居左，数值居右



##### 排版

如加粗居中：(chatGPT)

```java
CellStyle aligncenter = wb.createCellStyle();
aligncenter.setAlignment(HorizontalAlignment.CENTER);
Font bold = wb.createFont();//不要用java.awt包的
bold.setBold(true);
aligncenter.setFont(bold);
for (int i = 0; i < 5; ++i) {
    header.getCell(i).setCellStyle(aligncenter);
}
```





##### 列宽

自动调整，需要高级表格。[参考](https://blog.csdn.net/zh555888/article/details/125389802)

```java
SXSSFWorkbook wb = new SXSSFWorkbook();
SXSSFSheet sheet = wb.createSheet("sheet1");
for (int i = 0; i < 5; i++) { //总列数 
    sheet.trackAllColumnsForAutoSizing();
    sheet.autoSizeColumn(i);
    sheet.setColumnWidth(i, sheet.getColumnWidth(i) * 17 / 10);
}
```



### Swagger

#### 基本

一种自动生成文档的包。[参考入门](https://www.cnblogs.com/iqiuq/p/14883839.html)

在 pom 导入包：

```xml
<!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 -->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.9.2</version>
</dependency>

<!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui -->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.9.2</version>
</dependency>
```

@enableSwagger2：是springfox提供的一个注解，代表swagger2相关技术开启,会扫描当前类所在包，以及子包中所有的类型中的注解，做swagger文档的定值。通常可以在启动类添加该注释。

然后启动项目并输入 `http://localhost:8080/swagger-ui.html`，可以看到自动生成的接口文档。

> 如果使用的是swagger 3.0 需要使用，访问：http://localhost:8080/swagger-ui/index.html  就可以实现swagger-ui.html的访问

可以写一点文档信息：(这个写法很烂建议用生成器生成 api info)

```java
package ts.config;

import java.util.ArrayList;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

@Configuration
public class SwaggerConfig {
    @SuppressWarnings({ "rawtypes", "unchecked" })
    public ApiInfo apiInfo() {
        Contact contact = new Contact("lr580", "https://文档发布者的网站地址/", "lr580@163.com");
        return new ApiInfo(
             "这是一个标题","这是一个文档描述","1.0",
             "服务组url地址", contact , "Apache 2.0", "http://www.apache.org/licenses/LICENSE-2.0",
             new ArrayList());
    }

    @Bean
    public Docket docket() {
        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());
    }
}
```

扫描包设置：(只有一部分可以被扫描)

```js
@Bean
    public Docket docket() {
        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()).select().apis(RequestHandlerSelectors.basePackage("ts.controller")).paths(PathSelectors.regex("/index")).build();
    }
```

如果加上 `.enable(false)` 浏览器不能访问。

建议只写 getmapping / postmapping 而不是写 requestmapping, 否则文档一堆东西。(delete 啥的都可以)，如有一个控制类：

```java
@RestController
public class IndexController {
    @GetMapping("/index")
    public String index(@RequestParam String value) {
        return "你好" + value;
    }
    @GetMapping("/index2")
    public String index2() {
        return "你不好";
    }
}
```



#### 常用注解

##### Api

标注控制器名(显示上会标注名+类名)

```java
@Api(tags = "主控制器")
@RestController
public class IndexController {
```



##### ApiOperation

方法说明(values是接口名，notes可选)

```java
@ApiOperation(value = "主接口", notes = "这是备注")
@GetMapping("/index")
public String index(@RequestParam String value) {
    return "你好" + value;
}

@ApiOperation(value = "备用接口")
@GetMapping("/index2")
public String index2() {
    return "你不好";
}
```



##### ApiParam

```java
public String index(@RequestParam @ApiParam(name = "姓名", value = "任意字符", required=true) String value) {
```



##### ApiIgnore

忽略，当前注解描述的方法或类型，不生成api文档

```java
@ApiIgnore
@GetMapping("/index2")
public String index2() {
    return "你不好";
}
```



##### ApiResponse

不会去除原本有的 response (只修改和添加)

```java
@ApiResponses(value= {
    @ApiResponse(code=200,message="ok"),
    @ApiResponse(code=500,message="服务器错误"),
})
@GetMapping("/index")
public String index(@RequestParam  String value) {
    return "你好" + value;
}
```



#### 导出

以导出 md 文档为例。效果上本地那个更好

##### 在线

[参考](https://blog.csdn.net/fei12990/article/details/120857284),点击访问 [http://localhost:8080/v2/api-docs](http://localhost:8080/v2/api-docs)，将其内容保存到本地 `xx.yaml`

登录 [小幺鸡](http://xiaoyaoji.cn/)，进入控制台，新增-导入-swagger，然后点进去，更多功能-导出



##### 本地

[参考](https://blog.csdn.net/feiying0canglang/article/details/120657699),依赖

```xml
<dependency>
    <groupId>io.github.swagger2markup</groupId>
    <artifactId>swagger2markup</artifactId>
    <version>1.3.3</version>
</dependency>
```

在运行着服务器的情况下跑 test：

```java
package ts;

import org.junit.Test;

import java.net.MalformedURLException;
import java.net.URL;
import io.github.swagger2markup.GroupBy;
import io.github.swagger2markup.Language;
import io.github.swagger2markup.Swagger2MarkupConfig;
import io.github.swagger2markup.Swagger2MarkupConverter;
import io.github.swagger2markup.builder.Swagger2MarkupConfigBuilder;
import io.github.swagger2markup.markup.builder.MarkupLanguage;
import java.nio.file.Paths;

public class getMdDocs {
    @Test
    public void get() throws MalformedURLException {
        Swagger2MarkupConfig conig = new Swagger2MarkupConfigBuilder().withMarkupLanguage(MarkupLanguage.MARKDOWN).withOutputLanguage(Language.ZH).withPathsGroupedBy(GroupBy.TAGS).withGeneratedExamples().withoutInlineSchema().build();
        Swagger2MarkupConverter.from(new URL("http://localhost:8080/v2/api-docs")).withConfig(conig).build().toFolder(Paths.get("src/main/doc"));
    }
}

```



#### 常见问题

##### springboot版本过高

版本高，使用 2.9.2 的 swagger，且配置里添加：

```properties
spring.mvc.pathmatch.matching-strategy=ant_path_matcher
```



##### jwt token

[参考1](https://blog.csdn.net/zhy18820612/article/details/93880769?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-93880769-blog-116234417.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-93880769-blog-116234417.pc_relevant_recovery_v2&utm_relevant_index=5), [参考2](https://blog.csdn.net/qq_22256565/article/details/103747152)

swagger 类写成这样：

```java
package com.example.express.config;

import com.google.common.collect.Lists;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.ParameterBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.schema.ModelRef;
import springfox.documentation.service.*;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spi.service.contexts.SecurityContext;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import java.util.ArrayList;
import java.util.List;

@Configuration
@EnableSwagger2
@EnableWebMvc
public class SwaggerConfig implements WebMvcConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {

        registry.addResourceHandler("/**").addResourceLocations(
                "classpath:/static/");
        registry.addResourceHandler("swagger-ui.html").addResourceLocations(
                "classpath:/META-INF/resources/");
        registry.addResourceHandler("/webjars/**").addResourceLocations(
                "classpath:/META-INF/resources/webjars/");
        WebMvcConfigurer.super.addResourceHandlers(registry);
    }

    public static final String AUTHORIZATION_HEADER = "Access-Token";
    public static final String DEFAULT_INCLUDE_PATTERN = "/api/.*";
    /**
     * TODO
     * 可以根据配置读取是否开启swagger文档，针对测试与生产环境采用不同的配置
     */
    private boolean isSwaggerEnable = true;
    //是否开启swagger，正式环境一般是需要关闭的，可根据springboot的多环境配置进行设置
    //@Value(value = "${swagger.enabled}")
    Boolean swaggerEnabled = true;
    @Bean
    public Docket createRestApi() {
        ParameterBuilder ticketPar = new ParameterBuilder();
        List<Parameter> pars = new ArrayList<Parameter>();
        ticketPar.name(AUTHORIZATION_HEADER).description("user ticket")//Token 以及Authorization 为自定义的参数，session保存的名字是哪个就可以写成那个
                .modelRef(new ModelRef("string")).parameterType("header")
                .required(false).build(); //header中的ticket参数非必填，传空也可以
        pars.add(ticketPar.build());    //根据每个方法名也知道当前方法在设置什么参数
        return new Docket(DocumentationType.SWAGGER_2)
                //.groupName("group")
                .enable(swaggerEnabled)
                .apiInfo(apiInfo()).select()
                // 对所有该包下的Api进行监控，如果想要监控所有的话可以改成any()
                //.apis(RequestHandlerSelectors.basePackage("com.iscas"))
                .apis(RequestHandlerSelectors.any())
                // 对所有路径进行扫描
                .paths(PathSelectors.any())
                .build()
                //.globalOperationParameters(pars);
                .securityContexts(Lists.newArrayList(securityContext()))
                .securitySchemes(Lists.newArrayList(apiKey()));
    }
    private ApiKey apiKey() {
        return new ApiKey(AUTHORIZATION_HEADER , AUTHORIZATION_HEADER, "header");
    }
    private SecurityContext securityContext() {
        return SecurityContext.builder()
                .securityReferences(defaultAuth())
                //.forPaths(PathSelectors.regex(DEFAULT_INCLUDE_PATTERN))
                .forPaths(PathSelectors.regex("^(?!auth).*$"))
                .build();
    }
    List<SecurityReference> defaultAuth() {
        AuthorizationScope authorizationScope
                = new AuthorizationScope("global", "accessEverything");
        AuthorizationScope[] authorizationScopes = new AuthorizationScope[1];
        authorizationScopes[0] = authorizationScope;
        return Lists.newArrayList(
                new SecurityReference(AUTHORIZATION_HEADER, authorizationScopes));
    }
    /**
     * @return 生成文档说明信息
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("XXXX系统")
                .description("描述")
                //.termsOfServiceUrl("http://gaohanghang.github.io")
                .license("Apache 2.0")
                .licenseUrl("http://www.apache.org/licenses/LICENSE-2.0")
                .version("2.0.0").build();
    }
}
```

且 InterceptorConfig 类的 addInterceptors 添加：

```java
  public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new TokenInterceptor())
      .excludePathPatterns("/fileUpdataApi/upload","/swagger-resources/**", "/webjars/**", "/v2/**", "/swagger-ui.html/**");
  }//追加第三行
```

重新跑进 `http://localhost:8080/swagger-ui.html`，发现有接口，但查看接口详细信息需要输入 token。这个 token 根据 jwt 获取，例如可能会存储在数据库里。输入即可。



### Spring Cloud

#### 概念

##### 微服务

springboot单独存在的意义不大,独立运行,自动配置,完全是为了微服务的框架而创建的.springcloud框架必须基于springboot的工程才可以实现;

当微服务特别庞大的时候,就需要从管理.监控角度出发,对整个集群做到架构级别的技术整合--这种技术就成为微服务框架

常见的有spring cloud，dubbo(12年宣布停更,17年恢复更新);
spring cloud: 一种轻量级的,组件丰富全面的微服务框架技术,核心注册发现组件Eureka(不能由别人代替),实现的http的协议传输数据;组件特别丰富，所以开发投入成本较低;
dubbo: 组件没有springcloud丰富,注册发现组件可以使用Eureka(http协议),redis,zookeeper(rpc协议),使用rpc协议的技术,性能高;http性能虽然没有rpc高但是灵活度.
技术选型: spring cloud 开发成本低,所有组件是现成的直接使用,更新比较及时,对应市面的各种新技术做最新的进步;
dubbo 性能高,是dubbo重要的优点,开发成本高

#### Eureka

##### 概念

eureka是spring cloud 的微服务框架的核心组件(管理单位);是完成当前所有集群微服务的注册与发现的核心进程;可以动态的处理所有负载均衡访问的集群（serverList）的管理工作;

服务的注册:微服务节点作为真正的服务,功能的提供者.动态注册在eureka中心。

（nginx是静态的。维护serverList是一个静态文件，当服务器发生变化时，只能手动的修改静态文件，修改完后还要重新启动nginx才能完成。）

<img src="img/image-20230319202055736.png" alt="image-20230319202055736" style="zoom: 80%;" /><img src="img/image-20230319202102354.png" alt="image-20230319202102354" style="zoom: 67%;" />

服务的发现:客户端具备访问eureka的能力,动态的获取某个一个服务的真正提供者信息,从而发起访问调用;

<img src="img/image-20230319202226511.png" alt="image-20230319202226511" style="zoom:67%;" />

eureka组件中的角色:
o	注册中心,称为eureka中的服务端角色
o	注册在中心的微服务们,称为eureka中的客户端角色

启动的每一个eureka客户端进程.都会根据配置到eureka注册中心进行注册,注册之后, eureka客户端（服务）每30秒给注册中心发送一个心跳检测(续约) ,注册中心每60秒检测一次所有的服务续约,一旦发现服务超过90秒没有发送心跳检测的话,将会把服务对应的实例节点剔除;

<img src="img/image-20230320143939059.png" alt="image-20230320143939059" style="zoom:67%;" />

每一个服务的提供者注册到服务端时,访问调用`localhost:8761/eureka`发送请求.并且携带一些信息,Eureka服务端将这些信息保管在一个双层map中

<img src="img/image-20230320161822617.png" alt="image-20230320161822617" style="zoom:80%;" />

eureka注册中心.提供一种保护微服务集群注册服务信息的机制,防止由于网络波动导致大量的注册心跳检测发送未成功,造成的误剔除,给集群,给微服务带来的巨大伤害,所出现的一种机制--保护机制

当整个集群15%以上同一时间检测到超过90秒未发送心跳.将会开启保护机制,一旦开启,所有的服务注册信息,在eureka中心不会进行任何剔除;默认情况保护机制是开启的。

<img src="img/image-20230320162125465.png" alt="image-20230320162125465" style="zoom:67%;" />

##### 示例

###### 服务端

> 注：由于未知原因，如果启动后台显示不是 localhost 而是 lr580 或别的名字 UP 的，建议重启电脑，原因未知，怀疑跟梯子有关。但是，有时候即使是 lr580，也不代表跑不动，如果确实后续能跑动，那可以考虑不管。

创建一个 quickstart maven 工程。

加 pom，注意两个版本需要有对应关系，可以自己去查。

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.9.RELEASE</version>
</parent> 
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>Edgware.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

外边再再加上：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-eureka-server</artifactId>
</dependency>
```

> 参考完整配置文件：
>
> ```xml
> <project xmlns="http://maven.apache.org/POM/4.0.0"
> 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
> 	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
> 	<modelVersion>4.0.0</modelVersion>
> 
> 	<groupId>cn.edu.scnu</groupId>
> 	<artifactId>eureka-server</artifactId>
> 	<version>0.0.1-SNAPSHOT</version>
> 	<packaging>jar</packaging>
> 
> 	<name>eureka-server</name>
> 	<url>http://maven.apache.org</url>
> 
> 	<properties>
> 		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
> 		<java.version>1.8</java.version>
> 	</properties>
> 
> 	<parent>
>         <groupId>org.springframework.boot</groupId>
>         <artifactId>spring-boot-starter-parent</artifactId>
>         <version>1.5.9.RELEASE</version>
>     </parent>
> 
>     <dependencyManagement>
>         <dependencies>
>             <dependency>
>                 <groupId>org.springframework.cloud</groupId>
>                 <artifactId>spring-cloud-dependencies</artifactId>
>                 <version>Edgware.RELEASE</version>
>                 <type>pom</type>
>                 <scope>import</scope>
>             </dependency>
>         </dependencies>
>     </dependencyManagement>
> 
>     <dependencies>
>         <dependency>
>             <groupId>org.springframework.cloud</groupId>
>             <artifactId>spring-cloud-starter-eureka-server</artifactId>
>         </dependency>
>         <dependency>
>             <groupId>junit</groupId>
>             <artifactId>junit</artifactId>
>             <scope>test</scope>
>         </dependency>
>     </dependencies>
> </project>
> ```

<img src="img/image-20230319203013920.png" alt="image-20230319203013920"  />

设 `src/main/resources/application.properties`：

```properties
server.port=8761
#eureka config
eureka.instance.hostname=localhost
eureka.client.registerWithEureka=false
eureka.client.fetchRegistry=false
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
```

- 如果是 localhost 则 hostmane 不加也行
- registerWithEureka默认为true，指示该实例是否注册到eureka注册中心，设置false, 表示自己就是eureka服务中心
- fetch-registry: 默认值为true，指示此客户端是否应该从eureka获取eureka注册表信息，设置为false，表示自己就是注册中心，不用去注册中心获取其他服务的地址
- 对外暴露的注册地址(接口)是 default zone

写一个启动类：

```java
package cn.edu.scnu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class StarterEurekaServer {
    public static void main(String[] args) {
        SpringApplication.run(StarterEurekaServer.class, args);
    }
}
```

测试启动：`http://localhost:8761/`

###### 客户端

配置三个客户端，pom 修改单独 dependecy 为：

> 如果是 `eclipse` 复制粘贴项目，记得改 `.project` 项目名

```xml
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-eureka</artifactId>
</dependency>
```

然后配置文件：

```properties
server.port=9001
#eureka client config
spring.application.name=service01
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
```

- port 是启动端口，应该三个客户端都不一样。
- application 都填同一个
- default Zone 指向上文配置的服务器的地址。可以连多个，逗号分隔。

写一个启动类，仅修改为 Client 注解：

```java
package cn.edu.scnu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class StarterEurekaClient01 {
    public static void main(String[] args) {
        SpringApplication.run(StarterEurekaClient01.class, args);
    }
}
```

尝试在客户端增加一个测试功能：

```java
package cn.edu.scnu.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {
    @Value("${server.port}")
    private String port;

    @RequestMapping("hello")
    public String sayHello(String name) {
        return "hello " + name + " from " + port;
    }
}
```

那么输入 `localhost:9001/hello?name=白茶`



#### RIBBON

##### 概念

实现内部服务调用另外一个服务的客户端

在springcloud中,提供一个客户端组件,用来**负载均衡**的访问某个服务;

Ribbon启动之后,作为eureka的客户端到eureka注册中心实现抓取服务端的服务提供者列表list(每30秒重新抓取一次),这样就可以实现动态的对服务负载均衡访问。

绕过了nginx的静态文件配置.修改环境重启nginx;

这个客户端的访问服务的功能，需要依赖RestTemplate，发起http请求，请求的是服务名称)

<img src="img/image-20230320163534080.png" alt="image-20230320163534080" style="zoom:80%;" />

ribbon启动 eureka客户端(注册,**发现**)

ribbon客户端启动时,会根据eureka客户端角色到注册中心抓取所有的服务列表.将抓取的数据保存在内存的map

restTemplate在发起请求之前做拦截.替换,根据请求地址中的服务名称,找到map中key,拿到提供者list,根据负载均衡逻辑(默认轮询)进行轮询的负载均衡访问

<img src="img/image-20230320202540765.png" alt="image-20230320202540765" style="zoom:80%;" />

在LoadBalancerBuider做拦截

·    其他负载均衡irule实现类

除了轮询的机制,还提供很多.比如随机.比如权重

| IRULE实现类              | 功能                                                         |
| ------------------------ | ------------------------------------------------------------ |
| RamdomRule               | 实现拦截拼接服务提供者信息时,采用随机的选取方式              |
| WeightedResponseTimeRule | 根据每个节点平均响应时间做动态的权重值变化,响应速度越快,权重值越高(负载访问占比越高) |

当前的环境是根据生成的bean对象来加载负载均衡策略(缺省值就是RoundRobin的对象)

只需要在配置类中（启动类就是配置类）.利用@Bean创建当前想使用的对象即可

```java
// 创建一个自定义负载均衡策略
@Bean
public IRule myRule() {
    return new RandomRule();
}
```



##### 示例

书接上回 eureka，创建 quickstart，pom 依赖改为(即加一个)：

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-eureka</artifactId>
    </dependency>
    <!--Ribbon相关依赖 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-ribbon</artifactId>
    </dependency>
</dependencies>
```

配置：

```properties
server.port=9004
#eureka client config
spring.application.name=service02
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
```

写一个启动类：

```java
package cn.edu.scnu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableEurekaClient
public class StarterRibbonClient {
    public static void main(String[] args) {
        SpringApplication.run(StarterRibbonClient.class, args);
    }

    @Bean
    @LoadBalanced // 生成一个具备ribbon拦截功能的restTemplate
    // 加了注解后，在创建RestTemplate后会对它实现监听,通过它发起请求做到一个拦截
    // 会根据负载均衡策略对象(IRule接口的实现类)
    // 实现访问服务的负载均衡方式 默认roundRobin轮询
    public RestTemplate initRestTemplate() {
        return new RestTemplate();
    }
}
```

写一个测试服务：

```java
package cn.edu.scnu.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@RestController
public class HelloController {
    @Autowired
    private RestTemplate restTemplate;

    @RequestMapping("hello")
    public String sayHello(String name) {
        String responseStr = restTemplate.getForObject("http://service01/hello?name=" + name,
                String.class);
        return "From Ribbon: " + responseStr;
    }
}
```

测试：`http://localhost:9004/hello?name=白茶`。期望：`from` 不断更改，为上面三个 client 之一。



#### zuul

##### 概念

Zuul网关是整个微服务框架搭建完毕之后的集群中唯一对外界提供接口访问的角色,ribbon,eureka等等不能够将请求地址,接口地址对外暴露,一旦暴露就会出现被攻击的危险;

zuul底层实现了ribbon+restTemplate的编码逻辑的,可以在路由的模式下, 在zuul内部启动ribbon启动restTemplate,当对外暴露的接口地址被访问时.转发到一个真实的服务

zuul.routes.api-a.path:定义一个与访问api-a相关服务配置的path的映射地址 /api-a/**,请求的路径(url)中以/api-a开始的多级路径匹配。

例如：

localhost:9005/api-a/order/pay 可以匹配到

localhost:9005/api-h/order/pay 匹配不到

一旦当前请求和某一个路由匹配成功,将会根据zuul.routes.XX.path中的,寻找当前properties中一个zuul.routes.XX.serviceId=service01,从而找到对应的访问服务(ribbon+restTemplate访问服务获取响应)

例如：

localhost:9005/api-a/order/pay 

寻找到：

localhost:9005/service01/order/pay 

2）匹配规则:? 、* 、**

| 符号 | 匹配规则                                                     |
| ---- | ------------------------------------------------------------ |
| ?    | 匹配一个字符,例如/api-a/? 只能匹配到类似/api-a/a、/api-a/b   |
| *    | 匹配一个一级路径字符串,/api-a/*,匹配到/api-a/a,而/api-a/a/haha,/api-a/a/b则匹配不到了 |
| **   | 只要是起始匹配成功.后续的多级,多字符串匹配都通配/api-a/**,   |

 将nginx配置成访问网关暴露接口的匹配地址,js,页面就可以springcloud搭建的微服务集群访问高可用的分布式系统了

##### 示例

书接上文 ribbon。quickstart，依赖跟上面的差别是：

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-eureka</artifactId>
    </dependency>

    <!--zuul相关依赖 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-zuul</artifactId>
    </dependency>
</dependencies>
```

properties:

```properties
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
server.port=9005
spring.application.name=serviceZuul
zuul.routes.api-a.path=/api-a/**
zuul.routes.api-a.serviceId=service01
zuul.routes.api-b.path=/api-b/**
zuul.routes.api-b.serviceId=service02
zuul.routes.orders.path=/orders/**
zuul.routes.orders.serviceId=orderservice
zuul.routes.users.path=/users/**
zuul.routes.users.serviceId=userservice
```

启动类：

```java
package cn.scnu.edu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;

@SpringBootApplication
@EnableZuulProxy
public class StarterZuul {
    public static void main(String[] args) {
        SpringApplication.run(StarterZuul.class, args);
    }
}
```

测试：

```
localhost:9005/api-a/hello?name=haha (每次刷新不一样)
http://localhost:9005/api-b/hello?name=haha (同理)
# localhost:9005/orders/order/pay?orderId=a
# localhost:9005/users/user/query/point?userId=1
```

##### 高可用

<img src="img/image-20230321145710069.png" alt="image-20230321145710069" style="zoom:80%;" />

复制一份 server，修改两个 properties 分别为：

```properties
server.port=8761
#eureka config
spring.application.name=eureka-server
eureka.instance.hostname=localhost
eureka.client.registerWithEureka=true
eureka.client.fetchRegistry=true
eureka.instance.preferIpAddress=true
eureka.client.serviceUrl.defaultZone=http://localhost:8762/eureka
eureka.server.enable-seft-preservation=false
```

```properties
server.port=8762
#eureka config
spring.application.name=eureka-server
eureka.instance.hostname=localhost
eureka.client.registerWithEureka=true
eureka.client.fetchRegistry=true
eureka.instance.preferIpAddress=true
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.server.enable-seft-preservation=false
```

注解：

- 注册与发现开启,registry和fetch=true
- 服务端互相注册发现必须配置 ip优先的内容 preferIpAddress

两个都运行，然后进行测试：`localhost:8761`,`localhost:8762`

然后把三个客户端，和 ribbon, zuul 的 `defaultZone` 改成两个都连：

```properties
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/,http://localhost:8762/eureka/
```

同上进行测试。

> 未知原因，9005 连上了，但 url 不行，9006 9007 都可以。

搭建了Eureka高可用集群，所有访问都要先经过zuul网关，所以zuul网关也要搭建集群

springboot专门为maven提供了打包springboot的所有插件简化资源

zuul pom 添加：

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

右击项目，run as-maven clean,然后 maven install，看到根目录 target 有 jar 包。随便拖走 jar 到其他目录，然后运行多份：

```shell
java -jar zuul-0.0.1-SNAPSHOT.jar
java -jar zuul-0.0.1-SNAPSHOT.jar --server.port=9006
java -jar zuul-0.0.1-SNAPSHOT.jar --server.port=9007
```

修改 nginx：

```nginx
upstream zuulcluster {
    server 127.0.0.1:9005;
    server 127.0.0.1:9006;
    server 127.0.0.1:9007;
}
server {
    listen 80;
    server_name www.sssm.cn;
    location /user {
        proxy_pass http://zuulcluster/users/user;
    }
    location /order {
        proxy_pass http://zuulcluster/orders/order;
    }
    location /{
        root orderuser;
        index index.html;
    }
}
```

记得 hosts 加上 `127.0.0.1 www.sssm.cn`

> 对 order and user 的修改：从 javaweb 课程下一个前端页面，然后搞一个 microtest 数据库，导入。对 properties 修改如下：
>
> - 数据库密码
>
> - 自己用 mysql 8.0，所以
>
>   ```properties
>   spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
>   ```
>
> mysql 8.0 导致的 pom 修改，无视警告：
>
> ```xml
> <dependency>
>     <groupId>mysql</groupId>
>     <artifactId>mysql-connector-java</artifactId>
>     <version>8.0.26</version>
> </dependency>
> ```
>

#### config

##### 服务端例子

quickstart config-server。

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.9.RELEASE</version>
</parent>
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>Edgware.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-config-server</artifactId>
</dependency>
```

搭一个 git 仓库，如 `https://gitee.com/lr580/easymallconfig`，建一个文件夹如 `lr580test` 然后里面随便放一个配置文件随便写点内容如 `demo01-test.properties`，然后对本项目配置文件写入：

```properties
server.port=11000
spring.cloud.config.server.git.uri=https://gitee.com/lr580/easymallconfig
spring.cloud.config.server.git.searchPaths=/lr580test
#默认master
spring.cloud.config.label=master 
#spring.cloud.config.server.git.username= 私有仓库需要
#spring.cloud.config.server.git.password=
```

启动类：

```java
package cn.edu.scnu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer
public class StarterConfigServer {
    public static void main(String[] args) {
        SpringApplication.run(StarterConfigServer.class, args);
    }
}
```

启动，测试：`http://localhost:11000/demo01-test.properties`，能读出该文件，文本格式。

根据短横线能自动拆分(即一个或多个短横线可以用`-`替代，读到 json 格式：(返回完全一致)

- `http://localhost:11000/demo01/test/`
- `http://localhost:11000/demo01/test/master`

替代时，json有所不同，如 `http://localhost:11000/demo01-test/master`

如果没有一个短横线，要加default，如 `http://localhost:11000/redis/default` 对应 `redis.properties`

多文件查询：`http://localhost:11000/redis,datasource/default/master`。

##### 客户端例子

quickstart config client

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.9.RELEASE</version>
</parent>
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>Edgware.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

建 `bootstrap.properties` 如下：

- `spring.application.name=configclient` 默认读取以 `configclient` 为前缀的配置文件，除非下文有规定

- `spring.cloud.config.label=master`

- `spring.cloud.config.uri=http://localhost:11000` 暂时不高可用

- `spring.cloud.config.name=demo01`

- `spring.cloud.config.profile=test,test2`

  读取 `demo01-test.properties`, `demo01-test2.properties`

- `server.port=11100`

启动类：

```java
package cn.edu.scnu;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class StarterConfigClient {
    public static void main(String[] args) {
        SpringApplication.run(StarterConfigClient.class, args);
    }

    @Value("${name}")
    private String name;
    @Value("${location}")
    private String location;

    @RequestMapping("properties")
    public String getProperties() {
        return name + "/" + location;
    }
}

```

测试：`http://localhost:11100/properties`，发现正确读取了配置。

##### 高可用例子

服务端添加：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-eureka</artifactId>
</dependency>
```

```properties
spring.application.name=configserver
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka ,http://localhost:8762/eureka/
```

启动类加：

```java
@EnableEurekaClient
```

客户端：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-eureka</artifactId>
</dependency>
```

(删掉 `spring.cloud.config.uri`)

```properties
eureka.server.serviceUrl.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka
spring.cloud.config.discovery.enabled=true
spring.cloud.config.discovery.serviceId=configserver
```

上面的配置表示开启通过服务发现的方式找到配置中心的服务名称,进行调用底层restTemplate+ribbon http://配置中心服务名称/application/profile

启动类加：

```java
@EnableEurekaClient
```

记得开两个 eureka，然后启动，跟上面一样调试，实现高可用。

#### RabbitMQ

##### 理论

###### 消息队列

![img](img/clip_image002.jpg)

客户端/系统与系统间的通信时,可以通过消息队列实现高峰期无法处理的海量并发缓存--消峰限流;

也可以通过消息队列实现异步通信--通信解耦.

有时候一些方法的执行,第一步->第二步->第三步->第四步.由于第三步出错,导致整个方法执行失败;第三步并不是整个方法中最重要的部分;

例如:新增商品写缓存;新增描述;新增商品product;发消息:新增缓存; （交给异步去处理）

RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的,企业级的消息代理软件;
AMQP:sun公司对消息队列提出的规范(定义了一堆接口);
java的消息队列机制JMS(性能极低);
Erlang:一种并发语言(可以控制cpu核心,线程资源的语言).go也是并发语言.能将一个进程的并发性能处理到最强;Erlang是rabbitmq的核心组件交换机exchange的开发语言

###### 结构

客户端:一切连接rabbitmq的客户端可以分为两个角色:

- 生产者:消息生产者发送者
- 消费者:消息的接收者处理者

核心组件：

- 连接

  - connection:长连接（不能频繁销毁和创建的连接）
  - channel:信道,短连接

- 交换机组件exchange

  基于Erlang语言开发的,rabbitmq核心组件,处理客户端中生产端的所有消息的高并发。客户端并发能力不稳定（java处理并发的能力不稳定，所以要交给exchange处理，exchange是Erlang并发语言写的）。生产端的消息并不是直接发送给队列,队列能够接收处理消息的前提,就是交换机逻辑

- 队列queue

  真正处理消息的rabbitmq组件,消息的顺序排队,确定机制等,都由queue维护,没有队列,消息队列的技术不存在了，消息中的数据应该尽量精简到最小的单位

![img](img/clip_image002-16834584803442.jpg)

###### 交换机类型

rabbitmq应对不同的消息生产和消息消费的场景,使用不同的交换机类型:direct(routing路由模式),fanout(发布订阅),主题模式(topic,特殊的路由)

##### 场景

###### 简单模式

一对一

在一次消息的生产消费过程中,一个生产者对应一个消费者,形成一发一接的结构;

这里使用的是路由交换机,路由交换机需要绑定队列的名称作为路由Key(路由交换机可以使用默认的AMQP default交换机)

应用场景:消息软件,短信/微信

![image-20230507202033176](img/image-20230507202033176.png)

###### 工作模式

一发多接,资源争抢

在生产消息发送到队列,之后由多个消费端同时争抢.

谁的空闲率最大,谁争抢到的可能性就大;交换机可以是任意类型的(代码测试阶段还是AMQP default);

应用场景:抢红包.

![image-20230507202224938](img/image-20230507202224938.png)

###### 路由模式

路由模式不关心后端消费者数量,如果是一个消费者监听一个队列就是简单模式,如果是多个消费者监听一个队列就是争抢模式;

使用路由模式的交换机,可以自定义不同的路由key绑定不同队列,在消息中携带一个路由key,通过交换机后匹配后端的队列;

场景: error错误,通过筛选打印在开发人员的屏幕上

![image-20230507202832667](img/image-20230507202832667.png)

###### 发布订阅

一条消息不携带具体路由key,经过fanout模式的交换机发送给后端绑定的所有队列;

场景:邮件群发,广告(qq)

![image-20230507202859804](img/image-20230507202859804.png)

###### 主题模式

![image-20230507203054731](img/image-20230507203054731.png)

主题是一种特殊的路由模式,体现在后端队列绑定topic类型交换机时,可以不使用具体路由key,可以使用匹配符号

\*:表示一个字符串

\#:表示任意长度任意字符串

easymall.*:可以匹配到消息路由: easymall.product,easymall.user,

easymall.user.save(不能匹配到的)

easymall.#:可以匹配到消息路由:

easymall.product,easymall.dasfas.daskf.sdfklsad.sdf(只要以easymall.开始都能匹配上);

场景:多级消息发送接收的路由过程可以使用topic,快递

##### 搭建

###### 安装

rabbitmq核心组件exchange 基于erlang开发, linux需要安装erlang语言匹配rabbitmq的版本; 相当于tomcat启动依赖java,比如tomcat9必须匹配Java1.8以上

虚拟机下载 [erlang](https://www.erlang.org/downloads) 和 [rabbitmq](https://www.rabbitmq.com/which-erlang.html)

安装依赖：

```sh
yum install -y make gcc gcc-c++  glibc-devel m4 openssl openssl-devel ncurses-devel
```

安装 erlang，解压压缩包 (otp_src)，进去 make：

```sh
./configure --prefix=/usr/local/erlang
make && make install
```

检验安装：`cd /usr/local/erlang`

配全局 path：`vim /etc/profile`

```sh
export ER_LANG=/usr/local/erlang
export PATH=$PATH:$ER_LANG/bin
```

```sh
source /etc/profile
```

测试：`erl`

插件安装：rabbitmq,有些命令,底层运行需要依赖插件socat(提供了相对应的脚本命令)

```sh
yum -y install socat
```

rabbitmq-server-3.10.5-1.el8.noarch.rpm 版本要求在censtos8以上。我们选择rabbitmq-server-3.7.10-1.el6.noarch.rpm版本

```sh
rpm -ivh rabbitmq-server-3.7.10-1.el6.noarch.rpm --force --nodeps
```

模板复制：

```sh
cp /usr/share/doc/rabbitmq-server-3.7.10/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config
```

修改/新增一行开启用户登录权限：

```
{loopback_users, []}
```

直接开启web控制台监听插件(启动web应用) rabbitmq支持以视图页面web应用格式观察使用操作rabbitmq

```sh
rabbitmq-plugins enable rabbitmq_management
```

启动 rabbitmq

```sh
cd /usr/lib/rabbitmq/bin
./rabbitmq-server start
```

开开端口，开 15672 和 5672：

```sh
firewall-cmd --zone=public --add-port=15672/tcp --permanent && firewall-cmd --zone=public --add-port=5672/tcp --permanent && firewall-cmd --reload
```

测试访问(账号密码均为guest，15672是web默认访问端口客户端代码用5672)，测试：`http://192.168.126.129:15672/`

直接用 web 界面操作，点 admin-virtual hosts-add a new virtual host，输入 easymall。菜单栏看 exchanges 多了 7条数据。对应easymall虚拟主机。通过虚拟主机对交换机进行分组，只有绑定了easymall虚拟主机的用户，才能使用easymall虚拟主机对应的交换机，防止两个不同功能的用户用同个类型的交换机传两个完全不相关的数据，造成错乱

点击查看admin发现guest默认绑定easymall虚拟主机

admin-users，添加用户，账号 easymall 密码 123456，tags 点 admin 自动填充 administrator。all users点easymall，set permission 里 virtual host 选 easymall，点 set permission，可以看到 easymall 的 can access virtual hosts 多了 easymall。

##### 场景示例

###### 基建

quickstart 继承下文综合例子 easymall parent, 开依赖：

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

开 rabbitMQ

###### 简单模式

queueDeclare参数意义:

- queue:String类型,代表当前声明的queue名称
- durable:Boolean类型,表示当前队列创建之后,声明之后是否持久化(rabbitmq宕机之后是否重启恢复),true表示持久化宕机之后重启可以恢复队列,false表示不作持久化
- exclusive:Boolean类型,表示队列是否专属.true表示专属,只有当前连接对象创建的信道能够操作队列,其他连接对象不能,false表示不专属谁都能用。
- autoDelete:Boolean,是否自动删除,最后一个channel使用完毕队列,channel关闭之后,是否删除,true自动删,false表示不删
- arguments:Map类型,表示queue其他属性设置,例如队列可存储的消息长度,消息存储在队列是否有超时时间

basicPublish方法:发布消息

- exchange:交换机名称
- routingKey:消息发布时携带的路由key,交换机会根据路由key决定消息的目的队列
- props:BasicProperties类型,可以通过一个对象定义消息的各种属性,例如,可以指定消息也持久化(必须配合队列)
- body:消息体,byge[]数组

basicConsume:绑定消费者对象与队列,定义回执的逻辑;

channel.basicConsume(queue, autoAck, callback)

- queue:消费对象绑定的队列

- callback:回执使用的消费者对象

- autoAck:Boolean类型,是否自动回执确认(ack)

  true自动确认,一拿到消息就确认,false不自动确认,手动确认

```java
package cn.edu.scnu.rabbit.test;

import java.io.IOException;
import java.util.UUID;
import java.util.concurrent.TimeoutException;
import org.junit.Before;
import org.junit.Test;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.ConsumerCancelledException;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;
import com.rabbitmq.client.ShutdownSignalException;

@SuppressWarnings("deprecation")
public class SimpleMode {
    private Channel channel;

    @Before //Junit
    public void initChannel() {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("192.168.126.129");
        factory.setPort(5672);
        factory.setUsername("guest");
        factory.setPassword("guest");
        factory.setVirtualHost("/");
        Connection conn = null;
        try {
            conn = factory.newConnection();
        } catch (IOException | TimeoutException e) {
            e.printStackTrace();
        }
        try {
            channel = conn.createChannel();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private final String routingKey = "lr581";

    public void send() {
        String msg = "白茶abc@" + UUID.randomUUID().toString();
        try {
            channel.queueDeclare(routingKey, false, false, false, null);
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            channel.basicPublish("", routingKey, null, msg.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void consume() {
        QueueingConsumer consumer = new QueueingConsumer(channel);
        try {
            channel.basicConsume(routingKey, consumer);
        } catch (IOException e) {
            e.printStackTrace();
        }
        while (true) {// 实际代码使用nio
            try {
                Delivery delivery = consumer.nextDelivery();
                System.out.println(new String(delivery.getBody()));
            } catch (ShutdownSignalException | ConsumerCancelledException
                    | InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
    
    @Test
    public void test01() throws InterruptedException {
        send(); //每运行一次就加多一条
//        Thread.sleep(10);
        consume();
    }
}
```

```java
public void send2() throws IOException {
    channel.queueDeclare(routingKey, false, false, false, null);
    for (int i = 0; i < 10; ++i) {
        String msg = "msg" + i;
        channel.basicPublish("", routingKey, null, msg.getBytes());
    }
}

@Test
public void test02() throws IOException {
    send2();
    consume();// 按序到达
    // 如果启动多次test02，那么第一个启动的consume优先接收,其他consume当之前的关掉后会得到消息(消息不删除)
}
```



###### 工作模式

```java
public void consume2(String name) throws IOException, ShutdownSignalException,
ConsumerCancelledException, InterruptedException {
    QueueingConsumer consumer = new QueueingConsumer(channel);
    channel.basicConsume(routingKey, false, consumer);
    while (true) {
        System.out.println(name);
        Delivery delivery = consumer.nextDelivery();
        System.out.println(new String(delivery.getBody()));
        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
    }
}

@Test
public void test031() throws Exception {
    send2();
    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                consume2("1");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }).start();
    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                consume2("2");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }).start();
    for (;;)
        ;
    //都给了2或都给了1,不能各给一点,如果只开1就都给了1
}
```

###### 路由模式

如果 pos1 pos2 全部改成同一个字符串，就是发布订阅(全局广播)

```java
public void send3() throws IOException {
    channel.exchangeDeclare("direct01", "direct");
    channel.queueDeclare("heaven", false, false, false, null);
    channel.queueDeclare("hell", false, false, false, null);
    channel.queueBind("heaven", "direct01", "pos1");
    channel.queueBind("hell", "direct01", "pos2");
    channel.basicPublish("direct01", "pos1", null, "天国大魔境".getBytes());
    channel.basicPublish("direct01", "pos2", null, "地狱乐".getBytes());
}

public void consume31() throws IOException, ShutdownSignalException, ConsumerCancelledException,
InterruptedException {
    QueueingConsumer consumer = new QueueingConsumer(channel);
    channel.basicConsume("heaven", false, consumer);
    while (true) {
        Delivery delivery = consumer.nextDelivery();
        System.out.println("频道1:" + new String(delivery.getBody()));
        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
    }
}

public void consume32() throws IOException, ShutdownSignalException, ConsumerCancelledException,
InterruptedException {
    QueueingConsumer consumer = new QueueingConsumer(channel);
    channel.basicConsume("hell", false, consumer);
    while (true) {
        Delivery delivery = consumer.nextDelivery();
        System.out.println("频道2:" + new String(delivery.getBody()));
        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
    }
}

@Test
public void test4() throws Exception {
    send3();
    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                consume31();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }).start();
    consume32();
}
```

###### 主题模式

```java
public void send5() throws IOException {
    channel.queueDeclare("place1", false, false, false, null);
    channel.queueDeclare("place2", false, false, false, null);
    channel.queueDeclare("place3", false, false, false, null);
    channel.exchangeDeclare("topic01", "topic");
    String msc = "pwp可爱捏";
    channel.queueBind("place1", "topic01", "place1.#");
    channel.queueBind("place2", "topic01", "place1.street.#");
    channel.queueBind("place3", "topic01", "place1.street.block.*");
    channel.basicPublish("topic01", "place1.street.block.ac", null, msc.getBytes());
}
```



#### 综合例子

##### 基础工程

###### parent

创建 maven quick-start `artifact id` 为 `easymall-parent`，`group id` 是 `cn.edu.scnu`，source 删掉 `src/`，进 build path，删掉 jre system library, maven dependencies。点 pom.exe，编辑器点到 overview，把 packaging 改成 pom，或者，project 内一级标签：

```xml
<packaging>pom</packaging>
```

一级：

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.9.RELEASE</version>
</parent>
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <java.version>1.8</java.version>
</properties>
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>Edgware.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
        <version>3.3.2</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-eureka</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-ribbon</artifactId>
    </dependency>
</dependencies>
```

注：如果子项目pom报错，说找不到 parent，但能跑代码，则可以忽略不计。

可以考虑添加 dependencies management，不然疑似以后的子项目都要手动加一个:

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.27</version><!--$NO-MVN-MAN-VER$ -->
</dependency>
```

###### common-repository

然后造一个 quickstart `easymall-common-repository`，继承上述 pom，直接点overview 拉即可，或者手动点(记得删掉自己的group id)：

```xml
<parent>
    <groupId>cn.edu.scnu</groupId>
    <artifactId>easymall-parent</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</parent>
```

加点依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
	<version>8.0.27</version><!--$NO-MVN-MAN-VER$-->
</dependency>
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>1.3.0</version>
</dependency>
```

druid 连接池配置：

随便找一个有 starter 的项目如 order-n，点进 starter 主类

点击文件夹夹住有个浏览器的按钮(open type)，键入 `DatasourceAutoConfiguration`，然后打开，看到有 `@Bean` 的 `public DataSourceInitializer`，按住 ctrl 点击同名的，在 `public void init()` 下加断点，双击行数那里或者右击 toggle 一下。运行时点虫子一样的按钮(debug)-debug as-java application。然后看到会停在这里，一行绿色的。点击黄色上右下箭头(step over f6)，翻到 `if(this.dataSource == null)`，悬停，如果看到 `org.apache.tomcat.jdbc.pool` 就是 tomcat 连接池

回到 `DatasourceAutoConfiguration`，查看 `DataSourceProperties.class`，按住 ctrl 点击，看到有 `private Class<? extends DataSource> type;`。可以在配置文件中通过指定type的值，来定义自定义连接池。

根据 `spring.datasource.type`的连接池全路径名称，在 `springboot-order` 中配置新建连接池对象：

先在自己项目的的 pom文件中加入 Druid 数据源依赖，再在配置文件中指定type的值。

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.0.14</version>
</dependency>
```

在 `springboot-order` 的配置文件中配置连接池对象的全路径名称

```properties
pring.datasource.type=com.alibaba.druid.pool.DruidDataSource
```

再次 debug，在 variables properties 点看 type 则不为 null

在pom文件中加入Druid数据源依赖。

创建自定义初始化属性的配置类

```java
package cn.edu.scnu.repository.config;

import javax.sql.DataSource;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import com.alibaba.druid.pool.DruidDataSource;

@Configuration
@ConfigurationProperties("spring.datasource")
public class DataSourceInitConfig {
    private String driverClassName;
    private String url;
    private String username;
    private String password;
    private Integer maxActive; // 最大连接数
    private Integer maxIdle; // 最大空闲连接数
    private Integer initialSize; // 初始化连接数量
    private Integer minIdle; // 最大空闲数
    // 自定义创建的DruidDatasource对象返回给框架使用

    @Bean
    @Primary // 当容器中存在多个同类对象时,以Primary所在的优先级最高
    public DataSource initDruidDataSource() {
        DruidDataSource datasource = new DruidDataSource();
        datasource.setDriverClassName(driverClassName);
        datasource.setUrl(url);
        datasource.setUsername(username);
        datasource.setPassword(password);
        // 连接池初始化参数
        datasource.setInitialSize(initialSize);// 5
        datasource.setMaxActive(maxActive);// 200
        datasource.setMaxIdle(maxIdle);// 8
        datasource.setMinIdle(minIdle);// 3
        return datasource;
    }
    // setter&&getter
}
```

###### common-resources

在系统开发过程中,多个系统可能用到同一个工具类,这种也叫作共享资源,可以单独提取一个维护工具类**,**视图类**,**pojo类的common-resource工程

![image-20230327215223800](img/image-20230327215223800.png)

继承 parent，然后将 pojo, utils, vo 的类拷贝进来。

其他项目使用该仓库，直接 dependency 即可：

```xml
<dependency>
    <groupId>cn.edu.scnu</groupId>
    <artifactId>easymall-common-resources</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```

同理，对 repository 也是。

##### 商品系统

挂数据库(见砺儒云)。

###### 基建

> 如：
>
> ```mysql
> drop database easydb;
> CREATE DATABASE IF NOT EXISTS easydb  DEFAULT CHARACTER SET utf8;
> 
> USE easydb;
> 
> DROP TABLE IF EXISTS t_user;
> 
> CREATE TABLE t_user (
>   user_id char(36) NOT NULL COMMENT '用户id uuid 主键',
>   user_name varchar(100) NOT NULL COMMENT '用户登陆名称',
>   user_password varchar(32) NOT NULL DEFAULT '""' COMMENT '用户密码 md5',
>   user_nickname varchar(50) DEFAULT '上帝' COMMENT '用户昵称',
>   user_email varchar(30) DEFAULT '""' COMMENT '用户邮箱',
>   user_type int(11) DEFAULT '0' COMMENT '用户状态 0(普通用户),1(管理员),2(超级管理员)',
>   PRIMARY KEY (user_id),
>   UNIQUE KEY UN_user_name (user_name)
> ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
> 
> /*Data for the table t_user */
> insert  into t_user(user_id,user_name,user_password,user_nickname,user_email,user_type) 
> values ('f577f9f9-159e-4aaf-9332-fd7b294bc208','aa',md5('123'),'李筱雯','aa@163.com',0);
> 
> select * from t_user;
> 
> 
> DROP TABLE IF EXISTS t_product;
> CREATE TABLE t_product (
>   product_id char(36) NOT NULL DEFAULT '',
>   product_name varchar(100) DEFAULT NULL,
>   product_price double DEFAULT '0',
>   product_category varchar(100) DEFAULT '',
>   product_imgurl varchar(500) DEFAULT '',
>   product_num int(11) DEFAULT '0',
>   product_description varchar(255) DEFAULT '',
>   PRIMARY KEY (product_id),
>   UNIQUE KEY UN_product_name (product_name)
> ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
> 
> insert into t_product(product_id,product_name,product_price,product_category,product_imgurl,product_num,product_description) 
> values('05e20c1a-0401-4c0a-82ab-6fb0f37db397','荣耀Play5T','1199','手机数码','http://image.easymall.com/upload/5/e/d/5/4/5/e/b/5f0d34dc-157f-49ba-ad39-1b28927ba6ae_1005714.jpg',206,'22.5W超级快充 5000mAh大电池 6.5英寸护眼屏');
> ```

配置文件：(mysql8)

```properties
server.port=10001
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql:///easydb?useUnicode=true&characterEncoding=utf8&autoReconnect=true&allowMultiQueries=true
spring.datasource.username=root
spring.datasource.password=12345678
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.initialSize=5
spring.datasource.maxActive=50
spring.datasource.maxIdle=10
spring.datasource.minIdle=5

mybatis.typeAliasesPackage=com.easymall.common.pojo
mybatis.mapperLocations=classpath:mapper/*.xml
mybatis.configuration.mapUnderscoreToCamelCase=true
mybatis.configuration.cacheEnabled=false
spring.application.name=productservice
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/,http://localhost:8762/eureka/
```

>  /// 默认是本机 localhost:3306 (GPT)

如果发现 jar 里 mysql-connector 不是 8 的，那么强制覆盖一下父类的：

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
	<version>8.0.27</version><!--$NO-MVN-MAN-VER$-->
</dependency>
```

启动类：

```java
package cn.edu.scnu;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableEurekaClient
@MapperScan("cn.edu.scnu.product.mapper")
public class StarterProductCenter {
    public static void main(String[] args) {
        SpringApplication.run(StarterProductCenter.class, args);
    }

    @Bean
    @LoadBalanced
    public RestTemplate iniRestTemplateProduct() {
        return new RestTemplate();
    }
}

```

###### 商品分页查询

`src/main/resources/mapper/ProductMapper.xml`

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.edu.scnu.product.mapper.ProductMapper">
    <select id="queryTotal" resultType="int">
        select count(product_id) from t_product
    </select>
    <select id="queryByPage" resultType="Product">
        select * from t_product limit #{start},#{rows}
    </select>
</mapper>
```

```java
package cn.edu.scnu.product.mapper;

import java.util.List;
import org.apache.ibatis.annotations.Param;
import com.easymall.common.pojo.Product;//跟数据库结构一样的POJO

public interface ProductMapper {
    public Integer queryTotal();

    public List<Product> queryByPage(@Param("start") Integer start, @Param("rows") Integer rows);
}
```

```java
package cn.edu.scnu.product.service;

import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.easymall.common.pojo.Product;
import com.easymall.common.vo.EasyUIResult;
import cn.edu.scnu.product.mapper.ProductMapper;

@Service
public class ProductService {
    @Autowired
    private ProductMapper productMapper;

    public EasyUIResult productPageQuery(Integer page, Integer rows) {
        EasyUIResult result = new EasyUIResult();
        Integer total = productMapper.queryTotal();
        Integer start = (page - 1) * rows;
        List<Product> pList = productMapper.queryByPage(start, rows);
        result.setTotal(total);
        result.setRows(pList);
        return result;
    }
}
```

```java
package cn.edu.scnu.product.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.easymall.common.vo.EasyUIResult;

import cn.edu.scnu.product.service.ProductService;

@RestController
public class ProductController {
    @Autowired
    private ProductService productService;
    @RequestMapping("/product/manage/pageManage")
    public EasyUIResult productPageQuery(Integer page, Integer rows) {
        return productService.productPageQuery(page, rows);
    }
}
```

单元测试：`http://localhost:10001/product/manage/pageManage?page=1&rows=2`

返回的结果输出类似：

> ```json
> {
> 	"total": 29,
> 	"rows": [{
> 		"productId": "05e20c1a-0401-4c0a-82ab-6fb0f37db397",
> 		"productName": "荣耀Play5T",
> 		"productPrice": 1199.0,
> 		"productCategory": "手机数码",
> 		"productImgurl": "http://image.easymall.com/upload/5/e/d/5/4/5/e/b/5f0d34dc-157f-49ba-ad39-1b28927ba6ae_1005714.jpg",
> 		"productNum": 206,
> 		"productDescription": "22.5W超级快充 5000mAh大电池 6.5英寸护眼屏"
> 	}, {
> 		"productId": "09f47493-214d-44bc-927d-6ce0bf89a057",
> 		"productName": "爱疯9S(0315-01)",
> 		"productPrice": 1000.0,
> 		"productCategory": "手机数码",
> 		"productImgurl": "http://image.easymall.com/upload/5/2/3/4/7/8/d/c/1838eaa6-6459-420f-b8e2-6ea9f43c4b5e_dfd259ab-bcc7-43f6-a9d5-62872ff5671e.jpg",
> 		"productNum": 185,
> 		"productDescription": "爱疯9S(0315-01)"
> 	}]
> }
> ```

###### 网关

`easymall-micro-zuul` 项目，pom 如下：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>cn.edu.scnu</groupId>
	<artifactId>easymall-micro-zuul</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>easymall-micro-zuul</name>
	<url>http://maven.apache.org</url>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<java.version>1.8</java.version>
	</properties>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>1.5.9.RELEASE</version>
	</parent>
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>Edgware.RELEASE</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-eureka</artifactId>
		</dependency>

		<!--zuul相关依赖 -->
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-zuul</artifactId>
		</dependency>

		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>
	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
</project>
```

改 `application.properties`

```properties
server.port=9005
spring.application.name=serviceZuul
zuul.routes.zuul-product.path=/zuul-product/**
zuul.routes.zuul-product.serviceId=productservice
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/,http://localhost:8762/eureka/
```

启动类：

```java
package cn.edu.scnu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;

@SpringBootApplication
@EnableZuulProxy
public class StarterZuul {
    public static void main(String[] args) {
        SpringApplication.run(StarterZuul.class, args);
    }
}
```

在 nginx 根目录复制一个 `easymall-static`。hosts 加 `127.0.0.1 www.easymall.com`。配 nginx：

```nginx
server {
    listen 80;
    server_name www.easymall.com;
    location /{
        root easymall-static;
        index index.html;
    }	
    location /products {
        proxy_pass http://127.0.0.1:9005/zuul-product/product/manage;
        add_header 'Access-Control-Allow-Credentials' 'true';
        add_header 'Access-Control-Allow-Origin' '*'; 
    }
}
```

启动nginx，依次启动上次的两个 eureka-server，zuul 和 product 四个项目。运行测试：

```
http://www.easymall.com/products/pageManage?page=1&rows=5
```

根据上述逻辑，首先重定向到了 zuul，然后由于商品系统的 id 是 productservice，所以直接转发了过去。

###### 图片资源

添加hosts `127.0.0.1 image.easymall.com`，添加 nginx：

```nginx
server {
    listen       80;
    server_name  image.easymall.com;
    location / {
        root D:\\Temps\\easymall_image;
    }
}
```

对应路径为根目录丢一个教程里的 uploads 文件夹。重启 nginx，测试：

```
http://image.easymall.com/upload/2/6/4/a/a/5/2/3/ee6c796a-6333-4cd5-a06e-271d876aac8c_589577.jpg
```

###### 商品查询

`ProductMapper.xml` 追加：

```xml
<select id="queryById" parameterType="String" resultType="Product">
    select * from t_product where product_id=#{prodId}
</select>
```

`ProductMapper` 追加：

```java
public Product queryById(String prodId);
```

`ProductService` 追加：

```java
public Product queryById(String productId) {
    return productMapper.queryById(productId);
}
```

`ProductController` 追加：

```java
@RequestMapping("/product/manage/item/{prodId}")
public Product queryById(@PathVariable String prodId) {
    return productService.queryById(prodId);
}
```

根据接口描述，测试：

```
http://www.easymall.com/products/item/05e20c1a-0401-4c0a-82ab-6fb0f37db397
```

###### 商品新增

`ProductMapper.xml` 追加：

```xml
<insert id="productSave" parameterType="Product">
    insert into t_product(product_id, product_name, product_category, product_num, product_imgurl, product_price, product_description) values (#{productId}, #{productName}, #{productCategory}, #{productNum}, #{productImgurl}, #{productPrice}, #{productDescription})
</insert>
```

`ProductMapper` 追加：

```java
void productSave(Product product);
```

`ProductService` 追加：

```java
import java.util.UUID;
public void productSave(Product product) {
    product.setProductId(UUID.randomUUID().toString());
	productMapper.productSave(product);
}
```

`ProductController` 追加：

```java
import com.easymall.common.vo.SysResult;
@RequestMapping("/product/manage/save")
public SysResult productSave(Product product) {
    try {
        productService.productSave(product);
        return SysResult.ok();
    } catch (Exception e) {
        e.printStackTrace();
        return SysResult.build(201, e.getMessage(), null);
    }
}
```

###### 商品修改

```xml
<update id="productUpdate" parameterType="Product">
    update t_product set
    product_name=#{productName},
    product_category=#{productCategory},
    product_num=#{productNum},
    product_price=#{productPrice},
    product_description=#{productDescription},
    product_imgurl=#{productImgurl}
    where product_id=#{productId}
</update>
```

```java
void productUpdate(Product product);
```

```java
public void productUpdate(Product product) {
    productMapper.productUpdate(product);
}
```

```java
@RequestMapping("/product/manage/update")
public SysResult productUpdate(Product product) {
    try {
        productService.productUpdate(product);
        return SysResult.ok();
    } catch (Exception e) {
        e.printStackTrace();
        return SysResult.build(201, e.getMessage(), null);
    }
}
```

###### 图片上传

```nginx
location /uploadImg {
    proxy_pass http://127.0.0.1:9005/zuul-pic/pic/upload;
    add_header 'Access-Control-Allow-Credentials' 'true';
    add_header 'Access-Control-Allow-Origin' '*'; 
}
```

改网关配置：

```properties
zuul.routes.zuul-pic.path=/zuul-pic/**
zuul.routes.zuul-pic.serviceId=picservice
```

新 quick start：`easymall-microservice-pic`

```properties
server.port=10002
server.contextPath=/
spring.application.name=picservice
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka
pic.pathDirPrefix=d://Temps//easymall_image/
pic.urlPrefix=http://image.easymall.com/
```

```xml
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
<parent>
    <groupId>cn.edu.scnu</groupId>
    <artifactId>easymall-parent</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</parent>
```

```java
package cn.edu.scnu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class StarterPicCenter {
    public static void main(String[] args) {
        SpringApplication.run(StarterPicCenter.class, args);
    }
}
```

```java
package cn.edu.scnu.service;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.UUID;
import javax.imageio.ImageIO;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import com.easymall.common.utils.UploadUtil;
import com.easymall.common.vo.PicUploadResult;

@Service
public class PicService {
    @Value("${pic.pathDirPrefix}")
    private String pathDirPrefix;

    @Value("${pic.urlPrefix}")
    private String urlPreparePrefix;

    public PicUploadResult picUpload(MultipartFile pic) {
        PicUploadResult result = new PicUploadResult();
        String originName = pic.getOriginalFilename();
        String extName = originName.substring(originName.lastIndexOf("."));
        boolean isok = extName.matches(".(jpg|png|gif|JPG|PNG|GIF)");
        if (!isok) {
            result.setError(1);
            return result;
        }
        try { // 确认确实是图片
            BufferedImage bufImg = ImageIO.read(pic.getInputStream());
            bufImg.getWidth();
            bufImg.getHeight();
        } catch (Exception e) {
            e.printStackTrace();
            result.setError(1);
            return result;
        }
        String dir = "/" + UploadUtil.getUploadPath(originName, "upload") + "/";
        String pathDir = pathDirPrefix + dir;
        File file = new File(pathDir);
        if (!file.exists()) {
            file.mkdirs();
        }
        String urlPrefix = urlPreparePrefix + dir;
        String fileName = UUID.randomUUID().toString() + extName;
        try {
            pic.transferTo(new File(pathDir + fileName));
        } catch (Exception e) {
            e.printStackTrace();
            result.setError(1);
            return result;
        }
        result.setUrl(urlPrefix + fileName);
        return result;
    }
}
```

```java
package cn.edu.scnu.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;
import com.easymall.common.vo.PicUploadResult;
import cn.edu.scnu.service.PicService;

@RestController
public class PicController {
    @Autowired
    private PicService picService;
    @RequestMapping("/pic/upload")
    public PicUploadResult picUpload(MultipartFile pic) {
        return picService.picUpload(pic);
    }
}
```

测试：`http://www.easymall.com/manage.html`。疑似课程给的前端写的很烂，如果点什么地方没反应就刷新

遇到过需要重启来解决的问题：

1. eureka 主机 localhost 变 lr580
2. `netstat -ano | findstr 端口号` 找不到占用还是说占用

###### redis缓存

自己写的，不保证规范。

```properties
redis.ip=192.168.126.128
redis.port=6379
```

```java
@Value("${redis.ip}")
private String redis_ip;
@Value("${redis.port}")
private Integer redis_port;

static private ObjectMapper mapper = new ObjectMapper();

public EasyUIResult productPageQuery(Integer page, Integer rows) {
    EasyUIResult result = new EasyUIResult();
    Integer total = productMapper.queryTotal();
    Integer start = (page - 1) * rows;
    String key = "productlist_" + start + "_" + rows;
    Jedis jedis = new Jedis(redis_ip, redis_port, 10000);
    List<Product> pList = null;
    if (jedis.exists(key)) {
        System.out.println("Read page from Redis");
        String value = jedis.get(key);
        try {
            pList = mapper.readValue(value, new TypeReference<List<Product>>() {});
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    else {
        System.out.println("Read page from MySQL");
        pList = productMapper.queryByPage(start, rows);
        try {
            String value = mapper.writeValueAsString(pList);
            jedis.set(key, value);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
    }
    jedis.close();
    result.setTotal(total);
    result.setRows(pList);
    return result;
}

public String queryById(String productId) {
    String key = "product_" + productId;
    Jedis jedis = new Jedis(redis_ip, redis_port, 10000);
    if (jedis.exists(key)) {
        String value = jedis.get(key);
        jedis.close();
        System.out.println("Read by Redis");
        return value;
    }
    Product product = productMapper.queryById(productId);
    String value;
    try {
        value = mapper.writeValueAsString(product);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
        jedis.close();
        return "";
    }
    jedis.set(key, value);
    jedis.close();
    System.out.println("Read by MySQL");
    return value;
}
```

###### cluster

同用户系统(见下文)，拉配置和导依赖和加autowired。修改 `queryById` 为：

```java
public Product queryById(String productId) {
    String productKey = "product_query_" + productId;
    try {
        if (jedis.exists(productKey)) {
            String productJson = jedis.get(productKey);
            return MapperUtil.MP.readValue(productJson, Product.class);
        }
        Product product = productMapper.queryById(productId);
        String productJson = MapperUtil.MP.writeValueAsString(product);
        jedis.setex(productKey, 60 * 60 * 24 * 2, productJson);
        return product;
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}
```

```java
@RequestMapping("/product/manage/item/{prodId}")
public String queryById(@PathVariable String prodId) {
    Product product = productService.queryById(prodId);
    try {
        return MapperUtil.MP.writeValueAsString(product);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
        return "";
    }
}
```

上述逻辑会有一个错误：数据库中商品的价钱改变,由于缓存数据的存在.会导致至少2天用户查询的价钱是错误的

解决办法:只要商家对商品进行修改/删除,就将缓存数据删除，即：

```java
public void productUpdate(Product product) {
    jedis.del("product_query_" + product.getProductId());
    productMapper.productUpdate(product);
}
```

高并发下的缓存问题：商家修改商品之前删除了缓存,但是由于高并发的查询在还没有修改数据库之前,用户就把数据库的旧数据重新利用查询的逻辑,放到缓存中.这样就导致,商家修改后的数据又和缓存不一致了。

也就是说，修改时删掉了缓存，但是同时的查询又把旧数据写入了缓存。

<img src="img/image-20230502192803437.png" alt="image-20230502192803437" style="zoom:67%;" />

解决办法：在修改完毕之前:缓存的新增要上锁(redis上锁)，进一步修改：

```java
public void productUpdate(Product product) {
    String lock = "product_update_" + product.getProductId() + ".lock";
    String key = "product_query_" + product.getProductId();
    int leftTime = Integer.parseInt(jedis.ttl(key) + "");// 旧数据剩余时间
    jedis.setex(lock, leftTime, "");
    jedis.del(key);
    productMapper.productUpdate(product);
    jedis.del(lock);
}
```

同时修改 `queryById`：

```java
String lock = "product_update_" + productId + ".lock";
if (jedis.exists(lock)) {
    return productMapper.queryById(productId);
}
```

![image-20230502193336072](img/image-20230502193336072.png)

##### 用户系统

###### 基建

quickstart `easymall-microservice-user`，继承 parents,依赖两个 common。

```properties
server.port=10003
server.contextPath=/
spring.application.name=userservice
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/,http://localhost:8762/eureka/

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql:///easydb?useUnicode=true&characterEncoding=utf8&autoReconnect=true&allowMultiQueries=true
spring.datasource.username=root
spring.datasource.password=123
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.initialSize=5
spring.datasource.maxActive=50
spring.datasource.maxIdle=10
spring.datasource.minIdle=5

mybatis.typeAliasesPackage=com.easymall.common.pojo
mybatis.mapperLocations=classpath:mapper/*.xml
mybatis.configuration.mapUnderscoreToCamelCase=true
mybatis.configuration.cacheEnabled=false
```

```java
package cn.edu.scnu;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableEurekaClient
@MapperScan("cn.edu.scnu.user.mapper")
public class StarterUserCenter {
    public static void main(String[] args) {
        SpringApplication.run(StarterUserCenter.class, args);
    }
    
    @Bean
    @LoadBalanced
    public RestTemplate iniRestTemplateProduct() {
        return new RestTemplate();
    }
}
```

同理有 `UserController, UserService, UserMapper, UserMapper.xml`，autowired 下。

> 注意控制器是 `@RestController`，如果 `@Controller` 会挂。注意包是 `cn.scnu.edu.user.?`

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.edu.scnu.user.mapper.UserMapper">
</mapper>
```

nginx 修改并重启：

```nginx
location /user {
    proxy_pass http://127.0.0.1:9005/zuul-user/user/manage;
    add_header 'Access-Control-Allow-Credentials' 'true';
    add_header 'Access-Control-Allow-Origin' '*'; 
}
```

zuul 修改并重启：

```properties
zuul.routes.zuul-user.path=/zuul-user/**
zuul.routes.zuul-user.serviceId=userservice
```

###### 用户名存在检验

```xml
<select id="queryUsername" parameterType="String" resultType="int">
    select count(user_name) from t_user where user_name=#{userName};
</select>
```

```java
Integer queryUsername(String userName);
```

```java
public Integer checkUsername(String userName) {
    return userMapper.queryUsername(userName);
}
```

```java
@RequestMapping("/user/manage/checkUserName")
public SysResult checkUsername(String userName) {
    Integer exist = userService.checkUsername(userName);
    if (exist == 0) {
        return SysResult.ok();
    } else {
        return SysResult.build(201, "已存在", null);
    }
}
```

试运行，用 py 发 post：

```python
import requests
requests.post('http://www.easymall.com/user/checkUserName',data={'userName':'aa'}).text
```

###### 注册

```xml
<insert id="userSave" parameterType="User">
    insert into t_user(user_id, user_name, user_password, user_nickname, user_email) values (#{userId}, #{userName}, #{userPassword}, #{userNickname}, #{userEmail})
</insert>
```

```java
void userSave(User user);
```

```java
public void userSave(User user) {
    user.setUserId(UUID.randomUUID().toString());
    user.setUserPassword(MD5Util.md5(user.getUserPassword()));
    userMapper.userSave(user);
}
```

```java
@RequestMapping("/user/manage/save")
public SysResult userSave(User user) {
    Integer cnt = userService.checkUsername(user.getUserName());
    if (cnt > 0) {
        return SysResult.build(201, "用户名已存在", null);
    }
    try {
        userService.userSave(user);
        return SysResult.ok();
    } catch (Exception e) {
        e.printStackTrace();
        return SysResult.build(201, e.getMessage(), null);
    }
}
```

###### 登录

![image-20230419203852042](img/image-20230419203852042.png)

```xml
<select id="queryUserByNameAndPassword" parameterType="User" resultType="User">
    select * from t_user where user_name=#{userName} and user_password=#{userPassword}
</select>
```

```java
User queryUserByNameAndPassword(User user);
```

```java
@Value("${redis.ip}")
private String redis_ip;
@Value("${redis.port}")
private Integer redis_port;

public String doLogin(User user) {
    user.setUserPassword(MD5Util.md5(user.getUserPassword()));
    User exist = userMapper.queryUserByNameAndPassword(user);
    if (exist == null) {
        return "";
    }
    String ticket = UUID.randomUUID().toString();
    ObjectMapper mapper = new ObjectMapper();
    String userJson;
    try {
        userJson = mapper.writeValueAsString(exist);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
        return "";
    }
    Jedis jedis = new Jedis(redis_ip, redis_port);// 2000ms超时
    jedis.set(ticket, userJson);
    jedis.close();
    return ticket;
}
```

```java
@RequestMapping("/user/manage/login")
public SysResult doLogin(User user, HttpServletRequest request, HttpServletResponse response) {
    String ticket = userService.doLogin(user);
    if (!StringUtils.isEmpty(ticket)) {
        CookieUtils.setCookie(request, response, "EM_TICKET", ticket);
        // setCookie(request, response, cookieName, cookieValue, -1);
        return SysResult.ok();
    }
    return SysResult.build(201, "登陆失败", null);
}
```

启动eureka、zuul网关、product和ngin后，对登录进行测试，发现第一个登录功能在登录成功时，主页上没有显示登录账号，F12查看，发现没有存cookie，浏览器并不能接收cookie，原因是Zuul网关组件.默认对Cookie的头敏感，将cookie过滤掉了，我们只需要在Zuul网关的application.properties中添加敏感头为空的配置：

```properties
zuul.sensitive-headers=
```

调试查询 cookie：浏览器 f12 network 选择对应的请求，name 然后点右边菜单 cookies。或 application - storage - cookie。

第二步：根据 ticket 直接返回 user。

```java
public String queryUserJson(String ticket) {
    Jedis jedis = new Jedis(redis_ip, redis_port);
    String user = jedis.get(ticket);
    jedis.close();
    return user;
}
```

```java
@RequestMapping("/user/manage/query/{ticket}")
public SysResult checkLoginUser(@PathVariable String ticket) {
    String userJson = userService.queryUserJson(ticket);
    if (!StringUtils.isEmpty(userJson)) {
        return SysResult.build(200, "ok", userJson);
    }
    return SysResult.build(201, "", null);
}
```

之后由于 ticket 存在 cookie，所以一直可以免登录。如果需要调试，手动掐灭 cookie。

目前实现的缺点：

1. 代码中使用了new jedis,登录并发量多，导致内存溢出
2. 访问的redis是单机节点，节点down了，任何人都无法登录。所以单节点如果节点down了，任何人无法登录
3. 单节点，容易达到内存容量上限

###### 分片优化

```properties
spring.redis.shardedpool.nodes=192.168.126.128:6379,192.168.126.128:6380,192.168.126.128:6381
spring.redis.shardedpool.maxTotal=200
spring.redis.shardedpool.maxIdle=10
spring.redis.shardedpool.minIdle=2
```

配置类：

```java
package cn.edu.scnu.config;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import redis.clients.jedis.JedisShardInfo;
import redis.clients.jedis.ShardedJedisPool;

@Configuration
//读一个前缀的全部配置文件内容
@ConfigurationProperties(prefix = "spring.redis.shardedpool")
public class ShardedJedisPoolConfig {
    private List<String> nodes;
    private Integer maxTotal;
    private Integer maxIdle;
    private Integer minIdle;

    @Bean
    public ShardedJedisPool sjPoolInit() {
        List<JedisShardInfo> infoList = new ArrayList<>();
        for (String node : nodes) {
            String ip = node.split(":")[0];
            int port = Integer.parseInt(node.split(":")[1]);
            infoList.add(new JedisShardInfo(ip, port));
        }
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxIdle(maxIdle);
        config.setMinIdle(minIdle);
        config.setMaxTotal(maxTotal);
        return new ShardedJedisPool(config, infoList);
    }
    //getter setter
}
```

之后改 service

```java
@Autowired
private ShardedJedisPool pool;
private ObjectMapper mapper = MapperUtil.MP;

@SuppressWarnings("deprecation")
public String doLogin(User user) {
    ShardedJedis jedis = pool.getResource();
    try {
        user.setUserPassword(MD5Util.md5(user.getUserPassword()));
        User exist = userMapper.queryUserByNameAndPassword(user);
        if (exist == null) {
            return "";
        }
        String ticket = UUID.randomUUID().toString();
        String userJson = mapper.writeValueAsString(exist);
        jedis.set(ticket, userJson);
        return ticket;
    } catch (Exception e) {
        e.printStackTrace();
        return "";
    } finally {
        pool.returnResource(jedis);
    }
}

@SuppressWarnings("deprecation")
public String queryUserJson(String ticket) {
    ShardedJedis jedis = pool.getResource();
    try {
        return jedis.get(ticket);
    } catch (Exception e) {
        e.printStackTrace();
        return "";
    } finally {
        pool.returnResource(jedis);
    }
}
```

###### cluster

新建 `easymall_common_rediscluster`，将 `Redis-例子-cluster集成` 的配置类弄过去，配置文件里 `spring.redis.cluster` 内容拉到用户系统的配置文件，并导入依赖：

```xml
<dependency>
    <groupId>cn.edu.scnu</groupId>
    <artifactId>easymall-common-rediscluster</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```

对 `UserService` 直接绑定：

```java
@Autowired
private JedisCluster jedis;
```

对里面的方法，删掉 `ShardedJedis jedis = pool.getResource();` 和 finally。

###### 登录超时

之前的代码，用户的ticket的值一直保存在redis中。登录状态一直存在，不符合业务逻辑，必须设置登录超时时间：

//用户登录超时30分钟，在 `doLogin`：

```java
jedis.setex(ticket, 60*30, userJson);
```

如果写死了用户登录后30分钟超时，当用户连续操作了30分钟时，到达超时时间，用户操作了过程突然断开，用户必须重新登录后才可以继续操作，用户体验较差。

解决办法：制定一个阈值，用户登录后不断的操作,一旦时间到达这个阈值，就续租;

一旦发现某次访问redis后.ticket剩余时间少于10分钟,自动给延长5分钟

对 `queryUserJson` 添加：

```java
Long leftTime = jedis.ttl(ticket);
if (leftTime < 60 * 10L) {
    jedis.expire(ticket, (int) (leftTime + 60 * 5));
}
```

###### 登录顶替

登录顶替：当一个账号在另外一个地方登录时，直接清除前面的登录状态

![image-20230502185222623](img/image-20230502185222623.png)

即，判断当前用户是否已经存在如果是就把旧的删了，保存新的键值，在 `doLogin` 添加：

```java
// 上一次登录的ticket随机值是什么
String existTicket = jedis.get("user_logined_" + exist.getUserId());
if (StringUtils.isNotEmpty(existTicket)) {//可以syso登录顶替
    jedis.del(existTicket);
}
// 换一个随机值
jedis.setex("user_logined_" + exist.getUserId(), 60 * 30, ticket);
jedis.setex(ticket, 60 * 30, userJson);
```

测试：一台浏览器登录，另一台再登，后台输出登录顶替，前一台刷新发现登出

###### 同时登陆

以3个用户同时登陆为例，使用redis的list结构的数据用userId相关的字符串做list的key值,元素内容存储ticket的值,判断list的长度,一旦大于3,将进行顶替,lpush新增使用rpop顶替删除,rpush新增使用lpop删除

##### 配置系统

###### 仓库

如 `https://gitee.com/lr580/easymallconfig`，有文件夹 `lr580test`，有：

`datasouce.properties`

```properties
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql:///easydb?useUnicode=true&characterEncoding=utf8&autoReconnect=true&allowMultiQueries=true
spring.datasource.username=root
spring.datasource.password=1
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.initialSize=5
spring.datasource.maxActive=50
spring.datasource.maxIdle=10
spring.datasource.minIdle=5
mybatis.typeAliasesPackage=com.easymall.common.pojo
mybatis.mapperLocations=classpath:mapper/*.xml
mybatis.configuration.mapUnderscoreToCamelCase=true
mybatis.configuration.cacheEnabled=false
```

`redis.properties`

```properties
spring.redis.cluster.nodes=192.168.126.128:8000,192.168.126.128:8001,192.168.126.128:8002
spring.redis.cluster.maxTotal=200
spring.redis.cluster.maxIdle=8
spring.redis.cluster.minIdle=2
```

使用上文 `config-server`。

###### 商品系统

加依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>
```

备份原有 `application.properties` 为 `backup-application.properties` 后删掉，创建 `bootstrap.properties`，内容为：

```properties
server.port=10001
spring.application.name=productservice
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/,http://localhost:8762/eureka/
spring.cloud.config.label=master
spring.cloud.config.name=redis,datasource
spring.cloud.config.discovery.enabled=true
spring.cloud.config.discovery.serviceId=configserver
```

如果出现了端口被覆盖的问题，检查pom依赖项目或父项目`application.properties`有没有`server.port`等内容，如果有要删了。这是因为`application.properties`规定比`bootstrap.properties`后加载并且会覆盖所以当子类没有`application.properties`时父类的会进行覆盖。

###### 用户系统

加依赖。下面是自己的操作，模仿商品系统，有：

```properties
server.port=10003
server.contextPath=/
spring.application.name=userservice
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/,http://localhost:8762/eureka/
spring.cloud.config.label=master
spring.cloud.config.name=redis,datasource
spring.cloud.config.discovery.enabled=true
spring.cloud.config.discovery.serviceId=configserver
```

把 config 类 `ShardedJedisPoolConfig` 给扬了。

测试启动顺序：

- 清空redis持久化文件并启动redis集群
- 启动eureke和zuul
- 启动云配置服务
- 启动商品、用户和图片服务

##### 购物车系统

###### 基建

添加三个 common resources 基建，即 repository, resources, rediscluster。

配置：`bootstrap.properties`

```properties
server.port=10004
spring.application.name=cartservice
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/,http://localhost:8762/eureka/
spring.cloud.config.label=master
spring.cloud.config.name=redis,datasource
spring.cloud.config.discovery.enabled=true
spring.cloud.config.discovery.serviceId=configserver
```

```java
package cn.edu.scnu;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableEurekaClient
@MapperScan("cn.edu.scnu.cart.mapper")
public class StarterCartCenter {
    public static void main(String[] args) {
        SpringApplication.run(StarterCartCenter.class, args);
    }

    @Bean
    @LoadBalanced
    public RestTemplate initCartRestTemplate() {
        return new RestTemplate();
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.edu.scnu.cart.mapper.CartMapper">
</mapper>
```

```java
@Service
public class CartService {
    @Autowired
    private CartMapper cartMapper;
}
```

```java
@RestController
@RequestMapping("cart/manage")
public class CartController {
    @Autowired
    private CartService cartService;
}
```

nginx：

```nginx
location /cart {
    proxy_pass http://127.0.0.1:9005/zuul-cart/cart/manage;
    add_header 'Access-Control-Allow-Credentials' 'true';
    add_header 'Access-Control-Allow-Origin' '*'; 
}
```

zuul:

```properties
zuul.routes.zuul-cart.path=/zuul-cart/**
zuul.routes.zuul-cart.serviceId=cartservice
```

###### 查询

```xml
<select id="queryMyCart" parameterType="String" resultType="Cart">
    select * from t_cart where user_id=#{userId};
</select>
```

```java
import com.easymall.common.pojo.Cart;
List<Cart> queryMyCart(String userId);
```

```java
public List<Cart> queryMyCart(String userId) {
    return cartMapper.queryMyCart(userId);
}
```

```java
@RequestMapping("query")
public List<Cart> queryMyCart(String userId) {
    if (StringUtils.isEmpty(userId)) {
        return null;
    }
    return cartService.queryMyCart(userId);
}
```

单元测试：`http://localhost:10004/cart/manage/query?userId=f577f9f9-159e-4aaf-9332-fd7b294bc208`

联合测试：`http://www.easymall.com/mycart.html`

###### 加入购物车

```xml
<select id="queryOne" parameterType="Cart" resultType="Cart">
    select * from t_cart where user_id=#{userId} and product_id=#{productId};
</select>
<update id="updateNum" parameterType="Cart">
    update t_cart set num=#{num} where user_id=#{userId} and product_id=#{productId};
</update>
<insert id="saveCart" parameterType="Cart">
    insert into t_cart(user_id,product_id,product_name,product_image,product_price,num)values(#{userId},#{productId},#{productName},#{productImage},#{productPrice},#{num});
</insert>
```

```java
void updateNum(Cart exist);
void saveCart(Cart cart);
Cart queryOne(Cart cart);
```

```java
public void cartSave(Cart cart) {
    Cart exist = cartMapper.queryOne(cart);
    if (exist != null) {
        exist.setNum(exist.getNum() + cart.getNum());
        cartMapper.updateNum(exist);
        return;
    }
    String uri = "http://productservice/product/manage/item/" + cart.getProductId();
    Product product = restTemplate.getForObject(uri, Product.class);
    cart.setProductPrice(product.getProductPrice());
    cart.setProductName(product.getProductName());
    cart.setProductImage(product.getProductImgurl());
    cartMapper.saveCart(cart);
}
```

```java
@RequestMapping("save")
public SysResult cartSave(Cart cart) {
    try {
        cartService.cartSave(cart);
        return SysResult.ok();
    } catch (Exception e) {
        e.printStackTrace();
        return SysResult.build(201, "", null);
    }
}
```

###### 更新

```java
public void updateNum(Cart cart) {
    cartMapper.updateNum(cart);
}
```

```java
@RequestMapping("update")
public SysResult updateNum(Cart cart) {
    try {
        cartService.updateNum(cart);
        return SysResult.ok();
    } catch (Exception e) {
        e.printStackTrace();
        return SysResult.build(201, "", null);
    }
}
```

###### 删除

```xml
<delete id="deleteCart" parameterType="Cart">
    delete from t_cart where user_id=#{userId} and product_id=#{productId};
</delete>
```

```java
void deleteCart(Cart cart);
```

```java
public void deleteCart(Cart cart) {
    cartMapper.deleteCart(cart);
}
```

```java
@RequestMapping("delete")
public SysResult delete(Cart cart) {
    try {
        cartService.deleteCart(cart);
        return SysResult.ok();
    } catch (Exception e) {
        e.printStackTrace();
        return SysResult.build(201, "", null);
    }
}
```

##### 订单系统

###### 数据库

使用 mycat，配 `server.xml` 为：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mycat:server SYSTEM "server.dtd">
<mycat:server xmlns:mycat="http://io.mycat/">
    <system>
        <property name="defaultSqlParser">druidparser</property>
    </system>
    <user name="root">
        <property name="password">root</property>
        <property name="schemas">easydb</property>
    </user>
</mycat:server>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mycat:schema SYSTEM "schema.dtd">
<mycat:schema xmlns:mycat="http://io.mycat/" >
	<schema name="easydb" checkSQLschema="true" sqlMaxLimit="100">	
	<table name="t_order" primaryKey="order_id" dataNode="dn1,dn2" rule="order-by-murmur">
		<childTable name="t_order_item" primaryKey="id" joinKey="order_id" parentKey="order_id"/>
	</table>
	</schema>
	<dataNode name="dn1" dataHost="localhost1" database="easydb"/>
	<dataNode name="dn2" dataHost="localhost2" database="easydb"/>
	<dataHost name="localhost1" maxCon="1000" minCon="10" balance="0"
		writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
		<heartbeat>select user()</heartbeat>
		<writeHost host="hostM1" url="localhost:3306" user="root" password="Gu1+"/>
	</dataHost>
	<dataHost name="localhost2" maxCon="1000" minCon="10" balance="0"
		writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
		<heartbeat>select user()</heartbeat>
		<writeHost host="hostM1" url="192.168.126.129:3306" user="root" password="Gu1+"/>
	</dataHost>
</mycat:schema>
```

```xml
<tableRule name="custom-by-murmur">
    <rule>
        <columns>user_id</columns>
        <algorithm>murmur</algorithm>
    </rule>
</tableRule>
```

数据库与上述系统分离，互不影响。在每个虚拟机重建每个表，不要添加数据，表为：

```mysql
drop database easydb;
CREATE DATABASE IF NOT EXISTS easydb  DEFAULT CHARACTER SET utf8;
USE easydb;

CREATE TABLE t_order (
    order_id char(36) NOT NULL DEFAULT '',
    order_money double DEFAULT '0',
    order_receiverinfo varchar(255) DEFAULT '',
    order_paystate int(11) DEFAULT '0',
    order_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
    user_id char(36) DEFAULT NULL,
    PRIMARY KEY (order_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE t_order_item (
    id bigint(20) NOT NULL AUTO_INCREMENT,
    order_id char(100) DEFAULT NULL,
    product_id char(36) DEFAULT NULL,
    num int(11) DEFAULT '0',
    product_image varchar(500) DEFAULT NULL,
    product_name varchar(100) DEFAULT NULL,
    product_price double DEFAULT NULL,
    PRIMARY KEY (id)
) ENGINE=InnoDB AUTO_INCREMENT=138 DEFAULT CHARSET=utf8;
```

然后开 mycat，在 mycat 里导入全部数据，自动分片。查询测试。

###### 基建

继承 parent，导入两个 common，不用云配置，使用下面配置：

```properties
server.port=10005
spring.application.name=orderservice
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/,http://localhost:8762/eureka/

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://192.168.126.128:8066/easydb?useUnicode=true&characterEncoding=utf8&autoReconnect=true&allowMultiQueries=true
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.initialSize=5
spring.datasource.maxActive=50
spring.datasource.maxIdle=10
spring.datasource.minIdle=5

mybatis.typeAliasesPackage=com.easymall.common.pojo
mybatis.mapperLocations=classpath:mapper/*.xml
mybatis.configuration.mapUnderscoreToCamelCase=true
mybatis.configuration.cacheEnabled=false
```

懂的都懂：

```java
package cn.edu.scnu;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableEurekaClient
@MapperScan("cn.edu.scnu.order.mapper")
public class StarterOrderCenter {
    public static void main(String[] args) {
        SpringApplication.run(StarterOrderCenter.class, args);
    }
    
    @Bean
    @LoadBalanced
    public RestTemplate initCartRestTemplate() {
        return new RestTemplate();
    }
}
```

```java
package cn.edu.scnu.order.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import cn.edu.scnu.order.service.OrderService;

@RestController
@RequestMapping("/order/manage")
public class OrderController {
    @Autowired
    private OrderService orderService;
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.edu.scnu.order.mapper.OrderMapper">
</mapper>
```

```xml
zuul.routes.zuul-order.path=/zuul-order/**
zuul.routes.zuul-order.serviceId=orderservice
```

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.49</version><!-- $NO-MVN-MAN-VER$ -->
</dependency>
```

```nginx
location /order {
    proxy_pass http://127.0.0.1:9005/zuul-order/order/manage;
    add_header 'Access-Control-Allow-Credentials' 'true';
    add_header 'Access-Control-Allow-Origin' '*'; 
}
```

###### 查询

```xml
<resultMap type="Order" id="OrderRM">
    <id property="orderId" column="order_id" />
    <collection property="orderItems" javaType="List" ofType="OrderItem" column="order_id" select="queryOrderItems">
    </collection>
</resultMap>
<select id="queryOrder" parameterType="String" resultMap="OrderRM">
    select * from t_order where user_id=#{userId};
</select>
<select id="queryOrderItems" parameterType="String" resultType="OrderItem">
    select * from t_order_item where order_id=#{orderId}
</select>
```

```java
List<Order> queryOrder(String userId);
```

```java
public List<Order> queryMyOrder(String userId) {
    return orderMapper.queryOrder(userId);
}
```

```java
@RequestMapping("query/{userId}")
public List<Order> queryMyOrder(@PathVariable String userId){
    //        System.out.println(userId);
    return orderService.queryMyOrder(userId);
}
```

###### 新增

不要尝试 xml for each，不成功也不报错(因为不报错找出错在这里花了很久)。所以分开：

```xml
<insert id="saveOrder" parameterType="Order"> insert into t_order
    (order_id,
    order_money, order_paystate, order_receiverinfo, order_time,
    user_id) values
    (#{orderId}, #{orderMoney}, #{orderPaystate},
    #{orderReceiverinfo},
    #{orderTime},
    #{userId});
</insert>
<insert id="saveOrderItem" parameterType="OrderItem">
    insert into t_order_item
    (order_id,product_id,num,product_name,product_image,product_price)
    values
    (#{orderId},#{productId},#{num},#{productName},#{productImage},#{productPrice})
</insert>
```

```java
void saveOrder(Order order);
void saveOrderItem(OrderItem orderItem);
```

```java
public void saveOrder(Order order) {
    String orderId = UUID.randomUUID().toString();
    order.setOrderId(orderId);
    order.setOrderTime(new Date());
    order.setOrderPaystate(0);
    orderMapper.saveOrder(order);
    for (OrderItem orderItem : order.getOrderItems()) {
        orderItem.setOrderId(orderId);
        orderMapper.saveOrderItem(orderItem);
    }
}
```

```java
@RequestMapping("save")
public SysResult saveOrder(Order order) {
    try {
        orderService.saveOrder(order);
        return SysResult.ok();
    } catch (Exception e) {
        e.printStackTrace();
        return SysResult.build(201, e.getMessage(), null);
    }
}
```

###### 删除

不能一个 delete 两条语句，必须分开写。

```xml
<delete id="deleteOrderItem" parameterType="String">
    delete from t_order_item where order_id=#{orderId};
</delete>
<delete id="deleteOrder" parameterType="String">
    delete from t_order where order_id=#{orderId};
</delete>
```

```java
void deleteOrder(String orderId);
void deleteOrderItem(String orderId);
```

```java
public void deleteOrder(String orderId) {
    orderMapper.deleteOrder(orderId);
    orderMapper.deleteOrderItem(orderId);
}
```

```java
@RequestMapping("delete/{orderId}")
public SysResult deleteOrder(@PathVariable String orderId) {
    try {
        orderService.deleteOrder(orderId);
        return SysResult.ok();
    } catch (Exception e) {
        e.printStackTrace();
        return SysResult.build(201, e.getMessage(), null);
    }
}
```

##### 秒杀系统

###### 消息队列基建

quick start - `easymall-microservice-seckill`，parent 和 resources 和 repository，添加

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

配置

```properties
spring.rabbitmq.host=192.168.126.129
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtualHost=/
```

配置类：

```java
package cn.edu.scnu.seckill.config;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitmqConfig {
    public static final String exName = "seckillEx";
    public static final String qName = "seckillQueue";
    public static final String routingKey = "seckill";
    
    @Bean
    public DirectExchange exInit() {
        return new DirectExchange(exName, false, false);
    }
    
    @Bean
    public Queue queueInit() {
        return new Queue(qName, false, false ,false);
    }
    
    @Bean
    public Binding bindInit() {
        return BindingBuilder.bind(queueInit()).to(exInit()).with(routingKey);
    }
}
```

主类：

```java
package cn.edu.scnu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class StartSeckillCenter {
    public static void main(String[] args) {
        SpringApplication.run(StartSeckillCenter.class);
    }
}
```

发送：

```java
package cn.edu.scnu.seckill.controller;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import cn.edu.scnu.seckill.config.RabbitmqConfig;

@RestController
public class SenderController {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @RequestMapping("send")
    public String sendMsg(String msg) {
        rabbitTemplate.convertAndSend(RabbitmqConfig.exName, RabbitmqConfig.routingKey, msg);
        return "success";
    }
}
```

接收：

```java
package cn.edu.scnu.seckill.consumer;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;
import cn.edu.scnu.seckill.config.RabbitmqConfig;

@Component
public class SeckillConsumer {
    @RabbitListener(queues = RabbitmqConfig.qName)
    public void processMsg(String msg) {
        System.out.println("消费端接收消息:" + msg);
    }
}
```

启动 rabbitmq:

```sh
cd /usr/lib/rabbitmq/bin
./rabbitmq-server start
```

启动项目单独做测试：(先不管 repository，即依赖里删了先，忽略 eureka 报错)

`http://localhost:8080/send?msg=你好再见`

###### 基建

前端接收秒杀请求的系统的线程处理速度要快，这单位时间的并发量才会提高。

windows 主机新增数据库：

```mysql
CREATE DATABASE seckill;

USE seckill;

DROP TABLE IF EXISTS seckill;
CREATE TABLE seckill (
    seckill_id bigint(20) NOT NULL AUTO_INCREMENT COMMENT '商品库存id',
    name varchar(120) NOT NULL COMMENT '商品名称',
    number int(11) NOT NULL COMMENT '库存数量',
    initial_price bigint(20) NOT NULL COMMENT '原价',
    seckill_price bigint(20) NOT NULL COMMENT '秒杀价',
    sell_point varchar(500) NOT NULL COMMENT '卖点',
    create_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '秒杀创建时间',
    start_time timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '秒杀开始时间',
    end_time timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '秒杀结束时间',
    PRIMARY KEY (seckill_id),
    KEY idx_create_time (create_time),
    KEY idx_start_time (start_time),
    KEY idx_end_time (end_time)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 COMMENT='秒杀库存表';
delete from seckill;
insert  into seckill(seckill_id,name,number,initial_price,seckill_price,sell_point,create_time,start_time,end_time) values (1,'oppo17',719,2000,1000,'1000元成功秒杀oppo10','2022-08-17 11:12:49','2023-05-09 13:13:49','2023-05-18 00:00:00'),(2,'荣耀10',80,1800,800,'800元成功秒杀荣耀10','2023-07-21 22:08:49','2023-07-23 00:00:00','2023-07-24 00:00:00'),(3,'iPhone10',60,1600,600,'600元成功秒杀iPhone6','2023-08-21 23:08:49','2023-08-24 00:00:00','2023-06-25 00:00:00'),(4,'小米4',40,1400,400,'400元成功秒杀小米7','2023-06-21 22:08:49','2023-06-25 00:00:00','2023-06-26 00:00:00'),(5,'vivo2',20,1200,200,'200元成功秒杀vivo2','2023-01-21 22:08:49','2023-06-26 00:00:00','2023-06-27 00:00:00'),(6,'魅族3',10,1000,100,'100元成功秒杀魅族1','2018-06-21 22:08:49','2023-01-27 00:00:00','2023-06-28 00:00:00');

select * from seckill;
DROP TABLE IF EXISTS success;

CREATE TABLE success (
    success_id bigint(20) NOT NULL AUTO_INCREMENT COMMENT '秒杀成功id',
    seckill_id bigint(20) NOT NULL COMMENT '秒杀商品id',
    user_id varchar(11) NOT NULL COMMENT '用户手机号',
    state tinyint(4) NOT NULL DEFAULT '-1' COMMENT '状态标志：-1：无效；0：成功；1：已付款；2：已发货',
    create_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '秒杀成功创建时间',
    PRIMARY KEY (success_id),
    KEY idx_create_time (create_time)
) ENGINE=InnoDB AUTO_INCREMENT=6382 DEFAULT CHARSET=utf8 COMMENT='秒杀成功明细表';

update seckill set start_time = '2022-8-23 11:45:14';
```

重新加上 repository 依赖，加上 rediscluster 依赖，创建基建：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.edu.scnu.seckill.mapper.SecMapper">
</mapper>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.edu.scnu.seckill.mapper.SucMapper">
</mapper>
```

开 `SecService` 和 `SecController`。

```properties
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql:///seckill?useUnicode=true&characterEncoding=utf8&autoReconnect=true&allowMultiQueries=true
spring.datasource.username=root
spring.datasource.password=1
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.initialSize=5
spring.datasource.maxActive=50
spring.datasource.maxIdle=10
spring.datasource.minIdle=5

mybatis.typeAliasesPackage=com.easymall.common.pojo
mybatis.mapperLocations=classpath:mapper/*.xml
mybatis.configuration.mapUnderscoreToCamelCase=true
mybatis.configuration.cacheEnabled=false

#redis config
spring.redis.cluster.nodes=192.168.126.128:8000,192.168.126.128:8001,192.168.126.128:8002
spring.redis.cluster.maxTotal=200
spring.redis.cluster.maxIdle=8
spring.redis.cluster.minIdle=2
```

启动 redis：

```sh
cd /home/software/redis-3.2.11/
rm -rf appendonly800* dump800* nodes-800*
redis-server 8000/redis-cluster.conf && redis-server 8001/redis-cluster.conf && redis-server 8002/redis-cluster.conf && redis-server 8003/redis-cluster.conf && redis-server 8004/redis-cluster.conf && redis-server 8005/redis-cluster.conf
cd src
./redis-trib.rb create --replicas 1 192.168.126.128:8000 192.168.126.128:8001 192.168.126.128:8002 192.168.126.128:8003 192.168.126.128:8004 192.168.126.128:8005
```

```properties
zuul.routes.zuul-seckill.path=/zuul-seckill/**
zuul.routes.zuul-seckill.serviceId=seckillservice
```

```nginx
location /seckills {
	proxy_pass http://127.0.0.1:9005/zuul-seckill/seckill/manage;
	add_header 'Access-Control-Allow-Credentials' 'true';
	add_header 'Access-Control-Allow-Origin' '*'; 
}
```

主类加：

```java
@EnableEurekaClient
@MapperScan("cn.edu.scnu.seckill.mapper")
```

###### 查询

sec mapper

```xml
<select id="queryAll" resultType="Seckill">
    select * from seckill;
</select>
<select id="queryOne" parameterType="long" resultType="Seckill">
    select * from seckill where seckill_id=#{seckillId}
</select>
```

```java
public List<Seckill> queryAll();
public Seckill queryOne(Long seckillId);
```

```java
public List<Seckill> queryAll() {
    return secMapper.queryAll();
}
public Seckill queryOne(String seckillId) {
    long seckillId_long = Long.parseLong(seckillId);
    return secMapper.queryOne(seckillId_long);
}
```

```java
@RestController
public class SecController {
    @Autowired
    private SecService secService;
    
    @RequestMapping("seckill/manage/list")
    public List<Seckill> queryAll(){
        return secService.queryAll();
    }
    
    @RequestMapping("seckill/manage/detail")
    public Seckill queryOne(String seckillId) {
        return secService.queryOne(seckillId);
    }
}
```

启动，测试 `http://www.easymall.com/seckill-list.html`

前端改改：`seckill-detail.html` (刷新即可马上生效)

```javascript
for(i=0;i<result.length;i++){
    str += "非常感谢您参与本次秒杀活动，恭喜手机号为"+result[i].userId+"的幸运用户<br/>";
}
```

###### 秒杀

```java
@Autowired
private RabbitTemplate client;
private static Random random = new Random();
@RequestMapping("seckill/manage/{seckillId}")
public SysResult startSeckill(@PathVariable Long seckillId) {
    System.out.println(seckillId);
    String userId = "180888" + (random.nextInt(89999) + 10000);
    String msg = userId + "/" + seckillId;
    client.convertAndSend(RabbitmqConfig.exName, RabbitmqConfig.routingKey, msg);
    return SysResult.ok();
}
```

测试：`http://www.easymall.com/seckills/1`

sec mapper

```xml
<update id="updateNum">
    update seckill set number=number-1 where
    #{nowTime} &lt; end_time and #{nowTime} &gt; start_time
    and seckill_id=#{seckillId} and number &gt; 0
</update>
```

```java
import java.util.Date;
import org.apache.ibatis.annotations.Param;
public int updateNum(@Param("seckillId") Long seckillId, @Param("nowTime") Date nowTime);
```

suc mapper

```xml
<insert id="saveSuc" parameterType="Success">
    insert into success(success_id, seckill_id, user_id, state, create_time)
    values (#{successId}, #{seckillId}, #{userId}, #{state},
    #{createTime})
</insert>
```

```java
public void saveSuc(Success success);
```

```java
@Component
public class SeckillConsumer {
    @Autowired
    private SecMapper secMapper;
    @Autowired
    private SucMapper sucMapper;

    @RabbitListener(queues = RabbitmqConfig.qName)
    public void processMsg(String msg) {
        System.out.println("消费端接收消息:" + msg);
        String userId = msg.split("/")[0];
        Long seckillId = Long.parseLong(msg.split("/")[1]);
        Date nowTime = new Date();
        int result = secMapper.updateNum(seckillId, nowTime);
        if (result == 0) {
            System.out.println("秒杀失败，售罄");
            return;
        }
        Success success = new Success();
        success.setUserId(userId);
        success.setCreateTime(nowTime);
        success.setState(1);
        success.setSeckillId(seckillId);
        sucMapper.saveSuc(success);
    }
}
```

测试：`http://www.easymall.com/seckills/1`

预期：有 success 在 `select * from success;`

###### 防超卖

使用redis中的数据类型list,将秒杀商品的个数对应元素提前存放到redis中,秒杀之前先rpop取出数据，取数据成功的人才能调用减库存逻辑

```java
@Component
public class SeckillConsumer {
    @Autowired
    private SecMapper secMapper;
    @Autowired
    private SucMapper sucMapper;
    @Autowired
    private JedisCluster cluster;

    @RabbitListener(queues = RabbitmqConfig.qName)
    public void processMsg(String msg) {
        System.out.println("消费端接收消息:" + msg);
        if (!cluster.exists("opposeckill")) {
            System.out.println("售罄");
            return;
        }
        String rpop = cluster.rpop("opposeckill");
        if (rpop == null) {
            System.out.println("售罄-");
            return;
        }
        String userId = msg.split("/")[0];
        Long seckillId = Long.parseLong(msg.split("/")[1]);
        Date nowTime = new Date();
        int result = secMapper.updateNum(seckillId, nowTime);
        if (result == 0) {
            System.out.println("秒杀失败，售罄");
            return;
        }
        Success success = new Success();
        success.setUserId(userId);
        success.setCreateTime(nowTime);
        success.setState(1);
        success.setSeckillId(seckillId);
        try {
            sucMapper.saveSuc(success);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

进 redis 手动拉数据 

```
redis-cli -c -p 8000
lpush opposeckill 1 1 1 1 1 
```

测试：`http://www.easymall.com/seckills/1/userPhone`
