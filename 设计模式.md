# 理论

## 基础

### 面向对象设计原则

#### 背景

可维护性 maintainability、可复用性 reuseability 是两个独立目标。

可维护同时提高可复用性面向对象设计原则的目的。

> 可维护低的软件特点：
>
> - 僵硬 rigidity。硬编码 hard coding 多，灵活性差，修改都要改源码。功能涉及模块多，系统改动大。
> - 脆弱 fragility。修改导致别的地方出错。
> - 复用率低 immobility。组成部分在同一或不同项目重复使用的能力差；甚至重用可能是简单的复制粘贴。
> - 黏度过高 viscosity。改动时不按照原始设计意图/框架比按照更容易。
>
> 好的系统设计：
>
> - 可扩展性 extensibility。新功能添加方便。
> - 灵活性 flexibility。修改时波及模块少。
> - 可插入性 pluggability。方便替换一个类为有相同接口的另一个类。
>
> 复用和可维护可能会冲突，如 A,B 依赖 C，A 需要 C 加功能，B 不允许 C 加，如果要可维护就要放弃复用 C。

重构 refactoring：不改变功能基础上，调整代码以改善质量，性能，使设计模式和架构更合理，提高扩展性维护性。

#### 概述

七大原则：

- 单一职责原则 SRP single responsibility principle
- 开闭原则 OCP open-closed principle
- 里氏代换原则 LSP Liskov substitution principle
- 依赖倒转原则 DIP dependency inversion principle
- 接口隔离原则 ISP interface segregation principle
- 合成复用原则 CRP composite reuse principle
- 迪米特法则 LoD law of demeter

![image-20230523110712551](img/image-20230523110712551.png)

> 关系：相互依赖、相互补充

#### 单一职责原则

定义：

- Every object should have a single responsibility, and that responsibility should be entirely encapsulated by the class.

  一个对象应该只包含单一的指责，并且该职责被完整地封装在一个类中。

- There should never be more than one reason for a class to change.

  就一个类而言，应该仅有一个引起它变化的原因。



最简单最难运用的原则。

类的职责越多，复用可能性越小，耦合高。职责包括：

- 数据职责。通过属性体现。
- 行为职责。通过方法体现。

将不同的变化原因(职责)封装在不同的类。如果多个职责总是同时变化，可以封装到同一个类。

例子：

![image-20230523111219710](img/image-20230523111219710.png)

![image-20230523111232253](img/image-20230523111232253.png)

#### 开闭原则

定义：

- Software entities should be open for extension, but closed for modification.

  一个软件实体应该对扩展开放，对修改关闭。

  即：模块可以在不被修改的前提下被扩展，不修改源码改变行为。

  其中，XML, properties 格式配置文件无需编译，不认为对配置文件修改时修改源代码。



最重要原则之一。

实现：抽象化设计。如接口，抽象类。具体类进行扩展，抽象类不改动。

> 可变性封装原则 EVP principle of encapsulation of variation: 找到系统可变因素并封装起来，尽量不将多种不同可变性混合在一起。
>
> 使得类个数急剧增长，增加系统复杂度。

百分百开闭很难做到，但尽可能实现。

里氏代换、依赖倒转等是开闭原则的实现方法。

例子：

![image-20230523111743990](img/image-20230523111743990.png)

![image-20230523111808576](img/image-20230523111808576.png)



#### 里氏代换原则

定义：

- If or each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.

  如果对每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有对象 o1 都代换 o2 时，程序 P 的行为没有变化，那么类型 S 是类型 T 的子类。

- Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.

  所有引用基类的地方必须能透明地使用其子类的对象。

即，能用基类的地方一定能换成用子类，而不产生任何错误和异常，反过来不一定成立。

> 需要注意：
>
> 1. 子类所有方法必须父类声明，或子类必须实现父类声明的所有方法。如子类有父类没声明的方法，认为违背了里氏代换。
> 2. 父类尽量是抽象类/接口。
> 3. java 编译器会检查程序是否符合里氏代换，但只是纯语法的有限检查。

例子：

![image-20230523113021084](img/image-20230523113021084.png)

![image-20230523113029345](img/image-20230523113029345.png)



#### 依赖倒转原则

定义：

- High level modules should not depend upon low level modules, bot should depend upon abstractions. Abstractions should not depend upon details, details should depend upon abstractions.

  高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

- Program to an interface, not an implementation.

  要针对接口编程，不要针对实现编程。

实现面向对象设计的主要机制，抽象化的具体实现。

实现方法：抽象类使用，具体类放配置文件(细节放元数据)。

> 类的耦合关系(依赖关系)：
>
> - 零耦合关系。
> - 具体耦合关系。具体类(可实例化的类)，一个对另一个实例直接引用。
> - 抽象耦合关系。关系双方至少一个是抽象类。
>
> 依赖倒转要求客户端依赖于抽象耦合。

里氏代换原则是依赖倒转原则的基础。

依赖注入(DI dependence injection)是将一个类的对象传入另一个类，注入时尽量用父类对象，运行时子类覆盖父类。

注入方法：

1. 构造注入 constrctor injection

   ![image-20230523123156396](img/image-20230523123156396.png)

2. 设值注入 setter injection

   ![image-20230523123253228](img/image-20230523123253228.png)

3. 接口注入 interface injection

   ![image-20230523123316128](img/image-20230523123316128.png)

例子：

![image-20230523123415238](img/image-20230523123415238.png)

![image-20230523123421977](img/image-20230523123421977.png)

#### 接口隔离原则

定义：

- Clients should not be forced to depend upon interfaces that they do not use.

  客户端不应该依赖那些他不需要的接口。

- Once an interface has gotten too 'fat' it needs to be split into smaller and more specific interfaces so that any clients of the interface will only know about the methods that pertain to them.

  一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需直到与之相关的方法即可。

即使用多个专门的接口，而不是单一的总接口。每个接口承担相对独立的角色，功能不多不少。

> 接口的两种理解：
>
> - 一个类型所具有的方法特征的集合。逻辑抽象。理解为角色。
> - 语言定义的接口，有严格的定义和结构。

![image-20230523125318765](img/image-20230523125318765.png)

![image-20230523125724688](img/image-20230523125724688.png)

#### 合成复用原则

又名 CARP Composition/Aggregate Reuse Principle

定义：

- Favor composition of objects over inheritance as a reuse mechanism.

  尽量使用对象组合，而不是继承来达到复用的目的。

> 两种复用机制对比：
>
> - 继承。简单，可以覆盖父类，易于扩展。破坏封装性，基类细节对子类可见，白箱复用。基类继承的实现静态，灵活性差。有限制(如不能final类)。
> - 组合/聚合。黑箱复用。耦合度低，成员对象变化对新对象影响不大。可以动态引用，灵活。

例子：

![image-20230523131117994](img/image-20230523131117994.png)

![image-20230523131131825](img/image-20230523131131825.png)

#### 迪米特法则

定义：

- Don't talk to strangers. 不要与陌生人说话。

- Talk only to your immediate friends. 只与你的直接朋友通信。

- Each unit should have only limited knowledge about other units: only units 'closely' related to the current unit.

  每个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

用于降低耦合度，类与类保持松散耦合。

> 对象的密切相关对象：
>
> - 当前对象本身
> - 参数形式传入到当前对象方法的对象
> - 当前对象的成员对象
> - 当前对象的成员对象是集合时，集合的元素
> - 当前对象所创建的对象

狭义法则：两个类若不必直接通信，不应该发生直接相互作用。如果需要调用，通过第三者转发。

![image-20230523131611361](img/image-20230523131611361.png)

根据法则，A 不允许调用 C，即不能 `a.method1().method2()`。

狭义法则缺点是增加大量的小方法散落在系统各个角落，不同模块通行效率降低，不容易协调模块。

广义法则：对对象之间的信息流量、流向、信息影响的控制，主要是对信息隐藏的控制。即：

> - 划分上，尽量创建松耦合类，使得修改对关联类影响波及不大。
> - 结构上，每个类尽量降低成员变量/函数的访问权限。
> - 设计上，只要可能就一个类设计成不变类。
> - 引用上，对其他对象的引用降到最低。

例子：

![image-20230523131948106](img/image-20230523131948106.png)

![image-20230523132000884](img/image-20230523132000884.png)

### 概述

#### 定义

> 模式是特定环境中解决问题的一种方案  A pattern is a solution to a problem in a context.
>
> GoF 四人组 Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides

设计模式 design pattern 是一套被反复利用、多数人知晓的、经过分类编目的、代码设计经验的总结。

> 目的：可重用代码、更容易被理解、提高可靠性。

> 软件模式有四部分构成：问题描述、前提条件(环境/约束条件)、解法、效果。
>
> ![image-20230523132859989](img/image-20230523132859989.png)

> - 模式名称 pattern name
> - 问题 problem。设计中存在的问题和原因，先决条件等。
> - 解决方案 solution。模式的组成部分，相互关系，职责，协作方式。类图+核心代码。
> - 效果 consequences。优缺点分析。
> - 别名、分类、实用性、角色、实例、应用、扩展。



> 模式不孤立存在，可以相互组合多个模式设计同一个系统
>
> 设计模式的优点：
>
> - 便于沟通交流，降低理解难度。
> - 重用成功的设计更容易，避开不可重用的方案。
> - 设计更灵活，易于修改。
> - 提高开发效率和软件质量，节约成本。
> - 助于理解面向对象思想，提高设计水平。

#### 分类

GoF 有 23 种设计模式。

根据目的，分为：

- 创建型 creational 主要用于创建对象
  - > 简单工厂模式 Simple Factory Pattern / 静态工厂方法 Static Factory Method
  - 工厂方法模式 factory method / 虚拟构造器模式 virtual constructor / 多态工厂模式 polymorphic factory
  - 抽象工厂模式 abstract factory / Kit 模式
  - 建造者模式 builder / 生成器模式
  - 原型模式 prototype
  - 单例模式 singleton
- 结构型模式 structural 处理类或对象的组合
  - 适配器模式 adapter
  - 桥接模式 bridge
  - 组合模式 composite
  - 装饰模式 decorator
  - 外观模式 facade
  - 享元模式 flyweight
  - 代理模式 proxy
- 行为型模式 behavioral 描述对类或对象怎样交互和怎样分配职责
  - 职责链模式 chain of responsibility
  - 命令模式 command
  - 解释器模式 interpreter
  - 迭代器模式 iterator
  - 中介者模式 mediator
  - 备忘录模式 memento
  - 观察者模式 observer
  - 状态模式 state
  - 策略模式 strategy
  - 模板方法模式 template method
  - 访问者模式 visitor

根据范围，分为：

- 类模式。处理类和子类的关系。编译时确定，静态的。
- 对象模式。对象间的关系，动态。根据合成复用原则，这种模式更多。

![image-20230523211248718](img/image-20230523211248718.png)

> 简单工厂模式也是类创建型模式

![image-20230523211258224](img/image-20230523211258224.png)

![image-20230523211440228](img/image-20230523211440228.png)

![image-20230523211450983](img/image-20230523211450983.png)

#### 创建型模式

关注创建过程，将对象的创建和使用分离，使用对象时无需知道对象的创建细节。相同的创建过程可以多次复用，修改二者中的一个对另一个造成很小影响。

创建型模式简化了创建复杂对象的过程，类比想要获得苹果，手动创建需要自己种，使用创建型模式就像是直接去买。

![image-20230523234041924](img/image-20230523234041924.png)

#### 结构型模式

#### 行为型模式

## 创建型模式

### 简单工厂模式

#### 概念

简单工厂模式/静态工厂模式。类创建型模式。

不属于 GoF。

创建一些来自于相同父类的类的实例，专门定义一个类来创建，传入不同参数获得不同对象。

![image-20230523234141710](img/image-20230523234141710.png)

![image-20230523234347969](img/image-20230523234347969.png)

- `Factory` 工厂角色 工厂类，核心
- `Product` 抽象产品角色
- `ConcreteProduct` 具体产品角色



扩展：工厂类可以由抽象产品角色扮演，抽象产品类写静态工厂方法。

![image-20230524002003205](img/image-20230524002003205.png)

有些情况下，工厂、抽象产品、具体产品可以合并，既是工厂，又通过静态工厂方法创建自己的实例。

#### 评价

优点：

1. 责任分割，客户端不用实现创建产品对象，只消费产品。
2. 无需知道具体产品类名，只需要知道参数，减少使用者记忆量。
3. 引入配置文件，在不修改客户端代码时可以更换和增加新的产品类，提高灵活性。

缺点：

1. 工厂类若不能正常工作，整个系统受到影响。(耦合度高)

2. 增加类的个数，增加复杂度和理解难度。

3. 扩展困难，新产品需要修改工厂逻辑。产品多逻辑复杂，不利于扩展维护。违反了开闭原则。

4. 静态工厂方法，工厂角色无法继承。

   即 `Super obj = Sub(); obj.f()` 调用的一定是父类的静态方法 `f`。

适用环境：

1. 产品类别少。
2. 客户端只需要知道工厂类参数，不需要关心如何创建对象甚至类名。

#### 例子

##### 静态

支付方法选择

抽象支付方法：

![image-20230523234546455](img/image-20230523234546455.png)

具体支付方法：

![image-20230523234604052](img/image-20230523234604052.png)

![image-20230523234612066](img/image-20230523234612066.png)

工厂：

![image-20230523234630046](img/image-20230523234630046.png)

##### XML

![image-20230523234958971](img/image-20230523234958971.png)

![image-20230523235004716](img/image-20230523235004716.png)

![image-20230523235008152](img/image-20230523235008152.png)

![image-20230523235023301](img/image-20230523235023301.png)

![image-20230523235041890](img/image-20230523235041890.png)

![image-20230523235507584](img/image-20230523235507584.png)

![image-20230523235528163](img/image-20230523235528163.png)

XML 代码参考：(工厂模式)

```java
package util;

import java.io.File;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class XMLUtil {
    /**
     * 
     * @param path URL of a XML file
     * @return the Class of the XML described
     * @exampleXML like below
     * <?xml version="1.0"?>
       <config>
           <className>lab1_2.FileLogFactory</className>
        </config>
     * it gets FileLogFactory
     */
    public static Object getBean(String path) {
        try {
            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = dFactory.newDocumentBuilder();
            Document doc = builder.parse(new File(path));
            NodeList nl = doc.getElementsByTagName("className");
            Node classNode = nl.item(0).getFirstChild();
            String cName = classNode.getNodeValue();
            
            @SuppressWarnings("rawtypes")
            Class c = Class.forName(cName);
            Object obj = c.newInstance();
            return obj;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

下面文件放在 `src` 的 `lab1_2` 包内。

```xml
<?xml version="1.0"?>
<config>
    <className>lab1_2.DatabaseLogFactory</className>
</config>
```

调用：

```java
package lab1_2;

import util.XMLUtil;

//客户端测试类
class lab1_2 {
    public static void main(String args[]) {
        LogFactory factory;
        Log log;
        factory = (LogFactory) XMLUtil.getBean("src/lab1_2/lab1_2.xml");
        log = factory.createLog();
        log.writeLog();
    }
}
```

##### 基本2

![image-20230523235746369](img/image-20230523235746369.png)

![image-20230523235759333](img/image-20230523235759333.png)

![image-20230523235805166](img/image-20230523235805166.png)

![image-20230523235809890](img/image-20230523235809890.png)

![image-20230523235822103](img/image-20230523235822103.png)

![image-20230523235903615](img/image-20230523235903615.png)

![image-20230523235914882](img/image-20230523235914882.png)

![image-20230523235920052](img/image-20230523235920052.png)

##### JDK

`java.text.DateFormat`，格式化本地日期或时间，对多种语言和格式很有用。

其 `getDateInstance()` 是静态工厂方法：

![image-20230524000536912](img/image-20230524000536912.png)



密钥生成的 `javax.crypto.KeyGenerator` 和 `java.security.KeyPairGenerator` 类生成对称、非对称密钥，都有 `getInstance()` 静态工厂方法，根据参数返回密钥生成器：

![image-20230524000809128](img/image-20230524000809128.png)

加密解密的密码器的创建也是简单工厂模式：

![image-20230524000832980](img/image-20230524000832980.png)

该例子工厂、抽象产品、具体产品合并。

### 工厂方法模式

#### 概念

定义：

- Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

  工厂父类定义创建产品对象的公共接口，工厂子类负责生成具体产品对象，实例化延迟到子类。

![image-20230524133740283](img/image-20230524133740283.png)

结构：

![image-20230524134210700](img/image-20230524134210700.png)

- `Product` 抽象产品
- `ConcreteProduct` 具体产品
- `Factory` 抽象工厂
- `Concretefactory` 具体工厂

> 如：
>
> ![image-20230524135132493](img/image-20230524135132493.png)



扩展：

1. 抽象工厂角色可以定义多个工厂方法
2. 产品对象可以重复使用。工厂对象将创建过的产品保存到集合里，根据客户对产品的请求查询，如果有直接返回，没有创建一个并加入集合。即享元模式的设计思想。
3. 如果只返回一个具体产品对象，就不是工厂方法模式了。如果只有一个具体工厂类，可以退化成简单工厂模式。

#### 评价

优点：

1. 隐藏哪个具体产品类被实例化的细节，用户只需要关心所需产品对应的工厂，无需关心细节和具体产品类名。
2. 多态性设计，所有具体工厂同一抽象父类。
3. 增加新产品不需要修改接口、客户端、其他工厂和产品，符合开闭原则。

缺点：

1. 每次加产品，要成对添加类的个数，复杂度多，编译运行的类多，额外开销。
2. 抽象层理解难度大，DOM，反射实现难度大。

适用环境：

1. 客户端不需要知道具体类名，只需要知道创建产品的工厂类。
2. 类通过子类指定创建哪个对象，利用多态和里氏代换原则，容易扩展。
3. 使用时不需要知道哪个工厂子类创建，需要再动态指定。类名存储在配置文件/数据库。



#### 例子

##### 基本

支付方法是产品。

![image-20230524134449360](img/image-20230524134449360.png)

![image-20230524134456699](img/image-20230524134456699.png)

![image-20230524134527312](img/image-20230524134527312.png)

![image-20230524134547508](img/image-20230524134547508.png)

![image-20230524134640404](img/image-20230524134640404.png)

![image-20230524134738450](img/image-20230524134738450.png)

##### 基本2

![image-20230524134759588](img/image-20230524134759588.png)

![image-20230524134806205](img/image-20230524134806205.png)

![image-20230524134810348](img/image-20230524134810348.png)

![image-20230524134822041](img/image-20230524134822041.png)

![image-20230524134829683](img/image-20230524134829683.png)

![image-20230524135006440](img/image-20230524135006440.png)

![image-20230524135012941](img/image-20230524135012941.png)

![image-20230524135025624](img/image-20230524135025624.png)

##### JDK

`java.util.Collection` 接口定义的工厂方法 `iterator()` 返回的 `Iterator`。

![image-20230524142143116](img/image-20230524142143116.png)

![image-20230524142601436](img/image-20230524142601436.png)



消息服务 JMS(Java Messaging Service) 让 java 能通过支持 JSM 标准的 MOM(message oriented middleware)创建和交换消息。JSM 实现时使用工厂方法模式，创建 Connection 连接对象，Session 会话对象，Sender 消息发送者对象等：

![image-20230524143523926](img/image-20230524143523926.png)



JDBC 使用工厂方法模式创建连接对象 Connection，语句对象 Statement 和结果集对象 ResultSet：

![image-20230524143642053](img/image-20230524143642053.png)



### 抽象工厂模式

#### 概念

定义：

- Provide an interface for creating families of related or dependent objects without specifying their concrete classes.

  提供一个创建一系列相关或相互依赖的对象的接口，而无需指定它们具体的类。

抽象工厂模式是工厂模式里最为抽象、最具一般性的形态。面对多个产品等级结构。

产品等级结构：产品的继承结构。

产品族：同一个工厂生产的，位于不同产品等级结构的一组产品。

![image-20230525142055251](img/image-20230525142055251.png)

![image-20230525143226224](img/image-20230525143226224.png)

- `AbstractFactory` 抽象工厂
- `ConcreteFactory` 具体工厂
- `AbstractProduct` 抽象产品
- `ConcreteProduct` 具体产品

> 若每个具体工厂类只创建一个产品对象，退化为工厂方法模式。如果抽象工厂、具体工厂合并，提供同一工厂，静态方法，退化为简单工厂模式。

#### 评价

优点：

1. 隔离了具体类生成，客户不需要知道什么被创建，更换具体工厂相对容易。改变具体工厂实例就能改变软件系统行为，高内聚低耦合。
2. 产品族一起工作，始终只使用同一个产品族的对象。
3. 增加新的具体工厂、产品族方便，无需修改已有系统，符合开闭原则。

缺点：

1. 添加产品对象时(产品族加种类)，难以扩建抽象工厂。

适用：

1. 系统不依赖产品类实例如何被创建、组合、表达的细节。创建和使用解耦。
2. 多于一个产品族，每次只使用一个产品族，配置文件改变产品族。方便增加新产品族。
3. 属于同一个产品组的产品一起使用。
4. 系统提供产品类的库，所有产品以同样接口出现，客户端不依赖具体实现。

> 开闭原则的倾斜性：
>
> - 增加产品族，支持开闭原则，已有代码无需修改。
> - 增加新的产品等级结构，需要修改抽象工厂类，所有工厂类的生产新产品方法，不能很好支持开闭原则。



#### 例子

##### 基本

![image-20230525151248949](img/image-20230525151248949.png)

![image-20230525151425078](img/image-20230525151425078.png)

![image-20230525151357787](img/image-20230525151357787.png)

![image-20230525151403902](img/image-20230525151403902.png)

![image-20230525151416834](img/image-20230525151416834.png)

![image-20230525151843424](img/image-20230525151843424.png)

![image-20230525151850417](img/image-20230525151850417.png)

![image-20230525151920265](img/image-20230525151920265.png)

![image-20230525151931320](img/image-20230525151931320.png)

![image-20230525151939635](img/image-20230525151939635.png)

![image-20230525151957263](img/image-20230525151957263.png)

![image-20230525152056348](img/image-20230525152056348.png)

> ![image-20230525145711719](img/image-20230525145711719.png)
>
> ![image-20230525150657938](img/image-20230525150657938.png)

> ![image-20230525151051680](img/image-20230525151051680.png)
>
> ![image-20230525151145338](img/image-20230525151145338.png)

> ![image-20230525152122296](img/image-20230525152122296.png)



##### JDK

AWT(抽象窗口工具包)使用抽象工厂模式，使用 look and feel 机制支持不同操作系统。

> 软件系统更换界面主题，按钮、背景色等一起发生改变，可以使用抽象工厂模式。



### 建造者模式

#### 概念

定义：

- Separate the construction of a complex object from its representation so that the same construction process can create different representations.

  将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

需求：复杂对象拥有一系列成员属性，可能存在限制条件(如未赋值对象不能使用；必须按照某个顺序赋值)，成员的组合过程复杂，被外部化到一个建造者对象里，返回建造完毕的完整对象，无需关心包含的属性和组装方式。

![image-20230526190908321](img/image-20230526190908321.png)

- `Builder` 抽象建造者
- `ConcreteBuilder` 具体建造类
- `Product` 产品角色
- `Director` 指挥者/导演类。客户端与之交互。决定建造顺序，调用多个 `Builder` 方法。

扩展：

1. 若只有一个具体建造者，可以省略抽象建造者。
2. 省略抽象建造者时，可以让具体建造者同时当指挥者。

#### 评价

优点：

1. 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品角色。
2. 具体建造者相对独立，方便替换/增加。
3. 精细控制产品创建过程，将复杂产品创建步骤分解在不同方法中，使得创建过程更加清晰，方便使用程序控制创建过程。
4. 增加具体建造者不需要改类库，针对抽象编程，扩展方便，符合开闭原则。

缺点：

1. 建造者创建的产品需要有较多共同点，组成成分相似。差异大不适合用。
2. 产品内部若变化复杂，需要定义很多具体建造者类。

适用：

1. 产品有复杂内部结构，多个成员属性。
2. 产品属性相互依赖，指定生成顺序。
3. 创建过程独立于创建该对象的类，在指挥者类封装。
4. 隔离复杂对象的创建和使用，同一创建过程得到不同的产品。

> 如：地图组成部分，人物组成部分。

#### 例子

##### 基本

> ![image-20230526192356247](img/image-20230526192356247.png)
>
> ![image-20230526192402708](img/image-20230526192402708.png)
>
> ![image-20230526192413254](img/image-20230526192413254.png)
>
> ![image-20230526192959100](img/image-20230526192959100.png)

![image-20230526193007070](img/image-20230526193007070.png)

![image-20230526193024846](img/image-20230526193024846.png)

![image-20230526193135620](img/image-20230526193135620.png)

![image-20230526193215452](img/image-20230526193215452.png)

![image-20230526193231477](img/image-20230526193231477.png)

![image-20230526193239594](img/image-20230526193239594.png)

![image-20230526193248959](img/image-20230526193248959.png)

![image-20230526193254745](img/image-20230526193254745.png)



##### JDK

`JavaMail` 是一组 Java SE 扩展 API 类库，`Message` 和 `MimeMessage` 等都是退化建造者模式。

![image-20230526194744717](img/image-20230526194744717.png)

自行创建建造者：

![image-20230526195349500](img/image-20230526195349500.png)

### 原型模式

#### 概念

定义：

- Specify the kind off objects to create using a prototypical instance, and create new objects by copying this prototype.

  用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。

![image-20230527140002316](img/image-20230527140002316.png)

- `Prototype` 抽象原型类
- `ConcretePrototype` 具体原型类
- `Client` 客户类

两种形式：

- 浅克隆：普通成员变量值相同，对其他对象的引用仍指向原来的对象

  ![image-20230527141001299](img/image-20230527141001299.png)

- 深克隆：引用其他对象的变量指向被复制过的新对象

扩展：原型管理器。对有限个原型具体类，用哈希表存起来。

![image-20230527151925781](img/image-20230527151925781.png)

扩展：对相似对象(属性值大部分相同，小部分不同)，可以先克隆，再修改不同值。

#### 评价

优点：

1. 创建新对象实例复杂时，简化创建过程，提高创建效率。
2. 动态增加减少产品类，针对抽象编程，具体原型类写配置文件。
3. 简化创建结构，无需专门工厂类。
4. 深克隆保存对象状态，可以需要时使用/恢复。

缺点：

1. 对已有的类必须修改源代码，违背开闭原则。
2. 深克隆代码复杂。

适用：

1. 创建新对象成本大(时间，CPU，网络)可以通过复制。
2. 保存对象状态，状态变化很小或内存不大，可以原型+备忘录。很大则状态模式。
3. 避免分层次工厂类创建分层次对象，类的实例对象只有很少组合状态。



#### 例子

##### 基本

`Object` 提供 `clone` 方法。实现克隆的类实现 `Cloneable` 接口。否则调用 `clone` 方法就报错 `CloneNotSupportedException`。

![image-20230527140246772](img/image-20230527140246772.png)

![image-20230527140808828](img/image-20230527140808828.png)

满足：

1. 对任何对象 `x`，有 `x.clone()!=x`
2. 对任何对象 `x`，有 `x.clone().getClass()==x.getClass()`
3. 若 `equals()` 定义恰当，则 `x.clone().equals(x)` 成立

具体实现浅克隆办法：

1. 覆盖基类 `public clone()`。
2. 派生类 `clone()` 调用 `super.clone()`
3. 实现 `Cloneable` 接口

实现深克隆，通过序列化等方法。

序列化 `Serialization` 将对象写到流。写到流的对象是原对象的拷贝。再读出来。必须实现 `Serialization` 接口。

这两个接口都是空接口，又称标识接口，不定义方法，作用是告诉 JRE 这些接口的实现类是否具有某个功能。

##### 浅克隆

![image-20230527141630503](img/image-20230527141630503.png)

![image-20230527141723602](img/image-20230527141723602.png)

![image-20230527141749729](img/image-20230527141749729.png)

![image-20230527141834681](img/image-20230527141834681.png)

![image-20230527141855706](img/image-20230527141855706.png)

> false, true

##### 深克隆

![image-20230527141954394](img/image-20230527141954394.png)

![image-20230527142014029](img/image-20230527142014029.png)

![image-20230527142027573](img/image-20230527142027573.png)

![image-20230527142038533](img/image-20230527142038533.png)

> false ,false



##### JDK

> ctrl+c ctrl+v 的实现

`Struts2` 是 Java EE 框架之一，为了线程安全性，`Action` 对象使用原型模式，保证定义的变量无需加锁实现同步。

主流 Java EE 框架 Spring 里，原型模式创建新的 bean 实例，修改时对原有实例对象不造成任何影响。



##### 原型管理器

![image-20230527152012563](img/image-20230527152012563.png)

![image-20230527152041416](img/image-20230527152041416.png)

![image-20230527152047108](img/image-20230527152047108.png)

![image-20230527152056768](img/image-20230527152056768.png)

![image-20230527152117222](img/image-20230527152117222.png)

> false



##### 相似对象

某些属性值异同，复制后修改

![image-20230527152244266](img/image-20230527152244266.png)

![image-20230527152355780](img/image-20230527152355780.png)