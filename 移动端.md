# Android

## 基本概念

### 常识

创建于2003-10，现被 Google 收购。首个版本开始于 2008 。基于 Linux 内核。开源。

#### 系统架构

四层：

1. Linux 内核层，为硬件提供底层驱动，如显示、音频、蓝牙、电源等
2. 系统运行库层，通过 C/C++ 库提供特性支持。(早期 Dalvik 虚拟机，后期 ART运行环境)
3. 应用框架层。提供 API 。
4. 应用层。安装在手机上的应用程序。

![image-20220510142925781](img/image-20220510142925781.png)



#### 版本号

[官方介绍](http://developer.android.google.cn/about/dashboards)

![image-20220510143053644](img/image-20220510143053644.png)

![image-20220510143057566](img/image-20220510143057566.png)



#### 特点

四大组件：

- Activity 门面
- Service 后台
- BroadcastReceiver 广播
- ContentProvider 程序间共享数据

系统控件

SQLite 数据库

多媒体支持



### 开发环境

#### 安装

- JDK 即Java软件开发工具包
- Android SDK 开发工具包
- Android Studio 官方 IDE 

三者的集成： [下载地址](https://developer.android.google.cn/studio)

弹出无法访问 `add-on list` 就 cancel ，这是 Google 服务。

> 疑似 vscode 无法胜任



#### 使用

新建项目，选 empty activity ，语言选 Kotlin (或 Java) 。Minimum API level 是项目最低兼容版本，一般为 API 21。不支持 instance apps ，启用 AndroidX 。

一个安卓+手机的图标是启动Android模拟器。点击创建新的，例如Pixel。可以选择Android 10.0系统。

锤子图标按钮编译。播放图标按钮运行。

ctrl + alt + L 自动格式化



### 项目结构

#### 文件结构

点击最上方的Android区域切换项目结构模式为Project。

`.gradle` 和 `.idea` 是 studio 自动生成。

`app` 内是项目代码和资源。

- `build` 编译自动生成

- `libs` 第三方库

- `androidTest` 测试用例，自动化测试

- `java` Java 或 Kotlin 代码放置的地方

- `res` 图片等

  - `drawable` 图片
  - `layout` 布局
  - `values` 字符串
  - `mipmap` 应用图标，有很多是为了兼容性

- `AndroidManifest.xml` 项目配置文件

  定义所有四大组件的注册地方，添加权限声明等

- `test` Unit Test 测试用例

- `app.iml` 自动生成

- `build.gradle` 项目构建相关的配置

- `proguard-rules.pro` 指定项目代码的混淆规则，使得破解者难以阅读代码

`build` 是编译自动生成的文件

`gradle` 是 gradle wrapper 配置文件，默认启动，根据缓存决定是否联网下载 gradle 。如果改为离线模式 file-settings-build,exectuion,delpoyment-gradle

`build.gradle` 全局构建脚本

`gradle.properties` 配置文件

`gradlew` , `gradlew.bat` 执行命令，前者 linux/mac 后者 windows

`.iml` 是自动生成文件，意思是 IntelliJ IDEA

`local.properties` 指定本机 Android SDK 路径

`settings.gradle` 基本不用改



#### 代码结构

##### AndroidManifest.xml

在 `app\src\main\AndroidManifest.xml` 看到：

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="com.example.helloworld">

    <application
		<activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
  </application>

</manifest>
```

其中 `<activity android:name=".MainActivity"` 表示注册了 `MainActivity` ，后面的 action 和 category 表示点击应用图标首先启动这个 Activity 。



##### MainActivity

看到 `app\src\main\java\com\example\helloworld\MainActivity.kt` ，代码如下所示：

```kotlin
package com.example.helloworld

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}
```

显然这是一个继承类。



##### activity_main.xml

布局文件。在 `app\src\main\res\layout\activity_main.xml` ，如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>
```

有一个文本框 TextView 看到了 `Hello World!`



##### string.xml

`res/values/strings.xml` 应用程序名

```xml
<resources>
    <string name="app_name">helloworld</string>
</resources>
```

引用方法：

- 代码 `R.string.app_name` 
- XML `@string/app_name`



#### Gradle

项目构建工具，基于 Groovy 的领域特定语言 GDL 。

暂时不看，有需要看书。

> ##### app/build.gradle



#### 日志工具

日志类 `android.util.Log`

优先级从低到高是：

- `Log.v()` verbose
- `.d` debug
- `.i` info
- `.w` warn
- `.e` error

调用，如在 `.kt` 里：`Log.d(tag, msg)` ，tag是字符串，一般是当前类名，第二个是信息。

查看：shift+f10运行，底部工具栏 android monitor 看到打印信息

Log 可以用过滤器。可以编辑一个。



# Kotlin

## 基本概念

Kotlin 代码可以编译成 `.class` ，然后在 JVM 上跑，所以是解释型语言。代码较简洁，带新语法特性，100%兼容 Java ，可以直接调用 java 代码和第三方库。

运行：用[在线](https://try.kotlinlang.org/)或 IntelliJ IDEA。也可以在 Android Studio 独立写 main 来跑。如在 `app/src/main/java/com/example/helloworld` 下新建一个，即在左侧文件栏右击弹出菜单 new-kotlin file/class。

写一个 main 函数，会发现该函数左边有一个运行按钮，点击即可运行代码片段。如：

```kotlin
package com.example.helloworld

fun main() {
    println("QwQ 中文捏!")
}
```

基本规范：代码结尾不需要分号



## 基本语法

### 变量

#### 声明

##### 常规

声明的关键字：val (value)是 final 变量， var (variable)是非 final 变量，弱类型。规范建议优先用 val ，除非确实要修改。

可以手动定义变量类型，格式： `关键字 变量名: 类型 = 值` 。类型的首字母大写。基本数据类型名字同 Java 。基本运算同。如：

```kotlin
fun main(){
    val x = 3
    var y : Int = 4
    y += x
    println(y)
}
```

类型转换：变量的方法，如 `varname.toInt()` 。

其中有 Number 类。

可以定义全局变量，即不需要在类或main内。

字符串可以直接用 [] 取单个字符。并且可以内嵌表达式，如果表达式内只有一个变量就直接 `$变量名` ，否则 `${变量名的表达式}` 。如：

```kotlin
val a = listOf("baicha", "jinle")
val c = "sangze"
val b = "${a.get(0)} and ${a[1]} but $c.length no length"
println(b)//baicha and jinle but sangze.length no length
```





##### null

kotlin 默认所有参数和变量不可以为 null ，即比如传参数不可以传 null 。如果非要允许参数为空，需要在参数类型后加一个 `?` 。

判非空再执行成员函数操作符是 `?.` ，不为空就执行，为空跳过。

```kotlin
class tmp1(val name: String = "jinle") {
    fun gis() = println("QwQ, I am " + name)
}

fun f(a: tmp1?) {
    println("QwQ!")
    a?.gis()
}

fun main() {
    f(null)
    f(tmp1())
}
```

操作符 `a ?: b` ，若左边不为空返回左边，否则返回右边。如：

```kotlin
fun len(a: String?) = a?.length ?: 0
```

非空断言表达式： `!!.` ，断言对象不为空并跳过空指针检查，然后执行成员操作。

```kotlin
var k: String? = null
if (Math.random() <= 0.5) k = "baicha"
println(k!!.length)//有一半概率能跑
```





#### 集合

##### 基本语法

可以用 `listOf(一堆值)` 创建一个不可变的，能 for 的列表。

要可变的话，用 `mutableListOf` ，可以用 `add` 等方法。

集合就把上述的 `list` 改为 `set` 。

然而 `HashMap` 需要 `HashMap<keytype, valtype>()` 来构建。插入用 `put` 。也可以用类似 Python 的直接操作。即 `变量名[键名] = 值名` ，读取同理。初始化可以用 `mapOf(键 to 值, 键 to 值)` 

如：

```kotlin
val a = listOf(1, '2', 3.14)
for (i in a) {
    println(i)
}
println("---------")
val b = mutableListOf("w", 1)//val就行了
b.add("QwQ")
b.add(0, "GG")//插入后在0
for (i in b) {
    println(i)
}//也可以直接println(b)
println("---------")
val c = mutableSetOf(1, 1, 4, 5, 1, 4)
c.addAll(setOf(9, 9, 8, 2, 4, 4, 3, 5, 3))
println(c)//按照插入顺序排序
val d = HashMap<String, Int>()
d["lr580"] = 580
d["lr580"] = 581//覆盖
println(d)
```

```kotlin
val e = mapOf("baicha" to 1, "miming" to 666, "guodong" to 233)
for ((k, v) in e) {
    println(k + "'s favorite number is " + v)
}
```



##### 常用API

用 maxByOrNull(lambda) 求按规定的最值 ，如：

```kotlin
val a = listOf("baicha", "yunyan", "hefeng", "jinle")
println(a.maxByOrNull { it.length }) //baicha
```

```kotlin
val b = listOf(1, 4, 5, 1)
println(b.maxByOrNull { it.toInt() })
```

用 map 做映射得到新集合，如 `it.toUpperCase()` 

用 filter 做过滤得到新集合，可以配合其他来使用。

用 any 找是否存在满足，用 all 找是否都满足

```kotlin
println(a.filter { it.length > 5 }.map { it.uppercase() })
println("" + a.any { it[0] == 'b' } + " " + a.all { it[0] == 'b' })
```



### 逻辑控制

#### 条件判断

##### if

跟 Java 一样。但是可以用在赋值，如：

```kotlin
val x = if (1 > 0) 1 else if (2 > 0) 2 else 0
```

当然用大括号也行。显然也可以用在 return ，直接写成一个单行函数。



##### when

类似于 switch ，格式：

```kotlin
when (变量名) {
    值 -> 表达式
    值 -> 表达式
}
```

那么那个变量是哪个值就执行表达式。只有一行代码时大括号可以省略。

可以类型匹配：用 `is 类型名` ，可以 `else` 。

也可以：

```kotlin
when {
    表达式 -> 表达式
    表达式 -> 表达式
    else -> 表达式
}
```

如：

```kotlin
fun gis(a: Int) = when (a) {
    0 -> println("sudo rm -rf /")
    1 -> println("sudo reboot")
    else -> println("QwQ")
}
fun boring(a: Number) = when (a) {
    is Int -> "integer"
    is Double -> "double"
    else -> "unknown"
}
fun gettype(a: Char) = when {
    a >= 'A' && a <= 'Z' -> "Uppercase"
    a >= 'a' && a <= 'z' -> "Lowercase"
    a >= '0' && a <= '9' -> "Number"
    else -> "Unkouwn"
}
fun isLeap(a: Int) = when {
    (a % 4 == 0 && a % 100 != 0) || a % 400 == 0 -> true
    else -> false
}
```



#### 循环

##### while

略

##### for

删除了 for-i ，只有 for-in 了，类似 Python。for 的那个变量不需要声明 var 。

range 范围： `起始值x..终止值y` 表示两端闭区间 $[x,y]$ 的所有整数。

`x until y [step 1]` 表示 $[x,y)$ 。

可以降序，用 `x downTo y` ，那么是 $[y,x]$ 。

可以多值 `for` ，用 `for((var1, var2) in 可迭代变量)` 。

如：

```kotlin
fun f(a: Int) = print("" + a + " ")
for (i in 0..10) f(i)
println()
for (i in 0..10 step 2) f(i)
println()
for (i in 0 until 10 step 2) f(i)
println()
for (i in 580 downTo -220 step 100) f(i)
println()
```





### 函数

#### 常规

格式：

```kotlin
fun 函数名(参数名: 类型) [: 返回值] {
    return 值
}
```

可以按照变量语法整默认参数。参数一定是 val 。类型是不可省略的。

可以搞默认参数，可以用键值对传入参数，像 python 那样，即 key=val 。

函数里可以再定义函数。

如写一个快速幂：

```kotlin
val mod: Int = 1000000007

fun qpow(a: Int, b: Int = mod - 2, p: Int = mod): Int {
    var r: Long = 1
    var i: Long = b.toLong()
    var x: Long = a.toLong()
    while (i > 0) {
        if (i % 2 == 1L) {
            r = r * x % mod
        }
        x = x * x % mod
        i /= 2
    }
    return r.toInt()
}

fun main() {
    println(qpow(2))
}
```



单行函数：

```kotlin
fun 函数名() = 表达式
```

如：

```kotlin
fun inv(a: Int) = qpow(a)
fun gcd(a: Int, b: Int): Int = if (b > 0) gcd(b, a % b) else a
// 注意后者要类型，不然判断不出来
```



```kotlin
fun fff4(k: Int = 3, v: String) = println("kkksc $k awesome $v")
fun main() {
    fff4(v = "QwQ")
}
```





#### 内建



### 对象

可以直接 new-kotlin file/class 自己出来

#### 基本

```kotlin
[open] class 类名 [: 父类()] {
}
```

默认权限是公有。可以设属性默认值。默认是不允许继承。允许的话要 open 。继承带个括号是因为 Java 规定子类构造函数必须调用父类构造函数。单继承。能被子类改的函数也要 open 。

创建： `变量名 = 类名()` ，不需要 `new` 。

主构造函数，不带参数(也可以带)，没有函数体。

```kotlin
class 类名(val 或 var 属性名: 类型) {
}
```

可以用下面方法搞构造函数逻辑：

```kotlin
class 类名(val 或 var 属性名: 类型) {
    init {
    	函数逻辑
    }
}
```

对于父类里有的属性，就不要加 `val` 或 `var` 了

次构造函数存在时，若存在主构造，必须调用主构造。次构造的关键字是 `constructor` 。

```kotlin
class 类名(val 或 var 属性名: 类型) {
    constructor(属性名: 类型) : this(构造函数参数) {
    }
    constructor() : this(构造函数参数) {
    }
}
```

不存在时，就把 this 改成 super 即可。那么因为没有显示定义主构造函数，所以继承时不用加括号。

```kotlin
[open] class 类名(val 或 var 属性名: 类型) : 父类 {
    constructor(属性名: 类型) : super(构造函数参数) {
    }
}
```

可见性默认 public 。

- public 所有类可见
- private 当前类可见
- protected 当前类、子类可见，不管同包
- internal 同一模块内类可见



#### 接口

可以右击创建，选择 Interfafce 。

手写把关键字写成 `interface` 。继承接口就是在本来继承类的时候的冒号后加接口名即可，多个要继承的东西用逗号隔开。

接口内的函数可以实现可以不实现，实现即类似 Java 的 default 。

其抽象方法用 `override` 关键字复写。如：

```kotlin
interface chara {
    fun gis()
}

open class people(val name: String) {
    open fun att() = println(name + " will punch you via fist.")
}

class soldier(name: String, val weapon: String) : people(name), chara {
    override fun gis() = println("Hey, I am " + name)
    override fun att() = println(name + "'d smash you with my " + weapon + "!")
}

fun main() {
    val npc = people("villager")
    val bc = soldier("baicha", "diamond sword")
    val mm = soldier("miming", "enchanted bow")
    bc.gis()
    bc.att()
    mm.gis()
    mm.att()
    npc.att()
}
```



#### data类

类前加入关键字 data ，会自动编写 `equals, hashCode, toString` 方法。相等逻辑是成员变量全等。

如果类没有任何代码，可以删掉大括号。如：

```kotlin
data class MNode(val v1: Double, val v2: Double)
```



#### 单例类

即只拥有一个实例的类。在 Java 可通过构造函数私有化实现。在 Kotlin 将 `class` 改成 `object` 即可。右击创建对应点也行。调用它的方法就 `类名.方法名()` 即可，类似静态方法调用。如：

```kotlin
object mcserver : chara {
    val name = "贝壳"
    var cnt = 0
    override fun gis() = println(name + "一切正常。")
    fun refresh() = println(name + "刷新了" + (++cnt) + "次了喔！")
}

fun main() {
    mcserver.gis()
    mcserver.refresh()
    mcserver.refresh()
}
```



### Lambda

#### 基本

定义：一段可以作为参数传递的代码。语法：

```kotlin
{参数1: 类型, 参数2: 类型 -> 函数体}
```

最后一行代码作为该表达式的返回值。可以定义一个 lambda 变量，也可以不定义直接用。

若 lambda 表达式是函数的最后一个参数，可以移动到括号外。如果只有一个参数，可以不写括号，并且，如果只有一个参数，也不用声明，可以用 it 来代替，如下面这些全部等效：

```kotlin
val a = listOf("baicha", "yunyan", "hefeng", "jinle")
val f = { x: String -> x.length }
println(a.maxByOrNull(f))
println(a.maxByOrNull({ x: String -> x.length }))
println(a.maxByOrNull() { x: String -> x.length })
println(a.maxByOrNull { x: String -> x.length })
println(a.maxByOrNull { it.length })
```

例如，可以简写线程：

```kotlin
//简写前
Thread(object : Runnable {
    override fun run() {
        println("thr is running")
    }
}).start()
//简写后
Thread { println("QwQ") }.start()
```

简写依据：参数肯定是Runnable所以不用说出来；Runnable只有一个抽象方法所以也不用说出来。同理，对 Java 那一堆什么 action listener 都可以这么狂压压到只有一行。



#### let

函数。使得被调对象自身作为参数传递到该函数内，作为参数执行。一个常见的用途是 `?.let {...}` 来批量把 `?.` 全部改成 `.` ，节省特判。

```kotlin
for (i in 0..10) {
    var k: String? = null
    if (Math.random() <= 0.5)
    k = "baicha"
    k?.let {
        println("Yep So Lucky And " + k.length)
    } ?: println("Bad Luck")
}
```

