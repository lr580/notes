因为 `md` 太大加载太慢，所以分开多个 `leetcode`。记录算法题。

## 目录

### 旧

即 `leetcode.md` 的

#### 力扣

##### 题单

- 4\. 寻找两个正序数组的中位数

  **分治(二分)**

- 10\. 正则表达式匹配

  **DP 字符串**

- 23\. 合并K个升序链表

  堆

- 25\. K 个一组翻转链表

  模拟

- 30\. 串联所有单词的子串

  滑动窗口 STL

- 32\. 最长有效括号

  **DP / 贪心** / (前缀和 + 二分 + 树状数组)

- 37\. 解数独

  DFS

- 41\. 缺失的第一个正数

  模拟(mex)

- 42\. 接雨水

  前缀和 / <u>单调栈 / 双指针</u>

- 44\. 通配符匹配

  **DP 字符串** / **AC自动机**

- 51\. N皇后

  DFS

- 60\. 排列序列

  模拟(康托展开)

- 65\. 有效数字

  模拟(自动机/regex)

- 68\. 文本左右对齐

  模拟

- 72\.编辑距离

  DP 字符串

- 76\.最小覆盖子串

  滑动窗口

- 84\.柱状图中的最大矩形

  <u>单调栈</u> / ST表

- 85\.最大矩形

  悬线法 / <u>单调栈</u>

- 87\.扰乱字符串

  **记忆化DFS/DP**

- 115\.不同的子序列

  <u>DP</u>

- 123\.买卖股票的最佳时机III

  <u>DP</u> / 前缀和

- 124\.二叉树中的最大路径和

  DFS

- 126\.单词接龙II

  毒瘤卡常爆搜

- 132\.分割回文串II

  <u>DP</u> / DP+字符串哈希

- 140\.单词拆分II

  模拟DFS

- 149\.直线上最多的点数

  <u>枚举+STL</u> / 随机化

- 154\.寻找旋转排序数组中的最小值II

  **二分**

- 164\.最大间距

  基数排序

- 174\.地下城游戏

  **DP**

- 188\.买卖股票的最佳时机IV

  **DP** / **wqs二分**

- 212\.单词搜索II

  模拟DFS

- 214\.最短回文串

  manacher / 字符串哈希 / <u>KMP</u>

- 218\.天际线问题

  小模拟+(对顶堆 / <u>堆</u>)

- 220\.存在重复元素III

  滑动窗口+STL二分 / <u>滑动窗口+STL</u>

- 224\.基本计算器

  模拟(栈)

- 233\.数字1的个数

  思维 / <u>数位DP</u>

- 239\.滑动窗口最大值

  滑动窗口+(对顶堆 / <u>堆</u> / <u>单调队列</u>) / <u>ST表/分块</u>

- 273\.整数转英文表示

  模拟

- 282\.给表达式添加运算符

  模拟+DFS

- 295\.数据流的中位数

  对顶堆

- 297\.二叉树的序列化与反序列化

  DFS

- 301\.删除无效的括号

  DFS / <u>枚举子集</u>

- 312\.戳气球

  区间DP

- 315\.计算右侧小于当前元素的个数

  权值树状数组 / <u>归并排序</u> / <u>平衡树</u>

- 982\.按位与为零的三元组

  **<u>FWT</u> / <u>高维前缀和</u>** / <u>桶枚举</u> / bitset优化枚举

- 321\.拼接最大数

  (**单调栈+反悔贪心**(+后缀数组/后缀自动机)) / **子序列自动机**

- 327\.区间和的个数

  平衡树(pb\_ds) / <u>归并排序</u> / 线段树+离散化

- 329\.矩阵中的最长递增路径

  BFS/DFS/DP

- 330\.按要求补齐数组

  **贪心**

- 332\.重新安排行程

  欧拉图 DFS/Hierholzer

- 335\.路径交叉

  **思维**

- 1617\.统计子树中城市之间最大距离

  树直径+并查集判树+枚举子集 / <u>floyd+记忆化DFS/DP</u>

- 336\.回文对

  字符串哈希 / (trie+manacher)

- 352\.将数据流变为多个不相交区间

  模拟(链表/STL)

- 354\.俄罗斯套娃信封问题

  **单调栈+二分 (LIS)**

- 2488\.统计中位数为k的子数组

  前缀和 桶枚举

- 363\.矩形区域不超过k的最大数值和

  **二分优化枚举**
  
- 381\.O(1)时间插入、删除和获取随机元素-允许重复

  数据结构 STL <u>swap优化</u>
  
- 391\.完美矩阵

  (线段树+离散化+扫描线) / <u>扫描线</u> / <u>思维</u> / <u>格林公式</u>
  
- 407\.接雨水II

  **BFS+堆优化**
  
- 1626\.无矛盾的最佳球队

  DP <u>+树状数组优化</u>
  
- 410\.分割数组的最大值

  二分答案+贪心 / <u>DP</u>

- 1630\.等差子数组

  模拟 / <u>数学优化</u>

- 420\.强密码检测器

  **思维**
  
- 1032\.字符流

  <u>AC自动机</u> / 字符串哈希
  
- 1574\.删除最短的子数组使剩余数组有序

  <u>双指针</u> / 二分 

- 432\.全O(1)的数据结构

  哈希表+链表
  
- 1638\.统计只差一个字符的子串数目

  字符串哈希 / <u>枚举</u> / <u>DP</u>
  
- 1092\.最短公共超序列

  **DP**

- 1641\.统计字典序元音字符串的数目

  高阶前缀和 / DP
  
- 1039\.多边形三角剖分的最低得分

  <u>DP</u>
  
- 1053\.交换一次的先前排列

  <u>贪心</u> / STL二分
  
- 1000\.合并石子的最低成本

  **DP**
  
- 2417\.公因子的数目

  枚举 / <u>gcd优化</u>
  
- 1017\.负二进制转换

  模拟 进制
  
- 1040\.移动石子直到连续II

  思维+STL / 双指针

- 3\.无重复字符的最长子串

  双指针 / <u>前向星</u>
  
- 1125\.最小的必要团队

  BFS 状压
  
- 1147\.段式回文

  字符串哈希 贪心 双指针
  
- 1023\.驼峰式匹配

  小模拟 / <u>正则</u>
  
- 1157\.子数组中占绝大多数的元素

  **随机化+二分** / **摩尔投票+线段树**

- 2409\.统计共同度过的日子数

  日期 模拟 / <u>优化</u>
  
- 1026\.节点与其祖先之间的最大差值

  DFS
  
- 1043\.分隔数组以得到最大和

  **DP**
  
- 1187\.使数组严格递增

  DP+二分 / <u>优化</u>
  
- 1027\.最长等差数列

  DP
  
- 1105\.填充书架

  DP
  
- 1163\.按字典序排在最后的子串

  后缀数组 / <u>双指针</u>
  
- 1031\.两个非重叠子数组的最大和

  前缀和 / <u>DP+滑动窗口</u>
  
- 1048\.最长字符串链

  DP / 拓扑排序 / <u>后缀自动机</u>
  
- 1172\.餐盘栈

  数据结构
  
- 2423\.删除字符使频率相同

  STL
  
- 1003\.检查替换后的词是否有效

  贪心
  
- 2106\.摘水果

  前缀和 / <u>滑动窗口</u>
  
- 1419\.数青蛙

  贪心 小模拟
  
- 1010\.总持续时间可被60整除的歌曲

  枚举
  
- 1263\.推箱子

  BFS套BFS
  
- 1015\.可被k整除的最小整数

  数论
  
- 1016\.子串能表示从1到N的数字的二进制串

  枚举 / <u>滑动窗口+数学</u>
  
- 1330\.翻转子数组得到最大的数组值

  **思维**
  
- 1054\.距离相等的条形码

  STL
  
- 1335\.工作计划的最低难度

  DP / <u>单调栈优化</u>
  
- 2446\.判断两个事件是否存在冲突

  日期
  
- 1073\.负二进制数相加

  模拟
  
- 1079\.活字印刷

  DFS / <u>DP</u>
  
- 2514\.统计同位异构字符串数目

  组合数学
  
- LCP33\.蓄水

  贪心 <u>+优先队列</u>

- 1373\.二叉搜索子树的最大键值和

  DFS
  
- 1080\.根到叶路径上的不足节点

  DFS
  
- 1090\.受标签影响的最大值

  贪心
  
- 1377\.T秒后青蛙的位置

  DFS
  
- 2451\.差值数组不同的字符串

  模拟
  
- 1093\.大样本统计

  模拟
  
- 1439\.有序矩阵中的第k个最小数组和

  STL <u>+归并优化</u> <u>+DP剪枝</u> / <u>二分答案+DFS</u>
  
- 1110\.删点成林

  DFS

- 1130\.叶值的最小代价生成树

  区间DP / <u>单调栈</u>
  
- 2517\.礼盒的最大甜蜜度

  二分答案+STL / <u>二分答案</u>
  
- 2559\.统计范围内的元音字符串数目

  前缀和
  
- 1156\.单字符重复子串的最大长度

  小模拟 / 滑动窗口
  
- 2611\.老鼠和奶酪

  排序 / 优先级队列
  
- 1240.铺瓷砖

  **DFS**
  
- 2699\.修改图中的边权

  **Dijkstra序贪心** / **二分+最短路**
  
- 1170\.比较字符串最小字母出现频次

  前缀和
  
- 1171\.从链表中删去总和值为零的连续节点

  前缀和 STL 链表 / <u>优化</u>
  
- 1483\.树节点的第k个祖先

  树上k级祖先
  
- 2475\.数组中不等三元组的数目

  枚举 / <u>排序+指针</u> / <u>STL</u>
  
- 1375\.二进制字符串前缀一致的次数

  树状数组 / <u>思维</u>
  
- 1177\.构建回文串检测

  前缀和 / <u>前缀异或和</u>
  
- 1494\.并行课程 II

  DFS+BFS / <u>子集枚举</u>
  
- 2481\.分割圆的最少切割次数

  思维

- 1254\.统计封闭岛屿的数目

  BFS / DFS / 并查集
  
- 1262\.可被三整除的最大和

  贪心+二维DP / <u>贪心</u> / <u>DP</u>
  
- 1595\.连通两组点的最小成本

  **网络流** / **状压DP**
  
- LCP41\.黑白翻转棋

  模拟 / <u>BFS</u>
  
- 16\.19\.水域大小

  BFS
  
- 1659\.最大化网格幸福感

  <u>状压DP</u> / <u>轮廓线优化</u>
  
- 1401\.圆和矩形是否有重叠

  计算几何 / <u>思维</u>
  
- 2485\.找出中枢整数

  数学
  
- 1186\.删除一次得到子数组最大和

  **DP**
  
- 1681\.最小不兼容性

  **状压DP+枚举子集**
  
- 1253\.重构2行二进制矩阵

  构造
  
- 2490\.回环句

  小模拟
  
- 443\.两数相加II

  模拟链表
  
- 2178\.拆分成最多数目的正偶数之和

  贪心 构造
  
- 167\.两数之和 II - 输入有序数组

  二分 / <u>双指针</u>
  
- 15\.三数之和

  二分 / <u>双指针</u>
  
- 16\.最接近的三数之和

  二分 / <u>双指针</u>
  
- 1911\. 最大子序列交替和

  贪心 / <u>DP</u>
  
- 979\.在二叉树中分配硬币

  <u>DFS</u> / LCA+网络流
  
- 18\.四数之和

  二分 / 双指针
  
- 834\.树中距离之和

  树上DP
  
- 415\.字符串相加

  高精度
  
- 1851\.包含每个查询的最小区间

  离线 STL
  
- 918\.环形子数组的最大和

  前缀和+可删堆 / <u>前缀和+单调队列</u> / <u>DP</u>
  
- 1499\.满足不等式的最大值

  单调队列 / 堆
  
- 2050\.并行课程 III

  拓扑 / 记忆化DFS
  
- 141\.环形链表

  双指针 / 哈希表
  
- 142\.环形链表II

  <u>双指针</u> / 哈希表
  
- 143\.重排链表

  <u>双指针</u> / 模拟 
  
- 2681\.英雄的力量

  DP / 数学

- 822\.翻转卡片游戏

  小模拟 STL
  
- 21\.合并两个有序链表

  链表
  
- 980\.不同路径III

  BFS / DFS
  
- 1749\.任意子数组和的绝对值的最大值

  前缀和
  
- 1289\.下降路径最小和II

  DP 前缀和
  
- 88\.合并两个有序数组

  双指针
  
- 833\.字符串中的查找与替换

  模拟+双指针
  
- 1444\.切披萨的方案数

  DP+二维前缀和
  
- 1388\.3n 块披萨

  **DP** / **反悔贪心**
  
- 2337\.移动片段得到字符串

  贪心
  
- 849\.到最近的人的最大距离

  枚举 / 链表/前缀和
  
- 1782\.统计点对的数目

  二分 / <u>双指针</u>
  
- 225\.汇总区间

  小模拟
  
- 56\.合并区间

  排序
  
- 57\.插入区间

  小模拟
  
- 440\.字典序的第k小数字

  **DFS+trie**
  
- 823\.带因子的二叉树

  DP (+ <u>双指针优化</u>)

- 446\.等差数列划分 II

  **DP**

- 1654\.到家的最少跳跃次数

  <u>BFS</u>

- 458\.可怜的小猪

  思维+DP / <u>DP+组合数学</u> / <u>数学</u>
  
- 1761\.一个图中连通三元组的最小度数

  枚举 / <u>bitset优化</u> / <u>排序+快速矩阵乘法</u>
  
- 2240\.买钢笔和铅笔的方案数

  枚举 / <u>类欧几里得算法</u>
  
- 2511\.最多可以摧毁的敌人城堡数目

  小模拟
  
- 1921\.消灭怪物的最大数量

  贪心
  
- 449\.序列化和反序列化二叉搜索树

  小模拟
  
- 2605\.从两个数字数组生成最小数字

  小模拟
  
- 1123\.最深叶节点的最近公共祖先

  LCA / <u>DFS</u>
  
- 2594\.修车的最少时间

  二分 / STL
  
- 630\.课程表III

  **贪心**
  
- 1462\.课程表IV

  最短路(+bitset优化) / <u>快速矩阵乘法</u>
  
- 2596\.检查骑士巡视方案

  小模拟
  
- 886\.可能的二分法

  二分图判定 DFS/<u>种类并查集</u>
  
- 198\.打家劫舍

  DP
  
- 213\.打家劫舍II

  DP
  
- 337\.打家劫舍III

  树上DP
  
- 2560\.打家劫舍IV

  二分+DP / <u>二分+贪心</u>
  
- 2591\.将钱分给最多的儿童

  贪心 / <u>DP</u>
  
- 2603\.收集树中金币

  **拓扑排序** / **树上DP**
  
- 1993\.树上的操作

  DFS / <u>DFS序+树状数组二分</u>
  
- 2582\.递枕头

  数学
  
- 146\.LRU 缓存

  STL / <u>STL+链表</u>

- 460\.LFU 缓存

  <u>STL</u> / STL+链表
  
- 2251\.花期内花的数目

  差分+离线+双指针 / <u>二分</u>
  
- 605\.种花问题

  小模拟
  
- 466\.统计重复个数

  <u>字符串模拟+思维</u>
  
- 2136\.全部开花的最早一天

  贪心
  
- 472\.连接词

  字符串哈希+DP / <u>trie+记忆化DFS</u>
  
- 479\.最大回文数乘积

  <u>爆搜</u>

- 714\.买卖股票最佳时机含手续费

  贪心/DP
  
- 309\.买卖股票最佳时期含冷冻期

  DP

- 480\.滑动窗口中位数

  对顶堆+set / <u>对顶堆+pq</u>

- 483\.最小好进制

  二分+数学 / <u>数学</u>
  
- 488\.祖玛游戏

  <u>爆搜</u>
  
- 901\.股票价格跨度

  二分+线段树 / <u>单调栈</u>
  
- 493\.翻转对

  红黑树 / <u>离散化+树状数组</u> / <u>归并排序</u>
  
- 502\.IPO

  贪心+STL
  
- 514\.自由之路

  DP
  
- 2578\.最小和分割

  <u>贪心</u> / 爆搜
  
- 2731\.移动机器人

  思维 + 前缀和/<u>组合数学</u>
  
- 571\.超级洗衣机

  **贪心**
  
- 546\.移除盒子

  **DP**
  
- 786\.第k个最小的素数分数

  排序 / <u>堆</u> / <u>二分+双指针</u>
  
- 552\.学生出勤记录II

  DP / <u>矩阵快速幂</u>
  
- 1488\.避免洪水泛滥

  贪心+STL
  
- 564\.寻找最近的回文数

  思维/贪心+小模拟
  
- 137\.只出现一次的数字II

  STL / <u>位运算</u>
  
- 260\.只出现一次的数字III

  STL / <u>位运算</u>
  
- 2652\.倍数求和

  容斥
  
- 1726\.同积元素

  STL
  
- 2316\.统计无向图中无法相互到达点对数

  DFS
  
- 1402\.做菜顺序

  贪心 / <u>贪心+前缀和</u> / <u>DP</u>
  
- 1155\.掷骰子等于目标和的方法数

  DP / 分治 MTT
  
- 2698\.求一个整数的惩罚数

  爆搜
  
- 274\.H指数

  二分答案 / 排序 / 计数排序+后缀和
  
- 275\.H指数II

  二分答案

- 2127\.参加会议的最多员工数

  **拓扑排序**(内向基环树)

- 117\. 填充每个节点的下一个右侧节点指针 II

  DFS / <u>BFS层序</u>

- 2003\.每棵子树内缺失的最小基因值

  树上启发式合并+STL / <u>树上启发式合并</u> / <u>DFS</u>
  
- 421\.数组中两个数的最大异或值

  <u>01trie</u> / <u>STL</u>
  
- 187\.重复的DNA序列

  STL / <u>STL+滑动窗口</u>
  
- 318\.最大单词长度乘积

  位运算

- 229\.多数元素II

  STL / <u>摩尔投票</u>
  
- 2586\. 统计范围内的元音字符串数

  签到
  
- 2609\.最长平衡子字符串

  枚举
  
- 2258\.逃离火灾

  <u>BFS+二分 / BFS</u>
  
- 2300\.咒语和药水的成功对数

  双指针 / 二分
  
- 715\.Range 模块

  <u>动态开点线段树 / STL模拟</u>
  
- 765\.情侣牵手

  贪心 / <u>BFS(连通分量)</u>
  
- 1334\.阈值距离内邻居最少的城市

  最短路
  
- 2760\.最长奇偶子数组

  滑动窗口 / DP
  
- 2736\.最大和查询

  **权值树状数组 / 单调栈 / 归并排序**
  
- 689\.三个无重叠子数组的最大和

  **滑动窗口+前缀和 /前缀和 / DP**
  
- 53\.最大子数组和

  前缀和 / DP / <u>分治</u>
  
- 2216\.美化数组的最少删除数

  小模拟+贪心+DP / 贪心
  
- 2304\.网格中的最小路径代价

  最短路 / DP
  
- 1410\.HTML实体解析器

  STL
  
- 2824\.统计和小于目标的下标对数目

  二分 / 双指针
  
- 1457\.二叉树中的伪回文路径

  DFS(+位运算优化)
  
- 828\.统计子串中的唯一字符

  组合数学
  
- 907\.子数组的最小值之和

  单调栈 / 单调栈+DP
  
- 1670\.设计前中后队列

  STL
  
- 2336\.无限集中的最小数字

  STL
  
- 1657\.确定两个字符串是否接近

  STL
  
- 1423\.可获得的最大点数

  <u>滑动窗口</u> / <u>后缀数组</u>
  
- 1038\.从二叉搜索树到更大和树

  DFS / <u>Morris遍历</u>
  
- 2477\.到达首都的最少油耗

  DFS / 有根树拓扑排序
  
- 2646\.最小化旅行的价格总和

  LCA + 树上DP
  
- 2008\.出租车的最大盈利

  DP
  
- 2048\.下一个更大的数值平衡数

  爆搜  / <u>枚举</u> / 打表+二分
  
- 1631\.最小体力消耗路径

  最小生成树+DFS / 二分+BFS / <u>并查集</u> / 最短路
  
- 2454\.下一个更大元素IV

  ST表+二分 / <u>单调栈</u>
  
- 2132\.用邮票贴满网格图

  二维前缀和差分
  
- 2415\.反转二叉树的奇数层

  DFS(<u>+优化</u>)
  
- 2276\.统计区间中的整数数目

  动态开点线段树 / <u>STL(珂朵莉树)</u>
  
- 746\.使用最小花费爬楼梯

  DP
  
- 162\.寻找峰值

  枚举 / <u>二分</u>
  
- 1901\.寻找峰值II

  枚举 / <u>二分</u>
  
- 2828\.判别首字母缩略词

  签到
  
- 2866\.美丽塔II

  单调栈+DP
  
- 1671\.得到山形数组的最少删除次数

  DP+前缀和 / <u>DP</u> / <u>二分+单调栈</u>
  
- 1962\.移除石子使总数最小

  STL
  
- 1954\.收集足够苹果的最小花园周长

  数学+二分/枚举
  
- 1349\. 参加考试的最大学生数

  状压DP / <u>网络流</u>
  
- 2735\.收集巧克力

  枚举(+优化) / <u>单调栈+前缀和+斜率优化</u>
  
- 2706\.购买两块巧克力

  签到
  
- 2487\.从链表中移除节点

  链表
  
- 2397\. 被列覆盖的最多行数

  DFS / 二进制枚举 / <u>Gosper's Hack</u>
  
- 1944\.队列中可以看到的人数

  静态双链表 / <u>单调栈</u>
  
- 2807\.在链表中插入最大公约数

  链表
  
- 383\.赎金信

  STL
  
- 2707\.字符串中的额外字符

  DP
  
- 2696\.删除子串后的字符串

  静态双链表 / <u>栈</u>
  
- 2182\.构造限制重复的字符串

  贪心+小模拟/双指针
  
- 83\.删除排序链表中的重复元素

  链表
  
- 82\.删除排序链表中的重复元素II

  链表
  
- 2719\.统计整数数目

  数位DP
  
- 2744\.最大字符串配对数目

  哈希
  
- 2171\.拿出最少数目的魔法豆

  前缀和 排序
  
- 2809\. 使数组和小于等于 x 的最少时间

  **排序不等式 贪心 DP**
  
- 670\.最大交换

  贪心
  
- 2765\.最长交替子数组

  小模拟(指针)
  
- 2846\.边权重均等查询

  LCA 树上前缀和
  
- 365\.水壶问题

  裴蜀定理 / 搜索 / STL
  
- 2808\.使循环数组所有元素相等

  STL
  
- 1686\.石子游戏VI

  **贪心**+博弈论
  
- LCP24\.数字游戏

  对顶堆(证明定点距离和是中位数)
  
- 1690\.石子游戏VII

  博弈论 记忆化DFS/<u>DP</u>
  
- 1696\.跳跃游戏VI

  DP+单调队列
  
- LCP30\.魔塔游戏

  贪心+优先级队列
  
- 2641\.二叉树的堂兄弟节点II

  搜索
  
- 993\.二叉树的堂兄弟节点

  搜索
  
- 236\.二叉树的最近公共祖先

  LCA 搜索
  
- 94\.二叉树的中序遍历

  DFS
  
- 144\.二叉树的前序遍历

  DFS Morris遍历
  
- 145\.二叉树的后序遍历

  DFS Morris遍历
  
- 987\.二叉树的垂序遍历

  数据结构/<u>排序</u>

- 102\.二叉树的层序遍历

  BFS
  
- 2476\.二叉搜索树最近节点查询

  DFS+二分
  
- 105\.从前序与中序遍历序列构造二叉树

  DFS 分治

- 106\.从中序与后序遍历序列构造二叉树

  DFS 分治

- 889\.根据前序和后序遍历构造二叉树

  DFS 构造

- 235\.二叉搜索树的最近公共祖先

  DFS LCA
  
- 938\.二叉搜索树的范围和

  DFS
  
- 2867\.统计树中的合法路径数目

  欧拉筛 树上DP
  
- 2673\.使二叉树所有路径值相等的最小代价

  二分治+贪心 / <u>贪心</u>
  
- 2581\.统计可能的树根数目

  DFS(换根DP)
  
- 2369\.检查数组是否存在有效划分

  DP
  
- 2368\.受限条件下可到达节点的数目

  BFS DFS 并查集
  
- 225\.用队列实现栈

  STL
  
- 1976\.到达目的地的方案数

  Dijkstra
  
- 2575\.找出字符串的可整除数组

  数论
  
- 2834\.找出美丽数组的最小和

  贪心 数学
  
- 299\.猜数字游戏

  小模拟

- 2386\.找出数组的第K大和

  **二分答案+爆搜 / 最小堆**
  
- 2129\.将标题首字母大写

  小模拟
  
- 2864\.最大二进制奇数

  签到 贪心
  
- 2789\.合并后数组中的最大元素

  贪心
  
- 2312\.卖木头块

  **DP**
  
- 2684\.矩阵中移动的最大次数

  DP DFS BFS
  
- 310\.最小高度树

  换根DP / <u>重心</u>
  
- 1793\.好子数组的最大分数

  贪心 双指针
  
- 1969\.数组元素的最小非零乘积

  贪心 构造 快速幂
  
- 2671\.频率跟踪器

  STL
  
- 2642\.设计可以求最短路径的图类

  Dijkstra
  
- 2549\.统计桌面上的不同数字

  贪心
  
- 322\.零钱兑换

  无限背包DP
  
- 522\.零钱兑换II

  **背包DP计数**
  
- 2580\.统计将重叠区间合并成组的方案数

  模拟
  
- 2617\.网格图中最少访问的格子数

  **DP+单调栈** / **BFS+并查集/set** **DP+线段树** **贪心+最小堆**
  
- 1997\.访问完所有房间的第一天

  前缀和优化DP
  
- 2908\.元素和最小的山形三元组I

  前缀和
  
- 2952\.需要添加的硬币的最小数量

  贪心
  
- 331\.验证二叉树的前序序列化

  DFS
  
- 2810\.故障键盘

  STL
  
- P1314\.聪明的质监员

  前缀和 三分/<u>二分</u>
  
- 894\.所有可能的真二叉树

  DP DFS <u>指针</u>
  
- 2192\. 邮箱无向图中一个节点的所有祖先

  DFS / 拓扑排序
  
- 1483\.树节点的第k个祖先

  倍增
  
- 1600\.王位继承顺序

  DFS
  
- 2009\.使数组连续的最少操作数

  离散前缀和 / <u>滑动窗口</u>
  
- 2529\.正整数和负整数的最大计数

  二分
  
- 1702\.修改后的最大二进制字符串

  贪心 构造
  
- 1766\.互质树

  DFS
  
- 2924\.找到冠军II

  图论/签到
  
- 924\.尽量减少恶意软件的传播

  BFS / <u>连通分量(DFS/并查集)</u>
  
- 928\.尽量减少恶意软件的传播II

  爆搜 / <u>连通分量(DFS)</u>
  
- 1883\.准时抵达会议现场的最小跳过休息次数

  DP 精度
  
- 39\.组合总和

  DFS
  
- 216\.组合总和III

  DFS / 二进制枚举
  
- 377\.组合总和IV

  DP 取模
  
- 1052\.爱生气的书店老板

  前缀和 / <u>滑动窗口</u>
  
- 2385\.感染二叉树需要的总时间

  二叉树 DFS
  
- 2739\.总行驶距离

  数学
  
- 2639\.查询网格图中每一列的宽度

  签到
  
- 1146\.快照数组

  数据结构
  
- 1329\.将矩阵按对角线排序

  模拟
  
- 2462\.雇佣k位工人的总代价

  数据结构
  
- 857\.雇佣k名工人的最低成本

  排序+优先级队列
  
- 1235\.规划兼职工作

  DP + 树状数组(区间max)/线段树/<u>二分搜索</u>
  
- 1652\.拆炸弹

  前缀和 / 滑动窗口
  
- 741\.摘樱桃

  **DP**
  
- 1463\.摘樱桃II

  DP(/+压缩数组)
  
- 2079\.给植物浇水

  模拟
  
- 2105\.给植物浇水II

  模拟
  
- 2960\.统计已测试设备

  模拟 / 差分
  
- 2391\.收集垃圾的最少总时间

  模拟
  
- 1553\.吃掉N个橘子的最少天数

  记忆化搜索 / 最短路
  
- 994\.腐烂的橘子

  BFS
  
- 2244\.完成所有任务需要的最少轮数

  贪心
  
- 2589\.完成所有任务的最少时间

  **排序+贪心 (/线段树二分/栈上前缀和+二分) / 差分约束**
  
- 1953\.你可以工作的最大周数

  贪心 构造
  
- 826\.安排工作以达到最大收益

  排序 双指针
  
- 2644\.找出可整除性得分最大的整数

  签到
  
- 1535\.找出数组游戏的赢家

  模拟 思维
  
- 2769\.找出最大的可达成数字

  签到 思维
  
- 1542\.找出最长的超赞子字符串

  **前缀异或和**
  
- 2225\.找出输掉零场或一场比赛的玩家

  签到
  
- 2831\.找出最长等值子数组

  滑动窗口
  
- 1673\.找出最具竞争力的子序列

  <u>前缀和+模拟+贪心</u> / **贪心+单调栈/ST表(维护min所在下标)**/(优先队列+滑窗)/<u>线段树+二分</u>
  
- 2903\.找出满足差值条件的下标I

  滑动窗口+二分 / 滑动窗口
  
- 1738\.找出第 k 大的异或坐标值

  前缀和 排序(nth)
  
- 2028\.找出缺失的观测数据

  构造 模拟/数学
  
- 2981\.找出出现至少三次的最长特殊子字符串I

  模拟 排序/堆
  
- 2965\.找出缺失和重复的数字

  模拟 / <u>位运算(异或)</u>
  
- 2928\.给小朋友们分糖果I

  枚举 / <u>枚举优化 / 容斥原理</u>
  
- 3067\.在带权树网络中统计可连接服务器对数目

  计数 (DFS / <u>点分治</u>)
  
- 1103\.分糖果II

  暴力 / 二分 / 数学
  
- 3072\.将元素分配到两个数组中II

  pb\_ds / <u>离散化+树状数组</u>
  
- 2938\.区分黑球与白球

  贪心 逆向/组合数学
  
- 3040\.相同分数的最大操作数目II

  爆搜
  
- 881\.救生艇

  贪心 + (multiset二分 / <u>双指针</u>)
  
- 419\.甲板上的战舰

  BFS / 枚举
  
- 2813\.子序列最大优雅度

  排序 数据结构 贪心+枚举+模拟 / <u>反悔贪心</u>
  
- 2786\.访问数组中的位置使分数最大

  DP
  
- 2779\.数组的最大美丽值

  排序+二分 / 排序+滑动窗口 / 差分 / 离散差分 / 线段树
  
- 521\.最长特殊序列I

  签到 思维
  
- 522\.最长特殊序列II

  思维 字符串
  
- 2288\.价格减免

  小模拟 字符串
  
- 2713\.矩阵中严格递增的单元格数

  **DP**
  
- 2748\.美丽下标对的数目

  枚举
  
- LCP61\. 气温变化趋势

  签到
  
- 2663\.字典序最小的美丽字符串

  **构造 模拟 贪心**
  
- 503\.下一个更大元素 II

  单调栈
  
- 2732\. 找到矩阵中的好子集

  贪心 + 模拟/数学 <u>SOSDP</u>
  
- 2741\.特别的排列

  **状压DP**
  
- 2734\.执行子串操作后的字典序最小

  签到 贪心
  
- 2742\.给墙壁刷油漆

  01背包DP
  
- 2710\.移除字符串中的尾随零

  签到 / 正则表达式
  
- 494\.目标和

  折半搜索 / <u>01背包DP</u>
  
- 3102\.最小化曼哈顿距离

  **计算几何 曼哈顿距离 切比雪夫距离** <s>凸包直径</s>
  
- 3086\.拾起K个1需要的最少行动次数

  **中位数 贪心 前缀和 +二分/+双指针**
  
- 202\.快乐数

  STL / <u>快慢指针 / 打表</u>
  
- 2970\.统计移除递增子数组的数目I

  暴力 / 二分 / <u>双指针</u>
  
- 3011\.判断一个数组是否可以变为有序

  滑动窗口+排序 / <u>滑动窗口</u>
  
- 807\.保持城市天际线

  签到
  
- 721\.账户合并

  并查集 小模拟
  
- 2959\.关闭分部的可行集合数目

  爆搜+Floyd
  
- 3112\.访问消失节点的最少时间

  Dijkstra改
  
- 3096\.得到更多分数的最少关卡数目

  前缀和 签到
  
- 2850\.将石头分散到网格图的最少移动次数

  排列/DFS爆搜 / <u>最小费用最大流</u>
  
- 1186\.删除一次得到子数组最大和

  **DP**
  
- 2101\.引爆最多的炸弹

  DFS / <u>Floyd</u>
  
- 3098\.求出所有子序列的能量和

  **DP** / ***DP+前缀和优化***
  
- 2766\.重新放置石块

  签到
  
- 2844\.生成特殊数字的最少操作

  签到 思维 字符串
  
- 2740\.找出分区值

  签到 贪心 排序
  
- 3106\.满足距离约束且字典序最小的字符串

  贪心
  
- 699\.掉落的方块

  暴力 / <u>STL+二分</u> / 线段树 / 动态开点线段树
  
- 2961\.双模幂运算

  快速幂
  
- 3111\.覆盖所有点的最少矩形数目

  贪心
  
- LCP40\.心算挑战

  反悔贪心 / +<u>nth_element 优化排序</u>
  
- 3128\.直角三角形

  签到 组合数学(乘法原理)
  
- 3143\.正方形中的最多点数

  排序+枚举 / <u>二分 / 枚举(+最值维护)</u>
  
- 572\.另一棵树的子树

  爆搜 / 树哈希 /<u> DFS序+KMP</u>
  
- 600\.不含连续1的非负整数

  数位DP
  
- 3129\.找出所有稳定的二进制数组I

  **DP / DP + 容斥原理** (生成函数优化)
  
- 1443\.收集树上所有苹果的最少时间

  DFS
  
- 3131\.找出与数组相加的整数I

  签到 排序
  
- 3132\.找出与数组相加的整数II

  枚举+排序+双指针 / <u>排序+双指针</u>
  
- 1971\.寻找图中是否存在路径

  签到 DFS

- 2540\.找到 Alice 和 Bob 可以相遇的建筑

  离线 + map二分 / <u>离线 + 堆 / 离线 + 单调栈二分 / 在线 + 线段树二分</u>
  
- 1035\.不相交的线

  DP+前缀和 / <u>LCS DP</u>

- 676\.实现一个魔法字典

  字符串 暴力/预处理 / <u>字典树+DFS</u> 
  
- 3152\.特殊数组II

  ST表 / <u>前缀和</u>
  
- 3148\.矩阵中的最大得分

  DP / <u>二维前缀和</u>
  
- 3097\.或值至少为 K 的最短子数组

  **LogTrick + 二分/滑动窗口**
  
- 3117\.划分数组得到的最小的值之和

  <u>记忆化DFS / (LogTrick(二分/滑动窗口)/ST表二分 + (单调栈/线段树)优化DP)</u>
  
- 3137\.K 周期字符串需要的最少操作次数

  签到 思维 字符串
  
- 2492\.两个城市间路径的最小分数

  DFS
  
- 802\.找到最终的安全状态

  环 DFS / <u>拓扑排序</u>
  
- 1559\.二维网格图中探测环

  DFS / <u>并查集</u>
  
- 3154\.到达第K级台阶的方案数

  组合数学 / <u>DP(记忆化DFS)</u>
  
- 3007\.价值和小于等于K的最大数字

  位运算 二分
  
- 3133\.数组最后一个元素的最小值

  位运算
  
- 3145\.大数组元素的乘积

  位运算 二分/<u>倍增</u> 差分 快速幂 扩展欧拉公式
  
- 1466\.重新规划路线

  DFS
  
- 3146\.两个字符串的排列差

  签到 STL(哈希)
  
- 698\.划分为k个相等的子集

  状压 + 记忆化DFS/<u>(优化) / DP</u>
  
- 279\. 完全平方数

  BFS / DP / <u>数学</u>
  
- 3134\.找出唯一性数组的中位数

  **二分 + 滑动窗口**
  
- 3144\.分割字符频率相等的最少子字符串

  BFS / <u>记忆化DFS / DP</u>
  
- 3153\.所有数对中数位不同之和

  组合数学 计数
  
- 1450\.在既定时间做作业的学生人数

  签到 / 差分 / 二分
  
- 2024\.考试的最大困扰度

  滑动窗口
  
- 113\.路径总和II

  DFS / BFS 输出方案
  
- 2708\.一个小组的最大实力值

  二进制枚举 / 爆搜 / <u>贪心</u>
  
- 2860\.让所有学生保持开心的分组方法数

  排序 枚举
  
- 3176\.求出最长好子序列I

  DP <u>前缀和优化</u>
  
- 977\.有序数组的平方

  滑动窗口双指针
  
- 2115\.从给定原材料中找到所有可以做出的菜

  拓扑排序
  
- 2181\.合并零之间的节点

  链表
  
- 338\.比特位计数

  二进制 DP
  
- 2552\.统计上升四元组

  **DP 组合数学 枚举**
  
- 2555\.两个线段获得的最多奖品

  滑动窗口 前缀和(max)
  
- 2576\.求出最多标记下标

  排序 贪心 二分/<u>双指针</u>
  
- 2398\.预算内的最多机器人数目

  滑动窗口 单调栈
  
- 2390\.从字符串中移除星号

  签到 栈
  
- 2332\.坐上公交的最晚时间

  模拟 双指针
  
- 815\.公交路线

  BFS
  
- 2848\.与车相交的点

  前缀和差分
  
- 2414\.最长的字母序连续子字符串的长度

  签到 模拟

- 2376\.统计特殊整数

  DFS打表+二分 / <u>数位DP / 组合数学</u>
  
- 2374\.边积分最高的节点

  签到
  
- 997\.找到小镇的法官

  签到 图论
  
- 1014\.最佳观光组合

  前缀和
  
- 2207\.字符串中最多数目的子序列

  前缀和 / <u>贪心</u>
  
- 2306\.公司命名

  **组合数学 枚举**
  
- 2535\.数组元素和与数字和的绝对差

  签到
  
- 2516\.每种字符至少取K个

  二分+前缀和 / <u>滑动窗口</u>
  
- 2286\.以组为单位定音乐会的门票

  线段树二分
  
- 2073\.买票需要的时间

  签到 数学
  
- 1845\.座位预约管理系统

  堆/优先级队列
  
- 134\.加油站

  前缀和+滑动窗口+单调队列 / <u>贪心</u>
  
- 2187\.完成旅途的最少时间

  二分答案
  
- 1227\.飞机座位分配概率

  概率 (数学归纳 / <u>DP + 错位相减优化</u>)
  
- 983\.最低票价

  DP / (<u>+双指针优化</u>)
  
- 1870\.准时到达的列车最小时速

  二分答案
  
- 1928\.规定时间内到达终点的最小花费

  **Bellman Ford+DP / Dijkstra**
  
- 871\.最低加油次数

  **DP / 贪心+堆**
  
- 1436\.旅行终点站

  签到 set
  
- 3171\.找到按位或最接近K的子数组

  二分答案+滑动窗口+卡常 / <u>位运算枚举优化(logtrick)</u> / 滑动窗口+bin / <u>滑动窗口+栈</u>
  
- 3164\.优质数对的总数II

  <u>数论 倍数(因数) 质因数分解/调和级数枚举</u>
  
- 224\.基本计算器

  栈 模拟
  
- 258\.各位相加

  数论 同余
  
- 3158\.求出出现两次数字的XOR值

  位运算 bitset
  
- 1884\.鸡蛋掉落-两枚鸡蛋

  DP / 数学
  
- 887\.鸡蛋掉落

  **DP+(二分优化/单调决策优化/逆向思维)**
  
- 3200\.三角形的最大高度

  签到 / <u>数学</u>
  
- 3194\.最小元素和最大元素的最小平均值

  签到
  
- 3193\.统计逆序对的数目

  **DP/DP+前缀和优化**
  
- 3191\.使二进制数组全部等于1的最少操作次数I

  贪心
  
- 3192\.使二进制数组全部等于1的最少操作次数II

  贪心 前缀和
  
- 908\.最小差值I

  签到 数学/思维
  
- 910\.最小差值II

  枚举 排序 贪心
  
- 386\.字典序排数

  DFS / 枚举 / 排序
  
- 3185\.构成整天的下标对数目II

  签到 枚举 计数
  
- 3175\.找到连续赢K场比赛的第一位玩家

  数据结构(队列) 模拟 思维
  
- 110\.平衡二叉树

  DFS
  
- 3180\.执行操作可获得的最大总奖励I

  DP /+滑动窗口/二分优化
  
- 3181\.执行操作可获得的最大总奖励II

  DP + bitset优化 + SPJ优化
  
- 684\.冗余连接

  <u>并查集</u> 判环
  
- 685\.冗余连接II

  <u>并查集</u> 判有向环
  
- 264\.丑数II

  堆 / <u>DP+指针优化</u>
  
- 3211\.生成不含相邻零的二进制字符串

  爆搜(DFS/二进制枚举) DP算复杂度
  
- 50\.Pow(x,n)

  快速幂
  
- 3216\.交换后字典序最小的字符串

  签到
  
- 3165\.不包含相邻元素的子序列的最大和

  **带修DP 分治 线段树**
  
- 3259\.超级饮料的最大强化能量

  DP
  
- 2479\.图中最大星和

  图 排序 / <u>快速选择排序</u>
  
- 3226\.使两个整数相等的位更改次数

  签到 位运算
  
- 638\.大礼包

  DP 记忆化DFS 多维分组背包
  
- 209\.长度最小的子数组

  滑动窗口 / 前缀和+二分
  
- 633\.平方数之和

  枚举+数学(解方程) / <u>双指针 / 数学质因数分解</u>
  
- 3222\.求出硬币游戏的赢家

  签到 数学
  
- 930\.和相同的二元子数组

  滑动窗口 / 枚举+前缀和+STL
  
- 438\.找到字符串中所有字母异位词

  滑动窗口
  
- 3255\.长度为K的子数组的能量值II

  枚举 / 滑动窗口
  
- 3235\.判断矩形的两个角落是否可达

  **计算几何 DFS/并查集**
  
- 3242\.设计相邻元素求和服务

  签到
  
- 540\.有序数组中的单一元素

  二分
  
- 1547\.切棍子的最小成本

  <u>区间DP</u>
  
- 3258\.统计满足K约束的子字符串数量I

  滑动窗口+容斥 / <u>滑动窗口</u> / 签到
  
- 3261\.统计满足K约束的子字符串数量II

  **莫队+滑动窗口 / 滑动窗口+二分+前缀和 / 滑动窗口+预处理+前缀和**
  
- 3112\.访问消失节点的最少时间

  Dijkstra最短路
  
- 3249\.统计好节点的数目

  DFS 树
  
- 3341\.到达最后一个房间的最少时间I

  Dijkstra最短路
  
- 3239\.最少翻转次数使二进制矩阵回文I

  签到
  
- 3240\.最少翻转次数使二进制矩阵回文II

  **模拟 思维**
  
- 825\.适龄的朋友

  排序+二分 / <u>排序+双指针 / 前缀和</u>

- 661\.图片平滑器

  签到 前缀和
  
- 1202\.交换字符串中的元素

  并查集
  
- 3244\.新增道路查询后的最短距离II

  二分+模拟 / <u>并查集 / 线段树</u>
  
- 3248\.矩阵中的蛇

  签到
  
- 3233\.统计不是特殊数字的数字数量

  预处理 质数筛 + 二分 / <u>离散前缀和</u>
  
- 3238\.求出胜利玩家的数目

  签到
  
- 743\.网络延迟时间

  Dijkstra 最短路
  
- 69\.x 的平方根

  签到 数学 / <u>牛顿迭代法</u>

- 632\.最小区间

  <u>贪心+指针+堆</u> / 离散化+滑动窗口+二分 / 离散化+滑动窗口

- 3206\.交替组I

  签到
  
- 3208\.交替组II

  前缀和 / 滑动窗口
  
- 3245\.交替组III

  **线段树/树状数组 + 模拟 + 二分**
  
- 3251\.单调数组对的数目II

  DP + 差分 / <u> DP + 前缀和 / 组合数学 </u>
  
- 3232\.判断是否可以赢得数字游戏

  签到
  
- 3274\.检查棋盘方格颜色是否相同

  签到
  
- 3001\.捕获黑皇后需要的最少移动次数

  思维 + 模拟 / <u>数学</u>
  
- 2056\.棋盘上有效移动组合的数目

  DFS 模拟
  
- 999\.可以被进一步捕获的棋子数

  签到 模拟
  
- 688\.骑士在棋盘上的概率

  记忆化DFS / DP
  
- 782\.变为棋盘

  **思维 构造** 位运算
  
- 935\.骑士拨号器

  DP 预处理
  
- 2717\.半有序排列

  签到 数学
  
- 2931\.购买物品的最大开销

  数学(排序不等式) 排序 贪心
  
- 3266\.K次乘运算后的最终数组II

  数学(对数) 排序 贪心 快速幂 堆 模拟
  
- 1338\.数组大小减半

  STL(哈希/排序) 贪心 
  
- 1847\.最近的房间

  离线 二分 / +双指针
  
- 3285\.找到稳定山的下标

  签到
  
- 3292\.形成目标字符串需要的最少字符串数II

  **字符串哈希+二分+贪心 / 字符串哈希+双指针+贪心 / AC自动机+DP / Z函数+贪心 / KMP+DP**
  
- 3138\.同位字符串连接的最小长度

  数学(枚举因子) STL
  
- 2545\.根据第K场考试的分数排序

  排序 签到
  
- 1387\.将整数按权重排序

  记忆化DFS 排序
  
- 855\.考场就座

  大模拟 数据结构 STL 二分
  
- 1705\.吃苹果的最大数目

  模拟 数据结构 STL 贪心
  
- 3219\.切蛋糕的最小总开销II

  **DP / 最小生成树 贪心 逆向**
  
- 3080\.字符串及其反转中是否存在同一字符串

  签到 位运算优化
  
- 3159\.查询数组中元素的出现位置

  签到
  
- 3046\.分割数组

  签到 构造

- 1366\.通过投票对团队排名

  结构体排序
  
- 1367\.二叉树中的链表

  DFS (+ 字符串哈希 / KMP)
  
- 3280\.将日期转换为二进制表示

  签到
  
- 729\.我的日程安排表I

  二分 区间
  
- 731\.我的日程安排表II

  线段树
  
- 732\.我的日程安排表III

  差分 / 线段树
  
- 2241\.设计一个ATM机器

  模拟 签到
  
- 2274\.不含特殊楼层的最大连续楼层数

  排序
  
- 3019\.按键变更的次数

  签到 字符位运算
  
- 2264\.字符串中最大的3位相同数字

  签到
  
- 3298\.统计重新排列后包含另一个字符串的子字符串数目 II

  滑动窗口
  
- 3270\.求出数字答案

  签到
  
- 2275\.按位与结果大于零的最长组合

  **位运算 计数**
  
- 2270\.分割数组的方案数

  前缀和 枚举
  
- 3065\.超过阈值的最少操作数I

  签到
  
- 3066\.超过阈值的最少操作数II

  贪心 堆(STL)
  
- 3097\.或值至少为K的最短子数组II

  滑动窗口 / <u>LogTrick后缀和 / 滑动窗口+双栈重构(无逆运算区间滑动)</u>
  
- 3287\.求出数组中最大序列值

  状压DP / <u>贪心等优化</u>
  
- 2266\.统计打字方案数

  DP 数学(乘法原理，取模) 预处理
  
- 2239\.找到最接近0的数字

  签到
  
- 2218\.从栈中取出K个硬币的最大面值和

  **DP 分组背包**
  
- 1561\.你可以获得的最大硬币数目

  排序 贪心
  
- 2920\.收集所有金币可获得的最大积分

  树上DP
  
- 2944\.购买水果需要的最少金币数

  DP / <u>DP+滑动窗口优化</u>
  
- 2412\.完成所有交易的初始最少钱数

  **贪心**
  
- 40\.组合总和II

  <u>DFS 剪枝</u>
  
- 45\.跳跃游戏II

  DP / <u>DP+滑动窗口/堆优化 贪心</u>
  
- 119\.杨辉三角II

  签到
  
- 219\.存在重复元素II

  滑动窗口
  
- 350\.两个数组的交集II

  签到 STL
  
- 541\.反转字符串II

  签到 字符串
  
- 81\.搜索旋转排序数组II

  二分
  
- 598\.区间加法II

  思维 签到 数学
  
- 680\.验证回文串II

  签到 模拟 字符串
  
- 922\.按奇偶排序数组II

  签到 双指针
  
- 90\.子集II

  爆搜 DFS/二进制枚举
  
- 47\.全排列II

  爆搜 DFS/二进制枚举
  
- 80\.删除有序数组中的重复项II

  双指针 / 栈
  
- 63\.不同路径II

  DP
  
- 59\.螺旋矩阵II

  模拟 签到
  
- 913\.猫和老鼠

  **DP 拓扑排序 博弈论**
  
- 1728\.猫和老鼠 II

  DP 拓扑排序 博弈论
  
- 1760\.袋子里最少数目的球

  二分答案
  
- 1742\.盒子中小球的最大数目

  签到 枚举 / <u>预处理+前缀和 / 数位DP</u>
  
- 1552\.两球之间的磁力

  二分答案
  
- 1706\.球会落何处

  模拟
  
- 1299\.将每个元素替换为右侧最大元素

  签到 前缀和
  
- 1287\.有序数组中出现次数超过25%的元素

  签到 / 二分
  
- 624\.数组列表中的最大距离

  枚举 区间 思维

- 2595\.奇偶位数

  签到 位运算
  
- 2209\.用地毯覆盖后的最少白色砖块

  **DP**
  
- 2506\.统计相似字符串对的数目

  签到 数学 计数

### 新

- 1206\.设计跳表

  STL / <u>数据结构</u>

- 1656\.设计有序流

  签到 STL
  
- 2502\.设计内存分配器

  模拟 / <u>线段树二分</u>
  
- 2466\.统计构造好字符串的方案数

  DP
  
- 740\.删除并获得点数

  DP
  
- 3405\.统计恰好有 K 个相等相邻元素的数组数目

  <u>数学</u>
  
- 1472\.设计浏览器历史记录

  STL
  
- 2320\.统计放置房子的方式数

  DP / <u>DP+乘法原理</u>
  
- 2353\.设计食物评分系统

  STL
  
- 131\.分割回文串

  DFS
  
- 1278\.分割回文串III

  DP
  
- 2606\.找到最大开销的子字符串

  前缀和(/DP)

- 1745\.分割回文串IV

  DP / <u>manacher</u>
  
- 1328\.破坏回文串

  贪心 分类讨论
  
- 1191\.K次串联后最大子数组和

  前缀和

- 2321\.拼接数组的最大分数

  前缀和 / DP
  
- 2588\.统计美丽子数组数目

  位运算 前缀和 STL
  
- 2070\.每一个查询的最大美丽值

  排序 离线+双指针/<u>在线+前缀和+二分</u>
  
- 2269\.找到一个数字的K美丽值

  签到 数学(取模)
  
- 2597\.美丽子集的数目

  爆搜 / <u>DP+组合数学</u>
  
- 152\.乘积最大子数组

  DP
  
- 2012\.数组美丽值求和

  前缀和
  
- 3306\.元音辅音字符串计数II

  滑动窗口
  
- 3340\.检查平衡字符串

  签到
  
- 3110\.字符串的分数

  签到
  
- 2614\.对角线上的质数

  签到

- 1963\.使字符串平衡的最小交换次数

  贪心(括号序列)
  
- 2272\.最大波动的子字符串

  **DP**
  
- 2610\.转换二维数组

  STL / 排序
  
- 3418\.机器人可以获得的最大金币数

  DP
  
- 2612\.最少翻转操作数

  **BFS + (STL/并查集/笛卡尔树)优化**

- 1937\.扣分后的最大得分

  **DP+前缀和优化**
  
- 1143\.最长公共子序列

  DP

- 718\.最长重复子数组

  DP / 二分+字符串哈希
  
- 2680\.最大或值

  贪心+前缀和 / <u>贪心+位运算</u>

- 2787\.将一个数字表示成幂的和的方案数

  背包DP
  
- 2643\.一最多的行

  签到

- 2116\.判断一个括号字符串是否有效

  **括号序列 数学/STL/贪心**
  
- 2255\.统计是给定字符串前缀的字符串数目

  签到
  
- 2829\.k-avoiding数组的最小总和

  贪心 / 数学优化
  
- 2712\.使所有字符相等的最小成本

  前缀和 / <u>思维</u>
  
- 2716\.最小化字符串长度

  签到 STL/位运算 思维

- 2109\.向字符串添加空格

  模拟 字符串
  
- 2360\.图中的最长环

  DFS tarjan 内向基环树 

- 2711\.对角线上不同值的数量差

  前缀和 / 位运算 + 模拟(对角线)
  
- 2278\.字母在字符串中的百分比

  签到
  
- 2140\.解决智力问题

  DP
  
- 2874\.有序三元组中的最大值II

  前缀和(DP)
  
- 1863\.找出所有子集的异或总和再求和

  爆搜 / <u>数学+位运算</u>
  
- 368\.最大整除子集

  DP/最长路(拓扑排序) 数论
  
- 416\.分割等和子集

  DP(背包)
  
- 3375\.使数组的值全部为K的最少操作次数

  排序/map(unique)
  
- 435\.无重叠区间

  **贪心**
  
- 2999\.统计强大整数的数目

  <u>数位DP / 组合数学</u>
  
- 2843\.统计对称整数的数目

  枚举 / 预处理+前缀和 / <u>数位DP</u>
  
- 3272\.统计好整数的数目

  组合数学
  
- 1922\.统计好数字的数目

  快速幂
  
- 1534\.统计好三元组

  枚举 / <u>前缀和</u>

- 2179\.统计数组中好三元组数目

  树状数组
  
- 2537\.统计好子数组的数目

  滑动窗口

## 算法

> 力扣其他，CF杂题，其他杂题是 `leetcode.md` 搬过来的；力扣是新的力扣常规题。

### 力扣其他

> ### 力扣比赛

#### 周赛327

**vp成绩**：

![image-20230112173246572](img/image-20230112173246572.png)

##### 2529\. 正整数和负整数的最大计数

签到题。进阶就二分 xx bound 即可。

```c++
int maximumCount(vector<int> &nums)
{
    int neg = 0, pos = 0;
    for (int i = 0, n = nums.size(); i < n; ++i)
    {
        neg += nums[i] < 0;
        pos += nums[i] > 0;
    }
    return max(neg, pos);
}
```



##### 2530\. 执行 K 次操作后的最大分数

小根堆的板子题。

```c++
long long maxKelements(vector<int> &nums, int k)
{
    using ll = long long;
    priority_queue<ll> q;
    for (int i = 0, n = nums.size(); i < n; ++i)
    {
        q.push(nums[i]);
    }
    ll ans = 0;
    while (k--)
    {
        ll x = q.top();
        q.pop();
        ans += x;
        q.push((x - 1) / 3 + 1);
    }
    return ans;
}
```



##### 2531\. 使字符串总不同字符的数目相等

暴力优化。容易发现每个字母只有前两次出现(/首次出现)是有用的，之后再出现全删了。因此可以在一遍扫描后用 $O(26^2)$ 的复杂度暴力尝试所有字母组合的交换。(写得烂，实际上写出来 $O(52^2)$，但无伤大雅)

```c++
bool isItPossible(string word1, string word2)
{
    int bin1[130] = {}, bin2[130] = {};
    int n1 = 0, n2 = 0, m1 = 0, m2 = 0;
    string s1, s2;
    auto add = [&](char c, int *bin, int &m)
    {
        if (bin[c]++ == 0)
        {
            m++;
        }
    };
    auto del = [&](char c, int *bin, int &m)
    {
        if (--bin[c] == 0)
        {
            m--;
        }
    };
    for (auto c : word1)
    {
        add(c, bin1, m1);
        if (bin1[c] <= 2)
        {
            n1++;
            s1 += c;
        }
    }
    for (auto c : word2)
    {
        add(c, bin2, m2);
        if (bin2[c] <= 2)
        {
            n2++;
            s2 += c;
        }
    }
    for (int i = 0; i < n1; ++i)
    {
        for (int j = 0; j < n2; ++j)
        {
            del(s1[i], bin1, m1);
            del(s2[j], bin2, m2);
            add(s1[i], bin2, m2);
            add(s2[j], bin1, m1);
            if (m1 == m2)
            {
                return true;
            }
            del(s1[i], bin2, m2);
            del(s2[j], bin1, m1);
            add(s1[i], bin1, m1);
            add(s2[j], bin2, m2);
        }
    }
    return false;
}
```



##### 2532\. 过桥的时间

大模拟题。按题意做即可，一眼大约 $O(t\log n)$ 的复杂度。

```c++
static long long t;
static int suc;
static int hsuc;
struct worker
{
    int i, ltr, po, rtl, pn;
    bool operator<(const worker &rhs) const
    {
        if (ltr + rtl != rhs.ltr + rhs.rtl)
        {
            return ltr + rtl < rhs.ltr + rhs.rtl;
        }
        return i < rhs.i;
    }
};
static priority_queue<worker> lq, rq;

struct event;
static bool busy;
static priority_queue<event> ev;
const static int e_finish_cross_bridge_fright = 1;
const static int e_finish_putnew = 2;
const static int e_finish_cross_bridge_fleft = 3;
const static int e_finish_putold = 4;
struct event
{
    long long t;
    int ty;
    worker w;
    void next() const
    { // 回调事件
        if (ty == e_finish_cross_bridge_fright)
        { // putnew
            busy = false;
            ++suc;
            ev.push({t + w.pn, e_finish_putnew, w});
        }
        else if (ty == e_finish_putnew)
        { // left to right
            lq.push(w);
        }
        else if (ty == e_finish_cross_bridge_fleft)
        { // putold
            busy = false;
            ++hsuc;
            ev.push({t + w.po, e_finish_putold, w});
        }
        else if (ty == e_finish_putold)
        { // right to left
            rq.push(w);
        }
    }
    bool operator<(const event &rhs) const
    {
        return t > rhs.t;
    }
};

class Solution
{
public:
    int findCrossingTime(int n, int k, vector<vector<int>> &time)
    {
        t = 0;
        suc = 0;  // 走回左岸的
        hsuc = 0; // 从旧仓库拿起的
        busy = false;
        while (!ev.empty())
        {
            ev.pop();
        }
        while (!lq.empty()) // left side waiting
        {
            lq.pop();
        }
        while (!rq.empty())
        {
            rq.pop();
        }

        for (int i = 0; i < k; ++i)
        {
            lq.push({i, time[i][0], time[i][1], time[i][2], time[i][3]});
        }

        while (suc < n)
        {
            while (!ev.empty() && ev.top().t == t)
            {
                ev.top().next();
                ev.pop();
            }
            if (!busy)
            {
                if (!rq.empty())
                {
                    worker w = rq.top();
                    rq.pop();
                    ev.push({t + w.rtl, e_finish_cross_bridge_fright, w});
                    busy = true;
                }
                else if (!lq.empty() && hsuc < n)
                {
                    worker w = lq.top();
                    lq.pop();
                    ev.push({t + w.ltr, e_finish_cross_bridge_fleft, w});
                    busy = true;
                }
            }
            if (suc < n && !ev.empty())
            {
                t = ev.top().t;
            }
        }
        return t;
    }
};
```

> 挂了一次，因为 operator 重载写炸了，太久没练手写成了：
>
> ```c++
> bool operator<(const worker &rhs) const
> {
>  if (ltr + rtl < rhs.ltr + rhs.rtl)
>  {
>      return true;
>  }
>  return i < rhs.i;
> }
> ```





#### Shell

##### 193\. 有效电话号码

[题目](https://leetcode.cn/problems/valid-phone-numbers/),任意一种：

```shell
grep -P '^(\d{3}-|\(\d{3}\) )\d{3}-\d{4}$' file.txt
sed -n -r '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/p' file.txt
awk '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-([0-9]{4})$/' file.txt
```

chatGPT:

grep 是一种在文本文件中查找文本的命令行工具。它的基本语法如下：

```sh
grep 'pattern' file
```

其中，'pattern' 是要查找的文本字符串，file 是要搜索的文件。

如果要在多个文件中搜索，可以将文件名列在命令行中：

```sh
grep 'pattern' file1 file2 file3
```

可以在目录中搜索文件，可以使用通配符。

```sh
grep 'pattern' /path/to/dir/*
```

还可以使用递归模式搜索整个目录：

```sh
grep -r 'pattern' /path/to/dir
```

grep 命令还有很多选项可用, 例如：

- -n : 显示匹配行的行号。输出如 `\d:` 格式不带空格拼接后面内容
- -i : 忽略大小写。
- -v : 显示不包含匹配字符串的行。
- -w 用于在文本文件中搜索仅完全匹配单词的文本(类似于正则的单词边界检测，即若有 `sh` 能匹配 `sh st` 不能匹配 `shst`)

可以使用 man grep 查看详细信息。

`grep -P` 是一个选项，它允许使用 Perl 正则表达式 (PCRE) 来搜索文本。

Perl 正则表达式是一种功能强大的正则表达式语言，支持许多特殊字符和模式匹配操作。例如，可以使用 PCRE 中的捕获组来匹配多个子字符串，或者使用命名组来方便地管理匹配的子字符串。

如果要使用 PCRE 来搜索文本，可以在 grep 命令中使用 -P 选项，例如：

```sh
grep -P '\d{3}-\d{2}-\d{4}' file
```

这个命令将在文件中查找所有符合美国社会安全号码格式的字符串（xxx-xx-xxxx）。

请注意，使用 -P 选项需要 PCRE 库的支持。如果系统上没有安装该库，则会提示错误信息。

另外, -P 是GNU grep独有的参数，在其他版本的 grep 中可能不支持。

假设你有一个名为 "log.txt" 的文件，其中包含多行日志信息，你想查找所有包含 "error" 的行。

可以使用以下命令来实现：

```sh
grep 'error' log.txt
```

这个命令将在 "log.txt" 中查找所有含有 "error" 的行，并将这些行的文本打印到屏幕上。



##### 195\. 第十行

[题目](https://leetcode.cn/problems/tenth-line/)。

`cut` 是一个命令行工具，用于从文本文件中删除或提取特定字段。它通常用于处理以某种字符（通常是制表符或空格）分隔的文本文件。

`cut` 的基本语法如下：

```sh
cut -f field_number -d delimiter file
```

其中，-f 指定要提取的字段，-d 指定字段之间的分隔符，file 是要处理的文件。

例如，假设你有一个文件 "data.txt"，其中包含以逗号分隔的数据，如下所示：

```
Copy codeName,Age,Gender
John,30,Male
Sara,25,Female
```

你可以使用以下命令提取第一列（Name）：

```sh
cut -f 1 -d ',' data.txt
```

输出

```
Name
John
Sara
```

也可以提取多列，例如提取第一列和第二列

```sh
cut -f 1,2 -d ',' data.txt
```

输出

```
Name,Age
John,30
Sara,25
```

第二种格式：

`cut -d: -f2` 是一个 `cut` 命令的例子。

`-d:` 指定字段之间的分隔符为冒号 (:)。

`-f2` 指定要提取的字段是第二个字段。

例如，假设你有一个文件 "data.txt"，其中包含以冒号分隔的数据，如下所示：

```
Name:Age:Gender
John:30:Male
Sara:25:Female
```

你可以使用 `cut -d: -f2` 来提取第二列（Age）:

```sh
cut -d: -f2 data.txt
```

输出

```
30
25
```

这个命令将会在文件中查找所有冒号分隔的字段，并输出第二个字段。

由此，引出第一种解法：

```sh
grep -n "" file.txt | grep -w '10' | cut -d : -f 2
```



`sed` 是一个流编辑器，用于在文本文件中执行替换、删除、插入和其他编辑操作。它在命令行中运行，可以对文本文件进行非常强大的编辑。

`sed` 的基本语法如下：

```sh
sed 's/old/new/g' file
```

其中 `s/old/new/g` 是一个替换命令，它会替换文件中所有的 "old" 为 "new"。

```sh
sed -n '10p' file.txt
```

`-n` 选项表示禁止默认输出，只有在符合特定条件时才会输出

`10p` 指令是打印第10行。



```sh
awk '{if(NR==10){print $0}}' file.txt
```

`awk` 是一种用于文本处理的命令行工具，可以轻松地对文本文件进行模式匹配、替换、计算和其他操作。

在这个命令中，`NR==10` 是一个条件，它指明 awk 只对第10行执行操作。

`{print $0}` 指令是打印整行。



加小于十行判定：

```sh
row_num=$(cat file.txt | wc -l)
echo $row_num
if [ $row_num -lt 10 ];then
    echo "The number of row is less than 10"
else
    awk '{if(NR==10){print $0}}' file.txt
fi
```

输出总行数的办法：

```sh
awk '{print NR}' file.txt | tail -n1
awk 'END{print NR}' file.txt 
grep -nc "" file.txt 
grep -c "" file.txt 
grep -vc "^$" file.txt 
grep -n "" file.txt|awk -F: '{print '}|tail -n1 | cut -d: -f1
grep -nc "" file.txt
sed -n "$=" file.txt 
wc -l file.txt 
cat file.txt | wc -l
wc -l file.txt | cut -d' ' -f1
```



##### 194\. 转置字符

[题目](https://leetcode.cn/problems/transpose-file/)

```sh
columns=$(cat file.txt | head -n 1 | wc -w)
for i in $(seq 1 $columns)
do
awk '{print $'''$i'''}' file.txt | xargs
done
```

1. 使用 `cat` 命令读取文件 file.txt 的第一行
2. 使用 `head -n 1` 命令取出第一行
3. 使用 `wc -w` 命令统计第一行的单词数，并将结果存储在变量 `columns` 中
4. 使用 `seq 1 $columns` 命令生成从 1 到 $columns 的数字序列
5. 对于序列中的每一个数字，使用 `awk '{print $i}' file.txt` 命令取出文件中第i列的值
6. 将第i列的值使用 `xargs` 命令打印到屏幕上. xargs 可将多个参数用空格隔开，如 `cat` 管道到 `xargs` 会以空格代替换行

`xargs` 是一个命令行工具，它可以将输入转换为命令行参数并执行命令。通常与其他命令结合使用，如 find, grep 等等。

`xargs` 的基本语法如下：

```sh
command | xargs [options] [command [options]]
```

其中，`command` 是输入的命令，`xargs` 将其输出作为参数传递给后面的命令。

例如，假设你有一个文件夹 /tmp 中有很多文件，你想删除所有以 .txt 结尾的文件。

```sh
\find /tmp -name '*.txt' | xargs rm
```

这个命令将使用 find 命令在 /tmp 目录中查找所有以 .txt 结尾的文件，并将这些文件名传递给 xargs 命令。xargs 命令将这些文件名作为参数传递给后面的 rm 命令，从而删除这些文件

上文莫名其妙的一堆单引号，可以改为双引号解析内部变量：

```sh
awk '{print $'"$i"'}' file.txt | xargs
```

或：(因为多余的可以认为是空串`''`，做的字符串拼接)

```sh
awk '{print $'$i'}' file.txt | xargs
```



`$()` 是 shell 中的一种特殊格式，称为命令替换。它允许将命令的输出作为参数传递给其他命令。

它的语法如下：

```sh
$(command)
```

其中，command 是要执行的命令，$() 将命令的输出作为参数传递给其他命令



##### 192\. 统计词频

[题目](https://leetcode.cn/problems/word-frequency/)

```sh
cat words.txt | tr -s ' ' '\n' | sort | uniq -c | sort -nr | awk '{ print $2, $1 }'
```

`cat` 读文件并返回每行内容

`tr` 命令用于转换或删除文件中的字符 -s：缩减连续重复的字符成指定的单个字符。在这里将任意多空格转为单个换行

`sort` 按字典序排序每一行

`uniq` 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。-c：在每列开头显示该行重复出现的次数，格式是 `\d` 加一个空格与原内容隔开。

再次排序，使其倒序。注意，当单词的出现次数大于10时，sort 需要考虑按数字排序，而非默认的按 ascii 码排序

然后逐行按指定格式输出，[awk参考](https://mp.weixin.qq.com/s/rIvOa5yvXFCAWiidxFz_ug)



#### 数据库

##### 175\. 组合两个表

[题目](https://leetcode.cn/problems/combine-two-tables/)

```mysql
select a.firstName, a.lastName, b.city, b.state
from Person as a left join Address as b
on a.personId = b.personId;
```

> 更优雅：
>
> ```mysql
> select FirstName, LastName, City, State
> from Person left join Address
> on Person.PersonId = Address.PersonId;
> ```



##### 176\. 第二高的薪水

[题目](https://leetcode.cn/problems/second-highest-salary/)，注意去重后的第二高

对只有一行一列的数据，可以用再次 select 的方法输出，如果查不到数据，这样输出会返回 NULL，并且可以用 as 方法重命名列名

```mysql
select 1 as colname;
```

将查询结果套到这个 select 里，即可查空输出 NULL，个人解法：先嵌套子查询找最值，然后取小于最值的最大值

```mysql
select (
    select salary from Employee
    where salary < (select max(salary) from Employee)
    order by salary desc
    limit 1
) as SecondHighestSalary
```

更优解：直接排序时加 offset

```mysql
SELECT
    (SELECT DISTINCT
            Salary
        FROM
            Employee
        ORDER BY Salary DESC
        LIMIT 1 OFFSET 1) AS SecondHighestSalary;
```

也可以套 ifnull 函数：

```mysql
SELECT
    IFNULL(
      (SELECT DISTINCT Salary
       FROM Employee
       ORDER BY Salary DESC
        LIMIT 1 OFFSET 1),
    NULL) AS SecondHighestSalary
```



##### 177\. 第N高的薪水

[题目](https://leetcode.cn/problems/nth-highest-salary/)

offset 不能是表达式只能是变量/常量不然会炸，所以先设变量

```mysql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  declare x int;
  set x = n-1;
  RETURN (
      # Write your MySQL query statement below.
      select (
          select distinct salary from Employee
          order by salary desc limit 1 offset x
      ) 
  );
END
```

可以把赋值塞到初始化，两行合一行：

```mysql
declare x int default N-1;
```

也可以不设变量，直接修改传入的参数：

```mysql
set N = N-1; # 或 :=
```

> chatGPT:
>
> `set n = 1` 是在 MySQL 的 SQL 查询中设置变量的语法，在这种情况下， n 将会被视为一个普通的变量。
>
> 而 `set n := 1` 是在 MySQL 的存储过程中设置变量的语法，在这种情况下，n 将会被视为一个局部变量。

[更多其他解法](https://leetcode.cn/problems/nth-highest-salary/solution/mysql-zi-ding-yi-bian-liang-by-luanz/)



##### 178\. 分数排名

[题目](https://leetcode.cn/problems/rank-scores/)

```mysql
select score,
dense_rank() over (order by score desc) as `rank` 
from Scores
```



##### 180\. 连续出现的数字

[题目](https://leetcode.cn/problems/consecutive-numbers/)

```mysql
select distinct a.Num as ConsecutiveNums
from Logs as a, Logs as b, Logs as c
where a.Id = b.Id - 1 and b.Id = c.Id - 1 and a.Num = b.Num and b.Num = c.Num
```



##### 181\. 超过经理收入的员工

[题目](https://leetcode.cn/problems/employees-earning-more-than-their-managers/) 注意读题，题意应当是每个人只有零个或一个上级经理，找到收入大于他直接上级的人

个人版用时很高的的代码(800ms+)：

```mysql
select a.name as `Employee`
from Employee as a
where a.salary > (
    select b.salary from Employee as b
    where b.id=a.managerId and a.salary>b.salary)
```

快很多(360ms)的两个相似代码：

```mysql
SELECT
    a.Name AS 'Employee'
FROM
    Employee AS a,
    Employee AS b
WHERE
    a.ManagerId = b.Id
    AND a.Salary > b.Salary
```

```mysql
SELECT
     a.NAME AS Employee
FROM Employee AS a JOIN Employee AS b
     ON a.ManagerId = b.Id
     AND a.Salary > b.Salary
```



##### 184\. 部门工资最高的员工

[题目](https://leetcode.cn/problems/department-highest-salary/)

个人效率很低的代码：(1080ms)

```mysql
select b.name as `Department`, a.name as `Employee`, a.salary as `Salary`
from Employee as a, Department as b
where a.departmentId = b.id and a.salary >= (
    select max(salary) from Employee as c
    where c.departmentId = b.id 
)
```

优化代码：(664ms)

```mysql
SELECT
    Department.name AS 'Department',
    Employee.name AS 'Employee',
    Salary
FROM
    Employee
        JOIN
    Department ON Employee.DepartmentId = Department.Id
WHERE
    (Employee.DepartmentId , Salary) IN
    (   SELECT
            DepartmentId, MAX(Salary)
        FROM
            Employee
        GROUP BY DepartmentId
	)
```



##### 185\. 部门工资前三高的所有员工

[题目](https://leetcode.cn/problems/department-top-three-salaries/)

> 注意到子查询不能带 limit(`This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'`) 所以下面语句不能用：
>
> ```mysql
> select b.name as `Department`, a.name as `Employee`, Salary
> from Employee as a, Department as b
> where a.departmentId = b.id and
> Salary > any(
>  select c.salary from Employee as c
>  where a.departmentId = c.departmentId
>  order by salary desc limit 3
> )
> ```

修改上一题的思路，考虑：前三大，即在去重后的子查询里，最多只有两个(即 `<3`)人工资比他大，count 一下即可

```mysql
select b.name as `Department`, a.name as `Employee`, Salary
from Employee as a join Department as b
on a.departmentId = b.id
where 3 > (
    select count(distinct c.salary) from Employee as c
    where c.salary > a.salary
    and a.departmentId = c.departmentId
)
```



##### 182\. 查找重复的电子邮箱

[题目](https://leetcode.cn/problems/duplicate-emails/)

自己的弱智代码：(多余地增加了外层 select)

```mysql
select distinct a.Email from Person as a
where a.Email in (
    select b.Email from Person as b 
    group by b.Email having count(*)>1)
```

官解：

```mysql
select Email from Person group by Email having count(Email) > 1
```



##### 262\. 行程和用户

[题目](https://leetcode.cn/problems/trips-and-users/)

注意：

- 枚举类型的操作跟字符串差不多
- 联表要点(不能or合并连一次，必须连两次)
- round, sum, if 来实现计算

```mysql
select a.request_at as Day,
    round(sum(if(a.status='completed',0,1))/count(a.status),2) as `Cancellation Rate`
from Trips as a
join Users as b on a.client_id=b.users_id and b.banned='no'
join Users as c on a.driver_id=c.users_id and c.banned='no'
where a.request_at between '2013-10-01' and '2013-10-03'
group by a.request_at
```

效率高一点：

```mysql
SELECT T.request_at AS `Day`, 
	ROUND(
			SUM(
				IF(T.STATUS = 'completed',0,1)
			)
			/ 
			COUNT(T.STATUS),
			2
	) AS `Cancellation Rate`
FROM trips AS T
WHERE 
T.Client_Id NOT IN (
	SELECT users_id
	FROM users
	WHERE banned = 'Yes'
)
AND
T.Driver_Id NOT IN (
	SELECT users_id
	FROM users
	WHERE banned = 'Yes'
)
AND T.request_at BETWEEN '2013-10-01' AND '2013-10-03'
GROUP BY T.request_at
```



##### 196\.删除重复的电子邮箱

[题目](https://leetcode.cn/problems/delete-duplicate-emails/)

> 不能用下面语句，会报错为 `You can't specify target table 'Person' for update in FROM clause`
>
> ```mysql
> delete from Person
> where id not in (
>  select b.id from Person as b 
>  where b.id <= all (
>      select c.id from Person as c
>      where c.email = b.email
>  )
> )
> ```

```mysql
delete a from Person a, Person b
where a.email=b.email and a.id>b.id
```

其他方法：

```mysql
DELETE 
FROM
	Person 
WHERE
	id NOT IN 
	(SELECT t.id from (SELECT MIN(id) /*每个email分组中最小id*/as id FROM Person GROUP BY Email/*依据Email进行分组*/) t)
```



##### 601\.体育馆的流量

[题目](https://leetcode.cn/problems/human-traffic-of-stadium/)

个人不看题解的AC代码(340ms)：

```mysql
select distinct a.* from Stadium as a, Stadium as b, Stadium as c
where a.people>=100 and b.people>=100  and c.people>=100 and(
    (a.id=b.id-1 and b.id=c.id-1) or
    (a.id=b.id+1 and a.id=c.id-1) or
    (a.id=b.id+1 and b.id=c.id+1)
)
order by visit_date asc
```

372ms 的窗口函数解法，好处是适用于任意连续(上述连续几个要join几下)：

```mysql
with t1 as(
    select *,id - row_number() over(order by id) as rk
    from stadium
    where people >= 100
)

select id,visit_date,people
from t1
where rk in(
    select rk
    from t1
    group by rk
    having count(rk) >= 3
)
```

原理：如果要筛去 `<100` 的，则每次删除时会造成一个不连续，致使前后的 `id-row_number` (即未删时row number减既删时row number)的差值加至少1。所以每个连续段的差值是一致的，只要这个连续段长够3即可纳入



##### 197\.上升的温度

[题目](https://leetcode.cn/problems/rising-temperature/)

日期比较，使用 `datediff`，(472ms)

```mysql
select a.id from Weather as a, Weather as b
where datediff(a.recordDate,b.recordDate)=1 and a.Temperature>b.Temperature
```

窗口函数更快(348ms)

```mysql
select id
from
    (select 
        id,
        temperature,
        recordDate,
        lag(recordDate,1) over(order by recordDate) as last_date,
        lag(temperature,1) over(order by recordDate) as last_temperature
    from Weather) a
where temperature > last_temperature and datediff(recordDate, last_date) = 1
```

其他函数：

```mysql
select w1.Id
from Weather as w1, Weather as w2
where TIMESTAMPDIFF(DAY, w2.RecordDate, w1.RecordDate) = 1 
AND w1.Temperature > w2.Temperature
```

```mysql
select a.id 
    from weather a join weather b 
    on (a.recorddate = adddate(b.recorddate,INTERVAL 1 day))
where a.temperature > b.temperature
```

```mysql
select 
    w.Id
from Weather w
join (
    select 
        RecordDate,Temperature
    from 
        Weather
) t1
on w.RecordDate = DATE_ADD(t1.RecordDate,INTERVAL 1 day)
where w.Temperature > t1.Temperature;
```



##### 608\.树节点

[题目](https://leetcode.cn/problems/tree-node/)

个人代码：



```mysql
select id,
    case when (id in (select id from tree where isnull(p_id))) then 'Root'
    when (id in (select distinct p_id from tree)) then 'Inner'
    else 'Leaf' end as `Type`
from tree -- 或 is null 关键字而不是用函数
```

可以等价于：

```mysql
SELECT
    atree.id,
    IF(ISNULL(atree.p_id),
        'Root',
        IF(atree.id IN (SELECT p_id FROM tree), 'Inner','Leaf')) Type
FROM tree atree
```



##### 511\.游戏玩法分析I

[题目](https://leetcode.cn/problems/game-play-analysis-i/)

group by 裸题：

```mysql
select player_id, min(event_date) as first_login
from Activity group by player_id
```



##### 626\.换座位

[题目](https://leetcode.cn/problems/exchange-seats/)

if-else 题：

```mysql
select id,
    case when id%2=1 and isnull(lead(student,1) over (order by id asc))=0
        then lead(student,1) over (order by id asc)
    when id%2=0 then lag(Seat.student,1) over (order by id asc)
    else student end as `student`
from Seat
```

注意不能直接搞 min, max, count 等聚类函数，否则只会查一列。

要搞可以这么搞：

```mysql
SELECT
    (CASE
        WHEN MOD(id, 2) != 0 AND counts != id THEN id + 1
        WHEN MOD(id, 2) != 0 AND counts = id THEN id
        ELSE id - 1
    END) AS id,
    student
FROM
    seat,
    (SELECT
        COUNT(*) AS counts
    FROM
        seat) AS seat_counts
ORDER BY id ASC;
```



##### 584\.寻找用户推荐人

[题目](https://leetcode.cn/problems/find-customer-referee/)

注意 mysql 是三值比较，即有 true, false, unknown，所以要特判 null

```mysql
select name from customer where referee_id!=2 or isnull(referee_id)
```

安全等于：当两个操作数均为 NULL 时，其返回值为 1 而不为 NULL； 而当一个操作数为 NULL 时，其返回值为 0 而不为 NULL。 [ref](https://leetcode.cn/link/?target=http://c.biancheng.net/view/7191.html)

```mysql
SELECT name FROM customer WHERE NOT referee_id <=> 2;
```



##### 1393\.股票的资本损益

[题目](https://leetcode.cn/problems/capital-gainloss/)

```mysql
select stock_name,
    sum(case when operation='Buy' then -price else price end) as `capital_gain_loss`
from Stocks
group by stock_name
```

题解其他写法解法：

```mysql
select 
    stock_name, 
    sum(if(operation='Buy',-price, price)) capital_gain_loss 
from Stocks
group by stock_name
```



##### 586\.订单最多的客户

[题目](https://leetcode.cn/problems/customer-placing-the-largest-number-of-orders/)

我的实现：(一定要有 as c 不然报错，临时表必须命名)

```mysql
select c.customer_number from (
    select customer_number, count(*)
    from Orders
    group by customer_number 
    order by count(*) desc
    limit 1
) as c
```

更优雅的做法是：

```mysql
SELECT
    customer_number
FROM
    orders
GROUP BY customer_number
ORDER BY COUNT(*) DESC
LIMIT 1
```



##### 158\.市场分析I

[题目](https://leetcode.cn/problems/market-analysis-i/)

究极低效个人代码：

```mysql
select user_id as `buyer_id`, join_date, if(isnull(tmp),0,tmp) as `orders_in_2019`
from Users left join (
    select buyer_id, count(*) as tmp from Orders
    where extract(year from order_date)='2019'
    group by buyer_id
) as c on user_id=buyer_id
```

快 300ms：

```mysql
select Users.user_id as buyer_id, join_date, ifnull(UserBuy.cnt, 0) as orders_in_2019
from Users
left join (
    select buyer_id, count(order_id) cnt 
    from Orders
    where order_date between '2019-01-01' and '2019-12-31'
    group by buyer_id
) UserBuy
on Users.user_id = UserBuy.buyer_id
```



##### 595\.大的国家

[题目](https://leetcode.cn/problems/big-countries/)

慢：

```mysql
select name,population,`area` from World
where `area`>=3000000 or population>=25000000
```

快：(快一点)

```mysql
SELECT
    name, population, area
FROM
    world
WHERE
    area >= 3000000

UNION

SELECT
    name, population, area
FROM
    world
WHERE
    population >= 25000000
```



##### 596\.超过5名学生的课

[题目](https://leetcode.cn/problems/classes-more-than-5-students/)

签。

```mysql
select class from Courses
group by class
having count(*)>=5
```



##### 607\.销售员

[题目](https://leetcode.cn/problems/sales-person/)

较高效率的个人写法：

```mysql
select a.name from SalesPerson as a
where a.sales_id not in (
    select b.sales_id from Orders as b
    where b.com_id in (
        select c.com_id from Company as c
        where c.name like 'RED'
    )
)
```



##### 620\.有趣的电影

[题目](https://leetcode.cn/problems/not-boring-movies/)

签。

```mysql
select * from cinema
where id%2=1 and description not like 'boring'
order by rating desc
```



##### 627\.变更性别

[题目](https://leetcode.cn/problems/swap-salary/)

不快：

```mysql
update Salary set sex=(
    case when sex='f' then 'm' else 'f' end
)
```

比较快：

```mysql
update salary set sex = if(sex='m','f','m');
```

跟上面速度一样：

```mysql
update salary set sex = char(ascii('m') + ascii('f') - ascii(sex));
```



##### 1084\.销售分析III

[题目](https://leetcode.cn/problems/sales-analysis-iii/)

低效率：

```mysql
select product_id, product_name from Product
where product_id not in (
    select product_id from Sales
    where sale_date not between '2019-01-01' and '2019-03-31'
) and product_id in (
    select distinct product_id from Sales
)
```

一样低效率：

```mysql
select
    product_id,
    product_name
from product
where product_id in (
    select
        product_id
    from sales
    group by product_id
    having max(sale_date) <= '2019-03-31'
    and min(sale_date) >= '2019-01-01'
)
```

快 200ms:

```mysql
select
    s.product_id,
    p.product_name
from
    Sales s left join Product p
        on s.product_id = p.product_id
group by
    s.product_id
having
    min(s.sale_date) >= '2019-01-01'
        and max(s.sale_date) <= '2019-03-31'
```



##### 1141\.查询近30天活跃用户数

[题目](https://leetcode.cn/problems/user-activity-for-the-past-30-days-i/)

我的写法一：

```mysql
select activity_date as `day`,
    count(distinct user_id) as `active_users`
from Activity
where activity_date between '2019-06-28' and '2019-07-27'
group by activity_date
```

写法二：(没我的写法快)

```mysql
SELECT activity_date AS day, count(distinct user_id) AS active_users
FROM activity
WHERE DATEDIFF('2019-07-27', activity_date) >=0
AND DATEDIFF('2019-07-27', activity_date) < 30
GROUP BY activity_date;
```



##### 1148\.文章浏览I

[题目](https://leetcode.cn/problems/article-views-i/submissions/)

```mysql
select distinct author_id as id
from Views
where author_id=viewer_id
order by author_id asc
```



##### 1179\.重新格式化部门表

[题目](https://leetcode.cn/problems/reformat-department-table/)

```mysql
SELECT id, 
SUM(CASE WHEN month='Jan' THEN revenue END) AS Jan_Revenue,
SUM(CASE WHEN month='Feb' THEN revenue END) AS Feb_Revenue,
SUM(CASE WHEN month='Mar' THEN revenue END) AS Mar_Revenue,
SUM(CASE WHEN month='Apr' THEN revenue END) AS Apr_Revenue,
SUM(CASE WHEN month='May' THEN revenue END) AS May_Revenue,
SUM(CASE WHEN month='Jun' THEN revenue END) AS Jun_Revenue,
SUM(CASE WHEN month='Jul' THEN revenue END) AS Jul_Revenue,
SUM(CASE WHEN month='Aug' THEN revenue END) AS Aug_Revenue,
SUM(CASE WHEN month='Sep' THEN revenue END) AS Sep_Revenue,
SUM(CASE WHEN month='Oct' THEN revenue END) AS Oct_Revenue,
SUM(CASE WHEN month='Nov' THEN revenue END) AS Nov_Revenue,
SUM(CASE WHEN month='Dec' THEN revenue END) AS Dec_Revenue
FROM department
GROUP BY id
ORDER BY id;
```



##### 1484\.按日期分组销售产品

[题目](https://leetcode.cn/problems/group-sold-products-by-the-date/)

```mysql
select sell_date, count(distinct product) as `num_sold`,
    group_concat(distinct product order by product separator ',') as `products`
from Activities as a
group by sell_date
order by sell_date
```

或：

```mysql
SELECT sell_date,
       COUNT(DISTINCT product) num_sold,
       GROUP_CONCAT(DISTINCT product) products
FROM Activities
GROUP BY sell_date
```



##### 1407\.排名靠前的旅行者

[题目](https://leetcode.cn/problems/top-travellers/)

```mysql
select name, if(isnull(sum(distance)),0,sum(distance)) as `travelled_distance`
from Users left join Rides on Rides.user_id=Users.id
group by user_id
order by travelled_distance desc, name asc
```

效率差一点的写法：

```mysql
select
name,ifnull(travelled_distance,0) as travelled_distance
from Users
left join(
select
user_id,sum(distance) as travelled_distance 
from 
Rides 
group by user_id
)t1
on t1.user_id= Users.id
order by travelled_distance desc, name asc
```



##### 1795\.每个产品在不同商店的价格

[题目](https://leetcode.cn/problems/rearrange-products-table/)

is not null

```mysql
SELECT product_id, 'store1' store, store1 price FROM products WHERE store1 IS NOT NULL
UNION
SELECT product_id, 'store2' store, store2 price FROM products WHERE store2 IS NOT NULL
UNION
SELECT product_id, 'store3' store, store3 price FROM products WHERE store3 IS NOT NULL
```



##### 1873\.计算特殊奖金

[题目](https://leetcode.cn/problems/calculate-special-bonus/)

770ms:

```mysql
SELECT employee_id,
IF(MOD(employee_id,2)!=0 AND LEFT(name,1)!='M',salary,0) bonus
FROM Employees
ORDER BY employee_id
```

600ms:

```mysql
select employee_id, 
    case when name not like 'M%' and employee_id&1=1 then salary
    else 0 end as `bonus`
from Employees
order by employee_id asc
```

481ms:

```mysql
SELECT employee_id ,salary AS bonus
FROM Employees
WHERE employee_id%2!=0 AND name NOT LIKE ('M%')
UNION 
SELECT employee_id ,salary*0 AS bonus
FROM Employees
WHERE employee_id%2=0 OR name LIKE ('M%')
ORDER BY employee_id;
```



##### 1890\.2020年最后一次登录

[题目](https://leetcode.cn/problems/the-latest-login-in-2020/)

慢：

```mysql
select user_id, max(time_stamp) as `last_stamp`
from Logins
where extract(year from time_stamp) = '2020'
group by user_id
```

```mysql
SELECT user_id, max(time_stamp) last_stamp
FROM Logins
WHERE year(time_stamp) = 2020
GROUP BY user_id
```

```mysql
select user_id, max(time_stamp) last_stamp
from Logins
where time_stamp >= '2020-01-01 00:00:00' and time_stamp <= '2020-12-31 23:59:59'
group by user_id
```

```mysql
select user_id, max(time_stamp) as last_stamp
from logins
where datediff(time_stamp, '2020-01-01') >= 0 and datediff(time_stamp, '2021-01-01') < 0
group by user_id
```

快：

```mysql
select user_id,max(time_stamp)last_stamp from logins
where time_stamp like "2020%"
group by user_id
```



##### 1581\.进店缺未进行过交易的顾客

[题目](https://leetcode.cn/problems/customer-who-visited-but-did-not-make-any-transactions/)

1546ms:

```mysql
select customer_id, count(*) as `count_no_trans`
from Visits
where visit_id not in (select distinct visit_id from Transactions)
group by customer_id
```

1330ms:

```mysql
select v.customer_id,count(*) count_no_trans 
from Visits v 
left join Transactions t 
on (v.visit_id = t.visit_id) 
where amount is null 
group by customer_id 
```



##### 1527\.患某种疾病的患者

[题目](https://leetcode.cn/problems/patients-with-a-condition/)

```mysql
select * from Patients
where conditions like 'DIAB1%' or conditions like '% DIAB1%'
```

不能 `%DIAB1%`，考虑反例 `NOTDIAB11`

效率相近：

```mysql
SELECT * FROM PATIENTS
WHERE CONDITIONS REGEXP '^DIAB1|\\sDIAB1'
```



##### 1587\.银行账户概要II

[题目](https://leetcode.cn/problems/bank-account-summary-ii/)

910ms:

```mysql
select name, sum(amount) as `balance`
from Users, Transactions
where Users.account = Transactions.account
group by Users.account 
having sum(amount)>10000
```

750-800ms:

```mysql
select name, sum(amount) as balance
from users left join transactions on users.account = transactions.account
group by users.account
having balance > 10000
```



##### 1741\.查询每个员工花费的总时间

[题目](https://leetcode.cn/problems/find-total-time-spent-by-each-employee/)

```mysql
select event_day as `day`, emp_id, sum(out_time-in_time) as `total_time`
from Employees
group by day, emp_id
```



##### 1693\.每天的领导和合伙人

[题目](https://leetcode.cn/problems/reconstruct-itinerary/)

```mysql
select date_id, make_name, count(distinct lead_id) as `unique_leads`, 
count(distinct partner_id) as `unique_partners`
from DailySales
group by date_id, make_name
```

#### 多线程

##### 1114\.按序打印

[题目](https://leetcode.cn/problems/print-in-order/)

> 错误的：
>
> ```java
> class Foo {
> 
> private static boolean firstDone = false;
> private static boolean secondDone = false;
> 
> public Foo() {
> 
> }
> 
> public void first(Runnable printFirst) throws InterruptedException {
> 
>   // printFirst.run() outputs "first". Do not change or remove this line.
>   printFirst.run();
>   firstDone = true;
> }
> 
> public void second(Runnable printSecond) throws InterruptedException {
> 
>   // printSecond.run() outputs "second". Do not change or remove this line.
>   while (!firstDone)
>       ;
>   printSecond.run();
>   secondDone = true;
> }
> 
> public void third(Runnable printThird) throws InterruptedException {
> 
>   // printThird.run() outputs "third". Do not change or remove this line.
>   while (!secondDone)
>       ;
>   printThird.run();
> }
> }
> ```
>
>
> 换成非静态更错，会导致 TLE 的发生。
>
> 对非静态，分析如下：
>
> 每个线程有自己的工作内存(线程栈)，将用到的变量备份一份。所以最初每个线程都把 `firstDone, secondDone` 拷贝了一份。当 `firstDone` 更新时，这个更新没有通知其他线程的工作内存。
>
> 修改：被`volatile`关键字修饰的变量保证修改的值立刻更新到主存，使得其他线程需要读取时要到主存读取。所以上述变量加个 `volatile` 即可。

先看一份**错误的**代码：

```java
class Foo {

    private boolean firstDone = false;
    private boolean secondDone = false;

    public Foo() {
    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        firstDone = true;  
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while (!firstDone)
            ;
        printSecond.run();
        secondDone = true;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while (!secondDone)
            ;
        printThird.run();
    }
}
```

错误原因分析：

每个线程有自己的工作内存(线程栈)，将用到的变量备份一份。所以最初每个线程都把 `firstDone, secondDone` 拷贝了一份。当 `f1` 执行完毕时，`firstDone` 更新时，这个更新没有通知其他线程的工作内存，所以导致 `firstDone` 对其他线程一直认为是 `false` 的。

> 具体而言，JVM定义了内存模型JMM(java memory model)屏蔽硬件平台和操作系统的内存访问差异，规定所有变量存在主存，线程有自己的工作内存，所有操作在工作内存进行(不能直接对主存操作)，线程不能访问其他线程的工作内存。

被 `volatile` 关键字修饰的变量保证修改的值立刻更新到主存，使得其他线程需要读取时要到主存读取。

> 具体而言，类的成员或静态成员变量被 `volatile` 修饰后：
>
> - 保证可见性，一个线程修改值后新值对其他线程立刻可见
>
>   当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，这个写会操作会导致其他线程中的volatile变量缓存无效
>
> - 禁止进行指令重排序
>
>   即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见
>
> 但 volatile 不保证原子性，因为运算操作符并非原子操作，需要保证原子性可以使用下面三种方法之一：
>
> 1. synchronized
> 2. Lock 
> 3. `AtomicInteger`
>
> 由于单纯的 `firstDone = true` 操作是原子操作，所以直接使用 volatile 即可。具体而言，Java 只保证基本数据类型变量的读取和赋值是原子性操作，如：
>
> ```java
> x = 10; //原子性
> y = x; //非原子性
> x++; //非原子性
> x = x + 1; //非原子性
> ```

因此，正确代码如下：

```java
class Foo {

    private volatile boolean firstDone = false;
    private volatile boolean secondDone = false;

    public Foo() {
    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        firstDone = true;  
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while (!firstDone)
            ;
        printSecond.run();
        secondDone = true;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while (!secondDone)
            ;
        printThird.run();
    }
}
```

正确的其他：

①原子变量

```java
class Foo {

  private AtomicInteger firstJobDone = new AtomicInteger(0);
  private AtomicInteger secondJobDone = new AtomicInteger(0);

  public Foo() {}

  public void first(Runnable printFirst) throws InterruptedException {
    // printFirst.run() outputs "first".
    printFirst.run();
    // mark the first job as done, by increasing its count.
    firstJobDone.incrementAndGet();
  }

  public void second(Runnable printSecond) throws InterruptedException {
    while (firstJobDone.get() != 1) {
      // waiting for the first job to be done.
    }
    // printSecond.run() outputs "second".
    printSecond.run();
    // mark the second as done, by increasing its count.
    secondJobDone.incrementAndGet();
  }

  public void third(Runnable printThird) throws InterruptedException {
    while (secondJobDone.get() != 1) {
      // waiting for the second job to be done.
    }
    // printThird.run() outputs "third".
    printThird.run();
  }
}
```

同步锁：

```java
class Foo {
    
    private boolean firstFinished;
    private boolean secondFinished;
    private Object lock = new Object();

    public Foo() {
        
    }

    public void first(Runnable printFirst) throws InterruptedException {
        
        synchronized (lock) {
            // printFirst.run() outputs "first". Do not change or remove this line.
            printFirst.run();
            firstFinished = true;
            lock.notifyAll(); 
        }
    }

    public void second(Runnable printSecond) throws InterruptedException {
        
        synchronized (lock) {
            while (!firstFinished) {
                lock.wait();
            }
        
            // printSecond.run() outputs "second". Do not change or remove this line.
            printSecond.run();
            secondFinished = true;
            lock.notifyAll();
        }
    }

    public void third(Runnable printThird) throws InterruptedException {
        
        synchronized (lock) {
           while (!secondFinished) {
                lock.wait();
            }

            // printThird.run() outputs "third". Do not change or remove this line.
            printThird.run();
        } 
    }
}
```

##### 1115\.交替打印FooBar

[题目](https://leetcode.cn/problems/print-foobar-alternately/)

一种**错误的**超时代码如下：(n=5就超时了)

```java
class FooBar {
    private int n;
    private volatile boolean beforeBar = true;

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            while (!beforeBar)
                ;
            printFoo.run();
            beforeBar = false;
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            while (beforeBar)
                ;
            printBar.run();
            beforeBar = true;
        }
    }
}
```

错误理由：忙等太浪费 CPU，使得拉满时间片，占用了 2n 次时间片。

语法前置知识：

- synchronized了同一个对象的，同一时间只能有一个线程执行这个同步块中的代码。但不保证同步块内是原子性的。
- 将一个 Object 对象视为资源，当该对象使用 wait 方法时，阻塞掉对象所在线程。直到其他线程里被同一对象使用 notify(唤醒第一个wait的线程)或 notifyAll(唤醒所有wait的线程)
- 注意，wait 和 notify(All) 方法必须放在对该 object 自身的同步块内执行。

修改后的代码：

```java
class FooBar {
    private int n;
    private volatile boolean beforeBar = true;// 上一次打印了Bar
    private Object lock = new Object();

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            synchronized (lock) {
                while (!beforeBar) {
                    lock.wait(); // 因lock而阻塞当前线程
                }
                printFoo.run();
                beforeBar = false;
                lock.notifyAll(); // 唤醒所有被lock阻塞的线程
                //在本题,都用notify也行
            }
        }

    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            synchronized (lock) {
                while (beforeBar) {
                    lock.wait();
                }
                printBar.run();
                beforeBar = true;
                lock.notifyAll();
            }
        }
    }
}
```

为什么上述代码是可行的，考虑一种情况，线程 A 执行 foo，线程 B 执行 bar， A,B 单处理机并发，一种可能的顺序如下：(不考虑 print 等的 IO 阻塞)

1. A while 判假，直接 print foo
2. A 赋值 `beforeBar=false` 然后时间片到了让出了处理机
3. B 刚开始执行，看到 false 了所以 while 判假，print bar
4. B 继续跑，不仅弄了 `beforeBar = true` 还 `notifyAll` 了
5. B 这一轮 for 完了，下一次 while 里把自己阻塞了
6. A 顺着之前，`notifyAll` 然后时间片又到了(或者被B唤醒抢占)
7. B 被唤醒，while 走下一轮，又把自己阻塞了
8. A 继续 print foo……

> 这样写也行：(foo bar 都类似改)
>
> ```java
> for (int i = 0; i < n; i++) {
>  while (!beforeBar) {
>      synchronized (lock) { //如果改成 lock2 或别的不行
>          lock.wait(); // 因lock而阻塞当前线程
>      }
>  }
>  printFoo.run();
>  beforeBar = false;
>  synchronized (lock) {
>      lock.notify(); // 唤醒所有被lock阻塞的线程
>  }
> }
> ```



附：六种方法：

```java
//手太阴肺经 BLOCKING Queue
public class FooBar {
    private int n;
    private BlockingQueue<Integer> bar = new LinkedBlockingQueue<>(1);
    private BlockingQueue<Integer> foo = new LinkedBlockingQueue<>(1);
    public FooBar(int n) {
        this.n = n;
    }
    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            foo.put(i);
            printFoo.run();
            bar.put(i);
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            bar.take();
            printBar.run();
            foo.take();
        }
    }
}

//手阳明大肠经CyclicBarrier 控制先后
class FooBar6 {
    private int n;

    public FooBar6(int n) {
        this.n = n;
    }

    CyclicBarrier cb = new CyclicBarrier(2);
    volatile boolean fin = true;

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            while(!fin);
            printFoo.run();
            fin = false;
            try {
                cb.await();
            } catch (BrokenBarrierException e) {}
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            try {
                cb.await();
            } catch (BrokenBarrierException e) {}
            printBar.run();
            fin = true;
        }
    }
}

//手少阴心经 自旋 + 让出CPU
class FooBar5 {
    private int n;

    public FooBar5(int n) {
        this.n = n;
    }

    volatile boolean permitFoo = true;

    public void foo(Runnable printFoo) throws InterruptedException {     
        for (int i = 0; i < n; ) {
            if(permitFoo) {
        	    printFoo.run();
            	i++;
            	permitFoo = false;
            }else{
                Thread.yield();
            }
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {       
        for (int i = 0; i < n; ) {
            if(!permitFoo) {
        	printBar.run();
        	i++;
        	permitFoo = true;
            }else{
                Thread.yield();
            }
        }
    }
}



//手少阳三焦经 可重入锁 + Condition
class FooBar4 {
    private int n;

    public FooBar4(int n) {
        this.n = n;
    }
    Lock lock = new ReentrantLock(true);
    private final Condition foo = lock.newCondition();
    volatile boolean flag = true;
    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            lock.lock();
            try {
            	while(!flag) {
                    foo.await();
                }
                printFoo.run();
                flag = false;
                foo.signal();
            }finally {
            	lock.unlock();
            }
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n;i++) {
            lock.lock();
            try {
            	while(flag) {
                    foo.await();
            	}
                printBar.run();
                flag = true;
                foo.signal();
            }finally {
            	lock.unlock();
            }
        }
    }
}

//手厥阴心包经 synchronized + 标志位 + 唤醒
class FooBar3 {
    private int n;
    // 标志位，控制执行顺序，true执行printFoo，false执行printBar
    private volatile boolean type = true;
    private final Object foo=  new Object(); // 锁标志

    public FooBar3(int n) {
        this.n = n;
    }
    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            synchronized (foo) {
                while(!type){
                    foo.wait();
                }
                printFoo.run();
                type = false;
                foo.notifyAll();
            }
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            synchronized (foo) {
                while(type){
                    foo.wait();
                }
                printBar.run();
                type = true;
                foo.notifyAll();
            }
        }
    }
}


//手太阳小肠经 信号量 适合控制顺序
class FooBar2 {
    private int n;
    private Semaphore foo = new Semaphore(1);
    private Semaphore bar = new Semaphore(0);
    public FooBar2(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            foo.acquire();
        	printFoo.run();
            bar.release();
        }
    }
    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            bar.acquire();
        	printBar.run();
            foo.release();
        }
    }
}
```

##### 1116\.打印零与奇偶数

[题目](https://leetcode.cn/problems/print-zero-even-odd/)

个人：

```java
class ZeroEvenOdd {
    private int n;
    private volatile boolean beforeZero = false;
    private volatile boolean beforeEven = true;
    private Object lockZero = new Object();
    private Object lockOdd = new Object();
    private Object lockEven = new Object();

    public ZeroEvenOdd(int n) {
        this.n = n;
    }

    // printNumber.accept(x) outputs "x", where x is an integer.
    public void zero(IntConsumer printNumber) throws InterruptedException {
        for (int i = 0; i < n; ++i) {
            while (beforeZero) {
                synchronized (lockZero) {
                    lockZero.wait();
                }
            }
            printNumber.accept(0);
            beforeZero = true;
            synchronized (lockOdd) {
                lockOdd.notifyAll();
            }
            synchronized (lockEven) {
                lockEven.notifyAll();
            }
        }
    }

    public void even(IntConsumer printNumber) throws InterruptedException {
        for (int i = 2; i <= n; i += 2) {
            while (!(beforeZero && !beforeEven)) {
                synchronized (lockEven) {
                    lockEven.wait();
                }
            }
            printNumber.accept(i);
            beforeEven = true;
            beforeZero = false;
            synchronized (lockZero) {
                lockZero.notifyAll();
            }
            synchronized (lockOdd) {
                lockOdd.notifyAll();
            }
        }
    }

    public void odd(IntConsumer printNumber) throws InterruptedException {
        for (int i = 1; i <= n; i += 2) {
            while (!(beforeZero && beforeEven)) {
                lockOdd.wait();
            }
            printNumber.accept(i);
            beforeEven = false;
            beforeZero = false;
            synchronized (lockZero) {
                lockZero.notifyAll();
            }
            synchronized (lockEven) {
                lockEven.notifyAll();
            }
        }
    }
}
```

[其他一堆解法](https://leetcode.cn/problems/print-zero-even-odd/solution/by-be_a_better_coder-axp4/)

[一些解法](https://leetcode.cn/problems/print-zero-even-odd/solution/java-san-chong-xing-neng-you-yue-de-jie-h4pxx/)

信号量：

```java
class ZeroEvenOdd {
    private int n;

    // 默认 zero 有一个信号量可用
    private Semaphore zero = new Semaphore(1);

    // 默认 even 和 odd 没有可用信号量
    private Semaphore even = new Semaphore(0);
    private Semaphore odd = new Semaphore(0);

    public ZeroEvenOdd(int n) {
        this.n = n;
    }

    // printNumber.accept(x) outputs "x", where x is an integer.
    public void zero(IntConsumer printNumber) throws InterruptedException {

        for (int i = 1;i <= n; i++){

            // 首次执行时， zero 有一个可用的信号量
            zero.acquire();
            printNumber.accept(0);
            if(i % 2 == 1){
                // 可以理解为 odd 增加一个信号量，这样 odd 可以继续走流程
                odd.release();
            }else{
                // 可以理解为 even 增加一个信号量， 这样 even 可以继续走流程
                even.release();
            }
        }
    }

    public void even(IntConsumer printNumber) throws InterruptedException {

        for (int i = 2; i <= n;i += 2){

            // 等待信号量，获取到了信号后，往下走
            even.acquire();

            printNumber.accept(i);

            // 发送信号量给 zero
            zero.release();
        }

    }

    public void odd(IntConsumer printNumber) throws InterruptedException {

        for (int i = 1; i <= n; i += 2){

            // 等待信号量，获取到了信号后，往下走
            odd.acquire();
            printNumber.accept(i);

            // 发送信号量给 zero
            zero.release();
        }
    }

}
```

```java
class ZeroEvenOdd {
    private int n;

    // 方法二： 不用锁，直接用 volatile
    private volatile int curValue = 0;

    public ZeroEvenOdd(int n) {
        this.n = n;
    }

    // printNumber.accept(x) outputs "x", where x is an integer.
    public void zero(IntConsumer printNumber) throws InterruptedException {

        for (int i = 1; i <= n; i++) {
            while (curValue != 0) {
                Thread.yield();
            }

            printNumber.accept(0);

            if (i % 2 == 1) {
                curValue = 1;
            } else {
                curValue = 2;
            }

        }
    }

    public void even(IntConsumer printNumber) throws InterruptedException {
        for (int i = 2; i <= n; i += 2) {
            while (curValue != 2) {
                Thread.yield();
            }

            printNumber.accept(i);
            curValue = 0;
        }
    }

    public void odd(IntConsumer printNumber) throws InterruptedException {
        for (int i = 1; i <= n; i += 2) {
            while (curValue != 1) {
                Thread.yield();
            }

            printNumber.accept(i);
            curValue = 0;
        }
    }
}
```

##### 1117\.H2O生成

[题目](https://leetcode.cn/problems/building-h2o/)

个人：

```java
package lc;

import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;

class H2O {
    private Semaphore h1 = new Semaphore(0), h2 = new Semaphore(0);
    private Semaphore o1 = new Semaphore(0), o2 = new Semaphore(0);
    private Semaphore ho1 = new Semaphore(0), ho2 = new Semaphore(0);
    private Semaphore o = new Semaphore(1), h = new Semaphore(2);
    private AtomicInteger cnt = new AtomicInteger(0);

    public H2O() {

    }

    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {
//        System.out.println("1");
        boolean isFirst;
        synchronized (cnt) {
            isFirst = cnt.get() % 2 == 1 ? true : false;
            cnt.incrementAndGet();
        }
        h.acquire();
        if (isFirst) {
            h1.release();
            ho1.release();
            h2.acquire();
            o1.acquire();
        } else {
            h2.release();
            ho2.release();
            h1.acquire();
            o2.acquire();
        }
        // releaseHydrogen.run() outputs "H". Do not change or remove this line.
        releaseHydrogen.run();
        h.release();
    }

    public void oxygen(Runnable releaseOxygen) throws InterruptedException {
//        System.out.println(2);
        o.acquire();
        o1.release();
        o2.release();
        ho1.acquire();
        ho2.acquire();
        // releaseOxygen.run() outputs "O". Do not change or remove this line.
        releaseOxygen.run();
        o.release();
    }
}

public class lc1117 {
    public static void main(String[] args) throws InterruptedException {
        Runnable h = new Runnable() {
            @Override
            public void run() {
                System.out.print("H");
            }
        };
        Runnable o = new Runnable() {
            @Override
            public void run() {
                System.out.print("O");
            }
        };
        H2O h2o = new H2O();
        for (int i = 0; i < 2; ++i) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        h2o.hydrogen(h);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
        for (int i = 0; i < 1; ++i) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        h2o.oxygen(o);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
}
```

题解：

```java
class H2O {


    private Semaphore hSema = new Semaphore(2);
    private Semaphore oSema = new Semaphore(0);


    public H2O() {

    }

    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {
        hSema.acquire();
        releaseHydrogen.run();
        oSema.release();
    }

    public void oxygen(Runnable releaseOxygen) throws InterruptedException {
        oSema.acquire(2);
        releaseOxygen.run();
        hSema.release(2);
    }
}
```

[更多办法](https://leetcode.cn/problems/building-h2o/solution/chang-you-duo-xian-cheng-zhi-h2osheng-ch-8f7g/)

##### 1195\.交替打印字符串

[题目](https://leetcode.cn/problems/fizz-buzz-multithreaded/)

按序输出导致实际上每次只能同时运行一个线程。所以用一个变量表示当前应该输出哪个值，如果某个线程负责这个值就输出，否则就把自己的时间片让出去给别的线程。

因为变量值要通知给多个线程，所以可以考虑使用原子变量，或者使用 volatile 都可以。因为只能同时运行一个线程，所以不原子性也没啥问题。

原子变量：

```java
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.IntConsumer;

class FizzBuzz {
    private int n;
    private AtomicInteger cnt = new AtomicInteger(1);

    public FizzBuzz(int n) {
        this.n = n;
    }

    // printFizz.run() outputs "fizz".
    public void fizz(Runnable printFizz) throws InterruptedException {
        for (int i = 3; i <= n; i += 3) {
            if (i % 5 != 0) {
                while (cnt.get() != i) {
                    Thread.yield();
                }
                printFizz.run();
                cnt.incrementAndGet();
            }
        }
    }

    // printBuzz.run() outputs "buzz".
    public void buzz(Runnable printBuzz) throws InterruptedException {
        for (int i = 5; i <= n; i += 5) {
            if (i % 3 != 0) {
                while (cnt.get() != i) {
                    Thread.yield();
                }
                printBuzz.run();
                cnt.incrementAndGet();
            }
        }
    }

    // printFizzBuzz.run() outputs "fizzbuzz".
    public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException {
        for (int i = 15; i <= n; i += 15) {
            while (cnt.get() != i) {
                Thread.yield();
            }
            printFizzBuzz.run();
            cnt.incrementAndGet();
        }
    }

    // printNumber.accept(x) outputs "x", where x is an integer.
    public void number(IntConsumer printNumber) throws InterruptedException {
        for (int i = 1; i <= n; ++i) {
            if (i % 5 != 0 && i % 3 != 0) {
                while (cnt.get() != i) {
                    Thread.yield();
                }
                printNumber.accept(i);
                cnt.incrementAndGet();
            }
        }
    }
}
```

volatile:

```java
class FizzBuzz {
    private int n;
    private volatile int cnt = 1;

    public FizzBuzz(int n) {
        this.n = n;
    }

    // printFizz.run() outputs "fizz".
    public void fizz(Runnable printFizz) throws InterruptedException {
        for (int i = 3; i <= n; i += 3) {
            if (i % 5 != 0) {
                while (cnt != i) {
                    Thread.yield();
                }
                printFizz.run();
                ++cnt;
            }
        }
    }

    // printBuzz.run() outputs "buzz".
    public void buzz(Runnable printBuzz) throws InterruptedException {
        for (int i = 5; i <= n; i += 5) {
            if (i % 3 != 0) {
                while (cnt != i) {
                    Thread.yield();
                }
                printBuzz.run();
                ++cnt;
            }
        }
    }

    // printFizzBuzz.run() outputs "fizzbuzz".
    public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException {
        for (int i = 15; i <= n; i += 15) {
            while (cnt != i) {
                Thread.yield();
            }
            printFizzBuzz.run();
            ++cnt;
        }
    }

    // printNumber.accept(x) outputs "x", where x is an integer.
    public void number(IntConsumer printNumber) throws InterruptedException {
        for (int i = 1; i <= n; ++i) {
            if (i % 5 != 0 && i % 3 != 0) {
                while (cnt != i) {
                    Thread.yield();
                }
                printNumber.accept(i);
                ++cnt;
            }
        }
    }
}
```

[更多解法](https://leetcode.cn/problems/fizz-buzz-multithreaded/solution/chang-you-duo-xian-cheng-zhi-jiao-ti-da-eeurc/)

更好的本地调试：

```java
public static void main(String[] args) {
    Runnable printFizz = () -> {
        System.out.printf("%s", "fizz");
    };
    Runnable printBuzz = () -> {
        System.out.printf("%s", "buzz");
    };
    Runnable printFizzBuzz = () -> {
        System.out.printf("%s", "fizzbuzz");
    };
    IntConsumer intConsumer = new IntConsumer();
    FizzBuzz fb = new FizzBuzz(15);
    new Thread(() -> {
        try {
            fb.fizz(printFizz);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
    new Thread(() -> {
        try {
            fb.buzz(printBuzz);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
    new Thread(() -> {
        try {
            fb.fizzbuzz(printFizzBuzz);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
    new Thread(() -> {
        try {
            fb.number(intConsumer);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();

}


public class IntConsumer {
    public void accept(int i) {
        System.out.printf("%d", i);
    }
}
```

同步量：

```java
class FizzBuzz {
    private int n;

    private Semaphore number = new Semaphore(1);
    private Semaphore fizz = new Semaphore(0);
    private Semaphore buzz = new Semaphore(0);
    private Semaphore fizzbuzz = new Semaphore(0);


    public FizzBuzz(int n) {
        this.n = n;
    }

    // printFizz.run() outputs "fizz".
    public void fizz(Runnable printFizz) throws InterruptedException {
        for (int i = 1; i <= n; i++) {
            if (i % 3 == 0 && i % 5 != 0) {
                fizz.acquire();
                printFizz.run();
                number.release();
            }
        }
    }

    // printBuzz.run() outputs "buzz".
    public void buzz(Runnable printBuzz) throws InterruptedException {
        for (int i = 1; i <= n; i++) {
            if (i % 3 != 0 && i % 5 == 0) {
                buzz.acquire();
                printBuzz.run();
                number.release();
            }
        }
    }

    // printFizzBuzz.run() outputs "fizzbuzz".
    public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException {
        for (int i = 1; i <= n; i++) {
            if (i % 3 == 0 && i % 5 == 0) {
                fizzbuzz.acquire();
                printFizzBuzz.run();
                number.release();
            }
        }
    }

    // printNumber.accept(x) outputs "x", where x is an integer.
    public void number(IntConsumer printNumber) throws InterruptedException {
        for (int i = 1; i <= n; i++) {
            number.acquire();
            if (i % 3 != 0 && i % 5 != 0) {//开始打印
                printNumber.accept(i);
                number.release();
            } else if (i % 3 == 0 && i % 5 != 0) {//fizz开始打印
                fizz.release();
            } else if (i % 3 != 0 && i % 5 == 0) {//buzz开始打印
                buzz.release();
            } else {
                fizzbuzz.release();//fizzbuzz开始打印
            }
        }
    }
}
```

##### 1226\.哲学家进餐

[题目](https://leetcode.cn/problems/the-dining-philosophers/)

设 5 个信号量 $c$，$c_i$ 表示第 $i$ 根筷子是否空闲，初始有 $c_i=1$。如果写成下面的**错误**形式：

```java
c[i].acquire();
c[(i + 1) % 5].acquire();

pickLeftFork.run();
pickRightFork.run();
eat.run();
putLeftFork.run();
putRightFork.run();

c[i].release();
c[(i + 1) % 5].release();
```

会出现死锁问题，考虑：

5 个哲学家都只执行完第一行代码(`c[i].acquire();`)就时间片到，进而导致每个哲学家都只拿了一根筷子，且等待别人拿了的另一根，满足死锁的四个条件：互斥、不可剥夺、请求和保持、循环等待。

为了打破死锁，规定每个哲学家要么同时拿起两根筷子，要么一根也不拿(即拿起一双筷子原子化)，为了实现这样的目的，可以增设一个 mutex 信号量，即：五个哲学家里，每次只允许一个哲学家拿筷子，当有哲学家将要拿筷子时，任何其他哲学家不能拿筷子。

因为拿到筷子的哲学家一定能吃，所以他拿的筷子一定会被释放，所以如果有另一位哲学家拿到一只筷子，他的等待时间是有限的，进而打破了死锁。完整代码：

```java
class DiningPhilosophers {
    Semaphore c[] = new Semaphore[5], mutex = new Semaphore(1);

    public DiningPhilosophers() {
        for (int i = 0; i < 5; ++i) {
            c[i] = new Semaphore(1);
        }
    }

    // call the run() method of any runnable to execute its code
    public void wantsToEat(int i, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat,
            Runnable putLeftFork, Runnable putRightFork) throws InterruptedException {
        mutex.acquire();
        c[i].acquire();
        c[(i + 1) % 5].acquire();
        pickLeftFork.run();
        pickRightFork.run();
        mutex.release();
        eat.run();
        putLeftFork.run();
        putRightFork.run();
        c[i].release();
        c[(i + 1) % 5].release();
    }
}
```

> 思路参考：2023 王道计算机操作系统考研复习指导 P102-P103。

##### 2808\.使循环数组所有元素相等

[题目](https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array)

枚举每个值，求最长间隙可对应求得变为该值的最少秒数

```python
from typing import *
from collections import defaultdict
class Solution:
    def minimumSeconds(self, nums: List[int]) -> int:
        n = len(nums)
        ans = n // 2
        d = defaultdict(list)
        for i, v in enumerate(nums):
            d[v].append(i)
        for l in d:
            m, mx = len(d[l]), 0
            if m == 1:
                continue
            for i in range(m):
                x, y = d[l][i], d[l][(i + 1) % m]
                mx = max(mx, y-x-1+n*(y<x))
            ans=min(ans,(mx+1)//2)
        return ans
```

优雅写法：

```python
class Solution:
    def minimumSeconds(self, nums: List[int]) -> int:
        pos = defaultdict(list)
        for i, x in enumerate(nums):
            pos[x].append(i)

        ans = n = len(nums)
        for a in pos.values():
            a.append(a[0] + n)
            mx = max((j - i) // 2 for i, j in pairwise(a))
            ans = min(ans, mx)
        return ans
```



### CF杂题

#### 训练赛2

SCNU 软院集训队个人赛第二场。

1. E [CF710A](https://vjudge.csgrandeur.cn/problem/CodeForces-710A/origin)

   签到 模拟

2. A [CF707B](https://vjudge.csgrandeur.cn/problem/CodeForces-707B/origin)

   图论 STL

3. F [CF709C](https://vjudge.csgrandeur.cn/problem/CodeForces-709C/origin)

   贪心

4. B [CF707C](https://vjudge.csgrandeur.cn/problem/CodeForces-707C/origin)

   数学 构造

5. C [CF707D](https://vjudge.csgrandeur.cn/problem/CodeForces-707D/origin)

   并查集 DFS 离线 bitset

6. G [CF709D](https://vjudge.csgrandeur.cn/problem/CodeForces-709D/origin)

   贪心 构造

7. D [CF707E](https://vjudge.csgrandeur.cn/problem/CodeForces-707E/origin)

   二维树状数组 离线 预处理

8. H [CF709E](https://vjudge.csgrandeur.cn/problem/CodeForces-709E/origin)

   重心 树上DP

##### E CF710A

喵一眼题面 href 可知，王后八方向。直接模拟或数学即可。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    char c;
    ll d;
    cin >> c >> d;
    ll r = c - 'a' + 1;
    ll ans = 0;
    for (ll i = r - 1; i <= r + 1; ++i)
    {
        for (ll j = d - 1; j <= d + 1; ++j)
        {
            if (!(i == r && j == d))
            {
                if (i >= 1 && i <= 8 && j >= 1 && j <= 8)
                {
                    ++ans;
                }
            }
        }
    }
    cout << ans;
    return 0;
}
```

##### A CF707B

对只有非负权的边，显然任意最短路的最小值是只有一条边的最短路。set 存所有原料店，枚举每条边，如果边的一端在原料店内，一端不在，就更新边权。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll mn = 1e5 + 10, inf = 1e9 + 10;
ll n, m, k, ans = inf;
vector<pair<ll, ll>> g[mn];
set<ll> a;
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n >> m >> k;
    for (ll i = 1, u, v, w; i <= m; ++i)
    {
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }
    for (ll i = 1, u; i <= k; ++i)
    {
        cin >> u;
        a.insert(u);
    }
    for (ll u = 1; u <= n; ++u)
    {
        if (a.find(u) == a.end())
        {
            continue;
        }
        for (auto [v, w] : g[u])
        {
            if (a.find(v) != a.end())
            {
                continue;
            }
            ans = min(ans, w);
        }
    }
    if (ans == inf)
    {
        cout << -1;
    }
    else
    {
        cout << ans << '\n';
    }
    return 0;
}
```

##### F CF709C

找到第一个不是 a 的地方开始，然后对每个字符都不为 a 的连续子段操作。如果无法找到，字符串必然全 a，改最后一个。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll mn = 1e5 + 10;
ll n;
char s[mn];
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> s;
    n = strlen(s);
    for (ll i = 0; i < n; ++i)
    {
        if (s[i] != 'a')
        {
            for (; i < n && s[i] != 'a'; ++i)
            {
                s[i]--;
            }
            cout << s;
            return 0;
        }
    }
    // all a
    for (ll i = 0; i < n; ++i)
    {
        assert(s[i] == 'a');
    }
    s[n - 1] = 'z';
    cout << s;
    return 0;
}
/*
codeforces
abacaba
z
zbb
za
*/
```

##### B CF707C

考虑 $m^2-(m-1)^2=2m-1(m\ge2)$，可覆盖所有 $> 1$ 的奇数的 $n^2$。

接下来对 $m^2-(m-2)^2=4m-4(m\ge 3)$，可以覆盖从 $8$ 开始的所有的 $4$ 的倍数的 $n^2$。

对任意 $m^2-(m-i)^2=2mi-i^2(i > 2, m - i \ge 1)$，若 $i$ 是奇数，则结果是奇数，不如 $i=1$。

否则，若 $i$ 是偶数，则 $2mi$ 是 $4$ 的倍数，由于 $i=2j$，故 $i^2=4j^2$ 也是 $4$ 的倍数。最小的是 $i=4$，为 $5^2-(5-4)^2=24$，所以覆盖不了 $8$ 以下。其覆盖结果也都不如 $i=2$。

对于任意的 $n^2$，若 $n$ 是奇数，$n^2$ 也是奇数，必然能被 $i=1$ 覆盖。若 $n > 2$ 且 $n$ 是偶数，则 $n=2x,n^2=4x^2$，即 $n$ 必然是 $4$ 的倍数，能被 $i=2$ 覆盖。所以仅有 $n=1,n=2$ 无解。也就是说得以严格证明不需要使用 $m^2+k^2$，只需要使用 $m^2-(m-1)^2,m^2-(m-2)^2$ 就可以覆盖全体正整数。

因此只需要考虑 $i=1,2$ 就可以覆盖全部情况。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
ll n;
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n;
    n *= n;
    if (n > 1 && n % 2 == 1)
    {
        cout << n / 2 + 1 << ' ' << n / 2;
        return 0;
    }
    if (n > 4 && n % 4 == 0)
    {
        cout << n / 4 + 1 << ' ' << n / 4 - 1;
        return 0;
    }
    cout << -1;
    return 0;
}
/*
1
3
2
4
8
16
3200080001 40000 40001
200080010 10001 10003
*/
```

##### C CF707D

注意到每次修改只能基于当前版本，且每次操作 $4$ 只能回退当前版本。即本题对版本的变化灵活性较差，这是关键。

当没有操作 4 时，操作可以看成一条链，边就是操作。从初始版本 $0$ 出发走一遍就得到了链上每个结果。当有操作 4 时，设从 $v$ 回退到 $u$，则将 $u,v$ 两点合并(考虑并查集)，然后下一次非 $4$ 的操作从 $v$ 出发继续延伸链，可知，能将询问离线得到一棵树。 

那么只需要从根节点 $0$ 出发，遍历这棵树，遍历时执行操作，然后回溯时撤销掉所执行的操作，就能处理出全部的询问。使用 bitset 优化操作 $3$，则复杂度为 $O(\dfrac m C)$，其他操作都是 $O(1)$。故总复杂度为 $O(\dfrac{qm}C)$。

注意一个细节，对无效的操作 $1$ 或 $2$，不需要撤销。操作 $1$、操作 $2$ 互为逆操作，操作 $3$ 的逆操作是自身。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll mb = 1024, mn = 1e5 + 10;
bitset<mb> a[mb], rv;
ll k[mn], n, m, q, fa[mn], s;
struct cmd
{
    ll op, i, j;
};
vector<pair<ll, cmd>> g[mn];
ll findf(ll x)
{
    while (x != fa[x])
    {
        x = fa[x];
    }
    return x;
}
void perform(cmd &c)
{
    if (c.op == 1)
    {
        if (!a[c.i][c.j])
        {
            ++s;
        }
        else
        {
            c.op = 5;
        }
        a[c.i][c.j] = 1;
    }
    else if (c.op == 2)
    {
        if (a[c.i][c.j])
        {
            --s;
        }
        else
        {
            c.op = 5;
        }
        a[c.i][c.j] = 0;
    }
    else if (c.op == 3)
    {
        s -= a[c.i].count();
        a[c.i] ^= rv;
        s += a[c.i].count();
    }
}
void revoke(cmd c)
{
    if (c.op <= 2)
    {
        c.op = 3 - c.op;
    }
    perform(c);
}
void dfs(ll u)
{
    k[u] = s;
    // cout << "k:" << u << ' ' << k[u] << '\n';
    for (auto [v, cm] : g[u])
    {
        perform(cm);
        dfs(v);
        revoke(cm);
        // cout << "revoke: " << s << '\n';
    }
}
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n >> m >> q;
    for (ll i = 1; i <= m; ++i)
    {
        rv[i] = 1;
    }
    for (ll i = 1; i <= q; ++i)
    {
        fa[i] = i;
    }
    for (ll u = 0, v = 1; v <= q; ++v)
    {
        cmd cm;
        cin >> cm.op >> cm.i;
        if (cm.op <= 2)
        {
            cin >> cm.j;
        }
        if (cm.op == 4)
        {
            u = cm.i;
            fa[findf(v)] = findf(u);
            continue;
        }
        g[findf(u)].push_back({v, cm});
        u = v;
    }
    dfs(0);
    for (ll i = 1; i <= q; ++i)
    {
        cout << k[findf(i)] << '\n';
    }
    return 0;
}
```

##### G CF709D

打表找规律，一个参考打表程序如下：

> ```c++
> #include <bits/stdc++.h>
> using namespace std;
> using ll = long long;
> const ll mn = 1e6 + 10;
> ll a[mn], top;
> map<pair<ll, ll>, set<pair<ll, ll>>> m;
> signed main()
> {
> ios::sync_with_stdio(false), cin.tie(0);
> cin >> top;
> for (ll i = 0; i < 1 << top; ++i)
> {
>   for (ll j = 0; j < top; ++j)
>   {
>       a[j] = (i >> j) & 1;
>   }
>   ll a00 = 0, a01 = 0, a10 = 0, a11 = 0;
>   for (ll j = 0; j < top; ++j)
>   {
>       for (ll k = j + 1; k < top; ++k)
>       {
>           a00 += a[j] == 0 && a[k] == 0;
>           a01 += a[j] == 0 && a[k] == 1;
>           a10 += a[j] == 1 && a[k] == 0;
>           a11 += a[j] == 1 && a[k] == 1;
>       }
>   }
>   for (ll j = top - 1; j >= 0; --j)
>   {
>       cout << a[j];
>   }
>   cout << ' ' << a00 << ' ' << a01 << ' ' << a10 << ' ' << a11 << '\n';
>   m[{a00, a11}].insert({a01, a10});
> }
> for (auto [pr, s] : m)
> {
>   cout << pr.first << ' ' << pr.second << " - " << s.size() << " : ";
>   for (auto [a01, a10] : s)
>   {
>       cout << '(' << a01 << ',' << a10 << ") ";
>   }
>   cout << '\n';
> }
> return 0;
> }
> ```

根据打表规律，发现有解必然满足：

1. $a_{00},a_{11}$ 的出现次数是 $C_{x}^2$。其中 $x$ 是 $0$ 或 $1$ 的数目。

   证明：共有 $x$ 个 $0$ 时，$00$ 的数目一定是 $C_x^2$，直接高中组合数学即可。对 $1$ 同理。

2. 设有 $n_0$ 个 $0$，$n_1$ 个 $1$，若 $n_0 > 0,n_1 > 0$，恒满足 $n_0n_1=a_{01}+a_{10}$。

   证明：一共有 $n_1$ 个 $1$，对每个 $1$，与每个 $0$，要么组成 $10$，要么组成 $01$，故每个 $1$ 贡献 $n_0$ 个 $a_{01}+a_{10}$，故共贡献 $n_0n_1$ 次。

根据第二个规律的证明过程，可以通过在 $n_0$ 个 $0$ 上不断插入 $1$ 构造得字符串，对每次构造，设要插入的 $1$ 的前面有 $u(0\le u\le n_0)$ 个 $0$，后面有 $v=n_0-u$ 个 $0$，则当前 $1$ 对 $a_{01}$ 贡献 $u$，对 $a_{10}$ 贡献 $v$。可以直接贪心，即设 $1$ 先最大地去凑 $a_{10}$，然后再最大地去凑 $a_{01}$。反过来地，若已知某个 $1$ 贡献分别为 $(u,n_0-u)$，也能确定它必然插入在第 $u$ 个 $0$ 后面。注意每个 $0$ 后面可以插入零到任意多个 $1$。设当前还差 $c_{01}$ 个 $a_{01}$ 贡献要凑，$c_{10}$ 个 $a_{10}$ 贡献要凑，有：

- 若 $c_{10}\ge n_{0}$，把 $1$ 插入到最前面(第 $1$ 个 $0$ 前边)，导致 $c_{01}$ 不变，$c_{10}$ 减少 $n_0$。
- 否则，$0\le c_{10} < n_0$，把 $1$ 插入到第 $c_{10}$ 个 $0$ 前边，导致 $c_{10}$ 清零，$c_{01}$ 减少 $n_0-c_{10}$。

不断如此构造，即可得到有解的目标字符串。

特判一些边界，如全 $0$ 全 $1$ 等，即可得解。 

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
map<ll, ll> m;
const ll mn = 1e6 + 10;
ll n, n0, n1, a00, a01, a10, a11;
ll cnt[mn];
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    for (ll x = 1; x * (x - 1) / 2 <= 2e9; ++x)
    {
        m[x * (x - 1) / 2] = x;
    }
    cin >> a00 >> a01 >> a10 >> a11;
    if (a00 == 0 && a11 == 0 && a01 == 0 && a10 == 0)
    {
        cout << 0;
        return 0;
    }
    if (m.find(a00) == m.end() || m.find(a11) == m.end())
    {
        cout << "Impossible";
        return 0;
    }
    n0 = m[a00], n1 = m[a11], n = n0 + n1;
    if (a11 == 0 && a01 == 0 && a10 == 0)
    {
        for (ll i = 0; i < n0; ++i)
        {
            cout << 0;
        }
        return 0;
    }
    if (a00 == 0 && a01 == 0 && a10 == 0)
    {
        for (ll i = 0; i < n1; ++i)
        {
            cout << 1;
        }
        return 0;
    }
    if (n0 * n1 != a01 + a10)
    {
        cout << "Impossible";
        return 0;
    }
    ll c01 = a01, c10 = a10;
    for (ll i = 0; i < n1; ++i)
    {
        ll p01, p10;
        if (c10 >= n0)
        {
            p10 = n0;
        }
        else
        {
            p10 = c10;
        }
        p01 = n0 - p10;
        cnt[p01]++;
        c10 -= p10, c01 -= p01;
    }
    for (ll i = 0; i < n0; ++i)
    {
        for (ll j = 0; j < cnt[i]; ++j)
        {
            cout << 1;
        }
        cout << 0;
    }
    for (ll j = 0; j < cnt[n0]; ++j)
    {
        cout << 1;
    }
    return 0;
}
```

##### D CF707E

> 一开始审题失误没看到关键点 $len < 2000$，且没剩多少时间了，所以没开。

[能过的代码参考](https://blog.csdn.net/dieyi9889/article/details/101867233)

一眼二维树状数组维护矩阵和。对条链，先将其点亮，对应到二维树状数组上有 $O(len\log n\log m)\approx n\log^2 n$ 的代价。然后遍历共 $O(n)$ 次 ask，每次查询该点亮的链对该**子矩阵**(注意不是对该询问)的贡献是多少，查询的复杂度是四次树状数组询问，$O(n)$ 次 ask 故也共 $O(n\log^2 n)$。然后再将该链删掉，即还原树状数组，反向操作，耗费 $O(n\log^2 n)$。共 $k$ 条链，每条都做一次，共 $O(n^2\log^2n)$ 的复杂度。<u>经过这样的预处理，使得每条链对每个子矩阵的贡献都存了下来。</u>(解题核心思路)

接下来顺序遍历询问，维护 bool 数组表示当前点亮的链来维护 switch。对每个 ask，再遍历一遍每条链的点亮状态，如果亮着，加上该子矩阵该链的值。这个过程是 $O(q+nk)=O(n^2)$ 的。

故总复杂度为 $O(n^2\log^2n)$。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
bool Finish_read;
template <class T>
inline void read(T &x)
{
    Finish_read = 0;
    x = 0;
    int f = 1;
    char ch = getchar();
    while (!isdigit(ch))
    {
        if (ch == '-')
            f = -1;
        if (ch == EOF)
            return;
        ch = getchar();
    }
    while (isdigit(ch))
        x = x * 10 + ch - '0', ch = getchar();
    x *= f;
    Finish_read = 1;
}
template <class T>
inline void print(T x)
{
    if (x / 10 != 0)
        print(x / 10);
    putchar(x % 10 + '0');
}
template <class T>
inline void writeln(T x)
{
    if (x < 0)
        putchar('-');
    x = abs(x);
    print(x);
    putchar('\n');
}
template <class T>
inline void write(T x)
{
    if (x < 0)
        putchar('-');
    x = abs(x);
    print(x);
}
/*================Header Template==============*/
const int maxn = 2005;
int n, m, k, qcnt, q;
ll T[maxn + 50][maxn + 50];
int len[maxn];
int x[maxn][maxn], y[maxn][maxn], w[maxn][maxn];
int c[1000005], qx1[maxn], qy1[maxn], qx2[maxn], qy2[maxn];
bool change[maxn];
ll ans[maxn][maxn];
#define lowbit(x) x & (-x)
/*==================Define Area================*/
void Add(int x, int y, int w)
{
    for (int i = x; i <= maxn; i += lowbit(i))
    {
        for (int j = y; j <= maxn; j += lowbit(j))
        {
            T[i][j] += w;
        }
    }
}

ll Sum(int x, int y)
{
    ll res = 0;
    for (int i = x; i; i -= lowbit(i))
    {
        for (int j = y; j; j -= lowbit(j))
        {
            res += T[i][j];
        }
    }
    return res;
}

int main()
{
    read(n);
    read(m);
    read(k);
    for (int i = 1; i <= k; i++)
    {
        read(len[i]);
        for (int j = 1; j <= len[i]; j++)
        {
            read(x[i][j]);
            read(y[i][j]);
            read(w[i][j]);
        }
    }
    read(q);
    for (int i = 1; i <= q; i++)
    {
        char opt[2];
        scanf("%s", opt);
        if (opt[0] == 'A')
        {
            ++qcnt;
            read(qx1[qcnt]);
            read(qy1[qcnt]);
            read(qx2[qcnt]);
            read(qy2[qcnt]);
        }
        else
        {
            read(c[i]);
        }
    }
    for (int i = 1; i <= k; i++)
    {
        for (int j = 1; j <= len[i]; j++)
        {
            Add(x[i][j], y[i][j], w[i][j]);
        }
        for (int j = 1; j <= qcnt; j++)
        {
            ans[i][j] = Sum(qx2[j], qy2[j]) + Sum(qx1[j] - 1, qy1[j] - 1) - Sum(qx1[j] - 1, qy2[j]) - Sum(qx2[j], qy1[j] - 1);
        }
        for (int j = 1; j <= len[i]; j++)
        {
            Add(x[i][j], y[i][j], -w[i][j]);
        }
    }
    for (int i = 1, cnt = 1; i <= q; i++)
    {
        if (c[i])
        {
            change[c[i]] ^= 1;
        }
        else
        {
            ll res = 0;
            for (int j = 1; j <= k; j++)
            {
                if (!change[j])
                    res += ans[j][cnt];
            }
            printf("%lld\n", res);
            cnt++;
        }
    }
    return 0;
}
```

##### H CF709E

> 开始一眼以为统计方案数，所以跳了。

[参考](https://blog.csdn.net/xgc_woker/article/details/82957280)

以重心为根进行 DFS。维护子树大小，该点为根子树的最大和非严格次大子树大小。设 DFS 时选择移边的子树的大小是 $s$，将这条边移动到当前遍历的子树上。

对重心外的点，如果它不是最大子树，那么往下遍历该点时，若当前点的最大子树更大，更新 $s$。否则，它自己是最大子树，不能我挪我自己，所以若当前点的非严格次大子树更大，更新 $s$。

如果有 $s$，当前子树大小是 $t$，因为从重心开始遍历，所以 $t$ 肯定不超，然后子树外部分大小是 $n-t$，如果把那个可删的最大子树 $s$ 给锯掉，连到自己上去，发现能成为重心，就可行。否则不可行。

如果一开始 DFS 根下来第一次就选定了 $s$，容易得知不会再更新 $s$。否则，一开始选的严格次大的话，有可能更新当前的新子树为 $s$，但绝无可能再把原重心那边的更新过来，因为如果包含重心的子树，必然是大于一半个节点树的。所以接下来的更新只需要在 $s$ 子树内考虑即可，且只需要考虑最大子树，看看有没有大于最开始给的非严格次大即可。

参考：

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;
typedef long long LL;
int _min(int x, int y) { return x < y ? x : y; }
int _max(int x, int y) { return x > y ? x : y; }
int read()
{
    int s = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        s = s * 10 + ch - '0', ch = getchar();
    return s * f;
}

struct edge
{
    int x, y, next;
} e[810000];
int len, last[410000];
int n, mx1[410000], mx2[410000], bs[410000];
int tot[410000], ans[410000];

void ins(int x, int y)
{
    e[++len].x = x, e[len].y = y;
    e[len].next = last[x], last[x] = len;
}

void dfs(int x, int fa)
{
    tot[x] = 1;
    mx1[x] = mx2[x] = bs[x] = 0;
    for (int k = last[x]; k; k = e[k].next)
    {
        int y = e[k].y;
        if (y != fa)
        {
            dfs(y, x);
            tot[x] += tot[y];
            if (tot[y] > n / 2)
                bs[x] = tot[y]; // 不满足重心的一个子树
            else if (tot[y] > mx1[x])
                mx2[x] = mx1[x], mx1[x] = tot[y];
            else if (tot[y] > mx2[x])
                mx2[x] = tot[y];
        }
    }
    if (n - tot[x] > n / 2)
        bs[x] = n - tot[x];
    else if (n - tot[x] > mx1[x])
        mx2[x] = mx1[x], mx1[x] = n - tot[x];
    else if (n - tot[x] > mx2[x])
        mx2[x] = n - tot[x];
}

void dfs2(int x, int fa, int s)
{
    if (!bs[x])
        ans[x] = 1;
    else if (n - tot[x] - s <= n / 2)
        ans[x] = 1;
    for (int k = last[x]; k; k = e[k].next)
    {
        int y = e[k].y;
        if (y != fa)
        {
            if (mx1[x] != tot[y])
                dfs2(y, x, _max(s, mx1[x]));
            else
                dfs2(y, x, _max(s, mx2[x]));
        }
    }
}

int main()
{
    n = read();
    for (int i = 1; i < n; i++)
    {
        int x = read(), y = read();
        ins(x, y), ins(y, x);
    }
    dfs(1, 0); // 找重心
    int rt;
    for (int i = 1; i <= n; i++)
    {
        if (!bs[i])
        {
            rt = i;
            break;
        }
    }
    dfs(rt, 0); // 重心为根,重新维护最大和次大子树
    dfs2(rt, 0, 0);
    for (int i = 1; i <= n; i++)
        printf("%d ", ans[i]);
    return 0;
}
```

#### CCPC2023网络赛热身赛

原题：[2021CCPC女生赛](https://codeforces.com/gym/103389)，分别是K,B,H,J

- A 签到
- B 倍增
- C 半平面交
- D 树上DP

##### 音乐游戏

签。略。赛时忘了 getline 语法懒得去翻，所以写了 C 风格，然后 < 写成 <= debug 了五分钟左右：

```c++
#include <bits/stdc++.h>
using namespace std;
signed main()
{
    int n;
    char nth;
    scanf("%d%c",&n,&nth);
    int cnt = 0;
    for(int h=0;h<n;++h){
        char c;
        for(int i=0;i<6;++i){
            scanf("%c",&c);
            if(c=='-'){
                ++cnt;
            }
            //printf("[%c]",c);
        }
        //printf("Done %d %d\n", h,n);
        if(h+1<n){
            scanf("%c",&nth);
        }
    }
    cout << cnt << '\n';
    return 0;
}
```

##### 攻防演练

> 我的思路：通过暴力程序，找出未证明的规律，若一个串能找到 $t$ 个长为 $m$ 的 $A-M$ 的序列排列为子序列的串，那么答案为 $t+1$。例如对 $m=3$，`abcacb` 是 $k=3$，同理 `abbcaaaacacb` 也是 $k=3$，而 `abbcca` 只能是 $k=2$。然后发现对 $q$ 次询问做不到，我的复杂度无论如何只能 $O(nq)$。莫队不会回滚，ST/线段树/前缀和/DP 不会实现。

预处理出在下标 $i$ 处<u>的下个位置</u>到后面出现的首个第 $j$ 个字母的下标 $nxt_{i,j}$，可以 $O(nm)$ 处理。

定义 $f_{i,0}=\max_{j=0}^mnxt_{i,j}$，即包含 $A\sim M$ 的全体字符的子序列的最后一个字符所在。做倍增，定义 $f_{i,j}$ 表示包含 $2^j$ 个这样的子序列的最后一个字符所在，显然 $f_{i,j}=f_{f_{i,j-1},j-1}$。

长为 $k+1$ 的任意串都不是 $s_{l,r}$ 的子序列时，那么长为 $k$ 的是子序列，这表明从 $l-1$ 开始跳 $k$ 次能跳到。所以在跳完不超过 $r$ 的情况下跑倍增不断跳，输出 $k+1$ 即可。

暴力找出来的规律的具体原理：$k$ 长都匹配，即有长为 $k$ 的通配符。每个通配符具体到上面即一个 $f_{i,0}$ 的跨度

[参考](https://blog.csdn.net/kaka03200/article/details/121098182)

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
typedef unsigned long long ull;
const ll inf = 1e18;
const int N = 2e5 + 10;
const int M = 1e6 + 10;
const double eps = 1e-8;
const int mod = 998244353;

#define fi first
#define se second
#define re register
#define lowbit (-x&x)
#define endl '\n'
int n, m;
char s[N];
int nxt[N][26];
int f[N][20];
int pos[26];
void solve() {
    cin >> m >> n;
    cin >> (s + 1);
    for (int i = 0; i < 26; i++) nxt[n][i] = n + 1;
    for (int i = n; i >= 1; i--) {
        if (!pos[s[i]-'a']) nxt[i][s[i]-'a'] = n + 1;
        else nxt[i][s[i]-'a'] = pos[s[i]-'a'];
        pos[s[i]-'a'] = i;
        for (int j = 0; j < m; j++) {
            if (pos[j]) nxt[i-1][j] = pos[j];
            else nxt[i-1][j] = n + 1;
        }
    }
    for (int i = 0; i <= n; i++) {
        int ma = 0;
        for (int j = 0; j < m; j++) ma = max(ma, nxt[i][j]);
        f[i][0] = ma;
        for (int j = 0; j < 20; j++) f[n+1][j] = f[n][j] = n + 1;
    }
    for (int j = 1; j < 20; j++) {
        for (int i = 0; i <= n; i++) {
            f[i][j] = f[f[i][j-1]][j-1];
//            if (!i) cout << f[i][j] << ' ' << f[i][j-1] << ' ' << j-1 << endl;
        }
    }
    int q; cin >> q;
    while (q--) {
        int l, r; cin >> l >> r;
        int ans = 0;
        int now = l - 1;
        for (int i = 19; ~i; i--) {
            if (f[now][i] <= r) {
                ans += (1 << i);
                now = f[now][i];
            }
        }
        printf("%d\n", ans+1);
    }
}
signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifdef ACM_LOCAL
    freopen("input", "r", stdin);
    freopen("output", "w", stdout);
#endif

#ifdef ACM_LOCAL
    auto start = clock();
#endif
    int t = 1;
//    cin >> t;
    while (t--)
        solve();
#ifdef ACM_LOCAL
    auto end = clock();
    cerr << "Run Time: " << double(end - start) / CLOCKS_PER_SEC << "s" << endl;
#endif
    return 0;
}
```

##### 4G网络

[参考](https://codeforces.com/gym/103389/attachments/download/16594/2021CCPC%E5%A5%B3%E7%94%9F%E8%B5%9B%E9%A2%98%E8%A7%A3.pdf) 直接看官方题解，很清晰。超出能力不补。

##### 最大权边独立集

> 枚举位于答案边集的加入的边的数量 $t$，显然 $0\le t\le k$，因为独立集的定义故 $2t\le n$。加入 $t$ 条边等价于删掉 $2t$ 个点，则这 $t$ 条边贡献 $tp$，剩下的图再求一个最大权边独立集。
>
> 设 $f_{i,j,0}$ 表示 $i$ 为根的子树，子树删了 $j$ 个点，不能往上匹配时的答案，$1$ 是能网上匹配。枚举 $j$ 从 $0$ 到 $\min(size_x,k)$。
>
> 没有代码，看不懂 DP。



#### 未分类

目录：

1. CF367C-Hard problem

   DP/最短路

2. CF861B-Playing in a Casino

   枚举优化 排序

3. -Division

   质因数分解

4. codeton4-D Climbing the Tree

   思维 数学 讨论

##### CF367C-Hard problem

[题目](https://codeforces.com/contest/706/problem/C)

每个位置至于前后位置的选择有关。不妨建图，每个字符串有转与不转两种选择，分别连向前后转与不转，然后标上旋转代价，注意不要重复贡献(wa了一发)，然后图上拓扑DP/最短路即可。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll mn = 2e5 + 10, big = 1e16;
vector<pair<ll, ll>> g[mn];
ll n, c[mn], t;
string s[mn];
ll d[mn];
bool vis[mn];
struct node
{
    ll i, d;
    bool operator<(const node &o) const { return d > o.d; }
};
priority_queue<node> q;
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n;
    for (ll i = 1; i <= n; ++i)
    {
        cin >> c[i];
    }
    for (ll i = 1; i <= n; ++i)
    {
        cin >> s[i];
    }
    t = 2 * n + 1;
    g[0].push_back({1, 0});
    g[0].push_back({2, c[1]});
    for (ll i = 1; i < n; ++i)
    {
        string &sa = s[i], &sb = s[i + 1];
        string ta = sa, tb = sb;
        reverse(ta.begin(), ta.end());
        reverse(tb.begin(), tb.end());
        ll ua = 2 * i - 1, va = 2 * i, ub = 2 * i + 1, vb = 2 * i + 2;
        if (sa <= sb)
        {
            g[ua].push_back({ub, 0});
        }
        if (sa <= tb)
        {
            g[ua].push_back({vb, c[i + 1]});
        }
        if (ta <= sb)
        {
            g[va].push_back({ub, 0});
        }
        if (ta <= tb)
        {
            g[va].push_back({vb, c[i + 1]});
        }
    }
    g[2 * n - 1].push_back({t, 0});
    g[2 * n].push_back({t, 0});
    for (ll i = 1; i <= t; ++i)
    {
        d[i] = big;
    }
    q.push({0, 0});
    while (!q.empty())
    {
        node p = q.top();
        q.pop();
        ll u = p.i;
        if (vis[u])
        {
            continue;
        }
        vis[u] = true;
        for (auto [v, w] : g[u])
        {
            if (d[v] > d[u] + w)
            {
                d[v] = d[u] + w;
                q.push({v, d[v]});
            }
        }
    }
    if (d[t] >= big)
    {
        cout << -1;
    }
    else
    {
        cout << d[t];
    }
    return 0;
}
/*
2
1 2
ba
ac

3
1 3 1
aa
ba
ac

2
5 5
bbb
aaa

2
3 3
aaa
aa

4
0 0 8 6
bi
qp
bt
ya
*/
```

##### CF861B-Playing in a Casino

[题目](https://codeforces.com/contest/1808/problem/B)

按列排序后，可以去掉绝对值，那么对同一个被减数，减数是前缀和。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll mn = 3e5;
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    ll t;
    cin >> t;
    while (t--)
    {
        ll n, m;
        cin >> n >> m;
        vector<vector<ll>> a(m + 1, vector<ll>(n + 1));
        vector<vector<ll>> s(m + 1, vector<ll>(n + 1));
        for (ll i = 1; i <= n; ++i)
        {
            for (ll j = 1; j <= m; ++j)
            {
                cin >> a[j][i];
            }
        }
        for (ll i = 1; i <= m; ++i)
        {
            sort(a[i].begin(), a[i].end());
            for (ll j = 1; j <= n; ++j)
            {
                s[i][j] = a[i][j] + s[i][j - 1];
            }
        }
        ll ans = 0;
        for (ll i = 1; i <= m; ++i)
        {
            for (ll j = 1; j < n; ++j)
            {
                ans += (s[i][n] - s[i][j]) - a[i][j] * (n - j);
            }
        }
        cout << ans << '\n';
    }
    return 0;
}
```



##### Division

[题目]()

> 显然不可以对 $p$ 朴素质因数分解(pollard rho 也许可以？但我没成功，对一些数据卡到 TLE 了)。

对 $q$ 质因数分解，则要满足条件必然对所有 $q$ 的组成质数 $mq^{t_i}_i$，如果 $p$ 也有该质数 $mq_{i}^{t'_i}$，若对想要构造的 $x$，其必然 $t'$都是 $p$ 的子集，且满足 $t'_i < t'_i$。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    ll t;
    cin >> t;
    while (t--)
    {
        ll p, q;
        cin >> p >> q;
        map<ll, ll> mq;
        {
            ll x = q;
            for (ll i = 2; i * i <= x; ++i)
            {
                while (x % i == 0)
                {
                    ++mq[i];
                    x /= i;
                }
            }
            if (x > 1)
            {
                mq[x] = 1;
            }
        }
        ll r = 1;
        if (p % q)
        {
            r = p;
        }
        for (auto [p_, t_q] : mq)
        {
            ll x = p, t_p = 0;
            while (x % p_ == 0)
            {
                t_p++;
                x /= p_;
            }
            if (t_p >= t_q)
            {
                ll new_r = p;
                for (ll i = 0; i < t_p - t_q + 1; ++i)
                {
                    new_r /= p_;
                }
                r = max(r, new_r);
            }
        }
        cout << r << '\n';
    }
    return 0;
}
/*
2
1 998244353
6 580
*/
```



##### codeton4-D Climbing the Tree

[题目](https://codeforces.com/contest/1810/problem/D)

对 $(a,b,n)$ 可以确定唯一的可能高度区间 $[a(n-1)-b(n-2)+1,an-b(n-1)]$ (特判 $n=1$ 为 $[1,a]$)。对每个新的 $(a,b,n)$，如果与原有的区间不相交，不合法，否则，取重复区间。

对询问 $(a,b)$，设已知高度为 $h$，则最少需要 $an-b(n-1)\ge h$ 天，解得 $n=\lceil\dfrac{h-b}{a-b}\rceil$，特判 $h\le a$ 为 $1$ 天。对区间两个端点分别计算出 $n$，如果 $n$ 一致，输出，否则说不知道。

单次操作复杂度 $O(1)$。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pr = pair<ll, ll>;
const ll inf = 5e18;
bool intersect(pr x, pr y)
{
    return !(x.second < y.first || y.second < x.first);
}
/*
cout << intersect({1, 3}, {4, 6}) << '\n';
cout << intersect({4, 6}, {1, 3}) << '\n';
cout << intersect({2, 3}, {1, 4}) << '\n';
cout << intersect({1, 4}, {2, 3}) << '\n';
cout << intersect({1, 10}, {10, 11}) << '\n';
cout << intersect({10, 11}, {1, 10}) << '\n';
cout << intersect({4, 7}, {5, 7}) << '\n';
cout << intersect({5, 7}, {4, 7}) << '\n';
cout << intersect({4, 7}, {5, 8}) << '\n';
cout << intersect({5, 8}, {4, 7}) << '\n';
*/
pr combine(pr x, pr y)
{
    return {max(x.first, y.first), min(x.second, y.second)};
}
ll cei(ll a, ll b)
{
    return (a + b - 1) / b;
}
pr rng(ll a, ll b, ll n)
{
    if (n == 1)
    {
        return {1, a};
    }
    return {a * (n - 1) - b * (n - 2) + 1, a * n - b * (n - 1)};
}
ll minday(ll a, ll b, ll h)
{
    if (h <= a)
    {
        return 1;
    }
    return cei(h - b, a - b);
}
signed main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    ll t;
    cin >> t;
    while (t--)
    {
        pr eff = {0, inf};
        ll q;
        cin >> q;
        while (q--)
        {
            ll cmd, a, b, n;
            cin >> cmd >> a >> b;
            if (cmd == 1)
            {
                cin >> n;
                pr nw = rng(a, b, n);
                if (intersect(eff, nw))
                {
                    cout << "1 ";
                    eff = combine(eff, nw);
                }
                else
                {
                    cout << "0 ";
                }
            }
            else
            {
                ll l = minday(a, b, eff.first);
                ll r = minday(a, b, eff.second);
                if (l == r)
                {
                    cout << l << ' ';
                }
                else
                {
                    cout << "-1 ";
                }
            }
        }
        cout << "\n";
    }
    return 0;
}
```

### 其他杂题

#### ATC

##### DP-V-Subtree

[题目](https://atcoder.jp/contests/dp/tasks/dp_v?lang=en) [题解](https://blog.csdn.net/Emm_Titan/article/details/123875298)

$f$ 维护自己往下的子树数，$g$ 维护自己往上的子树数，答案是 $fg$。

转移时要用除法，但模数不是质数，所以将其转化为前后缀积乘法。

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define maxn 100005
vector < int > pre[maxn], suf[maxn];
vector < int > G[maxn];
int f[maxn], g[maxn];
int n, mod;
void dfs1( int u, int fa ) {
	f[u] = 1;
	for( int v : G[u] )
		if( v == fa ) continue;
		else dfs1( v, u ), f[u] = f[u] * (f[v] + 1) % mod;
	pre[u].resize( G[u].size() + 1, 1 );
	suf[u].resize( G[u].size() + 1, 1 );
	for( int i = 1;i < G[u].size();i ++ ) {
		pre[u][i] = pre[u][i - 1];
		if( G[u][i - 1] ^ fa ) 
			pre[u][i] = pre[u][i] * (f[G[u][i - 1]] + 1) % mod;
	}
	for( int i = G[u].size() - 2;i >= 0;i -- ) {
		suf[u][i] = suf[u][i + 1];
		if( G[u][i + 1] ^ fa )
			suf[u][i] = suf[u][i] * (f[G[u][i + 1]] + 1) % mod;
	}
}
void dfs2( int u, int fa ) {
	for( int i = 0;i < G[u].size();i ++ ) {
		int v = G[u][i];
		if( v == fa ) continue;
		g[v] = pre[u][i] * suf[u][i] % mod * g[u] % mod + 1;//加1是父亲代表的子树全为白 
		dfs2( v, u );
	}
}
signed main() {
	scanf( "%lld %lld", &n, &mod );
	for( int i = 1, u, v;i < n;i ++ ) {
		scanf( "%lld %lld", &u, &v );
		G[u].push_back( v );
		G[v].push_back( u );
	}
	dfs1( 1, 0 );
	g[1] = 1;
	dfs2( 1, 0 );
	for( int i = 1;i <= n;i ++ ) printf( "%lld\n", g[i] * f[i] % mod );
	return 0;
}
```

#### 微众银行笔试

##### 1

酷酷的小明准备和小伙伴们展示他捏出来的超酷的橡皮泥士兵。在展示之前，小明发现有些楼皮泥士兵大小十分相似甚至相同，这让小明感觉不是很酷，因为小明想要他的橡皮泥作品都有自己的风格，即使是大小也要有区别。小明的n个橡皮泥士兵的大小分别为a1,a.an，小明可以通过给某个士兵加一单位橡皮泥来使得其大小增加一单位。小明想知道如果他想要让所有的换皮泥士兵大小都不相同，至少需要一共加多少单位橡皮泥

第一行1个整数n，表示小明的橡皮泥士兵数量第二行n个整数a1a2.an，分别表示小明的橡皮泥士兵的大小对于100%的数据，1<=n<=50000,1<=ai<=100000

输出一行一个整数表示总共至少加多少单位的橡皮泥

```
5
1 1 2 3 3
```

```
5
```

我们给一个大小为1的橡皮泥士兵增加4单位橡皮泥，大小变为5;再给一个大小为3的橡皮泥士兵增加1单位橡皮泥，大小变为4。此时像皮泥士兵们的大小分别为1、2、3、4、5，没有两个橡皮泥士兵拥有相同大小了。可以证明没有更优方案。

 

##### 2

小明有一个数组。他挑选了一个有理数u/v，现在他想知道这个数组有多少个子区间的平均借
恰好等于u/v。数组的子区间即是数组中连续的一段区间，如数组[4,2,6]有6个子区间[4],[2],[6],[4,2],[2,6],[4,2,6]

第一行有三个整数n,u,v(1<=n<=100000,1<=u<=nv)，代表数组的长度，小明选择的有理数的分子和分母。输入保证u和v的最大公因数是1，即u/是最简分数第二行有n个绝对值不超过1000000的整数，代表数组中的元素
数字间两两有空格隔开。

输出一个非负整数，代表所求的答案

```c
6 5 2
2 4 1 3 2 3
```

```
6
```





##### 3

小美想要买糖果店的一根长长的糖果。糖果店顾客可以从中选取一个位置然后老板会在那切断，糖果前端到那个切断位置的糖果就会出售给这位顾客。这个糖果其实不同段有着不同的口味，小美希望她选出来的糖果中各个段有着不同的口味，在这基础上希望能选出尽可能长的糖果。小美想知道她能买到最长多长的糖果，请你帮帮她

第一行1个整数n，表示糖果的长度
第二行n个整数a1a2...an，其中ai表示从糖果前端开始第i的口味，每段均1为单位长
对于100%的数据，1<=n<=50000，1<=ai<=50000

```c
5
1 2 3 3 4
```

```
3
```

如果我们买长度为4的糖果，包含的口味为[1，2，3，3]，存在了重复而长度为3时，包含的口味为[1，2，3]，不存在重复。因此长度3为最长的不存在重复口味糖果长度



##### 解

> 1解：设 set $b_i$ 为全体未取之数，可以取到 $b_i=i(1\le i\le \max a+n)$ 即可。对每个 $a_i$，取最小 $\ge a_i$ 的 $b_j$ 作为目标数，加到 $s$ 上，删掉 $b_i$，最后计算 $s-\sum a$ 即可。
>
> 别人解：sort a, 顺序操 $a_i=\max(a_{i-1}+1,a_i)$ 即若小则变成上一个 +1,操作后减操作前(根据求和可分割性易得)



> 2参考题解：每个元素乘v转化为平均数为u，然后每个元素减u转化为区间和为0的个数
>
> 之后解：前缀和有多少 $s_r=s_{l-1}$，即统计 map $b_i$ 为 $s_j=i$ 的个数，求 $\sum C(b_i,2)$ 即可。



> 3解：满足单调性，二分长度，对每个长度，cnt 数组维护所有颜色计数，并维护 s 为 cnt[i] = 1 的个数，若存在 s=长度，该长度可行
>
> 别人解：set+双指针即可

#### 洛谷

##### P1314\.聪明的质监员

[题目](https://www.luogu.com.cn/problem/P1314)

原式转化为前缀和，对每个 $y_i$ 的每个内层求和，结果值固定(与外层无关)，使用前缀和维护内层的 $sumv$，并维护外层的计数 $cnt$ 前缀和。即可 $O(1)$ 求每个 $y_i$。

$y$ 随 $w$ 减少，则 $|y-s|$ 是单峰的凹函数。由于三分不能求有函数值连续相同的段的函数，注意到只有不同 $w_i$ 会改变 $y$，所以离散化三分要枚举的值设为 $w$。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
signed main() {
    // freopen("P1314_4.in", "r", stdin);
    ll n,m,s;
    cin>>n>>m>>s;
    vector<ll> w(n+1), v(n+1), a;
    for(int i=1;i<=n;++i){
        cin>>w[i]>>v[i];
        a.emplace_back(w[i]);
    }
    a.emplace_back(1e9);//不加也能过
    sort(a.begin(),a.end());
    ll lf = 0;
    ll rf = unique(a.begin(),a.end()) - a.begin();
    vector<ll> l(m+1), r(m+1);
    for(int i=1;i<=m;++i){
        cin>>l[i]>>r[i];
    }
    auto getStd = [&](ll W) {
        vector<ll> cs(n+1,0), ws(n+1,0);
        for(int i=1;i<=n;++i){
            cs[i]=cs[i-1]+(w[i]>=W);
            ws[i]=ws[i-1]+(w[i]>=W?v[i]:0);
        }
        ll y=0;
        for(int i=1;i<=m;++i){
            ll cnt=cs[r[i]]-cs[l[i]-1],sumv=(ws[r[i]]-ws[l[i]-1]);
            y+=cnt*sumv;
        }
        return abs(y-s);
    };
    ll ans = 9e18;
    while(lf<rf){
        ll tri = (rf-lf)/3;
        ll lc=lf+tri, rc=rf-tri;
        ll lv = getStd(a[lc]), rv = getStd(a[rc]);
        ans=min({lv,rv,ans});
        if(lv<rv) {
            rf=rc-1;
        } else {
            lf=lc+1;
        }
    }
    cout<<ans;
    return 0;
}
```

注意到 $y < s$ 时应当增大 $y$ 即减少 $w$；$y > s$ 时应当减小 $y$ 即增大 $w$，$y=s$ 时直接输出即可，可以根据 $y < s$ 与否来二分。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=200010;
int w[maxn],v[maxn],l[maxn],r[maxn];
long long pre_n[maxn],pre_v[maxn];
long long Y,s,sum;
int n,m,mx=-1,mn=2147483647;
bool check(int W)
{	
	Y=0,sum=0;
	memset(pre_n,0,sizeof(pre_n));
	memset(pre_v,0,sizeof(pre_v));
	for(int i=1;i<=n;i++)
	{
		if(w[i]>=W) pre_n[i]=pre_n[i-1]+1,pre_v[i]=pre_v[i-1]+v[i];
		else pre_n[i]=pre_n[i-1],pre_v[i]=pre_v[i-1];
	}
	for(int i=1;i<=m;i++)
		Y+=(pre_n[r[i]]-pre_n[l[i]-1])*(pre_v[r[i]]-pre_v[l[i]-1]);
		

	sum=llabs(Y-s);
	if(Y>s) return true;
	else return false;
	
}
int main(){
//	freopen("qc.in","r",stdin);
//	freopen("qc.out","w",stdout); 
	scanf("%d %d %lld",&n,&m,&s); 
	for(int i=1;i<=n;i++)
	{
		scanf(" %d %d",&w[i],&v[i]);
		mx=max(mx,w[i]);
		mn=min(mn,w[i]);	
	}
	for(int i=1;i<=m;i++)
		scanf(" %d %d",&l[i],&r[i]);
	int left=mn-1,right=mx+2,mid;  //这里有的人说要特判左右端点的check，但是其实你把left开成mn-1,right开成mx+2(注意取mx+1时即为W比所有都大，Y是0，这个情况要考虑，所以+2包含mx+1)就可以包含左右端点的check了，会简单点。
	long long ans=0x3f3f3f3f3f3f3f3f;//ll 范围内的无穷大，近似于(maxll/2)的大小
	while(left<=right)
	{
		mid=(left+right)>>1;
		if(check(mid)) 	left=mid+1;
		else right=mid-1;
		if(sum<ans) ans=sum;
	}
	printf("%lld",ans);
	return 0;
} 
```

#### 稀土掘金AI刷题

##### 2.计算位置x到y的最少步数

```python
from math import ceil
def solution(x_position, y_position):
    n = abs(x_position - y_position)
    # 1+1+...+k+k>=n, k->len=2k
    k1 = ceil(((1+4*n)**0.5-1)/2) * 2
    # 1+1+...+k+k+(k+1)>=n, k->len=2k+1
    k2 = ceil(n**0.5 - 1) * 2 + 1
    return min(k1, k2)

if __name__ == "__main__":
    #  You can add more test cases here
    print(solution(12, 6) == 4 )
    print(solution(34, 45) == 6)
    print(solution(50, 30) == 8)
```

##### 20\.比赛配对问题

~~即 $a_1=0,a_n=a_{\lceil\frac n2\rceil}+\lfloor\dfrac n2\rfloor$。~~每配对一次少一个队伍，最后要变成 1 个队伍，故 $n-1$。

```python
def solution(n: int) -> int:
    return n-1
    return 0 if n==1 else solution((n+1)//2)+n//2
```



#### NOIP

##### 494\.游戏通关

[题目](http://www.noip.ac.cn/p/494)

枚举打前 i 关，然后一直打第 i 关

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll mn = 2e5+3;
ll n, m, x[mn], y[mn], ans=9e18, s1;
signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (ll i = 1; i <= n; ++i) cin >> x[i] >> y[i];
    for (ll i = 1; i <= min(n,m); ++i) {
        s1 += x[i] + y[i];
        ans = min(ans, s1 + (m - i) * y[i]);
    }
    cout << ans;
    return 0;
}
```

#### sekai ctf 2024

##### nokotan

[题目](https://github.com/project-sekai-ctf/sekaictf-2024/blob/main/ppc/nokotan/solution/README.md)

- 题意：$n\le 10^5$ 个节点的完全二叉树，每个叶子结点可以自由选 0 或选 1，每个非叶子节点的值是子节点的异或，树和是 1 的数目，问共有多少种可能的树和

容易想到树形 DP，每个节点维护当前节点取 0/1 时，所有可能的子树和。

```python
def solve(n):
    dp = [[] for _ in range(n+1)] #dp[i][j] 是点i的子树，点i选j的所有可能的子树和
    m = (n+1)//2
    for i in range(m):
        dp[n-i] = [{0},{1}]
    for i in range(n-m,0,-1):
        if i*2+1>n:
            dp[i].append(dp[i*2][0])
            dp[i].append({v+1 for v in dp[i*2][1]})
            continue
        s01 = {v1+v2 for v1 in dp[i*2][0] for v2 in dp[i*2+1][0]}
        s02 = {v1+v2 for v1 in dp[i*2][1] for v2 in dp[i*2+1][1]}
        dp[i].append(s01|s02)
        s11 = {v1+v2+1 for v1 in dp[i*2][0] for v2 in dp[i*2+1][1]}
        s12 = {v1+v2+1 for v1 in dp[i*2][1] for v2 in dp[i*2+1][0]}
        dp[i].append(s11|s12)
    return dp[1][0]|dp[1][1]
for i in range(1,21):
    ans = solve(i)
    print(i,f'ans={len(ans)}',ans)
```

复杂度计算：层数 $d=\log n$，每个节点的子树大小是 $2^{d-i}$，要把两个子树做多项式乘法合并，共有 $2^i$ 个节点在第 $i$ 层，故 $\sum_{i=1}^d2^i(2^{d-i})^2\approx 2^{2d}=n^2$。即复杂度为 $O(n^2)$。

可以把多项式乘法用 FFT 优化，则复杂度变成 $O(n\log n)$(易算)。题解：

```c++
#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

typedef complex<double> C;
typedef vector<double> vd;
void fft(vector<C>& a) {
	int n = sz(a), L = 31 - __builtin_clz(n);
	static vector<complex<long double>> R(2, 1);
	static vector<C> rt(2, 1);  // (^ 10% faster if double)
	for (static int k = 2; k < n; k *= 2) {
		R.resize(n); rt.resize(n);
		auto x = polar(1.0L, acos(-1.0L) / k);
		rep(i,k,2*k) rt[i] = R[i] = i&1 ? R[i/2] * x : R[i/2];
	}
	vi rev(n);
	rep(i,0,n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;
	rep(i,0,n) if (i < rev[i]) swap(a[i], a[rev[i]]);
	for (int k = 1; k < n; k *= 2)
		for (int i = 0; i < n; i += 2 * k) rep(j,0,k) {
			// C z = rt[j+k] * a[i+j+k]; // (25% faster if hand-rolled)  /// include-line
			auto x = (double *)&rt[j+k], y = (double *)&a[i+j+k];        /// exclude-line
			C z(x[0]*y[0] - x[1]*y[1], x[0]*y[1] + x[1]*y[0]);           /// exclude-line
			a[i + j + k] = a[i + j] - z;
			a[i + j] += z;
		}
}
vd conv(const vd& a, const vd& b) {
	if (a.empty() || b.empty()) return {};
	vd res(sz(a) + sz(b) - 1);
	int L = 32 - __builtin_clz(sz(res)), n = 1 << L;
	vector<C> in(n), out(n);
	copy(all(a), begin(in));
	rep(i,0,sz(b)) in[i].imag(b[i]);
	fft(in);
	for (C& x : in) x *= x;
	rep(i,0,n) out[i] = in[-i & (n - 1)] - conj(in[i]);
	fft(out);
	rep(i,0,sz(res)) res[i] = imag(out[i]) / (4 * n);
	return res;
}
vector<int> multiply(vector<int> a, vector<int> b) {
  vd aa(a.size()), bb(b.size());
  for (int i = 0; i < (int) a.size(); ++i) aa[i] = (double) a[i];
  for (int i = 0; i < (int) b.size(); ++i) bb[i] = (double) b[i];
  vd res = conv(aa, bb);
  vector<int> resres(res.size());
  for (int i = 0; i < (int) res.size(); ++i) resres[i] = (int) (res[i] + 0.5);
  return resres;
}

void solve() {
  int n; cin >> n;
  vector<vector<int>> dpFull0(24);
  vector<vector<int>> dpFull1(24);
  vector<vector<int>> dpPartial0(24);
  vector<vector<int>> dpPartial1(24);
  dpFull0[0] = {1};
  dpFull1[0] = {0, 1};
  vector<pair<bool, int>> info(n + 1); // true = full, false = not full
  for (int i = n; i > 0; --i) {
    if (2 * i > n) info[i] = {true, 0};
    else if (2 * i + 1 > n) info[i] = {false, 1};
    else if (!info[2 * i].first || !info[2 * i + 1].first) info[i] = {false, info[2 * i].second + 1};
    else if (info[2 * i].second != info[2 * i + 1].second) info[i] = {false, info[2 * i].second + 1};
    else info[i] = {true, info[2 * i].second + 1};
  }
  for (int i = n; i > 0; --i) {
    int lvl = info[i].second;
    if (info[i].first) {
      if ((int) dpFull0[lvl].size()) continue;
      // needs to calculate dp:
      vector<int> t1 = multiply(dpFull0[lvl - 1], dpFull0[lvl - 1]);
      vector<int> t2 = multiply(dpFull0[lvl - 1], dpFull1[lvl - 1]); // shift, assign dpFull1
      vector<int> t3 = multiply(dpFull1[lvl - 1], dpFull0[lvl - 1]); // shift, assign dpFull1
      vector<int> t4 = multiply(dpFull1[lvl - 1], dpFull1[lvl - 1]);
      dpFull0[lvl].resize(max(t1.size(), t4.size()));
      for (int i = 0; i < dpFull0[lvl].size(); ++i) if ((i < (int) t1.size() && t1[i]) || (i < (int) t4.size() && t4[i])) dpFull0[lvl][i] = 1;
      dpFull1[lvl].resize(max(t2.size(), t3.size()) + 1);
      for (int i = 1; i < dpFull1[lvl].size(); ++i) if ((i - 1 < (int) t2.size() && t2[i - 1]) || (i - 1 < (int) t3.size() && t3[i - 1])) dpFull1[lvl][i] = 1;
    } else {
      // only one node per level, need to calculate dp no matter what:
      if (2 * i + 1 > n) {
        dpPartial0[lvl] = {1};
        dpPartial1[lvl] = {0, 0, 1};
      } else {
        vector<int> t1;
        vector<int> t2;
        vector<int> t3;
        vector<int> t4;
        if (!info[2 * i].first) {
          t1 = multiply(dpPartial0[lvl - 1], dpFull0[lvl - 2]);
          t2 = multiply(dpPartial0[lvl - 1], dpFull1[lvl - 2]);
          t3 = multiply(dpPartial1[lvl - 1], dpFull0[lvl - 2]);
          t4 = multiply(dpPartial1[lvl - 1], dpFull1[lvl - 2]);
        } else if (!info[2 * i + 1].first) {
          t1 = multiply(dpFull0[lvl - 1], dpPartial0[lvl - 1]);
          t2 = multiply(dpFull0[lvl - 1], dpPartial1[lvl - 1]);
          t3 = multiply(dpFull1[lvl - 1], dpPartial0[lvl - 1]);
          t4 = multiply(dpFull1[lvl - 1], dpPartial1[lvl - 1]);
        } else {
          t1 = multiply(dpFull0[lvl - 1], dpFull0[lvl - 2]);
          t2 = multiply(dpFull0[lvl - 1], dpFull1[lvl - 2]);
          t3 = multiply(dpFull1[lvl - 1], dpFull0[lvl - 2]);
          t4 = multiply(dpFull1[lvl - 1], dpFull1[lvl - 2]);
        }
        dpPartial0[lvl].resize(max(t1.size(), t4.size()));
        for (int i = 0; i < dpPartial0[lvl].size(); ++i) if ((i < (int) t1.size() && t1[i]) || (i < (int) t4.size() && t4[i])) dpPartial0[lvl][i] = 1;
        dpPartial1[lvl].resize(max(t2.size(), t3.size()) + 1);
        for (int i = 1; i < dpPartial1[lvl].size(); ++i) if ((i - 1 < (int) t2.size() && t2[i - 1]) || (i - 1 < (int) t3.size() && t3[i - 1])) dpPartial1[lvl][i] = 1;
      }
    }
  }
  int lvl = info[1].second;
  set<int> ans;
  if (info[1].first) {
    for (int i = 0; i < (int) dpFull0[lvl].size(); ++i) if (dpFull0[lvl][i]) ans.insert(i);
    for (int i = 0; i < (int) dpFull1[lvl].size(); ++i) if (dpFull1[lvl][i]) ans.insert(i);
  } else {
    for (int i = 0; i < (int) dpPartial0[lvl].size(); ++i) if (dpPartial0[lvl][i]) ans.insert(i);
    for (int i = 0; i < (int) dpPartial1[lvl].size(); ++i) if (dpPartial1[lvl][i]) ans.insert(i);
  }
  cout << ans.size() << '\n';
}

int main() {
  ios_base::sync_with_stdio(false); cin.tie(NULL);
  int t; cin >> t;
  for (int i = 0; i < t; ++i) solve();
  return 0;
}
```

### 力扣

##### 1206\.设计跳表

[题目](https://leetcode.cn/problems/design-skiplist) [跳表](https://oi-wiki.org/ds/skiplist/)

跳表是有序链表的改进，期望空间复杂度 $O(n)$ 且增删查期望 $O(\log n)$，最坏 $O(n)$。

> 跳表是一种随机化的数据结构，可以被看做二叉树的一个变种，它在性能上和红黑树、AVL树不相上下，但是跳表的原理非常简单，目前在Redis和LevelDB中都有用到。
>

跳表第一层是原始有序链表。设计常数 $p$，使得每个第 $i$ 层节点有 $p$ 概率出现在第 $i+1$ 层。第 $i$ 层期望有 $np^{i-1}$ 个元素。令第 $k$ 层期望有 $\dfrac1p$ 个元素，即 $np^{k-1}=p^{-1}$，解得 $k=\log_{1/p}n$。限制最高有 $k$ 层。

某节点最高停留在第 $i$ 层的概率为 $p^{i-1}(1-p)$，即前 $i-1$ 次在，第 $i$ 次不在。设共有 $l$ 层，则期望：
$$
E(l)=\sum_{i=1}^\infty i P(L=i)=\sum_{i=1}^\infty ip^{i-1}(1-p)=(1-p)\sum_{i=1}^\infty ip^{i-1}
$$
其中级数 $\sum_{i=1}^\infty ip^{i-1}=\dfrac1{(1-p)^2}$，故 $E(l)=\dfrac1{1-p}$ 为常数。故期望空间复杂度 $O(n)$，限制最高 $k$ 层时，最坏复杂度为 $O(n\log n)$。

查询：从最高的第 $k$ 层开始找，不断往低层，直到找到为止。可以解得(没看懂)期望查找 $\dfrac{L(n)-1}{p}+\dfrac2p$ 个节点，即 $O(\log n)$ 个节点。而插入和删除就是先查询，查到了就改它。

> 设在第 $i$ 层找 $x$，根据定义有 $p$ 的概率高一层还有 $x$，那么往高处找更好，否则低处更好。

实现：

- `SkiplistNode` 是一列，且 `forward` 表示每一列的下一节点。
- 查询：注意遍历层不是每次从头开始，而是从上一层的位置往下后往右，所以最坏 $O(n)$。然后找到小于目标的最近元素，看它下一个是不是目标即可。
- 插入：查询每一层小于插入点的最近节点并记录，然后随机一个插入点的层数，将这些层的记录上一个节点做单向链表插入。并更新最大层数。
- 删除：同理搞记录，把记录点跳到下一个点。

```c++
constexpr int MAX_LEVEL = 32;
constexpr double P_FACTOR = 0.25;

struct SkiplistNode {
    int val;
    vector<SkiplistNode *> forward;
    SkiplistNode(int _val, int _maxLevel = MAX_LEVEL) : val(_val), forward(_maxLevel, nullptr) {
        
    }
};

class Skiplist {
private:
    SkiplistNode * head;
    int level;
    mt19937 gen{random_device{}()};
    uniform_real_distribution<double> dis;

public:
    Skiplist(): head(new SkiplistNode(-1)), level(0), dis(0, 1) {

    }

    bool search(int target) {
        SkiplistNode *curr = this->head;
        for (int i = level - 1; i >= 0; i--) {
            /* 找到第 i 层小于且最接近 target 的元素*/
            while (curr->forward[i] && curr->forward[i]->val < target) {
                curr = curr->forward[i];
            }
        }
        curr = curr->forward[0];
        /* 检测当前元素的值是否等于 target */
        if (curr && curr->val == target) {
            return true;
        } 
        return false;
    }

    void add(int num) {
        vector<SkiplistNode *> update(MAX_LEVEL, head);
        SkiplistNode *curr = this->head;
        for (int i = level - 1; i >= 0; i--) {
            /* 找到第 i 层小于且最接近 num 的元素*/
            while (curr->forward[i] && curr->forward[i]->val < num) {
                curr = curr->forward[i];
            }
            update[i] = curr;
        }
        int lv = randomLevel();
        level = max(level, lv);
        SkiplistNode *newNode = new SkiplistNode(num, lv);
        for (int i = 0; i < lv; i++) {
            /* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */
            newNode->forward[i] = update[i]->forward[i];
            update[i]->forward[i] = newNode;
        }
    }

    bool erase(int num) {
        vector<SkiplistNode *> update(MAX_LEVEL, nullptr);
        SkiplistNode *curr = this->head;
        for (int i = level - 1; i >= 0; i--) {
            /* 找到第 i 层小于且最接近 num 的元素*/
            while (curr->forward[i] && curr->forward[i]->val < num) {
                curr = curr->forward[i];
            }
            update[i] = curr;
        }
        curr = curr->forward[0];
        /* 如果值不存在则返回 false */
        if (!curr || curr->val != num) {
            return false;
        }
        for (int i = 0; i < level; i++) {
            if (update[i]->forward[i] != curr) {
                break;
            }
            /* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */
            update[i]->forward[i] = curr->forward[i];
        }
        delete curr;
        /* 更新当前的 level */
        while (level > 1 && head->forward[level - 1] == nullptr) {
            level--;
        }
        return true;
    }

    int randomLevel() {
        int lv = 1;
        /* 随机生成 lv */
        while (dis(gen) < P_FACTOR && lv < MAX_LEVEL) {
            lv++;
        }
        return lv;
    }
};
```

> 我的 multiset：
>
> ```c++
> #include <bits/stdc++.h>
> using namespace std;
> class Skiplist {
>     multiset<int> s;
>     public:
>         Skiplist() {
>         }
>         
>         bool search(int target) {
>             return s.find(target)!=s.end();
>         }
>         
>         void add(int num) {
>             s.insert(num);
>         }
>         
>         bool erase(int num) {
>             auto it = s.find(num);
>             if(it!=s.end()){
>                 s.erase(it);
>                 return true;
>             }
>             return false;
>         }
>     };
>     
>     /**
>      * Your Skiplist object will be instantiated and called as such:
>      * Skiplist* obj = new Skiplist();
>      * bool param_1 = obj->search(target);
>      * obj->add(num);
>      * bool param_3 = obj->erase(num);
>      */
> ```

##### 1656\.设计有序流

[题目](https://leetcode.cn/problems/design-an-ordered-stream)

```c++
#include <bits/stdc++.h>
using namespace std;
class OrderedStream {
    int ptr = 1;
    vector<string> v;
    public:
        OrderedStream(int n) {
            v.resize(n+2);
        }
        
        vector<string> insert(int idKey, string value) {
            v[idKey] = value;
            vector<string> ans;
            while(v[ptr] != "") {
                ans.push_back(v[ptr]);
                ptr++;
            }
            return ans;
        }
    };
    
```

##### 2502\.设计内存分配器

[题目](https://leetcode.cn/problems/design-memory-allocator)

```c++
#include <bits/stdc++.h>
using namespace std;
class Allocator {
    vector<int> m;
    int n;
    public:
        Allocator(int n) {
            m.resize(n,0);
            this->n=n;
        }
        
        int allocate(int size, int mID) {
            int emp = 0, l = 0;
            for(int i = 0; i < n; ++i) {
                if(m[i] == 0) {
                    if(emp == 0) l = i;
                    if(++emp == size) {
                        for(int j = l; j <= i; ++j) {
                            m[j] = mID;
                        }
                        return l;
                    }
                } else {
                    emp = 0;
                }
            }
            return -1;
        }
        
        int freeMemory(int mID) {
            int cnt = 0;
            for(int i = 0; i < n; ++i) {
                if(m[i] == mID) {
                    m[i] = 0;
                    ++cnt;
                }
            }
            return cnt;
        }
    };
    
    /**
     * Your Allocator object will be instantiated and called as such:
     * Allocator* obj = new Allocator(n);
     * int param_1 = obj->allocate(size,mID);
     * int param_2 = obj->freeMemory(mID);
     */
```

```c++
class Allocator {
    vector<int> memory;

public:
    Allocator(int n) : memory(n) {}

    int allocate(int size, int mID) {
        int free = 0;
        for (int i = 0; i < memory.size(); i++) {
            if (memory[i] > 0) { // 已分配
                free = 0; // 重新计数
                continue;
            }
            free++;
            if (free == size) { // 找到了
                fill(memory.begin() + (i - size + 1), memory.begin() + (i + 1), mID);
                return i - size + 1;
            }
        }
        return -1; // 无法分配内存
    }

    int freeMemory(int mID) {
        int ans = 0;
        for (int i = 0; i < memory.size(); i++) {
            if (memory[i] == mID) {
                ans++;
                memory[i] = 0; // 标记为空闲内存
            }
        }
        return ans;
    }
};
```

解法二：线段树二分。设空闲内存为0，分配的内存为1，线段树维护区间的最长连续0个数 $max_0$，归并合并左右区间时，设前缀和后缀0个数记作 $pre_0,suf_0$，当前节点的 $max_0$ 为：
$$
max_0=\max\{max_{0left},max_{0right},suf_{0left}+pre_{0right}\}
$$
二分方法：先找左子树，若不符合，找 $suf_{0left}+pre_{0right}$，还不符合找右。注意在这种情况下，除了某个查询恰好是某个节点区间，其他答案都是从 $suf_{0left}+pre_{0right}$ 来的。

具体实现思路见代码。注意几个细节：

- 线段树长度的设置
- 一般修改 v=1/0，初始化时都一样不需要懒标签下放所以 v=-1，功能等价于 v=0

```c++
class SegTree {
    struct Node {
        int pre0, suf0, max0, todo;
    };

    vector<Node> t;

    void do_(int i, int l, int r, int v) {
        auto& o = t[i];
        int size = v <= 0 ? r - l + 1 : 0;
        o.pre0 = o.suf0 = o.max0 = size;
        o.todo = v;
    }

    // 下传懒标记
    void spread(int o, int l, int r) {
        int& v = t[o].todo;
        if (v != -1) {
            int m = (l + r) / 2;
            do_(o * 2, l, m, v);
            do_(o * 2 + 1, m + 1, r, v);
            v = -1;
        }
    }

    // 初始化线段树
    void build(int o, int l, int r) {
        do_(o, l, r, -1);
        if (l == r) {
            return;
        }
        int m = (l + r) / 2;
        build(o * 2, l, m);
        build(o * 2 + 1, m + 1, r);
    }

public:
    SegTree(int n) {
        t.resize(2 << bit_width((unsigned) n - 1));
        build(1, 0, n - 1);
    }

    // 把 [ql, qr] 都置为 v
    void update(int o, int l, int r, int ql, int qr, int v) {
        if (ql <= l && r <= qr) {
            do_(o, l, r, v);
            return;
        }
        spread(o, l, r);
        int m = (l + r) / 2;
        if (ql <= m) {
            update(o * 2, l, m, ql, qr, v);
        }
        if (m < qr) {
            update(o * 2 + 1, m + 1, r, ql, qr, v);
        }

        // 合并左右子树的信息
        Node& lo = t[o * 2];
        Node& ro = t[o * 2 + 1];
        // 区间前缀连续 0 的个数
        t[o].pre0 = lo.pre0;
        if (lo.pre0 == m - l + 1) {
            t[o].pre0 += ro.pre0; // 和右子树的 pre0 拼起来
        }
        // 区间后缀连续 0 的个数
        t[o].suf0 = ro.suf0;
        if (ro.suf0 == r - m) {
            t[o].suf0 += lo.suf0; // 和左子树的 suf0 拼起来
        }
        // 区间最长连续 0 的个数
        t[o].max0 = max({lo.max0, ro.max0, lo.suf0 + ro.pre0});
    }

    // 线段树二分，找最左边的区间左端点，满足区间全为 0 且长度 >= size
    // 如果不存在这样的区间，返回 -1
    int find_first(int o, int l, int r, int size) {
        if (t[o].max0 < size) {
            return -1;
        }
        if (l == r) {
            return l;
        }
        spread(o, l, r);
        int m = (l + r) / 2;
        int idx = find_first(o * 2, l, m, size); // 递归左子树
        if (idx < 0) {
            // 左子树的后缀 0 个数 + 右子树的前缀 0 个数 >= size
            if (t[o * 2].suf0 + t[o * 2 + 1].pre0 >= size) {
                return m - t[o * 2].suf0 + 1;
            }
            idx = find_first(o * 2 + 1, m + 1, r, size); // 递归右子树
        }
        return idx;
    }
};

class Allocator {
    int n;
    SegTree tree;
    unordered_map<int, vector<pair<int, int>>> blocks;

public:
    Allocator(int n) : n(n), tree(n) {}

    int allocate(int size, int mID) {
        int i = tree.find_first(1, 0, n - 1, size);
        if (i < 0) { // 无法分配内存
            return -1;
        }
        blocks[mID].emplace_back(i, i + size - 1);
        tree.update(1, 0, n - 1, i, i + size - 1, 1); // 分配内存 [i, i+size-1]
        return i;
    }

    int freeMemory(int mID) {
        int ans = 0;
        for (auto& [l, r] : blocks[mID]) {
            ans += r - l + 1;
            tree.update(1, 0, n - 1, l, r, 0); // 释放内存
        }
        blocks.erase(mID);
        return ans;
    }
};
```

##### 2466\.统计构造好字符串的方案数

[题目](https://leetcode.cn/problems/count-ways-to-build-good-strings)

```c++
#include <bits/stdc++.h>
const int mod = 1e9+7;
class Solution {
    public:
        int countGoodStrings(int low, int high, int zero, int one) {
            vector<int> dp(high+1);
            dp[0]=1;
            for(int i = 1;i<=high;++i) {
                if(i>=zero) dp[i]=(dp[i]+dp[i-zero])%mod;
                if(i>=one) dp[i]=(dp[i]+dp[i-one])%mod;
            }
            int ans = 0;
            for(int i = low;i<=high;++i) {
                ans=(ans+dp[i])%mod;
            }
            return ans;
        }
    };
```

##### 3405\.统计恰好有 K 个相等相邻元素的数组数目

[题目](https://leetcode.cn/problems/count-the-number-of-arrays-with-k-matching-adjacent-elements/)

隔板，从 $n-1$ 个空隙选 $k$ 个，形成 $C_{n-1}^k$ 个隔板隔开 $n-1-k$ 个片段，其中每个片段逻辑上含一个或两个相等元素。第一个片段元素任选，剩下的元素一定不能和之前的一样。故 $C_{n-1}^km(m-1)^{n-k-1}$。

```python
class Solution:
    def countGoodArrays(self, n: int, m: int, k: int) -> int:
        MOD = 1_000_000_007
        return comb(n - 1, k) % MOD * m * pow(m - 1, n - k - 1, MOD) % MOD
```

##### 740\.删除并获得点数

[题目](https://leetcode.cn/problems/delete-and-earn)

我的离散：16ms 很慢

```c++
#include <bits/stdc++.h>
using namespace std;
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        map<int, int> a;
        for(auto i : nums) ++a[i];
        int m = a.size();
        map<int, int> dp;
        dp[-3] = dp[-2] = 0;
        for(auto &[x, cnt] : a) {
            auto pv = dp.rbegin();
            if(pv->first+1 != x) {
                dp[x] = pv->second + x*cnt;
            } else {
                auto ppv = next(pv);
                dp[x] = max(pv->second, ppv->second + x*cnt);
            }
        }
        return dp.rbegin()->second;
    }
};
```

不离散 0ms

```c++
class Solution {
    // 198. 打家劫舍
    int rob(vector<int>& nums) {
        int f0 = 0, f1 = 0;
        for (int x : nums) {
            int new_f = max(f1, f0 + x);
            f0 = f1;
            f1 = new_f;
        }
        return f1;
    }

public:
    int deleteAndEarn(vector<int>& nums) {
        int mx = ranges::max(nums);
        vector<int> a(mx + 1);
        for (int x : nums) {
            a[x] += x; // 统计等于 x 的元素之和
        }
        return rob(a);
    }
};
```

##### 1472\.设计浏览器历史记录

[题目](https://leetcode.cn/problems/design-browser-history)

```c++
#include <bits/stdc++.h>
using namespace std;
class BrowserHistory {
    vector<string> h;
    int top = 0, now = 0;
    public:
        BrowserHistory(string homepage) {
            h.emplace_back(homepage);
        }
        
        void visit(string url) {
            ++now;
            if(now >= h.size()) {
                h.emplace_back(url);
            } else {
                h[now] = url;
            }
            top = now;
        }
        
        string back(int steps) {
            now = max(0, now - steps);
            return h[now];
        }
        
        string forward(int steps) {
            now = min(top, now + steps);
            return h[now];
        }
    };
    
    /**
     * Your BrowserHistory object will be instantiated and called as such:
     * BrowserHistory* obj = new BrowserHistory(homepage);
     * obj->visit(url);
     * string param_2 = obj->back(steps);
     * string param_3 = obj->forward(steps);
     */
```

```c++
class BrowserHistory {
    vector<string> history;
    int cur = 0; // 当前页面是 history[cur]

public:
    BrowserHistory(string homepage) : history{homepage} {}

    void visit(string url) {
        cur++;
        history.resize(cur); // 把浏览历史前进的记录全部删除
        history.push_back(url); // 从当前页跳转访问 url 对应的页面
    }

    string back(int steps) {
        cur = max(cur - steps, 0); // 后退 steps 步
        return history[cur];
    }

    string forward(int steps) {
        cur = min(cur + steps, (int) history.size() - 1); // 前进 steps 步
        return history[cur];
    }
};
```

##### 2320\.统计放置房子的方式数

[题目](https://leetcode.cn/problems/count-number-of-ways-to-place-houses)

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e4+1, p = 1e9+7;
int dp[maxn][2][2]; // 上面放没放，下面放没放
int ans[maxn];
auto f = []() {
    dp[0][0][0] = dp[0][0][1] = dp[0][1][0] = dp[0][1][1] = 1;
    ans[0] = 4;
    for (int i = 1; i < maxn; ++i) {
        dp[i][1][1] = dp[i-1][0][0];
        dp[i][1][0] = (dp[i-1][0][0] + dp[i-1][0][1]) % p;
        dp[i][0][1] = (dp[i-1][0][0] + dp[i-1][1][0]) % p;
        dp[i][0][0] = (1LL * dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][1][0] + dp[i-1][1][1]) % p;
        ans[i] = (1LL * dp[i][0][0] + dp[i][0][1] + dp[i][1][0] + dp[i][1][1]) % p;
    }
    return 0;
}();
class Solution {
public:
    int countHousePlacements(int n) {
        return ans[n-1];
    }
};
```

题解：如果只考虑单侧，那么就是朴素斐波那契 $fib_i$，且两侧相互独立，直接乘法原理得 $fib_i^2$。

```python
MOD = 10 ** 9 + 7
f = [1, 2]
for _ in range(10 ** 4 - 1):
    f.append((f[-1] + f[-2]) % MOD)

class Solution:
    def countHousePlacements(self, n: int) -> int:
        return f[n] ** 2 % MOD
```

```c++
const int MOD = 1e9 + 7, MX = 1e4 + 1;
int f[MX] = {1, 2};
int init = []() {
    for (int i = 2; i < MX; ++i)
        f[i] = (f[i - 1] + f[i - 2]) % MOD;
    return 0;
}();

class Solution {
public:
    int countHousePlacements(int n) {
        return (long) f[n] * f[n] % MOD;
    }
};
```

##### 2353\.设计食物评分系统

[题目](https://leetcode.cn/problems/design-a-food-rating-system)

```c++
#include<bits/stdc++.h>
using namespace std;
class FoodRatings {
    using Food = pair<int, string>;
    unordered_map<string, set<Food>> m;
    unordered_map<string, int> f;
    unordered_map<string, string> f2;
    public:
        FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {
            const int n = foods.size();
            for(int i = 0; i < n; i++){
                const string& food = foods[i];
                const int& rating = ratings[i];
                const string& cuisine = cuisines[i];
                f[food] = rating;
                f2[food] = cuisine;
                m[cuisine].insert({-rating, food});
            }
        }
        
        void changeRating(const string&food, const int&newRating) {
            Food fo = {-f[food], food};
            f[food] = newRating;
            auto& s = m[f2[food]];
            s.erase(fo);
            s.insert({-newRating, food});
        }
        
        string highestRated(const string&cuisine) {
            return m[cuisine].begin()->second;
        }
    };
    
    /**
     * Your FoodRatings object will be instantiated and called as such:
     * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);
     * obj->changeRating(food,newRating);
     * string param_2 = obj->highestRated(cuisine);
     */
```

const & 对时间影响不大，少一个 map 会快一点。

##### 131\.分割回文串

[题目](https://leetcode.cn/problems/palindrome-partitioning)

```c++
#include <bits/stdc++.h>
using namespace std;
bool isPali[18][18];
class Solution {
    public:
        vector<vector<string>> partition(string s) {
            int n = s.size();
            for(int i=0; i<n; ++i) {
                fill_n(isPali[i], n, false);
                isPali[i][i] = 1;
            }
            for(int i=0;i<n-1;++i) {
                isPali[i][i+1] = (s[i] == s[i+1]);
            }
            for(int len=3; len<=n; ++len) {
                for(int l=0, r=len-1; r<n; ++l, ++r) {
                    isPali[l][r] = isPali[l+1][r-1] && (s[l] == s[r]);
                }
            }
            vector<vector<string>> ans;
            vector<string> cur;
            auto dfs = [&](auto&self,int l) {
                if (n == l) {
                    ans.push_back(cur);
                    return;
                }
                for(int r=l; r<n; ++r) {
                    if(isPali[l][r]) {
                        cur.push_back(s.substr(l, r-l+1));
                        self(self, r+1);
                        cur.pop_back();
                    }
                }
            };
            dfs(dfs,0);
            return ans;
        }
    };
```

##### 1278\.分割回文串II

[题目](https://leetcode.cn/post-editor)

时间 100%，空间 93.62%

设 $pali[i][j]$ 表示字符串区间 $[i,j]$ 要变成回文串需要修改多少次，可以容易 $O(n^2)$ DP 得知。然后设 $dp[i][j]$ 表示字符串区间 $[0,i]$ 要变成恰 $j$ 个回文串需要修改多少次。转移：
$$
dp[i][j]=\min_{i2=0}^{i-1}(dp[i2][j-1]+pali[i2+1,i])
$$

> 注意无需区间 DP 或其他更复杂的转移求 $[i2,i]$ 分割为 $k-j2$ 个回文串，只需要分割为 $1$ 个回文串， 如果 $[i2,i]$ 需要分割为 $x$ 个回文串，必然存在最后一个回文串 $[i3,i]$，前面 $[i2,i3)$ 分割为 $x-1$ 个，等价于从 $dp[i3-1][j-x+1]$ 转移上面的方程。

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 101;
int pali[maxn][maxn]; // pali[i][j] let [i:j] be pali need pali[i][j] fix
int dp[maxn][maxn];   // dp[i][j] [0:i] cut j parts needs dp[i][j] fix
class Solution {
    public:
        int palindromePartition(string s, int k) {
            int n = s.length();
            for(int i=0;i<n;++i) pali[i][i] = 0;
            for(int i=0;i<n-1;++i) pali[i][i+1] = s[i]==s[i+1]?0:1;
            for(int len=3;len<=n;++len){
                for(int l=0,r=len-1;r<len;++l,++r) {
                    pali[l][r] = pali[l+1][r-1] + (s[l]==s[r]?0:1);
                }
            }
            for(int i=0;i<n;++i) dp[i][1] = pali[0][i];
            for(int j=2;j<=k;++j) { // j 维度可以压缩数组
                for(int i=0;i<n;++i) {
                    dp[i][j] = 1e9;
                    for(int i2=0;i2<i;++i2) {
                        dp[i][j] = min(dp[i2][j-1] + pali[i2+1][i], dp[i][j]);
                    }
                }
            }
            return dp[n-1][k];
        }
    };
```

更优的细节：

```c++
class Solution {
public:
    int palindromePartition(string s, int k) {
        int n = s.size();
        vector min_change(n, vector<int>(n));
        for (int i = n - 2; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                min_change[i][j] = min_change[i + 1][j - 1] + (s[i] != s[j] ? 1 : 0);
            }
        }

        vector f(k, vector<int>(n, INT_MAX));
        f[0] = move(min_change[0]);
        for (int i = 1; i < k; i++) {
            for (int r = i; r <= n - k + i; r++) { // r<n也行
                for (int l = i; l <= r; l++) {
                    f[i][r] = min(f[i][r], f[i - 1][l - 1] + min_change[l][r]);
                }
            }
        }
        return f[k - 1][n - 1];
    }
};
```

$r\le n-k+i$，是因为，当前到 $r$ 只有 $i+1$ 个，那么 $r$ 后必然还有 $k-i-1$ 个，至少需要 $k-i$ 大小，即 $r$ 上限从 $n-1$ 变为 $n-1-(k-i-1)=n-k+i$。

显然可以压缩 $i$ 这个维度。

```c++
class Solution {
public:
    int palindromePartition(string s, int k) {
        int n = s.size();
        vector min_change(n, vector<int>(n));
        for (int i = n - 2; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                min_change[i][j] = min_change[i + 1][j - 1] + (s[i] != s[j] ? 1 : 0);
            }
        }

        auto f = move(min_change[0]);
        for (int i = 1; i < k; i++) {
            for (int r = n - k + i; r >= i; r--) {
                f[r] = INT_MAX;
                for (int l = i; l <= r; l++) {
                    f[r] = min(f[r], f[l - 1] + min_change[l][r]);
                }
            }
        }
        return f[n - 1];
    }
};
```

##### 1745\.分割回文串IV

[题目](https://leetcode.cn/problems/palindrome-partitioning-iv)

预处理出每个子字符串是不是回文，然后枚举两个隔板端点即可。两种写法：

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2001;
bool isPali[maxn][maxn];
class Solution {
    public:
        bool checkPartitioning(string s) {
            int n = s.size();
            for(int i=0; i<n; ++i) {
                fill_n(isPali[i], n, false);
                isPali[i][i] = 1;
            }
            for(int i=0;i<n-1;++i) {
                isPali[i][i+1] = (s[i] == s[i+1]);
            }
            for(int len=3; len<=n; ++len) {
                for(int l=0, r=len-1; r<n; ++l, ++r) {
                    isPali[l][r] = isPali[l+1][r-1] && (s[l] == s[r]);
                }
            }
            for(int i=0;i<n;++i) {
                for(int j=i+1;j<n-1;++j) {
                    if(isPali[0][i] && isPali[i+1][j] && isPali[j+1][n-1]) {
                        return true;
                    }
                }
            }
            return false;
        }
    };
```

写法二：

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2001;
bool isPali[maxn][maxn];
auto f = []() {
    for(int i=0;i<maxn;++i) isPali[i][i] = true;
    for(int i=0;i<maxn-1;++i) isPali[i+1][i] = true;
    return 0;
}();
class Solution {
    public:
        bool checkPartitioning(string s) {
            int n = s.size();
            for(int i=n-2;i>=0;--i) 
                for(int j=i+1;j<n;++j) 
                    isPali[i][j] = isPali[i+1][j-1] && (s[i]==s[j]);
            for(int i=0;i<n;++i) 
                for(int j=i+1;j<n-1;++j) 
                    if(isPali[0][i] && isPali[i+1][j] && isPali[j+1][n-1]) 
                        return true;
            return false;
        }
    };
```

直接调用上一题：

```c++
return palindromePartition(s, 3) == 0;
```

对 `isPali` 的判断，需要 $O(n)$ 空间复杂度时，设 $v_i$ 表示 manacher 下半径，如 `aba` 的半径是 $2$，其中 $i$ 位置字符为 `b`。若 $[x,y]$ 是回文串，manacher 扩展串下中心是 $c=\dfrac{x+y}2$，直径为 $2v[c]-1$ 若等于区间长 $x-y+1$ 就是回文串。

```c++
class Solution {
public:
    bool checkPartitioning(string s) {
        int n = s.size();
        string t = "$";
        t += "#";
        for(int i = 0; i < n; i++) {
            t += s[i];
            t += "#";
        }
        t += "^";
        n = 2 * n + 3;
        vector<int> v(n);
        int id = 0;
        int mx = 0;
        for(int i = 1; i < n; i++) {
            if(i < mx) v[i] = min(v[2 * id - i], mx - i);
            else v[i] = 1;
            while(t[i - v[i]] == t[i + v[i]]) v[i]++;
            if(mx < i + v[i]) {
                id = i;
                mx = i + v[i];
            }
        }
        for(int i = 3; i < n; i += 2) {
            for(int j = i + 2; j < n - 3; j += 2) {
                if(check(1, i, v) && check(i, j, v) && check(j, n - 2, v)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    bool check(int x, int y, vector<int>& v) {
        if(v[(x + y) / 2] * 2 - 1 >= y - x + 1) return true;
        return false;
    }
};
```

线性做法，用 manacher 预处理出前缀是否双回文，再枚举一次。[src](https://leetcode.cn/problems/palindrome-partitioning-iv/solutions/3067717/ma-la-che-manacheyong-shi-0mszuo-fa-by-w-92ef/) HDU5340 [题目](https://acm.hdu.edu.cn/showproblem.php?pid=5340) [题解](https://leetcode.cn/problems/palindrome-partitioning-iv/solutions/616854/hui-wen-shu-on-by-hqztrue-4mvo/)

```c++
const int N = 2000 + 5;
int hL[N << 1];
int check(int l, int r) {
    l = l * 2 + 2;
    r = r * 2 + 2;
    int mid = l + r >> 1;
    return hL[mid] > r - mid;
}
int l[N];
class Solution {
public:
    bool checkPartitioning(string s) {
        for (int i = 0; i < N; i++)
            l[i] = 0;
        string t = "^#";
        for (char c : s) {
            t += c;
            t += '#';
        }
        t += '$';
        for (int i = 2, boxM = 0, boxR = 0; i < t.size() - 2; i++) {
            int hl = 1;
            if (i < boxR) {
                hl = min(hL[boxM * 2 - i], boxR - i);
            }
            l[i - 2 >> 1] = max(l[i - 2 >> 1], check(0, (i - 2 >> 1) - 1));
            while (t[i - hl] == t[i + hl]) {
                int cl = i - hl - 2 >> 1;
                int cr = i + hl - 2 >> 1;
                if (t[i - hl] != '#' && cl > 0) {
                    l[cr] = max(l[cr], check(0, cl - 1));
                }
                hl++;
                boxM = i;
                boxR = i + hl;
            }
            hL[i] = hl;
        }
        for (int i = 1; i < s.size() - 1; i++) {
            if (l[i] && check(i + 1, s.size() - 1))
                return 1;
        }
        return 0;
    }
};
```

##### 1745\.分割回文串IV

[题目](https://leetcode.cn/problems/palindrome-partitioning-iv)

预处理出每个子字符串是不是回文，然后枚举两个隔板端点即可。两种写法：

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2001;
bool isPali[maxn][maxn];
class Solution {
    public:
        bool checkPartitioning(string s) {
            int n = s.size();
            for(int i=0; i<n; ++i) {
                fill_n(isPali[i], n, false);
                isPali[i][i] = 1;
            }
            for(int i=0;i<n-1;++i) {
                isPali[i][i+1] = (s[i] == s[i+1]);
            }
            for(int len=3; len<=n; ++len) {
                for(int l=0, r=len-1; r<n; ++l, ++r) {
                    isPali[l][r] = isPali[l+1][r-1] && (s[l] == s[r]);
                }
            }
            for(int i=0;i<n;++i) {
                for(int j=i+1;j<n-1;++j) {
                    if(isPali[0][i] && isPali[i+1][j] && isPali[j+1][n-1]) {
                        return true;
                    }
                }
            }
            return false;
        }
    };
```

写法二：

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2001;
bool isPali[maxn][maxn];
auto f = []() {
    for(int i=0;i<maxn;++i) isPali[i][i] = true;
    for(int i=0;i<maxn-1;++i) isPali[i+1][i] = true;
    return 0;
}();
class Solution {
    public:
        bool checkPartitioning(string s) {
            int n = s.size();
            for(int i=n-2;i>=0;--i) 
                for(int j=i+1;j<n;++j) 
                    isPali[i][j] = isPali[i+1][j-1] && (s[i]==s[j]);
            for(int i=0;i<n;++i) 
                for(int j=i+1;j<n-1;++j) 
                    if(isPali[0][i] && isPali[i+1][j] && isPali[j+1][n-1]) 
                        return true;
            return false;
        }
    };
```

直接调用上一题：

```c++
return palindromePartition(s, 3) == 0;
```

对 `isPali` 的判断，需要 $O(n)$ 空间复杂度时，设 $v_i$ 表示 manacher 下半径，如 `aba` 的半径是 $2$，其中 $i$ 位置字符为 `b`。若 $[x,y]$ 是回文串，manacher 扩展串下中心是 $c=\dfrac{x+y}2$，直径为 $2v[c]-1$ 若等于区间长 $x-y+1$ 就是回文串。

```c++
class Solution {
public:
    bool checkPartitioning(string s) {
        int n = s.size();
        string t = "$";
        t += "#";
        for(int i = 0; i < n; i++) {
            t += s[i];
            t += "#";
        }
        t += "^";
        n = 2 * n + 3;
        vector<int> v(n);
        int id = 0;
        int mx = 0;
        for(int i = 1; i < n; i++) {
            if(i < mx) v[i] = min(v[2 * id - i], mx - i);
            else v[i] = 1;
            while(t[i - v[i]] == t[i + v[i]]) v[i]++;
            if(mx < i + v[i]) {
                id = i;
                mx = i + v[i];
            }
        }
        for(int i = 3; i < n; i += 2) {
            for(int j = i + 2; j < n - 3; j += 2) {
                if(check(1, i, v) && check(i, j, v) && check(j, n - 2, v)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    bool check(int x, int y, vector<int>& v) {
        if(v[(x + y) / 2] * 2 - 1 >= y - x + 1) return true;
        return false;
    }
};
```

线性做法，用 manacher 预处理出前缀是否双回文，再枚举一次。[src](https://leetcode.cn/problems/palindrome-partitioning-iv/solutions/3067717/ma-la-che-manacheyong-shi-0mszuo-fa-by-w-92ef/) HDU5340 [题目](https://acm.hdu.edu.cn/showproblem.php?pid=5340) [题解](https://leetcode.cn/problems/palindrome-partitioning-iv/solutions/616854/hui-wen-shu-on-by-hqztrue-4mvo/)

```c++
const int N = 2000 + 5;
int hL[N << 1];
int check(int l, int r) {
    l = l * 2 + 2;
    r = r * 2 + 2;
    int mid = l + r >> 1;
    return hL[mid] > r - mid;
}
int l[N];
class Solution {
public:
    bool checkPartitioning(string s) {
        for (int i = 0; i < N; i++)
            l[i] = 0;
        string t = "^#";
        for (char c : s) {
            t += c;
            t += '#';
        }
        t += '$';
        for (int i = 2, boxM = 0, boxR = 0; i < t.size() - 2; i++) {
            int hl = 1;
            if (i < boxR) {
                hl = min(hL[boxM * 2 - i], boxR - i);
            }
            l[i - 2 >> 1] = max(l[i - 2 >> 1], check(0, (i - 2 >> 1) - 1));
            while (t[i - hl] == t[i + hl]) {
                int cl = i - hl - 2 >> 1;
                int cr = i + hl - 2 >> 1;
                if (t[i - hl] != '#' && cl > 0) {
                    l[cr] = max(l[cr], check(0, cl - 1));
                }
                hl++;
                boxM = i;
                boxR = i + hl;
            }
            hL[i] = hl;
        }
        for (int i = 1; i < s.size() - 1; i++) {
            if (l[i] && check(i + 1, s.size() - 1))
                return 1;
        }
        return 0;
    }
};
```

##### 2606\.找到最大开销的子字符串

[题目](https://leetcode.cn/problems/find-the-substring-with-maximum-cost)

前缀和：

```c++
#include <bits/stdc++.h>
using namespace std;
class Solution
{
public:
    int maximumCostSubstring(string s, string chars, vector<int> &vals)
    {
        vector<int> v(26);
        iota(v.begin(), v.end(), 1);
        for (int i = 0; i < chars.size(); i++)
            v[chars[i] - 'a'] = vals[i];
        // max [l:r] = s[r] - min s[l-1]
        int mins = 0, ans = 0, sum = 0;
        for(int i = 0; i < s.size(); i++)
        {
            sum += v[s[i] - 'a'];
            ans = max(ans, sum - mins);
            mins = min(mins, sum);
        }
        return ans;
    }
};
```

DP：$f_i=\max(f_{i-1}+a_i, a_i)$，分别是接和不接(设新 $l$)前面的。

```python
class Solution:
    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:
        mapping = dict(zip(ascii_lowercase, range(1, 27))) | dict(zip(chars, vals))
        ans = f = 0
        for c in s:
            f = max(f, 0) + mapping[c]
            ans = max(ans, f)
        return ans
```

```python
class Solution:
    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:
        mapping = dict(zip(ascii_lowercase, range(1, 27))) | dict(zip(chars, vals))
        ans = f = 0
        for c in s:
            f = max(f, 0) + mapping[c]
            ans = max(ans, f)
        return ans
```

##### 1328\.破坏回文串

[题目](https://leetcode.cn/problems/break-a-palindrome)

```c++
#include <bits/stdc++.h>
using namespace std;
class Solution {
    public:
        string breakPalindrome(string palindrome) {
            if(palindrome.size() == 1) return "";
            int n = palindrome.size();
            for(int l=0,r=n-1;l<r;++l,--r){
                if(palindrome[l] != 'a'){
                    palindrome[l] = 'a';
                    return palindrome;
                }
            }
            palindrome[n-1] = 'b';
            return palindrome;
        }
    };
```

```c++
class Solution {
public:
    string breakPalindrome(string s) {
        int n = s.size();
        if (n == 1) {
            return "";
        }
        // 把第一个不等于 a 的字母改成 a
        // 只需找前一半，如果前一半没有不等于 a 的字母，那么后一半肯定也没有
        for (int i = 0; i < n / 2; i++) {
            if (s[i] != 'a') {
                s[i] = 'a';
                return s;
            }
        }
        // 除了回文中心，全是 a
        s.back() = 'b'; // 最后一个字母改成 b
        return s;
    }
};
```

##### 1191\.K次串联后最大子数组和

[题目](https://leetcode.cn/problems/k-concatenation-maximum-sum)

注意到所有长度为 $n$ 的子数组的和都等于原数组和，而不仅仅是所有起点是 $\forall c,cn$ 的长 $n$ 子数组等于。找到两倍长的最大子数组和，拼接 $k-2$ 个长 $n$ 子数组和。

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5+3, p = 1e9+7;
int a[maxn];
using ll = long long;
class Solution {
        ll solve(int n) {
            ll ans = 0, ml = 0, s = 0;
            for(int i=0; i<n; ++i) {
                s += a[i];
                ans = max(ans, s - ml);
                ml = min(ml, s);
            }
            return ans;
        }
    public:
        int kConcatenationMaxSum(vector<int>& arr, int k) {
            int n = arr.size();
            for(int i=0;i<n;++i) a[i] = arr[i];
            ll s = accumulate(a, a+n, 0LL);
            if(k==1) return solve(n);
            for(int i=0;i<n;++i) a[i+n] = a[i];
            ll smx = 0, pmx = 0, ss=0, sp=0;
            for(int i=0;i<n;++i) smx=max(smx, ss), ss+=a[i];
            for(int i=n-1;i>=0;--i) pmx=max(pmx, sp), sp+=a[i];
            ll a2 = solve(2*n);
            //cout << a2 << ' ' << s << " " << k << " " << pmx << " " << smx;
            return max({0LL, s*k, a2+max(0LL,s*(k-2)), max(0LL,s*(k-1))+max(pmx, smx)}) % p;
        }
    };
```

最大子数组和的 DP 解法有名 Kanade 算法。简化后只需要 a2+s(k-2) 项

```c++
class Solution {
  public int kConcatenationMaxSum(int[] arr, int k) {
    if (arr == null || arr.length == 0) return 0;
    long maxOfEnd = arr[0] > 0 ? arr[0] : 0L, maxSoFar = maxOfEnd, sum = arr[0];
    for (int i = 1; i < Math.min(k, 2) * arr.length; i++) {
      maxOfEnd = Math.max(maxOfEnd + arr[i % arr.length], arr[i % arr.length]);
      maxSoFar = Math.max(maxOfEnd, maxSoFar);
      if (i < arr.length) sum += arr[i];
    }
    if (sum > 0 && k > 2) {
        long r = (sum * (k - 2)) % 1000000007;
        maxSoFar += r;
    }
    return (int) maxSoFar % 1000000007;
  }
}
```

注意比较大小要在取模前。

##### 2321\.拼接数组的最大分数

[题目](https://leetcode.cn/problems/maximum-score-of-spliced-array)

设数组为 $a,b$，0-indexed，设选取 $0\le L\le l\le r\le R<n$，设区间和为 $s$，子问题：
$$
\begin{align}
f(a,b)=&\max_{L,l,r,R}sa[L,R]+sb[l,r]-sa[l,r]\\
=&\max_{L,l,r,R}sa[L,l-1]+sb[l,r]+sa[r+1,R]
\end{align}
$$
用前缀和维护 $\max sa[L,l-1]$，对子问题 $sa[L,l-1]+sb[l,r]$，等价于维护 $\max sb[l,r]=sb[r]-sb[l-1]$ 的基础上，变成 $sb[r]-sb[l-1]+sa[l-1]-sa[L-1]$。原本是维护 $\min sb[l-1]$ 即 $-\max sb[l-1]$，现在令 $sb'[l-1]=sb[l-1]+sa[l-1]-sa[L-1]$，其中 $sa[l-1]-sa[L-1]$ 根据“前缀和维护 $\max sa[L,l-1]$”可得，所以等价于维护 $sb[r]-sb'[l-1]$。同理，推广到 $f(a,b)$ 如法炮制得解。

写法一：

```c++
#include<bits/stdc++.h>
using namespace std;
class Solution {
    void test(const vector<int>& a) {
        for(auto&x:a) cout<<x<<' '; cout << '\n';
    }
    int solve(vector<int>& a, vector<int>& b) {
        int n = a.size();
        int ans = 0;
        vector<int> sa(n, 0), sb(n, 0);
        partial_sum(a.begin(), a.end(), sa.begin());
        partial_sum(b.begin(), b.end(), sb.begin());
        vector<int> s1(n, 0); // max -a[0:l]
        for(int i=1; i<n; i++) { 
            s1[i] = max(s1[i-1], -sa[i]); // 前缀min
        }
        vector<int> s2(n, 0); // max a[l:r]
        for(int i=1; i<n; i++) {
            s2[i] = max(s2[i-1], sa[i] + s1[i]);
            ans = max(ans, s2[i]);
        }
        // ans = max a[L:R] - b[l:r] L<=l<=r<=R
        // = max a[L:l-1] + b[l:r] + a[l+1:r]
        vector<int> s3(n, 0); // max -b[0:l]+a[L:l-1]
        for(int i=1; i<n; i++) {
            s3[i] = max(s3[i-1], -sb[i-1] + s2[i-1]);
        }
        vector<int> s4(n, 0); // max b[l:r]+a[L:l-1]
        for(int i=1; i<n; i++) {
            s4[i] = max(s4[i-1], sb[i] + s3[i]);
            ans = max(ans, s4[i]);
        }
        vector<int> s5(n, 0);
        for(int i=1; i<n; i++) {
            s5[i] = max(s5[i-1], -sa[i-1] + s4[i-1]);
        }
        vector<int> s6(n, 0);
        for(int i=1; i<n; i++) {
            s6[i] = max(s6[i-1], sa[i] + s5[i]);
            ans = max(ans, s6[i]);
        }

        return ans;
    }
public:
    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {
        nums1.insert(nums1.begin(), 0);
        nums2.insert(nums2.begin(), 0);
        return max(solve(nums1, nums2), solve(nums2, nums1));
    }
};
```

写法二：

```c++
#include<bits/stdc++.h>
using namespace std;
vector<int> blank(1e5+1);
class Solution {
    int ans = 0, n;
    vector<int> f(vector<int>& a, vector<int>& p) {
        vector<int> p2(n, 0);
        int minsl = 0, s = 0;
        for (int i = 1; i < n; i++) {
            s += a[i];
            minsl = max(minsl, -s + p[i]);
            p2[i] = max(p2[i - 1], s + minsl);
            ans = max(ans, p2[i]);
            
        }
        return p2;
    }
    void solve(vector<int>& a, vector<int>& b) {
        vector<int> p0 = f(a, blank);
        vector<int> p1 = f(b, p0);
        f(a, p1);
    }
public:
    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {
        nums1.insert(nums1.begin(), 0);
        nums2.insert(nums2.begin(), 0);
        n = nums1.size();
        solve(nums1, nums2);
        solve(nums2, nums1);
        return ans;
    }
};
```

解法二：假设交换了 $[l,r]$，对 $a$ 数组交换后的前缀和 $sa'_i$ 为：
$$
sa'_i=sa_i+sb_r-sb_{l-1}-(sa_r-sa_{l-1})
$$
令 $d=b-a$，其前缀和为 $sd$，即 $sa'_i=sa_i+sd_r-sd_{l-1}$。

求 $d$ 的最大子数组和，由于 $a>0$，则 $a$ 的最大子数组和必然是 $sa_{n-1}$，故原问题等价于 $d$ 的最大子数组和 $+sa_{n-1}$。

```python
class Solution:
    def solve(self, nums1: List[int], nums2: List[int]) -> int:
        max_sum = f = 0
        for x, y in zip(nums1, nums2):
            f = max(f, 0) + y - x
            max_sum = max(max_sum, f)
        return sum(nums1) + max_sum
    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:
        return max(self.solve(nums1, nums2), self.solve(nums2, nums1))
```

##### 2588\.统计美丽子数组数目

[题目](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays)

等价于求异或为 0 的子数组数量，等价于叠前缀异或后，找到对当前异或和，在这之前有几个一样的异或和。使用静态全局数组代替 map/unmap。可以 0ms 双百通过。

```c++
#include<bits/stdc++.h>
using namespace std;
int bin[(1<<20) + 3] {1};
class Solution {
    public:
        long long beautifulSubarrays(vector<int>& nums) {
            long long ans = 0;
            int s = 0;
            for(int&x:nums) {
                s ^= x;
                ans += bin[s]++;
            }
            s = 0;
            for(int&x:nums) {
                s ^= x;
                --bin[s];
            }
            return ans;
        }
    };
```

##### 2070\.每一个查询的最大美丽值

[题目](https://leetcode.cn/problems/most-beautiful-item-for-each-query)

离线：

```c++
#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        int m = queries.size(), n = items.size();
        vector<pair<int, int>> q(m);
        for(int i = 0; i < m; ++i) {
            q[i] = {queries[i], i};
        }
        sort(q.begin(), q.end());
        sort(items.begin(), items.end());
        vector<int> ans(m);
        int i = 0, maxBeauty = 0;
        for(int qi = 0; qi < m; ++qi) {
            while(i < n && items[i][0] <= q[qi].first) {
                maxBeauty = max(maxBeauty, items[i][1]);
                ++i;
            }
            ans[q[qi].second] = maxBeauty;
        }
        return ans;
    }
};
```

在线：前缀max上二分，可以再去掉递减信息降低前缀和长度

```c++
class Solution {
public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        ranges::sort(items, {}, [](auto& item) { return item[0]; });
        for (int i = 1; i < items.size(); i++) {
            // 原地计算 beauty 的前缀最大值
            items[i][1] = max(items[i][1], items[i - 1][1]);
        }

        for (int& q : queries) {
            int j = ranges::upper_bound(items, q, {}, [](auto& item) { return item[0]; }) - items.begin();
            q = j ? items[j - 1][1] : 0;
        }
        return queries;
    }
};
```

```c++
class Solution {
public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        ranges::sort(items, {}, [](auto& item) { return item[0]; });
        int k = 0;
        for (int i = 1; i < items.size(); i++) {
            if (items[i][1] > items[k][1]) { // 有用
                items[++k] = items[i];
            }
        }

        for (int& q : queries) {
            int j = upper_bound(items.begin(), items.begin() + (k + 1), q, [](int value, auto& item) {
                return value < item[0];
            }) - items.begin();
            q = j ? items[j - 1][1] : 0;
        }
        return queries;
    }
};
```

##### 2234\.花园里的最大总美丽值

[题目](https://leetcode.cn/problems/maximum-total-beauty-of-the-gardens)

排序。枚举不完善花园的最少数目，用后缀和+指针维护达成这个最少数目需要多少花，然后同样用指针维护在这之前的部分能最大搞多少个完善花园，注意在这之后的部分，除了最后一盆之外，也都能用除法计算出能额外搞多多少个完善花园。注意特判，细节参见代码。

```c++

#include<bits/stdc++.h>
using namespace std;
using ll = long long;
class Solution {
public:
    ll maximumBeauty(vector<int>& flowers, ll newFlowers, int target, int full, int partial) {
        int n = flowers.size();
        sort(flowers.begin(), flowers.end());
        reverse(flowers.begin(), flowers.end());
        vector<ll> sumLeft(n, 0);
        for(int i = 0; i < n; ++i) {
            sumLeft[i] = (i == 0 ? 0 : sumLeft[i - 1]);
            sumLeft[i] += max(0LL, target*1LL - flowers[i]);
        }
        ll iFull = upper_bound(sumLeft.begin(), sumLeft.end(), newFlowers) - sumLeft.begin() - 1;
        ll costFull = iFull>=0 ? sumLeft[iFull] : 0;
        ll ans = (iFull+1) * full;
        //cout << "iFull=" << iFull << " ans=" << ans << '\n';
        // i: 第一个下标，大于当前花的最少数目
        ll sumRight = 0, costRight = 0, i = n - 1;
        auto moveIFull = [&]() {
            if(iFull < 0) return;
            costFull -= target - flowers[iFull];
            --iFull;
        };
        if(iFull == n - 1) moveIFull();
        //cout << "iFull=" << iFull << " ans=" << ans << '\n';
        for(ll minNum = 1; minNum < target; ++minNum) {
            while(i >= 0 && flowers[i] < minNum) {
                sumRight += flowers[i];
                --i;
            }
            if(i==n-1 && flowers[i] > minNum) continue;
            costRight = minNum * (n - 1 - i) - sumRight;
            while(iFull > i) moveIFull();
            
            while(costFull + costRight > newFlowers) {
                moveIFull();
                if (iFull < 0) break;
            }
            if(costFull + costRight > newFlowers) break;
            ll costRemain = newFlowers - costFull - costRight;
            ll numFull = iFull + 1 + (costRemain / (target - minNum));
            numFull = min(numFull, n - 1LL);
            ll total = numFull * full + minNum * partial;
            ans = max(ans, total);
            //cout << "minNum=" << minNum << " iFull=" << iFull << " i=" << i << " costRight=" << costRight << " costFull=" << costFull << " total=" << total << '\n';
        }
        return ans;
    }
};
```

##### 2269\.找到一个数字的K美丽值

[题目](https://leetcode.cn/problems/find-the-k-beauty-of-a-number)

需要 long long

```c++
class Solution {
public:
    int divisorSubstrings(int num, int k) {
        long long x=0,ans=0,kp=10;
        string s = to_string(num);
        int n=s.size();
        for(int i=0;i<k-1;++i) {
            kp*=10;
            x=x*10+(s[i]-'0');
        }
        for(int i=k-1;i<n;++i) {
            x=(x*10+(s[i]-'0'))%kp;
            ans+=x&&(num%x==0);
        }
        return ans;
    }
};
```

更好的写法：模数扩大10倍每次，然后去掉最低数

```c++
class Solution {
public:
    int divisorSubstrings(int num, int k) {
        long long m = pow(10, k);
        int ans = 0;
        for (int n = num; n >= m / 10; n /= 10) {
            int x = n % m;
            if (x > 0 && num % x == 0) {
                ans++;
            }
        }
        return ans;
    }
};
```

字符串：

```c++
class Solution {
public:
    int divisorSubstrings(int num, int k) {
        string s = to_string(num);
        int ans = 0;
        for (int i = k; i <= s.size(); i++) {
            int x = stoi(s.substr(i - k, k)); // 长为 k 的子串
            if (x > 0 && num % x == 0) { // 子串能整除 num
                ans++;
            }
        }
        return ans;
    }
};
            }
            return ans;
        }
    };
```

##### 2597\.美丽子集的数目

[题目](https://leetcode.cn/problems/the-number-of-beautiful-subsets)

我的二进制枚举：800ms

```c++
#include <bits/stdc++.h>
using namespace std;
int bin[2003];
class Solution {
    public:
        int beautifulSubsets(vector<int>& nums, int k) {
            int n = nums.size(), ans = 0;
            for(int i=1;i<1<<n;++i) {
                bool ok = true;
                int je = 0;
                for(int j=0;j<n;++j) {
                    if(i>>j&1) {
                        int v = nums[j];
                        je=j;
                        ++bin[v];
                        if(v-k>=0 && bin[v-k] || bin[v+k]) {
                            ok = false;
                            break;
                        }
                    }
                }
                ans += ok;
                for(int j=0;j<=je;++j) 
                    if(i>>j&1) 
                        --bin[nums[j]];
                
            }
            return ans;
        }
    };
```

注意到二进制枚举完全不剪枝，虽然不递归，但是实际上远远慢于爆搜，因为爆搜会剪枝，例如同样条件下，DFS 快 10 倍，80ms

```c++
int cnt[2003];
class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        int ans = -1; // 去掉空集

        // 在 [i, n-1] 中选一个数
        auto dfs = [&](this auto&& dfs, int i) -> void {
            ans++;
            if (i == nums.size()) {
                return;
            }
            for (int j = i; j < nums.size(); j++) { // 枚举选哪个
                int x = nums[j];
                if ((x-k<0||cnt[x - k] == 0) && cnt[x + k] == 0) { // 可以选
                    cnt[x]++; // 选
                    dfs(j + 1); // 下一个数在 [j+1, n-1] 中选
                    cnt[x]--; // 撤销，恢复现场
                }
            }
        };

        dfs(0);
        return ans;
    }
};
// 第二种写法：不要j+1，就选与不选 dfs(i+1)
```

```c++
class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        int ans = -1; // 去掉空集
        unordered_map<int, int> cnt; // unmap:200ms，像我那样就80ms

        // nums[i] 选或不选
        auto dfs = [&](this auto&& dfs, int i) -> void {
            if (i == nums.size()) {
                ans++;
                return;
            }
            dfs(i + 1); // 不选
            int x = nums[i];
            if (cnt[x - k] == 0 && cnt[x + k] == 0) { // 可以选
                cnt[x]++; // 选
                dfs(i + 1); // 讨论 nums[i+1] 选或不选
                cnt[x]--; // 撤销，恢复现场
            }
        };

        dfs(0);
        return ans;
    }
};
```

按摸 $k$ 同余把 $num$ 划分为若干个同余组，每个组是 $a$，组内每个元素的出现次数是 $c$。

定义 $f_{i+1}$ 是在 $a[0,i]$ 的选数方案。选与不选：

1. 不选，$f_{i+1}=f_i$。

2. 选，若 $a_i-a_{i-1}=k$，组内上一个不可以选，上上一个可以选。并且在 $c_i$ 个 $a_i$ 元素选非空子集有 $2^{c_i}-1$ 个方案，故总方案 $f_{i-1}(2^{c_i}-1)$。

   若 $a_i-a_{i-1}=k$，同理，$f_i(2^{c_i}-1)$。 其中这种情况与不选合并，可得 $f_i2^{c_i}$。

选子集，显然跨组的两个元素相减无论如何都凑不出 $k$，每组互不干扰，故每个 $f$ 乘法原理即可。复杂度取划分复杂度 $O(n\log n)$。注意删掉空集方案。

```c++
class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        unordered_map<int, map<int, int>> groups;
        for (int x : nums) {
            // 模 k 同余的数分到同一组，记录元素 x 及其出现次数
            groups[x % k][x]++;
        }

        int ans = 1;
        for (auto& [_, cnt] : groups) {
            // 计算这一组的方案数
            int m = cnt.size();
            vector<int> f(m + 1);
            auto it = cnt.begin();
            f[0] = 1;
            f[1] = 1 << it++->second;
            for (int i = 1; i < m; i++, it++) {
                auto [x, c] = *it;
                if (x - prev(it)->first == k) {
                    f[i + 1] = f[i] + f[i - 1] * ((1 << c) - 1);
                } else {
                    f[i + 1] = f[i] << c;
                }
            }
            ans *= f[m]; // 每组方案数相乘
        }
        return ans - 1; // 去掉空集
    }
};
```

上述 DP，根据打家劫舍，可以滚动优化。

```python
class Solution:
    def beautifulSubsets(self, nums: List[int], k: int) -> int:
        groups = defaultdict(Counter)
        for x in nums:
            # 模 k 同余的数分到同一组，记录元素 x 及其出现次数
            groups[x % k][x] += 1

        ans = 1
        for cnt in groups.values():
            # 计算这一组的方案数
            a = sorted(cnt.items())
            f0, f1 = 1, 1 << a[0][1]
            for (pre, _), (x, c) in pairwise(a):
                if x - pre == k:
                    f0, f1 = f1, f1 + f0 * ((1 << c) - 1)
                else:
                    f0, f1 = f1, f1 << c
            ans *= f1  # 每组方案数相乘
        return ans - 1  # 去掉空集
```

还可以继续优化，卡掉 $\log n$。注意到如果同余组里某一相邻隔断了超过 $k$，隔断前后各取一个无论怎么减都凑不起来 $k$，也就是说等价于可以拆成两组求 $f$。找到每个同余的首项，直接在 map 里不断 $+k$ 推。实际表现不如不优化。

```c++
class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        unordered_map<int, int> cnt;
        for (int x : nums) {
            cnt[x]++;
        }

        int ans = 1;
        for (auto& [x, c] : cnt) {
            if (cnt.contains(x - k)) { // x 不是等差数列的首项
                continue;
            }
            // 计算这一组的方案数
            int f0 = 1, f1 = 1 << c;
            for (int y = x + k; cnt.contains(y); y += k) {
                int new_f = f1 + f0 * ((1 << cnt[y]) - 1);
                f0 = f1;
                f1 = new_f;
            }
            ans *= f1; // 每组方案数相乘
        }
        return ans - 1; // 去掉空集
    }
};
```

##### 152\.乘积最大子数组

[题目]()

注意负负得正。

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        long maxF = nums[0], minF = nums[0], ans = nums[0];
        for (int i = 1; i < nums.size(); ++i) {
            long mx = maxF, mn = minF;
            maxF = max(mx * nums[i], max((long)nums[i], mn * nums[i]));
            minF = min(mn * nums[i], min((long)nums[i], mx * nums[i]));
            if(minF<INT_MIN) {
                minF=nums[i];
            }
            ans = max(maxF, ans);
        }
        return ans;
    }
};
```

##### 2012\.数组美丽值求和

[题目](https://leetcode.cn/problems/sum-of-beauty-in-the-array)

```c++
#include <bits/stdc++.h>
using namespace std;
class Solution {
    public:
        int sumOfBeauties(vector<int>& nums) {
            int n = nums.size(), mx = nums[0], ans = 0;
            vector<int> mi(n, 0);
            mi[n-1]=nums[n-1];
            for(int i=n-2;i>=0;--i) {
                mi[i] = min(nums[i], mi[i+1]);
            }
            for(int i=1;i<=n-2;++i) {
                if(mx < nums[i] && nums[i] < mi[i+1])
                    ans+=2;
                else if(nums[i-1] < nums[i] && nums[i] < nums[i+1])
                    ++ans;
                mx = max(mx, nums[i]);
            }
            return ans;
        }
    };
```

##### 3306\.元音辅音字符串计数II

[题目](https://leetcode.cn/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii)

> I 可以暴力枚举字符串：我的 go (37ms 比题解 56ms 快)
>
> ```go
> package main
> 
> func countOfSubstrings(word string, k int) int {
> 	n := len(word)
> 	ans := 0
> 	var isAeiou = func(c byte) bool {
> 		switch c {
> 		case 'a', 'e', 'i', 'o', 'u':
> 			return true
> 		}
> 		return false
> 	}
> 	for l := 0; l < n; l++ {
> 		cnt := make(map[byte]int)
> 		ac := 0
> 		cnt2 := 0
> 
> 		for r := l; r < n; r++ {
> 			if isAeiou(word[r]) {
> 				if cnt[word[r]] == 0 {
> 					ac++
> 				}
> 				cnt[word[r]]++
> 			} else {
> 				cnt2++
> 			}
> 			if ac == 5 && cnt2 == k {
> 				ans++
> 			}
> 			if cnt2 > k {
> 				break
> 			}
> 		}
> 	}
> 	return ans
> }
> ```
>
> 题解：(我加了 break)
>
> ```go
> func countOfSubstrings(word string, k int) int {
>     vowels := map[byte]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true}
>     n := len(word)
>     res := 0
>     for i := 0; i < n; i++ {
>         occur := map[byte]bool{}
>         consonants := 0
>         for j := i; j < n; j++ {
>             if vowels[word[j]] {
>                 occur[word[j]] = true
>             } else {
>                 consonants++
>             }
>             if len(occur) == 5 && consonants == k {
>                 res++
>             }
>             if consonants > k {
>                 break
>             }
>         }
>     }
>     return res
> }
> ```

双指针维护满足有所有元音的最右边 $lV$，则对给定 $r$，满足元音条件的左边取值范围是 $[0,lV]$。

再任意手段维护出现 $k$ 次辅音的区间段 $[lC1,lC2]$。把这两个取值范围合并即可。

650ms

```go
package main

func countOfSubstrings(word string, k int) int64 {
	vowel := map[byte]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true}
	var ans int64
	n := len(word)
	numVowel := map[byte]int{}
	cntVowel := 0
	cons := []int{} // 所有辅音的下标
	lV := 0         //保持全部元音的最右
	lC1 := 0        // 保持k个辅音的最左
	lC2 := 0        // 保持k个辅音的最右
	var failVowelAfterRemove = func() bool {
		c := word[lV]
		if !vowel[c] { // 辅音不影响，不会影响
			return false
		}
		return numVowel[c] == 1
	}
	for r := 0; r < n; r++ {
		c := word[r]
		if vowel[c] {
			if numVowel[c] == 0 {
				cntVowel++
			}
			numVowel[c]++
		} else {
			cons = append(cons, r)
			if len(cons) >= k {
				//最右>=k个辅音的下标
				i := len(cons) - k - 1
				if i < 0 { // len == k
					lC1 = 0
				} else {
					lC1 = cons[i] + 1
				}
				if k != 0 {
					lC2 = cons[i+1]
				}
			}
		}

		for ; lV < r && !failVowelAfterRemove(); lV++ {
			c = word[lV]
			if vowel[c] {
				numVowel[c]--
				if numVowel[c] == 0 {
					cntVowel--
				}
			}
		}
		if cntVowel == 5 && len(cons) >= k {
			if k != 0 {
				ans += int64(max(0, min(lV, lC2)-lC1+1))
			} else {
				ans += int64(max(0, lV-lC1+1))
			}
		}
	}
	return ans
}
```

等价于求：

- 各元音字母至少出现一次，至少包含 $k$ 个辅音的个数 $f_k$
- 各元音字母至少出现一次，至少包含 $k+1$ 个辅音的个数 $f_{k+1}$
- 当前答案为 $f_k-f_{k+1}$

```go
func f(word string, k int) (ans int64) {
	// 这里用哈希表实现，替换成数组会更快
	cnt1 := map[byte]int{} // 每种元音的个数
	cnt2 := 0 // 辅音个数
	left := 0
	for _, b := range word {
		if strings.ContainsRune("aeiou", b) {
			cnt1[byte(b)]++
		} else {
			cnt2++
		}
		for len(cnt1) == 5 && cnt2 >= k {
			out := word[left]
			if strings.ContainsRune("aeiou", rune(out)) {
				cnt1[out]--
				if cnt1[out] == 0 {
					delete(cnt1, out)
				}
			} else {
				cnt2--
			}
			left++
		}
		ans += int64(left)
	}
	return
}

func countOfSubstrings(word string, k int) int64 {
	return f(word, k) - f(word, k+1)
}
```

位运算优化：把字母表看成 26 位整数，故在不在 aeiou 就看看当前字母是不是地 aeiou 个数位，按位与>0即可，能把上述代码 400ms 优化到 50ms

```go
func f(word string, k int) (ans int64) {
	const vowelMask = 1065233
	cnt1 := ['u' - 'a' + 1]int{}
	size1 := 0 // 元音种类数
	cnt2 := 0
	left := 0
	for _, b := range word {
		b -= 'a'
		if vowelMask>>b&1 > 0 {
			if cnt1[b] == 0 {
				size1++
			}
			cnt1[b]++
		} else {
			cnt2++
		}
		for size1 == 5 && cnt2 >= k {
			out := word[left] - 'a'
			if vowelMask>>out&1 > 0 {
				cnt1[out]--
				if cnt1[out] == 0 {
					size1--
				}
			} else {
				cnt2--
			}
			left++
		}
		ans += int64(left)
	}
	return
}

func countOfSubstrings(word string, k int) int64 {
	return f(word, k) - f(word, k+1)
}
```

也可以同时滑两个

```go
func countOfSubstrings(word string, k int) (ans int64) {
	const vowelMask = 1065233
	var cntVowel1, cntVowel2 ['u' - 'a' + 1]int
	sizeVowel1, sizeVowel2 := 0, 0 // 元音种类数
	cntConsonant1, cntConsonant2 := 0, 0
	left1, left2 := 0, 0
	for _, b := range word {
		b -= 'a'
		if vowelMask>>b&1 > 0 {
			if cntVowel1[b] == 0 {
				sizeVowel1++
			}
			cntVowel1[b]++
			if cntVowel2[b] == 0 {
				sizeVowel2++
			}
			cntVowel2[b]++
		} else {
			cntConsonant1++
			cntConsonant2++
		}

		for sizeVowel1 == 5 && cntConsonant1 >= k {
			out := word[left1] - 'a'
			if vowelMask>>out&1 > 0 {
				cntVowel1[out]--
				if cntVowel1[out] == 0 {
					sizeVowel1--
				}
			} else {
				cntConsonant1--
			}
			left1++
		}

		for sizeVowel2 == 5 && cntConsonant2 > k {
			out := word[left2] - 'a'
			if vowelMask>>out&1 > 0 {
				cntVowel2[out]--
				if cntVowel2[out] == 0 {
					sizeVowel2--
				}
			} else {
				cntConsonant2--
			}
			left2++
		}

		ans += int64(left1 - left2)
	}
	return
}
```

##### 3340\.检查平衡字符串

[题目](https://leetcode.cn/problems/check-balanced-string)

```go
func isBalanced(num string) bool {
	s, p := 0, 1
	for _, v := range num {
		s += (int(v) - 48) * p
		p *= -1
	}
	return s == 0
}
```

第二种写法：

```go
func isBalanced(num string) bool {
    s := 0
    for i, b := range num {
        s += (i%2*2 - 1) * int(b-'0')
    }
    return s == 0
}
```

##### 3110\.字符串的分数

[题目](https://leetcode.cn/problems/score-of-a-string)

```go
import "math"

func scoreOfString(s string) int {
	ans, n := 0.0, len(s)
	for i := 1; i < n; i++ {
		ans += math.Abs(float64(s[i]) - float64(s[i-1]))
	}
	return int(ans)
}
```

```go
func scoreOfString(s string) (ans int) {
	for i := 1; i < len(s); i++ {
		ans += abs(int(s[i-1]) - int(s[i]))
	}
	return
}

func abs(x int) int { if x < 0 { return -x }; return x }
```

##### 2272\.最大波动的子字符串

[题目](https://leetcode.cn/problems/substring-with-largest-variance)

枚举当前最大 $a$ 和最小次数字符 $b$ 分别是哪两个，如果答案不是这个的话，这样的枚举虽然冗余但不破坏正确性。然后对最大最小分别记作 $+1,-1$，其他记作 $0$，统计这样的最大子数组和。需要增设状态条件是否包含 $b$，否则只有 $b$ 一种字符最大最小都是它。设 $f_{i+1,0}$ 是不管是否包含 $s_i$ 结尾，$f_{i+1,1}$ 是包含。$f_{i+1,0}$ 就是朴素最大子数组和，对 $f_{i+1,1}$，首先可以继承 $f_{i,1}$，如果当前是 $b$，就可以继承 $f_{i+1,0}$。初始值 $f_{0,1}=-\infty$。复杂度 $O(n|\Sigma|^2)$。

```go
func largestVariance(s string) (ans int) {
    for a := 'a'; a <= 'z'; a++ {
        for b := 'a'; b <= 'z'; b++ {
            if b == a {
                continue
            }
            f0, f1 := 0, math.MinInt
            for _, ch := range s {
                if ch == a {
                    f0 = max(f0, 0) + 1
                    f1++
                } else if ch == b {
                    f1, f0 = max(f0, 0)-1, max(f0, 0)-1
                } // else { f0 = max(f0, 0) } 可以留到 ch 等于 a 或者 b 的时候计算，f1 不变
                ans = max(ans, f1)
            }
        }
    }
    return
}
```

优化：只遍历一次字符串，同时维护所有 $|\Sigma|^2$ 次 DP。

```go
func largestVariance(s string) (ans int) {
	var f0, f1 [26][26]int
	for i := range f1 {
		for j := range f1[i] {
			f1[i][j] = math.MinInt
		}
	}

	for _, ch := range s {
		ch -= 'a'
		// 遍历到 ch 时，只需计算 a=ch 或者 b=ch 的状态，其他状态和 ch 无关，f 值不变
		for i := range 26 {
			if i == int(ch) {
				continue
			}
			// 假设出现次数最多的字母 a=ch，更新所有 b=i 的状态
			f0[ch][i] = max(f0[ch][i], 0) + 1
			f1[ch][i]++
			// 假设出现次数最少的字母 b=ch，更新所有 a=i 的状态
			f0[i][ch] = max(f0[i][ch], 0) - 1
			f1[i][ch] = f0[i][ch]
			ans = max(ans, f1[ch][i], f1[i][ch])
		}
	}
	return
}
```

##### 2614\.对角线上的质数

[题目](https://leetcode.cn/problems/prime-in-diagonal)

```go
func diagonalPrime(nums [][]int) int {
	n, ans := len(nums), 0
	isPrime := func(x int) bool {
		for i := 2; i*i <= x; i++ {
			if x%i == 0 {
				return false
			}
		}
		return x > 1
	}
	for i := 0; i < n; i++ {
		x, y := i, n-1-i
		if isPrime(nums[i][x]) {
			ans = max(ans, nums[i][x])
		}
		if x != y && isPrime(nums[i][y]) {
			ans = max(ans, nums[i][y])
		}
	}
	return ans
}
```

```go
func isPrime(n int) bool {
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            return false
        }
    }
    return n >= 2 // 1 不是质数
}

func diagonalPrime(nums [][]int) (ans int) {
    for i, row := range nums {
        if x := row[i]; x > ans && isPrime(x) {
            ans = x
        }
        if x := row[len(nums)-1-i]; x > ans && isPrime(x) {
            ans = x
        }
    }
    return
}
```

##### 1963\.使字符串平衡的最小交换次数

[题目](https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/description/)

反正盲猜出来了，每次匹配一定能消掉两对。

```go
func minSwaps(s string) int {
	ans, l := 0, 0
	for _, c := range s {
		if c == '1' {
			l++
		} else {
			l--
		}
		ans = min(ans, l)
	}
	return (-ans + 1) / 2
}
```

括号字符串的前 $i$ 个字符的左括号数减右括号数设为 $c_i$，括号合法的充要条件是 $\forall i,c_i\ge0$。

> - 必要性：只要合法，一定满足该条件。显然。
> - 充分性：只要满足该条件，一定合法。也容易理解。

0x3f方案：对第一个不匹配的右括号，找到最右边的左括号进行交换。

贪心的说，这个交换一定让第一个不匹配位置 $i$ 的 $c_i$ 增加 $2$，并且让 $c$ 得到右括号减少 $1$ 的时间尽可能的后，所以交换方案，如找更前边的左括号交换，答案一定不会更优。所以，在策略角度，是最优策略。

证明：这样的操作一定能多匹配两个失配的。所有匹配掉的都可以删去，本质上等价于求简化的 `]]]....[[[....`，没有区别。也就是说，求这个的交换和求原串交换等价。因为从这个简化(按消除顺序)加回去一样的。在交换前，如果有两个失配右括号，必然有两个失配左括号。交换后显然可以多匹配两个。只需要忽略掉所有本来就匹配了的括号，容易得知。

> 计算上模拟：
>
> ```go
> func minSwaps(S string) (ans int) {
> 	s := []byte(S)
> 	c := 0
> 	j := len(s) - 1
> 	for _, b := range s {
> 		if b == '[' {
> 			c++
> 		} else if c > 0 {
> 			c--
> 		} else { // c == 0
> 			// 找最右边的左括号交换
> 			for s[j] == ']' {
> 				j--
> 			}
> 			s[j] = ']' // s[i] = '[' 可以省略
> 			ans++
> 			c++ // s[i] 变成左括号，c 加一
> 		}
> 	}
> 	return
> }
> ```
>
> 等价于：
>
> ```go
> func minSwaps(s string) (ans int) {
> 	c := 0
> 	for _, b := range s {
> 		if b == '[' {
> 			c++
> 		} else if c > 0 {
> 			c--
> 		} else { // c == 0
> 			ans++
> 			c++ // s[i] 变成左括号，c 加一
> 		}
> 	}
> 	return
> }
> ```

> 如：`]]][[[` 本来得到 `[][[]]`，但计算上等价于 `[][[[[`，即下面代码：
>
> ```go
> func minSwaps(s string) (ans int) {
> 	c := 0
> 	for _, b := range s {
> 		if b == '[' {
> 			c++
> 		} else if c > 0 {
> 			c--
> 		} else { // c == 0
> 			ans++
> 			c++ // s[i] 变成左括号，c 加一
> 		}
> 	}
> 	return
> }
> ```
>
> 进一步优化为：多出的左括号的次数。
>
> ```go
> func minSwaps(s string) int {
> 	c := 0
> 	for _, b := range s {
> 		if b == '[' || c == 0 {
> 			c++
> 		} else {
> 			c--
> 		}
> 	}
> 	return c / 2
> }
> ```

##### 2610\.转换二维数组

[题目](https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions)

```go
import "sort"

func findMatrix(nums []int) (ans [][]int) {
	sort.Ints(nums)
	prv, cnt := 0, 0
	for _, x := range nums {
		if prv != x {
			cnt = 0
		}
		if len(ans) <= cnt {
			ans = append(ans, []int{})
		}
		ans[cnt] = append(ans[cnt], x)
		prv = x
		cnt++
	}
	return
}
```

一行行写：

```go
func findMatrix(nums []int) (ans [][]int) {
    // 统计每个元素的出现次数
    cnt := map[int]int{}
    for _, x := range nums {
        cnt[x]++
    }

    for len(cnt) > 0 {
        row := make([]int, 0, len(cnt)) // 预分配空间
        // cnt 中的每个元素的出现次数都减一
        for x := range cnt {
            row = append(row, x)
            cnt[x]--
            if cnt[x] == 0 {
                delete(cnt, x) // 删除当前正在遍历的元素是安全的
            }
        }
        ans = append(ans, row)
    }
    return
}
```

或者记录上一个数字出现在了第几行：

```go
func findMatrix(nums []int) (ans [][]int) {
    cnt := make([]int, len(nums)+1)
    for _, x := range nums {
        c := cnt[x]
        if c == len(ans) { // 需要加一行
            ans = append(ans, []int{})
        }
        ans[c] = append(ans[c], x)
        cnt[x]++
    }
    return
}
```

##### 3418\.机器人可以获得的最大金币数

[题目](https://leetcode.cn/problems/maximum-amount-of-money-robot-can-earn)

```go
package main

func maximumAmount(coins [][]int) (ans int) {
	n, m := len(coins), len(coins[0])
	dp := make([][][]int, n+1)
	for i := range dp {
		dp[i] = make([][]int, m+1)
		for j := range dp[i] {
			dp[i][j] = make([]int, 3)
		}
	}
	for k := 0; k < 3; k++ {
		for i := 0; i <= n; i++ {
			dp[i][0][k] = -1e9
		}
		for j := 0; j <= m; j++ {
			dp[0][j][k] = -1e9
		}
	}
	for k := 0; k < 3; k++ { 
        dp[1][0][k] = 0
    }
	for i := 1; i <= n; i++ {
		for j := 1; j <= m; j++ {
			for k := 0; k < 3; k++ {
				dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k]) + coins[i-1][j-1]
				if k > 0 && coins[i-1][j-1] < 0 {
					dp[i][j][k] = max(dp[i-1][j][k-1], dp[i][j-1][k-1], dp[i][j][k])
				}
			}
		}
	}
    ans = -1e9
    for k := 0; k < 3; k++ { 
        ans = max(ans, dp[n][m][k])
    }
	return
}
```

其他写法：

```go
func maximumAmount(coins [][]int) int {
	m, n := len(coins), len(coins[0])
	f := make([][][3]int, m+1)
	for i := range f {
		f[i] = make([][3]int, n+1)
	}
	for j := range f[0] {
		f[0][j] = [3]int{math.MinInt / 2, math.MinInt / 2, math.MinInt / 2}
	}
	f[0][1] = [3]int{}
	for i, row := range coins {
		f[i+1][0] = [3]int{math.MinInt / 2, math.MinInt / 2, math.MinInt / 2}
		for j, x := range row {
			f[i+1][j+1][0] = max(f[i+1][j][0], f[i][j+1][0]) + x
			f[i+1][j+1][1] = max(f[i+1][j][1]+x, f[i][j+1][1]+x, f[i+1][j][0], f[i][j+1][0])
			f[i+1][j+1][2] = max(f[i+1][j][2]+x, f[i][j+1][2]+x, f[i+1][j][1], f[i][j+1][1])
		}
	}
	return f[m][n][2]
}
```

```go
func maximumAmount(coins [][]int) int {
	m, n := len(coins), len(coins[0])
	memo := make([][][3]int, m)
	for i := range memo {
		memo[i] = make([][3]int, n)
		for j := range memo[i] {
			for k := range memo[i][j] {
				memo[i][j][k] = math.MinInt
			}
		}
	}
	var dfs func(int, int, int) int
	dfs = func(i, j, k int) int {
		if i < 0 || j < 0 {
			return math.MinInt
		}
		x := coins[i][j]
		if i == 0 && j == 0 {
			if k == 0 {
				return x
			}
			return max(x, 0)
		}
		p := &memo[i][j][k]
		if *p != math.MinInt { // 之前计算过
			return *p
		}
		res := max(dfs(i-1, j, k), dfs(i, j-1, k)) + x // 选
		if x < 0 && k > 0 {
			res = max(res, dfs(i-1, j, k-1), dfs(i, j-1, k-1)) // 不选
		}
		*p = res // 记忆化
		return res
	}
	return dfs(m-1, n-1, 2)
}
```

压缩：直接去掉第一个维度，对 k 改成逆序

```go
func maximumAmount(coins [][]int) int {
	n := len(coins[0])
	f := make([][3]int, n+1)
	for j := range f {
		f[j] = [3]int{math.MinInt / 2, math.MinInt / 2, math.MinInt / 2}
	}
	f[1] = [3]int{}
	for _, row := range coins {
		for j, x := range row {
			f[j+1][2] = max(f[j][2]+x, f[j+1][2]+x, f[j][1], f[j+1][1])
			f[j+1][1] = max(f[j][1]+x, f[j+1][1]+x, f[j][0], f[j+1][0])
			f[j+1][0] = max(f[j][0], f[j+1][0]) + x
		}
	}
	return f[n][2]
}
```

##### 2612\.最少翻转操作数

[题目](https://leetcode.cn/problems/minimum-reverse-operations)

显然 BFS。容易判断出，$i$ 的下一步是 $i+k-1,i+k-3,\cdots,i-k+1$，即共 $k$ 项，公差为 $2$。进一步地，设按 $[L,R]$ 区间翻转，$L\to R,L+1\to R-1,\cdots$，可以发现翻转前后下标之和为 $L+R$，故 $i\to L+R-i$。

枚举和单调分析可知，0-indexed，$i<k-1$，则极小值 $L=0,R=k-1$，有 $i$ 翻转为 $k-i-1$。若 $i>n-k$，$L=n-k,R=n-1$ 极大值 $L+R-i=2n-k-i-1$。

故 $i$ 翻转后的下标范围是：(公差为 $2$)
$$
(\max(i-k+1,k-i-1),\min(i+k-1,2n-k-i-1))
$$
问题的关键是如何快速遍历这里没被访问过的下标。显然，公差为 $2$，同一步奇偶相同，故可以维护两个 set，代表未访问下标。每次在这个范围的下标入队，并清除这些下标。也可以用并查集做到这一点，每个根是最大值，能够做到类似双向链表删除的快速遍历 skip vis 策略。都是 $O(n\log n)$。如果用笛卡尔树代替并查集，可以做到线性复杂度。暴力位运算 bitset / 汇编优化也可以卡过，略 [src](https://leetcode.cn/problems/minimum-reverse-operations/solutions/2204034/on232de-ya-wei-bao-li-by-hqztrue-ownd/?envType=daily-question&envId=2025-03-20)。

set C++ 459ms, go 295ms

```c++
class Solution {
public:
    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {
        unordered_set<int> ban{banned.begin(), banned.end()};
        set<int> indices[2];
        for (int i = 0; i < n; i++) {
            if (i != p && !ban.contains(i)) {
                indices[i % 2].insert(i);
            }
        }
        indices[0].insert(n); // 哨兵，下面无需判断 it != st.end()
        indices[1].insert(n);

        vector<int> ans(n, -1);
        ans[p] = 0; // 起点
        queue<int> q;
        q.push(p);
        while (!q.empty()) {
            int i = q.front(); q.pop();
            // indices[mn % 2] 中的从 mn 到 mx 的所有下标都可以从 i 翻转到
            int mn = max(i - k + 1, k - i - 1);
            int mx = min(i + k - 1, n * 2 - k - i - 1);
            auto& st = indices[mn % 2];
            for (auto it = st.lower_bound(mn); *it <= mx; it = st.erase(it)) {
                ans[*it] = ans[i] + 1; // 移动一步
                q.push(*it);
            }
        }
        return ans;
    }
};
```

```go
func minReverseOperations(n int, p int, banned []int, k int) []int {
    ban := map[int]struct{}{p: {}}
    for _, b := range banned {
        ban[b] = struct{}{}
    }

    indices := [2]*redblacktree.Tree[int, struct{}]{
        redblacktree.New[int, struct{}](),
        redblacktree.New[int, struct{}](),
    }
    for i := range n {
        if _, ok := ban[i]; !ok {
            indices[i%2].Put(i, struct{}{})
        }
    }
    indices[0].Put(n, struct{}{}) // 哨兵，下面无需判断 node != nil
    indices[1].Put(n, struct{}{})

    ans := make([]int, n)
    for i := range ans {
        ans[i] = -1
    }
    ans[p] = 0 // 起点
    q := []int{p}
    for len(q) > 0 {
        i := q[0]
        q = q[1:]
        // indices[mn%2] 中的从 mn 到 mx 的所有下标都可以从 i 翻转到
        mn := max(i-k+1, k-i-1)
        mx := min(i+k-1, n*2-k-i-1)
        t := indices[mn%2]
        for node, _ := t.Ceiling(mn); node.Key <= mx; node, _ = t.Ceiling(mn) {
            j := node.Key
            ans[j] = ans[i] + 1 // 移动一步
            q = append(q, j)
            t.Remove(j)
        }
    }
    return ans
}
```

并查集 C++ 31ms，go 28ms

```c++
class UnionFind {
    vector<int> fa;

public:
    UnionFind(int n) : fa(n) {
        iota(fa.begin(), fa.end(), 0);
    }

    int find(int x) {
        if (fa[x] != x) {
            fa[x] = find(fa[x]);
        }
        return fa[x];
    }

    void merge(int from, int to) {
        fa[find(from)] = find(to);
    }
};

class Solution {
public:
    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {
        UnionFind indices(n + 2);
        indices.merge(p, p + 2); // 删除 p
        for (int i : banned) {
            indices.merge(i, i + 2); // 删除 i
        }

        vector<int> ans(n, -1);
        ans[p] = 0;
        queue<int> q;
        q.push(p);
        while (!q.empty()) {
            int i = q.front(); q.pop();
            int mn = max(i - k + 1, k - i - 1);
            int mx = min(i + k - 1, n * 2 - k - i - 1);
            for (int j = indices.find(mn); j <= mx; j = indices.find(j + 2)) { // 快速跳到 >= j+2 的下一个下标
                ans[j] = ans[i] + 1;
                q.push(j);
                indices.merge(j, mx + 2); // 删除 j
            }
        }
        return ans;
    }
};
```

```go
type unionFind struct {
    fa []int
}

func newUnionFind(n int) unionFind {
    fa := make([]int, n)
    for i := range fa {
        fa[i] = i
    }
    return unionFind{fa}
}

func (uf unionFind) find(x int) int {
    if uf.fa[x] != x {
        uf.fa[x] = uf.find(uf.fa[x])
    }
    return uf.fa[x]
}

func (uf unionFind) merge(from, to int) {
    uf.fa[uf.find(from)] = uf.find(to)
}

func minReverseOperations(n, p int, banned []int, k int) []int {
    indices := newUnionFind(n + 2)
    indices.merge(p, p+2) // 删除 p
    for _, i := range banned {
        indices.merge(i, i+2) // 删除 i
    }

    ans := make([]int, n)
    for i := range ans {
        ans[i] = -1
    }
    ans[p] = 0
    q := []int{p}
    for len(q) > 0 {
        i := q[0]
        q = q[1:]
        mn := max(i-k+1, k-i-1)
        mx := min(i+k-1, n*2-k-i-1)
        for j := indices.find(mn); j <= mx; j = indices.find(j + 2) { // 快速跳到 >= j+2 的下一个下标
            ans[j] = ans[i] + 1
            q = append(q, j)
            indices.merge(j, mx+2) // 删除 j
        }
    }
    return ans
}
```

[笛卡尔树](https://ljt12138.blog.uoj.ac/blog/4874)

##### 1937\.扣分后的最大得分

[题目](https://leetcode.cn/problems/maximum-number-of-points-with-cost)

分类讨论，转移方程 $f_{i,j}=a_{i,j}+\max f_{i-1,k}-|k-j|$ 化简为：
$$
f_{i,j}=\begin{cases}
a_{i,j}-j+\max f_{i-1,k}+k,k\le j\\
a_{i,j}+j+\max f_{i-1,k}-k,k> j\\
\end{cases}
$$
记 $f0=f_{i-1,k+k},f1=f_{i-1,k}-k$，分别维护 $f0$ 前缀 max，$f1$ 后缀 max。

```go
func maxPoints(points [][]int) int64 {
	ans := 0
	n := len(points[0])
	f := make([][2]int, n)
	sufMax := make([]int, n) // 后缀最大值
	for i, row := range points {
		if i == 0 {
			for j, v := range row {
				ans = max(ans, v)
				f[j][0] = v + j
				f[j][1] = v - j
			}
		} else {
			preMax := math.MinInt32
			for j, v := range row {
				preMax = max(preMax, f[j][0])
				res := max(v-j+preMax, v+j+sufMax[j]) // 左侧和右侧的最大值即为选择 points[i][j] 时的计算结果
				ans = max(ans, res) // 直接更新答案，这样下面就不直接存储 res 了，改为存储 res + j 和 res - j
				f[j][0] = res + j
				f[j][1] = res - j
			}
		}
		// 计算完一整行 f 后，对于每个位置 j，计算其右侧的所有 f[k] - k 的最大值
		// 这可以通过倒着遍历 f 求出
		sufMax[n-1] = f[n-1][1]
		for j := n - 2; j >= 0; j-- {
			sufMax[j] = max(sufMax[j+1], f[j][1])
		}
	}
	return int64(ans)
}

func max(a, b int) int { if a > b { return a }; return b }
```

##### 2787\.将一个数字表示成幂的和的方案数

[题目](https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers)

背包 DP；可以预处理出全部结果。

```go
package main

const mod int = 1e9 + 7

func numberOfWays(n int, x int) int {
	a := []int{}
	for i := 1; ; i++ {
		ip := 1
		for j := 1; j <= x; j++ {
			ip *= i
		}
		a = append(a, ip)
		if ip > n {
			break
		}
	}
	dp := make([]int, n+1)
	dp[0] = 1
	for x := range a {
		for i := n; i >= a[x]; i-- {
			dp[i] = (dp[i] + dp[i-a[x]]) % mod
		}
	}
	return dp[n]
}
```

```go
func numberOfWays(n, x int) int {
	f := make([]int, n+1)
	f[0] = 1
	for i := 1; pow(i, x) <= n; i++ {
		v := pow(i, x)
		for s := n; s >= v; s-- {
			f[s] += f[s-v]
		}
	}
	return f[n] % 1_000_000_007
}

// 本题数据范围小，math.Pow 的计算结果一定准确
func pow(i, x int) int {
	return int(math.Pow(float64(i), float64(x)))
}
```

预处理

```go
package main

const mod int = 1e9 + 7

var dp = [5][301]int{}

func init() {
	for x := 0; x < 5; x++ {
		a := []int{}
		for i := 1; ; i++ {
			ip := 1
			for j := 0; j <= x; j++ {
				ip *= i
			}
			a = append(a, ip)
			if ip > 300 {
				break
			}
		}
		dp[x][0] = 1
		for v := range a {
			for i := 300; i >= a[v]; i-- {
				dp[x][i] = (dp[x][i] + dp[x][i-a[v]]) % mod
			}
		}
	}
}

func numberOfWays(n int, x int) int {
	return dp[x-1][n]
}
```

##### 1143\.最长公共子序列

[题目](https://leetcode.cn/problems/longest-common-subsequence)

```go
func longestCommonSubsequence(s, t string) int {
    n, m := len(s), len(t)
    f := [2][]int{make([]int, m+1), make([]int, m+1)}
    for i, x := range s {
        for j, y := range t {
            if x == y {
                f[(i+1)%2][j+1] = f[i%2][j] + 1
            } else {
                f[(i+1)%2][j+1] = max(f[i%2][j+1], f[(i+1)%2][j])
            }
        }
    }
    return f[n%2][m]
}
```

优化到一个数组：

```go
func longestCommonSubsequence(s, t string) int {
    m := len(t)
    f := make([]int, m+1)
    for _, x := range s {
        pre := 0 // f[0]
        for j, y := range t {
            if x == y {
                f[j+1], pre = pre+1, f[j+1]
            } else {
                pre = f[j+1]
                f[j+1] = max(f[j+1], f[j])
            }
        }
    }
    return f[m]
}
```

##### 718\.最长重复子数组

[题目](https://leetcode.cn/problems/maximum-length-of-repeated-subarray)

```go
package main

func findLength(nums1 []int, nums2 []int) (ans int) {
	n, m := len(nums1), len(nums2)
	dp := make([][]int, 2)
	dp[0] = make([]int, m+1)
	dp[1] = make([]int, m+1)
	for i := 1; i <= n; i++ {
		for j := 1; j <= m; j++ {
			if nums1[i-1] == nums2[j-1] {
				dp[i&1][j] = dp[(i-1)&1][j-1] + 1
			} else {
				dp[i&1][j] = 0
			}
			ans = max(ans, dp[i&1][j])
		}
	}
	return
}
```

滑动窗口：本质上就是优化的枚举。让 A 在 B 滑或 B 在 A 滑，在这个过程暴力枚举最长匹配的。

```go
func findLength(A []int, B []int) int {
    n, m := len(A), len(B)
    ret := 0
    for i := 0; i < n; i++ {
        len := min(m, n - i)
        maxLen := maxLength(A, B, i, 0, len)
        ret = max(ret, maxLen)
    }
    for i := 0; i < m; i++ {
        len := min(n, m - i)
        maxLen := maxLength(A, B, 0, i, len)
        ret = max(ret, maxLen)        
    }
    return ret
}

func maxLength(A, B []int, addA, addB, len int) int {
    ret, k := 0, 0
    for i := 0; i < len; i++ {
        if A[addA + i] == B[addB + i] {
            k++
        } else {
            k = 0
        }
        ret = max(ret, k)
    }
    return ret
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}

func min(x, y int) int {
    if x < y {
        return x
    }
    return y
}
```

字符串哈希+二分：参考蓝桥2024pythonA省赛E题吊坠，在我的其他笔记 `.md`，即算法练习部分，有。略，很显然。

##### 2680\.最大或值

[题目](https://leetcode.cn/problems/maximum-or)

贪心，对一个数一直操作比对多个数分别操作好，容易反证。维护前后缀 or。

```go
func findLength(nums1 []int, nums2 []int) (ans int) {
	n, m := len(nums1), len(nums2)
	dp := make([][]int, 2)
	dp[0] = make([]int, m+1)
	dp[1] = make([]int, m+1)
	for i := 1; i <= n; i++ {
		for j := 1; j <= m; j++ {
			if nums1[i-1] == nums2[j-1] {
				dp[i&1][j] = dp[(i-1)&1][j-1] + 1
			} else {
				dp[i&1][j] = 0
			}
			ans = max(ans, dp[i&1][j])
		}
	}
	return
}
```

优化：设整体异或和为 `allOr`，记录出现过 $\ge2$ 个 $1$ 的所有位为 `fixed`，即当前 `allOr & x` 为 $1$ 的所有位的或。那么去掉 `x` 的异或和为 `(allOr^x)|fixed`。故

```go
func maximumOr(nums []int, k int) int64 {
    allOr, fixed := 0, 0
    for _, x := range nums {
        // 如果在计算 allOr |= x 之前，allOr 和 x 有公共的 1
        // 那就意味着有多个 nums[i] 在这些比特位上都是 1
        fixed |= allOr & x // 把公共的 1 记录到 fixed 中
        allOr |= x // 所有数的 OR
    }
    ans := 0
    for _, x := range nums {
        ans = max(ans, (allOr^x)|fixed|x<<k)
    }
    return int64(ans)
}
```

##### 2643\.一最多的行

[题目](https://leetcode.cn/problems/row-with-maximum-ones)

```go
func rowAndMaximumOnes(mat [][]int) []int {
    mxCnt, idx := 0, 0
	for i, row := range mat {
		cnt := 0
		for _, v := range row {
			cnt += v
		}
		if cnt > mxCnt {
			mxCnt = cnt
			idx = i
		}
	}
	return []int{idx, mxCnt}
}
```

##### 2116\.判断一个括号字符串是否有效

[题目](https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid)

贪心，首先枚举最多可以得到多少个 `(`，这个过程如果失配就 fail。然后继续枚举，看看最多得到多少个 `)`，这个过程如果失配就 fail。[src](https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/solutions/3624031/python3javacgotypescript-yi-ti-yi-jie-ta-9t9b/?envType=daily-question&envId=2025-03-23)

```go
func canBeValid(s string, locked string) bool {
	n := len(s)
	if n%2 == 1 {
		return false
	}
	x := 0
	for i := range s {
		if s[i] == '(' || locked[i] == '0' {
			x++
		} else if x > 0 {
			x--
		} else {
			return false
		}
	}
	x = 0
	for i := n - 1; i >= 0; i-- {
		if s[i] == ')' || locked[i] == '0' {
			x++
		} else if x > 0 {
			x--
		} else {
			return false
		}
	}
	return true
}
```

一次遍历，对不 lock 的位置，视为 `?`，并分别选择 ±，维护所有可能到达的左-右的数目，使用 set 位运算维护，或直接维护最大最小值(因为一定是连续的集合)，看看最后是否有一个可能的状态是 0 即可。

```go
func canBeValid(s, locked string) bool {
    if len(s)%2 > 0 {
        return false
    }
    mn, mx := 0, 0
    for i, lock := range locked {
        if lock == '1' { // 不能改
            d := 1 - int(s[i]%2*2) // 左括号是 1，右括号是 -1
            mx += d
            if mx < 0 { // c 不能为负
                return false
            }
            mn += d
        } else { // 可以改
            mx++ // 改成左括号，c 加一
            mn-- // 改成右括号，c 减一
        }
        if mn < 0 { // c 不能为负
            mn = 1 // 此时 c 的取值范围都是奇数，最小的奇数是 1
        }
    }
    return mn == 0 // 说明最终 c 能是 0
}
```

##### 2255\.统计是给定字符串前缀的字符串数目

[题目](https://leetcode.cn/problems/count-prefixes-of-a-given-string)

```go
import "strings"
func countPrefixes(words []string, s string) (ans int) {
	for _, v := range words {
		if strings.HasPrefix(s, v) {
			ans++
		}
	}
	return
}
```

##### 2829\.k-avoiding数组的最小总和

[题目](https://leetcode.cn/problems/determine-the-minimum-sum-of-a-k-avoiding-array)

贪心取 $[1,\lfloor\dfrac k2\rfloor]\cup[k,\infty)$ 的前 $n$ 个元素，可以等差数列优化。

```go
package main

func minimumSum(n int, k int) (s int) {
	cnt := 0
	for i := 1; i <= k/2; i++ {
		s += i
		cnt++
		if cnt == n {
			return
		}
	}
	for i := k; cnt < n; i++ {
		s += i
		cnt++
	}
	return
}
```

设 $m=\min(\lfloor\dfrac k2\rfloor,n)$，取 $\dfrac{m(m+1)}2$ 和 $n-m$ 个首项为 $k$ 的 $\dfrac{(n-m)(2k+n-m-1)}2$。

```go
func minimumSum(n, k int) int {
    m := min(k/2, n)
    return (m*(m+1) + (k*2+n-m-1)*(n-m)) / 2
}
```

##### 2712\.使所有字符相等的最小成本

[题目](https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal)

容易发现，如果对 <= i 的全部用前缀翻转，>i 的全部用后缀翻转，要反转的下标是固定的，故答案一定不会比在这两部分都有前缀有后缀更差。维护前缀后缀，分别表示把这段前缀/后缀全部变成0/1所需的代价和，其代价和就是所有当前下标不等于下一个下标字符的下标和。

```go
func minimumCost(s string) (ans int64) {
	n := len(s)
	getPrefix := func(s string) ([]int64, []int64) {
		sumPos := int64(0)
		to0 := make([]int64, n)
		to1 := make([]int64, n)
		for i := int64(0); i < int64(n); i++ {
			if s[i] == '0' {
				to0[i] = sumPos
				to1[i] = sumPos + i + 1
			} else {
				to1[i] = sumPos
				to0[i] = sumPos + i + 1
			}
			if i+1 < int64(n) && s[i] != s[i+1] {
				sumPos += i + 1
			}
		}
		return to0, to1
	}
	to0p, to1p := getPrefix(s)
	rs := []rune(s)
	for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
		rs[i], rs[j] = rs[j], rs[i]
	}
	ans = min(to0p[n-1], to1p[n-1])
	to0s, to1s := getPrefix(string(rs))
	for i, j := 0, n-1; i < n-1; i, j = i+1, j-1 {
		to0v := to0p[i] + to0s[j-1]
		to1v := to1p[i] + to1s[j-1]
		ans = min(ans, to0v, to1v)
	}
	return
}
```

贪心：每对相邻字符串相互独立，目标是每个相邻相等，每次操作只会改变一个相邻相等，其他等价不变。故每对选最小的即可。

```go
func minimumCost(s string) (ans int64) {
    n := len(s)
    for i := 1; i < n; i++ {
        if s[i-1] != s[i] {
            ans += int64(min(i, n-i))
        }
    }
    return
}
```

##### 2716\.最小化字符串长度

[题目](https://leetcode.cn/problems/minimize-string-length)

```go
func minimizedStringLength(s string) int {
    m := make(map[rune]bool)
    for _, c := range s {
        m[c] = true
    }
    return len(m)
}
```

```go
func minimizedStringLength(s string) int {
    set := map[rune]struct{}{}
    for _, c := range s {
        set[c] = struct{}{}
    }
    return len(set)
}
```

```go
func minimizedStringLength(s string) int {
    mask := uint(0)
    for _, c := range s {
        mask |= 1 << (c - 'a') // 把 c-'a' 加到集合中
    }
    return bits.OnesCount(mask) // 集合的大小
}
```

##### 2109\.向字符串添加空格

[题目](https://leetcode.cn/problems/adding-spaces-to-a-string)

朴素 sb，8ms

```go
package main
import "strings"
func addSpaces(s string, spaces []int) string {
	j, m := 0, len(spaces)
	sb := strings.Builder{}
	for i, v := range s {
		if j < m && spaces[j] <= i {
			sb.WriteByte(' ')
			j++
		}
		sb.WriteRune(v)
	}
	return sb.String()
}
```

换成静态数组，更慢 11ms

```go
func addSpaces(s string, spaces []int) string {
	ans := make([]byte, 0, len(s)+len(spaces))
	j := 0
	for i, c := range s {
		if j < len(spaces) && spaces[j] == i {
			ans = append(ans, ' ')
			j++
		}
		ans = append(ans, byte(c))
	}
	return string(ans)
}
```

分组添加，很快，0ms，分隔符思路

```go
func addSpaces(s string, spaces []int) string {
	spaces = append(spaces, len(s)) // 这样可以在循环中处理最后一段
	ans := make([]byte, 0, len(s)+len(spaces))
	ans = append(ans, s[:spaces[0]]...)
	for i := 1; i < len(spaces); i++ {
		ans = append(ans, ' ')
		ans = append(ans, s[spaces[i-1]:spaces[i]]...)
	}
	return string(ans)
}
```

##### 2360\.图中的最长环

[题目](https://leetcode.cn/problems/longest-cycle-in-a-graph)

我的：

```go
package main

func longestCycle(edges []int) (ans int) {
	n := len(edges)
	g := make([][]int, n)
	for u, v := range edges {
		if v != -1 {
			g[u] = append(g[u], v)
		}
	}
	dfn := make([]int, n)
	t := 1
	vis := make([]int, n)
	var dfs func(u int) // tarjan
	dfs = func(u int) {
		if vis[u] > 0 {
			if vis[u] == 1 {
				ans = max(ans, t-dfn[u])
			}
			return
		}
		vis[u] = 1
		dfn[u] = t
		t++
		for _, v := range g[u] {
			dfs(v)
		}
		vis[u] = 2
	}
    ans = -1
	for i := 0; i < n; i++ {
		dfs(i)
	}
	return
}
```

有向图，树，添加一条有向边，至少会形成一个环，称为内向基环树。定义：(ds)

1. 每个点有且仅有一个出边
2. 由多棵基环树组成，即：一个环和若干指向该环的树

```go
func longestCycle(edges []int) int {
    ans := -1
    curTime := 1 // 当前时间
    visTime := make([]int, len(edges)) // 首次访问 x 的时间
    for x := range edges {
        startTime := curTime // 本轮循环的开始时间
        for x != -1 && visTime[x] == 0 { // 没有访问过 x
            visTime[x] = curTime // 记录访问 x 的时间
            curTime++
            x = edges[x] // 访问下一个节点
        }
        if x != -1 && visTime[x] >= startTime { // x 在本轮循环中访问了两次，说明 x 在环上
            ans = max(ans, curTime-visTime[x]) // 前后两次访问 x 的时间差，即为环长
        }
    }
    return ans // 如果没有找到环，返回的是 ans 的初始值 -1
}
```

##### 2829\.k-avoiding数组的最小总和

[题目](https://leetcode.cn/problems/determine-the-minimum-sum-of-a-k-avoiding-array)

贪心取 $[1,\lfloor\dfrac k2\rfloor]\cup[k,\infty)$ 的前 $n$ 个元素，可以等差数列优化。

```go
package main

func minimumSum(n int, k int) (s int) {
	cnt := 0
	for i := 1; i <= k/2; i++ {
		s += i
		cnt++
		if cnt == n {
			return
		}
	}
	for i := k; cnt < n; i++ {
		s += i
		cnt++
	}
	return
}
```

设 $m=\min(\lfloor\dfrac k2\rfloor,n)$，取 $\dfrac{m(m+1)}2$ 和 $n-m$ 个首项为 $k$ 的 $\dfrac{(n-m)(2k+n-m-1)}2$。

```go
func minimumSum(n, k int) int {
    m := min(k/2, n)
    return (m*(m+1) + (k*2+n-m-1)*(n-m)) / 2
}
```

##### 2712\.使所有字符相等的最小成本

[题目](https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal)

容易发现，如果对 <= i 的全部用前缀翻转，>i 的全部用后缀翻转，要反转的下标是固定的，故答案一定不会比在这两部分都有前缀有后缀更差。维护前缀后缀，分别表示把这段前缀/后缀全部变成0/1所需的代价和，其代价和就是所有当前下标不等于下一个下标字符的下标和。

```go
func minimumCost(s string) (ans int64) {
	n := len(s)
	getPrefix := func(s string) ([]int64, []int64) {
		sumPos := int64(0)
		to0 := make([]int64, n)
		to1 := make([]int64, n)
		for i := int64(0); i < int64(n); i++ {
			if s[i] == '0' {
				to0[i] = sumPos
				to1[i] = sumPos + i + 1
			} else {
				to1[i] = sumPos
				to0[i] = sumPos + i + 1
			}
			if i+1 < int64(n) && s[i] != s[i+1] {
				sumPos += i + 1
			}
		}
		return to0, to1
	}
	to0p, to1p := getPrefix(s)
	rs := []rune(s)
	for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
		rs[i], rs[j] = rs[j], rs[i]
	}
	ans = min(to0p[n-1], to1p[n-1])
	to0s, to1s := getPrefix(string(rs))
	for i, j := 0, n-1; i < n-1; i, j = i+1, j-1 {
		to0v := to0p[i] + to0s[j-1]
		to1v := to1p[i] + to1s[j-1]
		ans = min(ans, to0v, to1v)
	}
	return
}
```

贪心：每对相邻字符串相互独立，目标是每个相邻相等，每次操作只会改变一个相邻相等，其他等价不变。故每对选最小的即可。

```go
func minimumCost(s string) (ans int64) {
    n := len(s)
    for i := 1; i < n; i++ {
        if s[i-1] != s[i] {
            ans += int64(min(i, n-i))
        }
    }
    return
}
```

##### 2716\.最小化字符串长度

[题目](https://leetcode.cn/problems/minimize-string-length)

```go
func minimizedStringLength(s string) int {
    m := make(map[rune]bool)
    for _, c := range s {
        m[c] = true
    }
    return len(m)
}
```

```go
func minimizedStringLength(s string) int {
    set := map[rune]struct{}{}
    for _, c := range s {
        set[c] = struct{}{}
    }
    return len(set)
}
```

```go
func minimizedStringLength(s string) int {
    mask := uint(0)
    for _, c := range s {
        mask |= 1 << (c - 'a') // 把 c-'a' 加到集合中
    }
    return bits.OnesCount(mask) // 集合的大小
}
```

##### 2109\.向字符串添加空格

[题目](https://leetcode.cn/problems/adding-spaces-to-a-string)

朴素 sb，8ms

```go
package main
import "strings"
func addSpaces(s string, spaces []int) string {
	j, m := 0, len(spaces)
	sb := strings.Builder{}
	for i, v := range s {
		if j < m && spaces[j] <= i {
			sb.WriteByte(' ')
			j++
		}
		sb.WriteRune(v)
	}
	return sb.String()
}
```

换成静态数组，更慢 11ms

```go
func addSpaces(s string, spaces []int) string {
	ans := make([]byte, 0, len(s)+len(spaces))
	j := 0
	for i, c := range s {
		if j < len(spaces) && spaces[j] == i {
			ans = append(ans, ' ')
			j++
		}
		ans = append(ans, byte(c))
	}
	return string(ans)
}
```

分组添加，很快，0ms，分隔符思路

```go
func addSpaces(s string, spaces []int) string {
	spaces = append(spaces, len(s)) // 这样可以在循环中处理最后一段
	ans := make([]byte, 0, len(s)+len(spaces))
	ans = append(ans, s[:spaces[0]]...)
	for i := 1; i < len(spaces); i++ {
		ans = append(ans, ' ')
		ans = append(ans, s[spaces[i-1]:spaces[i]]...)
	}
	return string(ans)
}
```

##### 2360\.图中的最长环

[题目](https://leetcode.cn/problems/longest-cycle-in-a-graph)

我的：

```go
package main

func longestCycle(edges []int) (ans int) {
	n := len(edges)
	g := make([][]int, n)
	for u, v := range edges {
		if v != -1 {
			g[u] = append(g[u], v)
		}
	}
	dfn := make([]int, n)
	t := 1
	vis := make([]int, n)
	var dfs func(u int) // tarjan
	dfs = func(u int) {
		if vis[u] > 0 {
			if vis[u] == 1 {
				ans = max(ans, t-dfn[u])
			}
			return
		}
		vis[u] = 1
		dfn[u] = t
		t++
		for _, v := range g[u] {
			dfs(v)
		}
		vis[u] = 2
	}
    ans = -1
	for i := 0; i < n; i++ {
		dfs(i)
	}
	return
}
```

有向图，树，添加一条有向边，至少会形成一个环，称为内向基环树。定义：(ds)

1. 每个点有且仅有一个出边
2. 由多棵基环树组成，即：一个环和若干指向该环的树

```go
func longestCycle(edges []int) int {
    ans := -1
    curTime := 1 // 当前时间
    visTime := make([]int, len(edges)) // 首次访问 x 的时间
    for x := range edges {
        startTime := curTime // 本轮循环的开始时间
        for x != -1 && visTime[x] == 0 { // 没有访问过 x
            visTime[x] = curTime // 记录访问 x 的时间
            curTime++
            x = edges[x] // 访问下一个节点
        }
        if x != -1 && visTime[x] >= startTime { // x 在本轮循环中访问了两次，说明 x 在环上
            ans = max(ans, curTime-visTime[x]) // 前后两次访问 x 的时间差，即为环长
        }
    }
    return ans // 如果没有找到环，返回的是 ans 的初始值 -1
}
```

##### 2711\.对角线上不同值的数量差

[题目](https://leetcode.cn/problems/difference-of-number-of-distinct-values-on-diagonals)

我的模拟：先定义每条对角线如何运算，然后对第一行和第一列为对角线起点，直接复用运算。

```go
package main

func differenceOfDistinctValues(grid [][]int) [][]int {
	n, m := len(grid), len(grid[0])
	ans := make([][]int, n)
	for i := range ans {
		ans[i] = make([]int, m)
	}
	abs := func(x int) int {
		if x < 0 {
			return -x
		}
		return x
	}
	f := func(x, y int) {
		tlv := make(map[int]bool)
		tkn := []int{}
		i, j := x, y
		for ; i < n && j < m; i, j = i+1, j+1 {
			tkn = append(tkn, len(tlv))
			tlv[grid[i][j]] = true
		}
		brv := make(map[int]bool)
		brn := 0
		i, j = i-1, j-1
		for ; i >= x && j >= y; i, j = i-1, j-1 {
			ans[i][j] = abs(tkn[len(tkn)-1] - brn)
			tkn = tkn[:len(tkn)-1]
			brv[grid[i][j]] = true
			brn = len(brv)
		}
	}
	for i := 1; i < n; i++ {
		f(i, 0)
	}
	for i := 0; i < m; i++ {
		f(0, i)
	}
	return ans
}
```

另一种遍历主对角线：设有 $n$ 列，设对角线编号为 $k=i-j+n$，则从右上角到左下角为 $1\to m+n-1$。且 $i=k+j-n$ 或者说 $j=n+i-k$。故每个 $k$，对应的 $j\in[\max(0, n-k), \min(n-1,n+m-1-k)]$。可以原地存储，先存左上，再更新为左上-右下，并共用 set，来优化内存。

```go
func differenceOfDistinctValues(grid [][]int) [][]int {
    m, n := len(grid), len(grid[0])
    ans := make([][]int, m)
    for i := range ans {
        ans[i] = make([]int, n)
    }
    set := map[int]struct{}{}

    // 第一排在右上，最后一排在左下
    // 每排从左上到右下
    // 令 k=i-j+n，那么右上角 k=1，左下角 k=m+n-1
    for k := 1; k < m+n; k++ {
        // 核心：计算 j 的最小值和最大值
        minJ := max(n-k, 0)       // i=0 的时候，j=n-k，但不能是负数
        maxJ := min(m+n-1-k, n-1) // i=m-1 的时候，j=m+n-1-k，但不能超过 n-1

        clear(set)
        for j := minJ; j <= maxJ; j++ {
            i := k + j - n
            ans[i][j] = len(set) // topLeft[i][j] == len(set)
            set[grid[i][j]] = struct{}{}
        }

        clear(set)
        for j := maxJ; j >= minJ; j-- {
            i := k + j - n
            ans[i][j] = abs(ans[i][j] - len(set)) // bottomRight[i][j] == len(set)
            set[grid[i][j]] = struct{}{}
        }
    }
    return ans
}

func abs(x int) int { if x < 0 { return -x }; return x }
```

位运算，显然：

```go
func differenceOfDistinctValues(grid [][]int) [][]int {
    m, n := len(grid), len(grid[0])
    ans := make([][]int, m)
    for i := range ans {
        ans[i] = make([]int, n)
    }

    for k := 1; k < m+n; k++ {
        minJ := max(n-k, 0)
        maxJ := min(m+n-1-k, n-1)

        set := uint(0)
        for j := minJ; j <= maxJ; j++ {
            i := k + j - n
            ans[i][j] = bits.OnesCount(set) // set 的大小
            set |= 1 << grid[i][j] // 把 grid[i][j] 加到 set 中
        }

        set = 0
        for j := maxJ; j >= minJ; j-- {
            i := k + j - n
            ans[i][j] = abs(ans[i][j] - bits.OnesCount(set))
            set |= 1 << grid[i][j]
        }
    }
    return ans
}

func abs(x int) int { if x < 0 { return -x }; return x }
```

##### 2278\.字母在字符串中的百分比

[题目](https://leetcode.cn/problems/percentage-of-letter-in-string)

```go
func percentageLetter(s string, letter byte) int {
    n := 0
    for _, c := range s {
        if byte(c) == letter {
            n++
        }
    }
    return n*100/len(s)
}
```

```go
func percentageLetter(s string, letter byte) int {
    return strings.Count(s, string(letter)) * 100 / len(s)
}
```

##### 2140\.解决智力问题

[题目](https://leetcode.cn/problems/solving-questions-with-brainpower)

```go
func mostPoints(questions [][]int) int64 {
    n := len(questions)
    dp := make([]int64, n)
    dp[n-1] = int64(questions[n-1][0])
    for i := n-2; i >=0; i-- {
        dp[i] = max(int64(questions[i][0]), dp[i+1])
        if i+questions[i][1]+1<n {
            dp[i] = max(dp[i], int64(questions[i][0])+dp[i+questions[i][1]+1])
        }
    }
    return dp[0]
}
```

其他实现：

```go
func mostPoints(questions [][]int) int64 {
    n := len(questions)
    dp := make([]int64, n + 1) // 解决每道题及以后题目的最高分数
    for i := n - 1; i >= 0; i-- {
        dp[i] = max(dp[i + 1], int64(questions[i][0]) + dp[min(n, i + questions[i][1] + 1)])
    }
    return dp[0]
}
```

```go
func mostPoints(questions [][]int) int64 {
    n := len(questions)
    f := make([]int64, n+1)
    for i, q := range slices.Backward(questions) {
        j := min(i+q[1]+1, n)
        f[i] = max(f[i+1], f[j]+int64(q[0]))
    }
    return f[0]
}
```

顺推，从查表变成刷表：

```go
func mostPoints(questions [][]int) int64 {
    n := len(questions)
    f := make([]int64, n+1)
    for i, q := range questions {
        f[i+1] = max(f[i+1], f[i])
        j := min(i+q[1]+1, n)
        f[j] = max(f[j], f[i]+int64(q[0]))
    }
    return f[n]
}
```

##### 2874\.有序三元组中的最大值II

[题目](https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii)

先枚举 j 维护最大差值，再枚举 k 维护答案

```go
package main

func maximumTripletValue(nums []int) (ans int64) {
	n := len(nums)
	mxi := nums[0]
	maxdis := make([]int, n)
	for j := 1; j < n; j++ {
		maxdis[j] = max(maxdis[j-1], mxi-nums[j])
		mxi = max(mxi, nums[j])
	}
	for k := 2; k < n; k++ {
		ans = max(ans, int64(maxdis[k-1])*int64(nums[k]))
	}
	return
}
```

优化：

```python
func maximumTripletValue(nums []int) int64 {
    var ans, maxDiff, preMax int
    for _, x := range nums {
        ans = max(ans, maxDiff*x)
        maxDiff = max(maxDiff, preMax-x)
        preMax = max(preMax, x)
    }
    return int64(ans)
}
```

也可以枚举 j 为最后，维护前后的最大值，i, k 都取最大值即可，显然。

```go
func maximumTripletValue(nums []int) int64 {
    ans := 0
    n := len(nums)
    sufMax := make([]int, n+1)
    for i := n - 1; i > 1; i-- {
        sufMax[i] = max(sufMax[i+1], nums[i])
    }

    preMax := 0
    for j, x := range nums {
        ans = max(ans, (preMax-x)*sufMax[j+1])
        preMax = max(preMax, x)
    }
    return int64(ans)
}
```

##### 1863\.找出所有子集的异或总和再求和

[题目](https://leetcode.cn/problems/sum-of-all-subset-xor-totals)

二进制枚举

```go
func subsetXORSum(nums []int) (s int) {
    n := len(nums)
    for i:=0;i<1<<n;i++ {
        x := 0
        for j:=0;j<n;j++ {
            if (i>>j)&1==1 {
                x ^= nums[j]
            }
        }
        s +=x
    }
    return
}
```

设元素全是 0/1，那么只要子集有奇数个 1，异或和一定是 1。

设有 $m$ 个 1，$n-m$ 个 $0$，在 $m$ 个 1 里选出奇数个 1 的方案数一定是 $2^{m-1}$ 

多种证明方法，一种是二项式定理，$2^m=(1+1)^m=C_m^0+\cdots C_m^m$，且 $0^m=(1-1)^n=C_m^0-C_m^1+\cdots+(-1)^mC_m^m$，相减得 $2^m-0^m=2(C_m^1+C_m^3+\cdots)$，故 $C_m^1+C_m^3+\cdots=2^{m-1}$。

则剩下的 $0$ 选与不选都不影响有奇数个 $1$，总方案数为 $2^{m-1}2^{n-m}=2^{n-1}$。

即，只要有至少一个 $1$，异或和为 $1$ 的方案数一定是 $2^{n-1}$。

由于每个位相互独立互不影响，故每个位分别这样算，然后加起来即可。设第 $x_1,\cdots, x_t$ 位有 $1$，则答案为 $2^{x_1}2^{n-1}+\cdots+2^{x_t}2^{n-1}$，即 $orsum\cdot 2^{n-1}$，其中原数组全部或起来 $orsum=2^{x_1}+\cdots+2^{x_t}$。

```go
func subsetXORSum(nums []int) int {
    or := 0
    for _, x := range nums {
        or |= x
    }
    return or << (len(nums) - 1)
}
```

##### 368\.最大整除子集

[题目](https://leetcode.cn/problems/largest-divisible-subset)

相互整除的元素，等价于排序后，后一个元素总能被前一个元素整除。

等价于维护DAG(边权为1)的最长路，按拓扑序(升序即可)DP即可。

```go
package main

import "sort"

func largestDivisibleSubset(nums []int) (ans []int) {
	sort.Ints(nums)
	n := len(nums)
	prv := make([]int, n)
	for u := 0; u < n; u++ {
		prv[u] = -1
	}
	siz := make([]int, n)
	mxSiz, mxIdx := 0,0
	for u := 0; u < n; u++ {
		for v := u+1; v < n; v++ {
			if nums[v]%nums[u] != 0 {
				continue
			}
			if siz[v] < siz[u]+1 {
				siz[v] = siz[u] + 1
				prv[v] = u
				if siz[v] > mxSiz {
					mxSiz = siz[v]
					mxIdx = v
				}
			}
		}
	}
	for mxIdx != -1 {
		ans = append(ans, nums[mxIdx])
		mxIdx = prv[mxIdx]
	}
	return
}
```

> 优化前：
>
> ```go
> package main
> 
> import "sort"
> 
> func largestDivisibleSubset(nums []int) (ans []int) {
> 	sort.Ints(nums)
> 	n := len(nums)
> 	g := make([][]int, n)
> 	du := make([]int, n)
> 	for i := 0; i < n; i++ {
> 		for j := i+1; j < n; j++ {
> 			if nums[j]%nums[i] == 0 {
> 				g[i] = append(g[i], j)
> 				du[i]++
> 			}
> 		}
> 	}
> 	prv := make([]int, n)
> 	for u := 0; u < n; u++ {
> 		prv[u] = -1
> 	}
> 	siz := make([]int, n)
> 	mxSiz, mxIdx := 0, 0
> 	for u := 0; u < n; u++ {
> 		for _, v := range g[u] {
> 			if siz[v] < siz[u]+1 {
> 				siz[v] = siz[u] + 1
> 				prv[v] = u
> 				if siz[v] > mxSiz {
> 					mxSiz = siz[v]
> 					mxIdx = v
> 				}
> 			}
> 		}
> 	}
> 	for mxIdx != -1 {
> 		ans = append(ans, nums[mxIdx])
> 		mxIdx = prv[mxIdx]
> 	}
> 	return
> }
> ```

##### 416\.分割等和子集

[题目](https://leetcode.cn/problems/partition-equal-subset-sum)

```go
func canPartition(nums []int) bool {
    s := 0
    for _, v := range nums {
        s += v
    }
    if s % 2 != 0 {
        return false
    }
    t := s / 2
    dp := make([]bool, t+1)
    dp[0] = true
    for _, v := range nums {
        for i := t; i >= v; i-- {
            dp[i] = dp[i] || dp[i-v]
        }
    }
    return dp[t]
}
```

从 10多ms(上一份)优化到1s，只需要一个break

```go
func canPartition(nums []int) bool {
    s := 0
    for _, x := range nums {
        s += x
    }
    if s%2 != 0 {
        return false
    }
    s /= 2 // 注意这里把 s 减半了
    f := make([]bool, s+1)
    f[0] = true
    s2 := 0
    for _, x := range nums {
        s2 = min(s2+x, s)
        for j := s2; j >= x; j-- {
            f[j] = f[j] || f[j-x]
        }
        if f[s] {
            return true
        }
    }
    return false
}
```

位运算优化(bitset)：0ms

```go
func canPartition(nums []int) bool {
    s := 0
    for _, x := range nums {
        s += x
    }
    if s%2 != 0 {
        return false
    }
    s /= 2
    f := big.NewInt(1)
    p := new(big.Int)
    for _, x := range nums {
        f.Or(f, p.Lsh(f, uint(x)))
    }
    return f.Bit(s) == 1
}
```

##### 3396\.使数组元素互不相同所需的最少操作次数

[题目](https://leetcode.cn/problems/minimum-number-of-operations-to-make-elements-in-array-distinct/description/?envType=daily-question&envId=2025-04-08)

```go
func minimumOperations(nums []int) int {
	n := len(nums)
	s := make(map[int]bool)
	for i := n - 1; i >= 0; i-- {
		if !s[nums[i]] {
			s[nums[i]] = true
		} else {
			return (i + 3) / 3
		}
	}
	return 0
}
```

写法2：

```go
func minimumOperations(nums []int) int {
    seen := map[int]struct{}{}
    for i, x := range slices.Backward(nums) {
        if _, ok := seen[x]; ok {
            return i/3 + 1
        }
        seen[x] = struct{}{}
    }
    return 0
}
```

##### 3375\.使数组的值全部为K的最少操作次数

[题目](https://leetcode.cn/problems/minimum-operations-to-make-array-values-equal-to-k)

一定要不大于最小元素，这样最小元素才能变成 k。不断把最大元素变成次大元素，直到所有元素都变成 k。

两种写法：set / 排序邻元素遍历

```go
import "sort"
func minOperations(nums []int, k int) int {
	sort.Ints(nums)
	if nums[0] < k {
		return -1
	}
	n := len(nums)
	i := sort.Search(n, func(i int) bool { return nums[i] > k })
	s := make(map[int]bool)
	for ; i < n; i++ {
		s[nums[i]] = true
	}
	return len(s)
}
```

```go
import "sort"
func minOperations(nums []int, k int) int {
	sort.Ints(nums)
	if nums[0] < k {
		return -1
	}
	n := len(nums)
	i := sort.Search(n, func(i int) bool { return nums[i] > k })
	s := 0
	if i < n {
		s++
	}
	for j := i + 1; j < n; j++ {
		if nums[j] != nums[j-1] {
			s++
		}
	}
	return s
}
```

##### 2999\.统计强大整数的数目

[题目](https://leetcode.cn/problems/count-the-number-of-powerful-integers)

数位 DP，limitHigh 表示当前是否受到了上界的影响，初始是，之后每次都选最高位就是继续是限制。同理有 limitLow，也可以做两次(dp(High) - dp(Low-1))。

不限制就记忆化，限制就不记忆化。显然限制只有一次，即限制状态数是线性的。复杂度 $O(D\log a)$，其中 $a$ 是上限，$D=10$ 是数位 limit。

```go
func numberOfPowerfulInt(start, finish int64, limit int, s string) int64 {
	low := strconv.FormatInt(start, 10)
	high := strconv.FormatInt(finish, 10)
	n := len(high)
	low = strings.Repeat("0", n-len(low)) + low // 补前导零，和 high 对齐
	diff := n - len(s)

	memo := make([]int64, n)
	for i := range memo {
		memo[i] = -1
	}
	var dfs func(int, bool, bool) int64
	dfs = func(i int, limitLow, limitHigh bool) (res int64) {
		if i == n {
			return 1
		}
		
		if !limitLow && !limitHigh {
			p := &memo[i]
			if *p >= 0 {
				return *p
			}
			defer func() { *p = res }()
		}

		// 第 i 个数位可以从 lo 枚举到 hi
		// 如果对数位还有其它约束，应当只在下面的 for 循环做限制，不应修改 lo 或 hi
		lo := 0
		if limitLow {
			lo = int(low[i] - '0')
		}
		hi := 9
		if limitHigh {
			hi = int(high[i] - '0')
		}

		if i < diff { // 枚举这个数位填什么
			for d := lo; d <= min(hi, limit); d++ {
				res += dfs(i+1, limitLow && d == lo, limitHigh && d == hi)
			}
		} else { // 这个数位只能填 s[i-diff]
			x := int(s[i-diff] - '0')
			if lo <= x && x <= min(hi, limit) {
				res += dfs(i+1, limitLow && x == lo, limitHigh && x == hi)
			}
		}
		return
	}
	return dfs(0, true, true)
}
```

不能设置为 `hi=min(hi,limit)`，这是因为high可能是大于limit的，比如 `high=63666` (灵神[视频](https://www.bilibili.com/video/BV1Fg4y1Q7wv) 45分钟例子)，`limit=5`，那么第一位搜 5 进入 limit，第二位只能选 0-3；但事实上第一位选 5 不是被限制，第二位可以任选 0-5。

```c++
class Solution {
public:
    long long numberOfPowerfulInt(long long start, long long finish, int limit, string s) {
        string low = to_string(start);
        string high = to_string(finish);
        int n = high.size();
        low = string(n - low.size(), '0') + low; // 补前导零，和 high 对齐
        int diff = n - s.size();

        vector<long long> memo(n, -1);
        auto dfs = [&](this auto&& dfs, int i, bool limit_low, bool limit_high) -> long long {
            if (i == low.size()) {
                return 1;
            }

            if (!limit_low && !limit_high && memo[i] != -1) {
                return memo[i]; // 之前计算过
            }

            // 第 i 个数位可以从 lo 枚举到 hi
            // 如果对数位还有其它约束，应当只在下面的 for 循环做限制，不应修改 lo 或 hi
            int lo = limit_low ? low[i] - '0' : 0;
            int hi = limit_high ? high[i] - '0' : 9;

            long long res = 0;
            if (i < diff) { // 枚举这个数位填什么
                for (int d = lo; d <= min(hi, limit); d++) {
                    res += dfs(i + 1, limit_low && d == lo, limit_high && d == hi);
                }
            } else { // 这个数位只能填 s[i-diff]
                int x = s[i - diff] - '0';
                if (lo <= x && x <= min(hi, limit)) {
                    res = dfs(i + 1, limit_low && x == lo, limit_high && x == hi);
                }
            }

            if (!limit_low && !limit_high) {
                memo[i] = res; // 记忆化 (i,false,false)
            }
            return res;
        };
        return dfs(0, true, true);
    }
};
```

```python
class Solution:
    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:
        high = list(map(int, str(finish)))  # 避免在 dfs 中频繁调用 int()
        n = len(high)
        low = list(map(int, str(start).zfill(n)))  # 补前导零，和 high 对齐
        diff = n - len(s)

        @cache
        def dfs(i: int, limit_low: bool, limit_high: bool) -> int:
            if i == n:
                return 1

            # 第 i 个数位可以从 lo 枚举到 hi
            # 如果对数位还有其它约束，应当只在下面的 for 循环做限制，不应修改 lo 或 hi
            lo = low[i] if limit_low else 0
            hi = high[i] if limit_high else 9

            res = 0
            if i < diff:  # 枚举这个数位填什么
                for d in range(lo, min(hi, limit) + 1):
                    res += dfs(i + 1, limit_low and d == lo, limit_high and d == hi)
            else:  # 这个数位只能填 s[i-diff]
                x = int(s[i - diff])
                if lo <= x <= min(hi, limit):
                    res = dfs(i + 1, limit_low and x == lo, limit_high and x == hi)
            return res

        return dfs(0, True, True)
```

组合数学：i 0-indexed，preLen 是上界x长减去s长度。全体长度到 i 的数：

- 如果当前位比限制要大，当前位和剩下的 s 之外的位，设一共有 preLen-i 位，它们都可以在 limit+1 个数任选。答案位 $(limit+1)^{preLen-1}$。
- 否则，当前位限制，当前位取到 $x_i$，剩下的任取，故 $x_i(limit+1)^{preLen-i-1}$

最后特判一下 s 位数(x的这几位)，是否有唯一答案。

```go
func numberOfPowerfulInt(start int64, finish int64, limit int, s string) int64 {
    start_ := strconv.FormatInt(start - 1, 10)
	finish_ := strconv.FormatInt(finish, 10)
	return calculate(finish_, s, limit) - calculate(start_, s, limit)
}

func calculate(x string, s string, limit int) int64 {
	if len(x) < len(s) {
		return 0
	}
	if len(x) == len(s) {
		if x >= s {
			return 1
		}
		return 0
	}

	suffix := x[len(x) - len(s):]
	var count int64
	preLen := len(x) - len(s)

	for i := 0; i < preLen; i++ {
		digit := int(x[i] - '0')
		if limit < digit {
			count += int64(math.Pow(float64(limit + 1), float64(preLen - i)))
			return count
		}
		count += int64(digit) * int64(math.Pow(float64(limit + 1), float64(preLen - 1- i)))
	}
	if suffix >= s {
		count++
	}
	return count
}
```

##### 2843\.统计对称整数的数目

[题目](https://leetcode.cn/problems/count-symmetric-integers)

```go
package main

var s [10001]int

func init() {
	for i := 1; i <= 9; i++ {
		s[11*i]++
	}
	for x4 := 1; x4 <= 9; x4++ {
		for x3 := 0; x3 <= 9; x3++ {
			s2 := x3 + x4
			for x2 := max(0, s2-9); x2 <= min(9, s2); x2++ {
				x1 := s2 - x2
				s[x1+x2*10+x3*100+x4*1000]++
			}
		}
	}
	for i := 1; i <= 10000; i++ {
		s[i] += s[i-1]
	}
}
func countSymmetricIntegers(low int, high int) int {
	return s[high] - s[low-1]
}
```

数位：

```go
func countSymmetricIntegers(low, high int) int {
    lowS := strconv.Itoa(low)
    highS := strconv.Itoa(high)
    n := len(highS)
    m := n / 2
    diffLH := n - len(lowS)

    memo := make([][][]int, n)
    for i := range memo {
        memo[i] = make([][]int, diffLH+1) // start <= diffLH
        for j := range memo[i] {
            memo[i][j] = make([]int, m*18+1)
            for k := range memo[i][j] {
                memo[i][j][k] = -1
            }
        }
    }
    var dfs func(int, int, int, bool, bool) int
    dfs = func(i, start, diff int, limitLow, limitHigh bool) (res int) {
        if i == n {
            if diff != 0 {
                return 0
            }
            return 1
        }

        // start 当 isNum 用
        if start != -1 && !limitLow && !limitHigh {
            p := &memo[i][start][diff+m*9]
            if *p != -1 {
                return *p
            }
            defer func() { *p = res }()
        }

        lo := 0
        if limitLow && i >= diffLH {
            lo = int(lowS[i-diffLH] - '0')
        }
        hi := 9
        if limitHigh {
            hi = int(highS[i] - '0')
        }

        // 如果前面没有填数字，且剩余数位个数是奇数，那么当前数位不能填数字
        if start < 0 && (n-i)%2 > 0 {
            if lo > 0 {
                return 0 // 必须填数字但 lo > 0，不合法
            }
            return dfs(i+1, start, diff, true, false)
        }

        isLeft := start < 0 || i < (start+n)/2
        for d := lo; d <= hi; d++ {
            newStart := start
            if start < 0 && d > 0 {
                newStart = i // 记录第一个填数字的位置
            }
            newDiff := diff
            if isLeft {
                newDiff += d
            } else {
                newDiff -= d
            }
            res += dfs(i+1, newStart, newDiff, limitLow && d == lo, limitHigh && d == hi)
        }
        return
    }
    return dfs(0, -1, 0, true, true)
}
```

##### 3272\.统计好整数的数目

[题目](https://leetcode.cn/problems/find-the-count-of-good-integers)

> 错误的我的数位 DP：不能处理前导 0：
>
> ```go
> package main
> import "math/bits"
> func countGoodIntegers(n int, k int) (ans int64) {
> 	dp := make([][][]int64, n)
> 	for i := 0; i < n; i++ {
> 		dp[i] = make([][]int64, k)
> 		for j := 0; j < k; j++ {
> 			dp[i][j] = make([]int64, 1<<10)
> 		}
> 	}
> 	for j := 0; j <= 9; j++ {
> 		dp[0][j%k][1<<j] = 1
> 	}
> 	for i := 1; i < n; i++ { //第几位
> 		low := 0
> 		if i == n-1 {
> 			low = 1
> 		}
> 		for j := low; j <= 9; j++ { //第i位选啥
> 			for r := 0; r < k; r++ { //之前余多少
> 				r2 := (r*10 + j) % k         // 现在余多少
> 				for b := 0; b < 1<<10; b++ { //当前各数字奇偶性
> 					dp[i][r2][b] += dp[i-1][r][b^(1<<j)]
> 				}
> 			}
> 		}
> 	}
> 	for b := 0; b < 1<<10; b++ {
> 		if bits.OnesCount(uint(b)) == 1 {
> 			ans += dp[n-1][0][b]
> 		}
> 	}
> 	return ans
> }
> ```

枚举每个被k整除的回文数，计算每个回文数的排列组合。

注意去除，如 `12021` 和 `21012` 若 k=1 都是合法的，且排列组合一样，故 map 去重只算一次。

设当前回位数每个数位 $i$ 有 $cnt_i$ 个，共有 $n$ 位：

- 若不含 $0$，计算为
  $$
  C_n^{cnt_1}C_{n-cnt_1}^{cnt_2}C_{n-cnt_1-cnt_2}^{cnt_3}\cdots=\prod_{i=1}^9C_{n-\sum_{j=1}^{i-1}cnt_j}^{cnt_i}
  $$

- 若含 $0$，第一个位置不能填，第一项 $n-1$ 而不是 $n$。计算为：
  $$
  C_{n-1}^{cnt_0}C_{n-cnt_0}^{cnt_2}C_{n-cnt_0-cnt_1}^{cnt_1}C_{n-cnt_0-cnt_1-cnt_2}^{cnt_3}\cdots=C_{n-1}^{cnt_0}\prod_{i=1}^9C_{n-\sum_{j=0}^{i-1}cnt_j}^{cnt_i}
  $$
  

全部回文数的排列组合加起来即可。

```go
package main

import "fmt"

var pw [11]int64
var C [11][11]int64 // 杨辉三角

func init() {
	pw[0] = 1
	for i := 1; i <= 10; i++ {
		pw[i] = pw[i-1] * 10
	}
	C[0][0] = 1
	for i := 1; i <= 10; i++ {
		C[i][0] = 1
		for j := 1; j <= i; j++ {
			C[i][j] = C[i-1][j] + C[i-1][j-1]
		}
	}
}

func comb(x int64, k int, sbin map[int64]int64) (ans int64) {
	cnt := [10]int64{}
	var num int64
	for i := x; i > 0; i /= 10 {
		cnt[i%10]++
		num++
	}
	if x%int64(k) != 0 {
		return int64(0)
	}

	// 判重
	var v int64
	for i := 0; i < 10; i++ {
		v += pw[i] * int64(cnt[i])
	}
	if sbin[v] > 0 {
		// fmt.Println("!!", sbin[v], x)
		return int64(0)
	}
	sbin[v] = x

	// 计算组合数
	if cnt[0] > 0 {
		ans = C[num-1][cnt[0]]
		n := num - cnt[0]
		for i := 1; i < 10; i++ {
			ans *= C[n][cnt[i]]
			n -= cnt[i]
		}
	} else {
		ans = 1
		n := num
		for i := 0; i < 10; i++ {
			ans *= C[n][cnt[i]]
			n -= cnt[i]
        }
	}
	return ans
}

func countGoodIntegers(n, k int) (ans int64) {
	sbin := make(map[int64]int64) // 防止重复计数
	m := n / 2
	if n == 1 {
		return int64(9 / k)
	}
	for i := pw[m-1]; i < pw[m]; i++ {
		var iv int64
		for it := i; it > 0; it /= 10 {
			iv = iv*10 + it%10
		}
		if n%2 == 1 {
			for j := int64(0); j <= 9; j++ {
				ans += comb(iv+j*pw[m]+i*pw[m+1], k, sbin)
			}
		} else {
			ans += comb(iv+i*pw[m], k, sbin)
		}
	}
	return ans
}
```

题解：第一位有 $n-cnt_0$ 个可以选，剩下的位任意，总方案数为 $(n-cnt_0)\cdot (n-1)!$，然后排除所有重复子项，除以全体 $cnt_i!$ 的乘积即可。即：$\dfrac{(n-cnt_0)\cdot (n-1)!}{\prod_{i=0}^9cnt_i!}$。用排序字符串写哈希更简单。

```go
func countGoodIntegers(n, k int) (ans int64) {
	factorial := make([]int, n+1)
	factorial[0] = 1
	for i := 1; i <= n; i++ {
		factorial[i] = factorial[i-1] * i
	}

	vis := map[string]bool{}
	base := int(math.Pow10((n - 1) / 2))
	for i := base; i < base*10; i++ { // 枚举回文数左半边
		x := i
		t := i
		if n%2 > 0 {
			t /= 10
		}
		for ; t > 0; t /= 10 {
			x = x*10 + t%10
		}
		if x%k > 0 { // 回文数不能被 k 整除
			continue
		}

		bs := []byte(strconv.Itoa(x))
		slices.Sort(bs)
		s := string(bs)
		if vis[s] { // 不能重复统计
			continue
		}
		vis[s] = true

		cnt := [10]int{}
		for _, c := range bs {
			cnt[c-'0']++
		}
		res := (n - cnt[0]) * factorial[n-1]
		for _, c := range cnt {
			res /= factorial[c]
		}
		ans += int64(res)
	}
	return
}
```

##### 1922\.统计好数字的数目

[题目](https://leetcode.cn/problems/count-good-numbers)

显而易见。

```go
package main

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}
func countGoodTriplets(arr []int, a int, b int, c int) (ans int) {
	n := len(arr)
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			for k := j + 1; k < n; k++ {
				if abs(arr[i]-arr[j]) <= a && abs(arr[j]-arr[k]) <= b && abs(arr[i]-arr[k]) <= c {
					ans++
				}
			}
		}
	}
	return
}
```

枚举 $j,k$，对 $i$ 满足：

-  $|a_i-a_j|\le a\Rightarrow a_j-a\le a_i\le a_j+a$
-  $|a_i-a_k|\le c\Rightarrow a_k-c\le a_i\le a_k+c$

故 $a_i\in[\max(a_j-a,a_k-c,0),\min(a_j+a,a_k+c,\max a)]$。

对 $a$ 的值域计数 bin，叠前缀和，然后可以查询这个区间有多少个 $a_i$。

考虑到 $[0,x]$ 要求 $s[0-1]$，所以用 1 下标代表值 0，以此类推。

```go
func countGoodTriplets(arr []int, a, b, c int) (ans int) {
    mx := slices.Max(arr)
    s := make([]int, mx+2) // cnt 数组的前缀和
    for j, y := range arr {
        for _, z := range arr[j+1:] {
            if abs(y-z) > b {
                continue
            }
            l := max(y-a, z-c, 0)
            r := min(y+a, z+c, mx)
            ans += max(s[r+1]-s[l], 0) // 如果 l > r + 1，s[r + 1] - s[l] 可能是负数
        }
        for v := y + 1; v < mx+2; v++ {
            s[v]++ // 把 y 加到 cnt 数组中，更新所有受到影响的前缀和
        }
    }
    return
}

func abs(x int) int { if x < 0 { return -x }; return x }
```

##### 2179\.统计数组中好三元组数目

[题目](https://leetcode.cn/problems/count-good-triplets-in-an-array)

把 nums1 变成 iota 0,1,2,..., n-1 ，则原问题为统计 nums2 的上升三元组对数。故需要计算每个位置前面小于它和后面大于它的个数相乘即可。树状数组/线段树/平衡树都可以。

```go
package main

type fenwick struct {
	n int
	a []int
}

func NewFenwick(n int) *fenwick {
	return &fenwick{n: n, a: make([]int, n+1)}
}

func (t *fenwick) Add(i int) {
	for ; i <= t.n; i += i & -i {
		t.a[i] += 1
	}
}

func (t *fenwick) Query(i int) (sum int) {
	for ; i > 0; i -= i & -i {
		sum += t.a[i]
	}
	return
}

func (t *fenwick) QueryRange(l, r int) int {
	return max(0, t.Query(r)-t.Query(l-1))
}

func goodTriplets(nums1 []int, nums2 []int) (ans int64) {
	n := len(nums1)
	v2i := make([]int, n)
	for i, v := range nums1 {
		v2i[v] = i
	}
	for i, v := range nums2 {
		nums2[i] = v2i[v]
	}
	lt := make([]int64, n) // lt[i]: <i 有几个小于它的元素
	gt := make([]int64, n) // gt[i]: >i 有几个大于它的元素
	t1 := NewFenwick(n)
	for i, v := range nums2 {
		v++
		lt[i] = int64(t1.QueryRange(1, v-1))
		t1.Add(v)
	}
	t2 := NewFenwick(n)
	for i := n - 1; i >= 0; i-- {
		v := nums2[i] + 1
		gt[i] = int64(t2.QueryRange(v+1, n))
		t2.Add(v)
	}
	for i := 1; i < n-1; i++ {
		ans += lt[i] * gt[i]
	}
	return
}

```

优化：0-indexed，当前元素是 v，下标是 i，设左侧有 x 个元素比 v 小。在 [0, n-1] 全排列里，恒有 n-1-v 个元素比 v 大，在前面的 i 个元素中，既然 x 个比它小，那就有 i-x 个元素比它大，那么 n-1-v - (i-x) 个元素比它大，不用再算 gt 了。

```go
func goodTriplets(nums1, nums2 []int) (ans int64) {
	n := len(nums1)
	p := make([]int, n)
	for i, v := range nums1 {
		p[v] = i
	}
	tree := make([]int, n+1)
	for i := 1; i < n-1; i++ {
		for j := p[nums2[i-1]] + 1; j <= n; j += j & -j { // 将 p[nums2[i-1]]+1 加入树状数组
			tree[j]++
		}
		y, less := p[nums2[i]], 0
		for j := y; j > 0; j &= j - 1 { // 计算 less
			less += tree[j]
		}
		ans += int64(less) * int64(n-1-y-(i-less))
	}
	return
}
```

Python sortedList

```python
from sortedcontainers import SortedList

class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        p = [0] * n
        for i, x in enumerate(nums1):
            p[x] = i
        ans = 0
        s = SortedList()
        for i in range(1, n - 1):
            s.add(p[nums2[i - 1]])
            y = p[nums2[i]]
            less = s.bisect_left(y)
            ans += less * (n - 1 - y - (i - less))
        return ans
```

##### 2537\.统计好子数组的数目

[题目](https://leetcode.cn/problems/count-the-number-of-good-subarrays)

```go
package main

func countGood(nums []int, k int) (ans int64) {
	bin := make(map[int]int)
	var cnt int // never > int32 since l++
	l := 0      // [l, r] longest invalid
	for _, v := range nums {
		cnt += bin[v]
		bin[v]++
		for cnt >= k {
			v2 := nums[l]
			bin[v2]--
			cnt -= bin[v2]
			l++
		}
		ans += int64(l)
	}
	return
}
```

##### 435\.无重叠区间

[题目](https://leetcode.cn/problems/non-overlapping-intervals)

右端点排序，然后贪心算当前能选的即可。每次都是一个最优子问题。

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: x[1])
        ans = 0
        pre_r = -inf
        for l, r in intervals:
            if l >= pre_r:
                ans += 1
                pre_r = r
        return len(intervals) - ans
```

