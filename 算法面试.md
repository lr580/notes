所有面试算法题。

# 目录

### 牛客

- 2024美团春招第一场笔试

  1. 小美的平衡矩阵

     二维前缀和

  2. 小美的数组询问

     签到 (快读快写)

  3. 小美的MT

     签到

  4. 小美的朋友关系

     并查集 逆向 离散化

  5. 小美的区间删除

     数论 (前缀和+二分 / 滑动窗口)
  
- 2024美团秋招第一场笔试

  11. 小美的密码
  
      签到 (STL)
  
  12. 小美的数组删除
  
      枚举 mex
  
  13. 小美的彩带
  
      离散化 + 莫队 / <u>权值树状数组</u>
  
- 2024OPPO秋招研发岗笔试

  12. oppo杯手机diy大赛

      数据结构 / 枚举

  13. 小欧的字符串判定

      字符串 签到
  
  14. 小欧找数
  
      数学 签到
  
- 2024阿里云秋招算法岗第一批笔试

  1. 小红的字符串修改

    枚举 字符串

  2. 小歪和大富翁2.0

    DFS BFS DP 模拟

  3. 信用评分模型优化

    决策树(信息增益比)
  
- 2024阿里云秋招研发岗第一批笔试

  1. 小红闯关

    堆 贪心

  2. 小苯的子串删除

    前缀和 计数

  3. 小红的完全平方数

    **数论**
  
- 2024淘天集团春招研发岗笔试

  1. 小苯的区间删除

     二分 / <u>双指针</u>
  
  2. 小苯的比赛上分
  
     STL / <u>堆</u>
  
  3. 小苯的魔法染色
  
     二分答案
  




# 题目

## 牛客

#### 美团2024春招第一场笔试

##### 小美的平衡矩阵

[题目](https://www.nowcoder.com/exam/test/85806188/submission?examPageSource=Company&pid=55750560&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26tagIds%3D179&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91)

> 小美拿到了一个 $n \times n$ 的矩阵，其中每个元素是 0 或者 1。小美认为一个矩形区域是完美的，当且仅当该区域内 0 的数量恰好等于 1 的数量。
>
> 现在，小美希望你回答有多少个 $i \times i$ 的完美矩形区域。你需要回答 $1 \leq i \leq n$ 的所有答案。
>
> 第一行输入一个正整数 $n$，代表矩阵大小。  
> 接下来的 $n$ 行，每行输入一个长度为 $n$ 的 01 串，用来表示矩阵。  
> $1 \leq n \leq 200$
>
> 输出 $n$ 行，第 $i$ 行输出 $i \times i$ 的完美矩形区域的数量。
>
> ```
> 4
> 1010
> 0101
> 1100
> 0011
> ```
>
> ```
> 0
> 7
> 0
> 1
> ```

二维前缀和，枚举端点，复杂度 $O(n^3)$。

```c++
import java.util.Scanner;
import java.util.ArrayList;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        String a[] = new String[n];
        for(int i=0;i<n;++i) {
            a[i] = in.next();
        }
        int s[][] = new int[n+1][n+1];
        for(int i=1;i<=n;++i) {
            for(int j=1;j<=n;++j) {
                s[i][j] = s[i-1][j] +s[i][j-1] - s[i-1][j-1] + (a[i-1].charAt(j-1) - '0');
            }
        }
        for(int i=1;i<=n;++i) {
            int cnt = 0;
            for(int x=i;x<=n;++x) {
                for(int y=i;y<=n;++y) {
                    int num1 = s[x][y] - s[x-i][y] - s[x][y-i] + s[x-i][y-i];
                    int num0 = i*i - num1;
                    cnt += num1 == num0 ? 1 : 0;
                }
            }
            System.out.println(cnt);
        }
    }
}
```

##### 小美的数组询问

> 小美拿到了一个由正整数组成的数组，但其中有一些元素是未知的（用 0 来表示）。现在小美想知道，如果那些未知的元素在区间 $[l, r]$ 范围内随机取值的话，数组所有元素之和的最小值和最大值分别是多少？共有 $q$ 次询问。
> 
> - 第一行输入两个正整数 $n, q$，代表数组大小和询问次数。
> - 第二行输入 $n$ 个整数 $a_i$，其中如果输入的 $a_i$ 为 0，那么说明 $a_i$ 是未知的。
> - 接下来的 $q$ 行，每行输入两个正整数 $l, r$，代表一次询问。
> 
> 限制条件：
> - $1 \leq n, q \leq 10^5$  
> - $0 \leq a_i \leq 10^9$  
> - $1 \leq l \leq r \leq 10^9$
> 
> 输出 $q$ 行，每行输出两个正整数，代表所有元素之和的最小值和最大值。
> 
> 输入例子：
> ```
> 3 2
> 1 0 3
> 1 2
>4 4
> ```
> 输出例子：
> ```
> 5 6
>8 8
> ```
> 只有第二个元素是未知的。 
> 第一次询问，数组最小的和是 $1 + 1 + 3 = 5$，最大的和是 $1 + 2 + 3 = 6$。 
>第二次询问，显然数组的元素和必然为 $8$。

java 要快读，不然可能会超时。

```java
import java.util.Scanner;
import java.io.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    static StreamTokenizer scanner = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

    public static int nextInt() throws IOException {// 快约一倍
        scanner.nextToken();
        return (int) scanner.nval;
    }

    public static long nextLong() throws IOException {
        scanner.nextToken();
        return (long) scanner.nval;
    }

    public static void main(String[] args) throws IOException {
       // Scanner in = new Scanner(System.in);
        int num0 = 0;
        long suma = 0;
        int n = nextInt();
        int q = nextInt();
        for(int i=0;i<n;++i) {
            int a = nextInt();
            if(a==0) {
                ++num0;
            }else{
                suma+=a;
            }
        }
        while(q-->0) {
            long l=nextLong(), r=nextLong();
            out.print((suma+l*num0)+" ");
            out.println(suma+r*num0);
        }
        out.close();
    }
}
```

##### 小美的MT

> MT 是美团的缩写，因此小美很喜欢这两个字母。现在小美拿到了一个仅由大写字母组成字符串，她可以最多操作 $k$ 次，每次可以修改任意一个字符。小美想知道，操作结束后最多共有多少个 'M' 和 'T' 字符？
>
> - 第一行输入两个正整数 $n, k$，代表字符串长度和操作次数。
> - 第二行输入一个长度为 $n$ 的、仅由大写字母组成的字符串。
>
> 限制条件：
> - $1 \leq k \leq n \leq 10^5$
>
> 输出操作结束后最多共有多少个 'M' 和 'T' 字符。
>
> ```
> 5 2
> MTUAN
> ```
>
> ```
> 4
> ```
>
> 修改第三个和第五个字符，形成的字符串为 MTTAM，这样共有 4 个'M'和'T'。

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt(), k = in.nextInt();
        String s = in.next();
        int cnt = 0;
        for(int i=0;i<n;++i) {
            char c = s.charAt(i);
            cnt += (c=='M'||c=='T') ? 1 : 0;
            //System.out.println(cnt);
        }
        System.out.println(Math.min(n, cnt+k));
    }
}
```

##### 小美的朋友关系

> 小美认为，在人际交往中，随着时间的流逝，朋友的关系会慢慢变淡，最终朋友关系就淡忘了。现在初始有一些朋友关系，存在一些事件会导致两个人淡忘了他们的朋友关系。小美想知道某一时刻中，某两人是否可以通过朋友介绍互相认识？
>
> 事件共有 2 种：
> 1. `1 u v`：代表编号 $u$ 的人和编号 $v$ 的人淡忘了他们的朋友关系。
> 2. `2 u v`：代表小美查询编号 $u$ 的人和编号 $v$ 的人是否能通过朋友介绍互相认识。
>
> > 注：介绍可以有多层，比如 2 号把 1 号介绍给 3 号，然后 3 号再把 1 号介绍给 4 号，这样 1 号和 4 号就认识了。
>
> - 第一行输入三个正整数 $n, m, q$，代表总人数，初始的朋友关系数量，发生的事件数量。
> - 接下来的 $m$ 行，每行输入两个正整数 $u, v$，代表初始编号 $u$ 的人和编号 $v$ 的人是朋友关系。
> - 接下来的 $q$ 行，每行输入三个正整数 $op, u, v$，含义如题目描述所述。
>
> 限制条件：
> - $1 \leq n \leq 10^9$
> - $1 \leq m, q \leq 10^5$
> - $1 \leq u, v \leq n$
> - $1 \leq op \leq 2$
> - 保证至少存在一次查询操作。
>
> 对于每次 `2` 号操作，输出一行字符串代表查询的答案。如果编号 $u$ 的人和编号 $v$ 的人能通过朋友介绍互相认识，则输出 "Yes"。否则输出 "No"。
>
> ```
> 5 3 5
> 1 2
> 2 3
> 4 5
> 1 1 5
> 2 1 3
> 2 1 4
> 1 1 2
> 2 1 3
> ```
>
> ```
> Yes
> No
> No
> ```
>
> 第一次事件，1 号和 5 号本来就不是朋友，所以无事发生。
> 第二次事件是询问，1 号和 3 号可以通过 2 号的介绍认识。
> 第三次事件是询问，显然 1 号和 4 号无法互相认识。
> 第四次事件，1 号和 2 号淡忘了。
> 第五次事件，此时 1 号无法再经过 2 号和 3 号互相认识了。

离散化。对不在询问里的初始朋友关系，并查集直接设置，逆序遍历询问，一边处理一边逆向遗忘；加特判缝缝补补修WA所以很乱。Java 可以快读快写。

```java
import java.util.Scanner;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.HashMap;
import java.io.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    static StreamTokenizer scanner = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

    public static int nextInt() throws IOException {// 快约一倍
        scanner.nextToken();
        return (int) scanner.nval;
    }

    public static long nextLong() throws IOException {
        scanner.nextToken();
        return (long) scanner.nval;
    }

    static int fa[], n1;
    static int findFa(int x0) {
        int x=hget(x0);
        if(x>=n1) {
            //System.out.println("!!!"+x0+" "+n1+" "+x);
            return (int)(1e9+7)+x0;
        }
        //System.out.println("?"+x0+" "+n1+" "+x);
        while(x!=fa[x]) {
            x=fa[x]=fa[fa[x]];
        }
        return x;
    }
    static HashMap<Integer, Integer> h2;
    static int hget(int x) {
        if(!h2.containsKey(x)) {
            h2.put(x, h2.size());
        }
        return h2.get(x);
    }
    public static void main(String[] args) throws IOException {
        //Scanner in = new Scanner(System.in);
        int n = nextInt(), m = nextInt(), q = nextInt();
        int cmd[][] = new int[q][4];
        HashSet<Long> h = new HashSet<>();
        int nn = (int)(1e9+7);
        h2 = new HashMap<>();
        for(int i=0;i<m;++i) {
            int u = nextInt(), v = nextInt();
            int x = Math.min(u, v), y = Math.max(u, v);
            hget(x);
            hget(y);
            h.add((long)x*nn+y);
        }
        n1 = h2.size();
        for(int i=0;i<q;++i) {
            cmd[i][0] = nextInt();
            int u = nextInt(), v = nextInt();
            int x = Math.min(u, v), y = Math.max(u, v);
            boolean valid = h.contains((long)x*nn+y);
            cmd[i][1] = x;
            cmd[i][2] = y;
            hget(x);
            hget(y);
            if(valid) {
                if(cmd[i][0] == 1) {
                    h.remove((long)x*nn+y);
                }
            }else {
                cmd[i][3]=1;
            }
        }
        
        // for(int x:h2.keySet()) {
        //     System.out.println(x+" "+ h2.get(x));
        // }
        fa = new int[n1];
        for(int i=0;i<n1;++i) {
            fa[i]=i;
        }
        for(Long pr:h) {
            int u=(int)(pr/nn), v=(int)(pr%nn);
            fa[findFa(u)]=findFa(v);
        }
        ArrayList<Boolean> ans = new ArrayList<>();
        for(int i=q-1;i>=0;--i) {
            int u=findFa(cmd[i][1]), v=findFa(cmd[i][2]);
            //System.out.println("?");
            if(cmd[i][0]==1) {
                if(cmd[i][3]==1) {
                    continue;
                }
                if(u>=n1||v>=n1) continue;
                fa[u]=v;
            }else {
                if(u>=n1||v>=n1) {
                    ans.add(false);
                    continue;
                }
                ans.add(fa[u]==fa[v]);
            }
        }
        for(int i=ans.size()-1;i>=0;--i) {
            out.println(ans.get(i)?"Yes":"No");
        }
        out.close();
    }
}
```

##### 小美的区间删除

> 从一个大小为 $n$ 的数组中删除一个区间，以使得剩余所有元素的乘积末尾至少有 $k$ 个 0。小美想知道一共有多少种不同的删除方案。
>
> - 第一行输入两个正整数 $n, k$。
> - 第二行输入 $n$ 个正整数 $a_i$，代表小美拿到的数组。
>
> 限制条件：
> - $1 \leq n, k \leq 10^5$  
> - $1 \leq a_i \leq 10^9$
>
> 输出一个整数，代表删除的方案数。
>
> ```
> 5 2
> 2 5 3 4 20
> ```
>
> ```
> 4
> ```
>
> 第一个方案，删除[3]。
> 第二个方案，删除[4]。
> 第三个方案，删除[3,4]。
> 第四个方案，删除[2]。

0数量=2因子数和5因子数的最小值。

解法一：前缀和处理，然后枚举每一个区间右端点并二分得到左端点。

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt(), k = in.nextInt();
        int s2[] = new int[n+1], s5[] = new int[n+1];
        for(int i=1;i<=n;++i) {
            int a = in.nextInt();
            while(a%2==0) {
                ++s2[i];
                a/=2;
            }
            while(a%5==0) {
                ++s5[i];
                a/=5;
            }
            //System.out.println(s2[i]+" "+s5[i]);
            s2[i]+=s2[i-1];
            s5[i]+=s5[i-1];
        }
        //System.out.println(s2[n]+" "+s5[n]);
        long ans=0;
        for(int r=1;r<=n;++r) {
            int lf=1, rf=r, l=r+1;
            while(lf<=rf) {
                int cf=(lf+rf)>>1;
                int m2 = s2[r] - s2[cf-1];
                int m5 = s5[r] - s5[cf-1];
                //System.out.println(cf+" "+r+" "+m2+" "+m5);
                int n0 = Math.min(s2[n]-m2, s5[n]-m5);
                if(n0>=k) {
                    l=cf;
                    rf=cf-1;
                }else{
                    lf=cf+1;
                }
            }
            //System.out.println(l+" "+r);
            ans+=Math.max(0, r-l+1);
        }
        System.out.println(ans);
    }
}
```

解法二：滑动窗口。

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt(), k = in.nextInt();
        int n2[] = new int[n], n5[] = new int[n];
        int s2=0,s5=0;
        for(int i=0;i<n;++i) {
            int a = in.nextInt();
            while(a%2==0) {
                ++n2[i];
                a/=2;
            }
            while(a%5==0) {
                ++n5[i];
                a/=5;
            }
            s2+=n2[i];
            s5+=n5[i];
        }
        long ans=0;
        int c2=0,c5=0;
        for(int r=0,l=0;r<n;++r) {
            c2+=n2[r];
            c5+=n5[r];
            while(l<=r&&Math.min(s5-c5,s2-c2)<k) {
                c2-=n2[l];
                c5-=n5[l];
                l+=1;
            }
            ans+=Math.max(0,r-l+1);
        }
        System.out.println(ans);
    }
}
```

#### 美团2024秋招第一场笔试

##### 小美的密码

> # 问题描述
>
> 小美准备登录美团，需要输入密码。小美忘记了密码，只记得密码可能是 `n` 个字符串中的一个。小美会按照密码的长度从小到大依次尝试每个字符串，对于相同长度的字符串，小美随机尝试，并且相同的密码只会尝试一次。小美想知道，她最少需要尝试多少次才能登录成功，最多需要尝试多少次才能登录成功。
>
> 小美不会重新尝试已经尝试过的字符串。成功登录后会立即停止尝试。
>
> - 第一行输入一个整数 `n`（`1 ≤ n ≤ 1000`），代表密码字符串的个数。
> - 第二行输入一个只由小写字母组成的字符串 `s`（`1 ≤ |s| ≤ 1000`），代表正确的密码。
> - 接下来 `n` 行，每行输入一个长度不超过 `1000` 的字符串，代表小美记得的密码。
>
> 在一行上输出两个整数，表示最少和最多尝试次数。
>
> ```
> 4
> ab
> abc
> ab
> ac
> ac
> ```
>
> ```
> 1 2
> ```
>
> 小美可能按照 ["ab", "ac", "abc"] 的顺序尝试，第一次尝试成功，也可能按照 ["ac", "ab", "abc"] 的顺序尝试，第二次尝试成功。
>
> 小美在尝试 "ac" 发现不正确后不会继续尝试 "ac"。

签到。

```java
import java.util.Scanner;
import java.util.TreeMap;
import java.util.HashSet;
import java.util.Map;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        TreeMap<Integer, Integer> m = new TreeMap<>();
        HashSet<String> p = new HashSet<>();
        String t = in.next();
        for(int i=0;i<n;++i) {
            p.add(in.next());
        }
        int cnt2 = -1;
        for(String s : p) {
            if (t.equals(s)) {
                ++cnt2;
            }
            int l = s.length();
            m.put(l, 1+m.getOrDefault(l,0));
        }
        int l = t.length(), cnt = 0;
        for(Map.Entry<Integer, Integer> it : m.entrySet()) {
            int l2 = it.getKey(), s = it.getValue();
            if(l2 < l) {
                cnt += s;
            } else {
                System.out.println((cnt+1)+" "+(cnt+s-cnt2));
                break;
            }
        }
    }
}
```

##### 小美的数组删除

> 小美有一个长度为 $ n $ 的数组 $ a_1, a_2, \dots, a_n $，他可以对数组进行如下操作：
>
> - **删除第一个元素 $ a_1 $**，同时数组的长度减一，花费为 $ x $。
> - **删除整个数组**，花费为 $ k \times \text{MEX}(a) $（其中 $ \text{MEX}(a) $ 表示 $ a $ 中未出现过的最小非负整数。例如 $[0,1,2,4]$ 的 $ \text{MEX} $ 为 $ 3 $）。
>
> 小美想知道将数组 $ a $ 全部清空的最小代价是多少，请你帮帮他吧。
>
> 每个测试文件均包含多组测试数据。第一行输入一个整数 $ T $（$ 1 \le T \le 1000 $）代表数据组数，每组测试数据描述如下：
>
> - 第一行输入三个正整数 $ n, k, x $（$ 1 \leq n \leq 2 \times 10^5 $，$ 1 \leq k, x \leq 10^9 $），分别代表数组中的元素数量、删除整个数组的花费系数、删除单个元素的花费。
> - 第二行输入 $ n $ 个整数 $ a_1, a_2, \dots, a_n $（$ 0 \leq a_i \leq n $），表示数组元素。
> - 除此之外，保证所有的 $ n $ 之和不超过 $ 2 \times 10^5 $。
>
> 对于每一组测试数据，在一行上输出一个整数，表示将数组中所有元素全部删除的最小花费。
>
> ```
> 1
> 6 3 3
> 4 5 2 3 1 0
> ```
>
> ```
> 15
> ```
>
> - 若不执行操作一就全部删除，$ \text{MEX}\{4,5,2,3,1,0\} = 6 $，花费 $ 18 $；
> - 若执行一次操作一后全部删除，$ \text{MEX}\{5,2,3,1,0\} = 4 $，花费 $ 3 + 12 $；
> - 若执行两次操作一后全部删除，$ \text{MEX}\{2,3,1,0\} = 4 $，花费 $ 6 + 12 $；
> - 若执行三次操作一后全部删除，$ \text{MEX}\{3,1,0\} = 2 $，花费 $ 9 + 6 $；
> - 若执行四次操作一后全部删除，$ \text{MEX}\{1,0\} = 2 $，花费 $ 12 + 6 $；
> - 若执行五次操作一后全部删除，$ \text{MEX}\{0\} = 1 $，花费 $ 15 + 3 $；
> - 若执行六次操作一，$ \text{MEX}\{\} = 0 $，花费 $ 18 $。
>

倒序遍历枚举，set 维护 MEX

```java
import java.util.Scanner;
import java.util.HashSet;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int T = in.nextInt();
        while(T-->0) {
            int n = in.nextInt(), k = in.nextInt(), x = in.nextInt();
            int a[] = new int[n];
            for(int i=0;i<n;++i) {
                a[i] = in.nextInt();
            }
            HashSet<Integer> h = new HashSet<>();
            long ans = (long)n * x;
            int mex = 0;
            for(int i=n-1;i>=0;--i) {
                h.add(a[i]);
                while(h.contains(mex)) {
                    ++mex;
                }
                ans = Math.min(ans, (long)i*x + (long)k*mex);
            }
            System.out.println(ans);
        }
    }
}
```

##### 小美的彩带

> 小美的彩带是由一条长度为 $ n $ 的彩带无限循环得到的。彩带的每一个位置都有一个颜色，用 $ a_i $ 表示。因此当 $ i > n $ 时，$ a_i = a_{i-n} $。
>
> 小美每次会从左往右或从右往左剪一段长度为 $ x $ 的彩带，她想知道每次剪下来的彩带有多少种颜色。
>
> - 第一行输入两个整数 $ n, q $（$ 1 \leq n, q \leq 2 \times 10^5 $），分别代表彩带长度和剪彩带次数。
> - 第二行输入 $ n $ 个整数 $ a_1, a_2, \dots, a_n $（$ 1 \leq a_i \leq 10^9 $），代表彩带每一个位置的颜色。
> - 此后 $ q $ 行，每行输入一个字符 $ c $ 和一个整数 $ x $（$ 1 \leq x \leq 10^9 $，$ c \in \{ \text{'L'}, \text{'R'} \} $），代表裁剪方向和裁剪长度。其中：
>   - `'L'` 表示从左往右剪，
>   - `'R'` 表示从右往左剪。
>
> 对于每一次裁剪彩带，在一行上输出一个整数，代表剪下来的彩带中颜色的数量。
>
> ```
> 6 3
> 1 1 4 5 1 4
> L 2
> L 3
> R 12
> ```
>
> ```
> 1
> 3
> 3
> ```
>
> 1. 第一次剪彩带，剪下来的是 $[1, 1]$，有 $\{1\}$ 这 1 种颜色； 
> 2. 第二次剪彩带，剪下来的是 $[4, 5, 1]$，有 $\{1, 4, 5\}$ 这 3 种颜色； 
> 3. 第三次剪彩带，剪下来的是 $[1, 1, 4, 5, 1, 4, 1, 1, 4, 5, 1, 4]$，有 $\{1, 4, 5\}$ 这 3 种颜色。 

可以看看当前属于第几个取模，注意负数-1不然0这一块多一块。

莫队处理，记得加inline，把unmap用离散化换掉说不定更快。可能不过可能过，看评测抖动

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5+3;
int a[maxn*2], sq, ans[maxn];
struct query {
    int l, r, i;
    bool operator<(const query &x) const
    {
        if (l / sq != x.l / sq)
            return l < x.l;
        if (l / sq & 1)
            return r < x.r;
        return r > x.r;
    }
} cmd[maxn];
unordered_map<int,int> cnt;
int sum;
inline void add(int i) {
    sum += cnt[a[i]]++ == 0;
}
inline void del(int i) {
    sum -= --cnt[a[i]] == 0;
}
signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int n, q;
    cin >> n >> q;
    for(int i=0;i<n; ++i) cin >> a[i];
    for(int i=0;i<n; ++i) a[i+n]=a[i];
    int li = 0, ri = n - 1;
    for(int qi=0;qi<q;++qi) {
        char cm;
        int len,l,r;
        cin >> cm >> len;
        if(cm=='L') {
            l=li, r=li+len-1;
            li=(li+len)%n;
        }else{
            r=ri, l=ri-len+1;
            ri=(ri-len%n+n)%n;
        }
        int lb=l/n-(l<0), rb=r/n-(r<0);
        // cout << l << " " << r << " " << lb << " " << rb << " : ";
        l=(l%n+n)%n, r=(r%n+n)%n;
        if(abs(lb-rb)>=2) {
            cmd[qi] = {0, n-1, qi};
        } else if(lb==rb) {
            cmd[qi] = {l, r, qi};
        } else {
            cmd[qi] = {l, n+r, qi};
        }
    }
    sq=sqrt(n*2);
    sort(cmd, cmd+q);
    for(int i=0,l=0,r=-1; i<q; ++i) {
        while(l>cmd[i].l) add(--l);
        while(r<cmd[i].r) add(++r);
        while(l<cmd[i].l) del(l++);
        while(r>cmd[i].r) del(r--);
        ans[cmd[i].i] = sum;
    }
    for(int i=0;i<q;++i) {
        cout<<ans[i]<<'\n';
    }
    return 0;
}
```

> TLE 的线段树+unmap，理由：每次查询要合并 unmap，故复杂度是 $O(qn)$。
>
> ```c++
> #include <bits/stdc++.h>
> using namespace std;
> const int maxn = 2e5+3;
> unordered_set<int> t[maxn*4]; // 线段树
> int a[maxn];
> void init(int p, int l, int r) {
>     if(l==r) {
>         t[p].insert(a[l]);
>         return;
>     }
>     int c=(l+r)>>1;
>     init(p<<1, l, c);
>     init(p<<1|1, c+1, r);
>     t[p].insert(t[p<<1].begin(), t[p<<1].end());
>     t[p].insert(t[p<<1|1].begin(), t[p<<1|1].end());
> }
> unordered_set<int> query(int p, int l, int r, int ql, int qr) {
>     if(ql<=l && r<=qr) return t[p];
>     int c=(l+r)>>1;
>     unordered_set<int> res;
>     if(ql<=c) {
>         auto tmp=query(p<<1, l, c, ql, qr);
>         res.insert(tmp.begin(), tmp.end());
>     }
>     if(c<qr) {
>         auto tmp=query(p<<1|1, c+1, r, ql, qr);
>         res.insert(tmp.begin(), tmp.end());
>     }
>     return res;
> }
> signed main() {
>     ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
>     int n, q;
>     cin >> n >> q;
>     for(int i=0;i<=4*n+1; ++i) t[i].clear();
>     for(int i=0;i<n; ++i) cin >> a[i];
>     init(1, 0, n-1);
>     int li = 0, ri = n - 1;
>     while(q--) {
>         char cmd;
>         int len,l,r;
>         cin >> cmd >> len;
>         if(cmd=='L') {
>             l=li, r=li+len-1;
>             li=(li+len)%n;
>         }else{
>             r=ri, l=ri-len+1;
>             ri=(ri-len%n+n)%n;
>         }
>         int lb=l/n-(l<0), rb=r/n-(r<0);
>         // cout << l << " " << r << " " << lb << " " << rb << " : ";
>         l=(l%n+n)%n, r=(r%n+n)%n;
>         if(abs(lb-rb)>=2) {
>             cout << t[1].size() << '\n';
>         } else if(lb==rb) {
>             cout << query(1, 0, n-1, l, r).size() << '\n';
>         } else {
>             auto tmp=query(1, 0, n-1, l, n-1);
>             tmp.insert(query(1, 0, n-1, 0, r).begin(), query(1, 0, n-1, 0, r).end());
>             
>             cout << tmp.size() << '\n';
>         }
>     }
>     return 0;
> }
> ```
>
> 写了发现不对的树状数组+离散化：
>
> ```c++
> #include <bits/stdc++.h>
> using namespace std;
> const int maxn = 2e5+3;
> int a[maxn*2], ans[maxn], n;
> struct query {
>     int l, r, i;
>     bool operator<(const query &x) const {
>         return r<x.r;
>     }
> } cmd[maxn];
> map<int, int> b; // 离散化
> int t[maxn*2];
> void add(int i) {
>     for(;i<=n;i+=(i&-i)) t[i]+=1;
> }
> int query(int i) {
>     int ans = 0;
>     for(;i;i-=(i&-i)) ans+=t[i];
>     return ans;
> }
> signed main() {
>     ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
>     int q;
>     cin >> n >> q;
>     for(int i=0;i<n; ++i) cin >> a[i];
>     for(int i=0;i<n; ++i) {
>         if(b.find(a[i])==b.end()) {
>             b[a[i]] = 1+b.size();
>         }
>         a[i] = b[a[i]];
>     }
>     for(int i=0;i<n; ++i) a[i+n]=a[i];
>     int li = 0, ri = n - 1;
>     for(int qi=0;qi<q;++qi) {
>         char cm;
>         int len,l,r;
>         cin >> cm >> len;
>         if(cm=='L') {
>             l=li, r=li+len-1;
>             li=(li+len)%n;
>         }else{
>             r=ri, l=ri-len+1;
>             ri=(ri-len%n+n)%n;
>         }
>         int lb=l/n-(l<0), rb=r/n-(r<0);
>         // cout << l << " " << r << " " << lb << " " << rb << " : ";
>         l=(l%n+n)%n, r=(r%n+n)%n;
>         if(abs(lb-rb)>=2) {
>             cmd[qi] = {0, n-1, qi};
>         } else if(lb==rb) {
>             cmd[qi] = {l, r, qi};
>         } else {
>             cmd[qi] = {l, n+r, qi};
>         }
>     }
>     sort(cmd, cmd+q);
>     n*=2;
>     for(int i=0, qi=0; i<n; ++i) {
>         
>     }
>     return 0;
> }
> ```

离散化+莫队，稳定 300ms 内

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5+3;
int a[maxn*2], sq, ans[maxn];
map<int, int> b; // 离散化
struct query { // 莫队
    int l, r, i;
    bool operator<(const query &x) const
    {
        if (l / sq != x.l / sq)
            return l < x.l;
        if (l / sq & 1)
            return r < x.r;
        return r > x.r;
    }
} cmd[maxn];
int cnt[maxn];
int sum;
inline void add(int i) {
    sum += cnt[a[i]]++ == 0;
}
inline void del(int i) {
    sum -= --cnt[a[i]] == 0;
}
signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int n, q;
    cin >> n >> q;
    for(int i=0;i<n; ++i) cin >> a[i];
    for(int i=0;i<n; ++i) {
        if(b.find(a[i])==b.end()) {
            b[a[i]] = b.size();
        }
        a[i] = b[a[i]];
    }
    for(int i=0;i<n; ++i) a[i+n]=a[i];
    int li = 0, ri = n - 1;
    for(int qi=0;qi<q;++qi) {
        char cm;
        int len,l,r;
        cin >> cm >> len;
        if(cm=='L') {
            l=li, r=li+len-1;
            li=(li+len)%n;
        }else{
            r=ri, l=ri-len+1;
            ri=(ri-len%n+n)%n;
        }
        int lb=l/n-(l<0), rb=r/n-(r<0);
        // cout << l << " " << r << " " << lb << " " << rb << " : ";
        l=(l%n+n)%n, r=(r%n+n)%n;
        if(abs(lb-rb)>=2) {
            cmd[qi] = {0, n-1, qi};
        } else if(lb==rb) {
            cmd[qi] = {l, r, qi};
        } else {
            cmd[qi] = {l, n+r, qi};
        }
    }
    sq=sqrt(n*2);
    sort(cmd, cmd+q);
    for(int i=0,l=0,r=-1; i<q; ++i) {
        while(l>cmd[i].l) add(--l);
        while(r<cmd[i].r) add(++r);
        while(l<cmd[i].l) del(l++);
        while(r>cmd[i].r) del(r--);
        ans[cmd[i].i] = sum;
    }
    for(int i=0;i<q;++i) {
        cout<<ans[i]<<'\n';
    }
    return 0;
}
```

评论解法，树状数组：

考虑到当前出现某个颜色时，之间所有该颜色都不会对查询有贡献，因此维护每种颜色的上一个出现位置即可，当又出现该颜色时清除之前出现的位置，这样查询不同颜色数量就转为一个区间求和。而以上清除和求和操作都可由树状数组高效完成

借助这个思路和我写了一半的树状数组代码，deepseek 深度思考了几分钟补全，AC了，三百多ms。

按右端点排序询问，用 last[i] 数组记录在固定右端点下，每个位置 i 是否有颜色。叠树状数组维护 last 的前缀和，然后对每个询问求区间和即可。

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5+3;
int a[maxn*2], ans[maxn], n;
struct query {
    int l, r, i;
    bool operator<(const query &x) const {
        return r<x.r;
    }
} cmd[maxn];
map<int, int> b; // 离散化
int t[maxn*2];
map<int, int> last; // 记录每个颜色最后出现的位置

void add(int i, int delta) {
    while (i < maxn*2) {
        t[i] += delta;
        i += i & -i;
    }
}

int query(int i) {
    int res = 0;
    while (i > 0) {
        res += t[i];
        i -= i & -i;
    }
    return res;
}

signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int q;
    cin >> n >> q;
    for(int i=0; i<n; ++i) cin >> a[i];
    // 离散化颜色
    for(int i=0; i<n; ++i) {
        if(b.find(a[i]) == b.end()) {
            b[a[i]] = 1 + b.size();
        }
        a[i] = b[a[i]];
    }
    for(int i=0; i<n; ++i) a[i+n] = a[i];
    int li = 0, ri = n - 1;
    // 处理每个查询，确定对应的区间
    for(int qi=0; qi<q; ++qi) {
        char cm;
        int len, l, r;
        cin >> cm >> len;
        if(cm == 'L') {
            l = li;
            r = li + len - 1;
            li = (li + len) % n;
        } else {
            r = ri;
            l = ri - len + 1;
            ri = (ri - len % n + n) % n;
        }
        int lb = l / n - (l < 0 ? 1 : 0);
        int rb = r / n - (r < 0 ? 1 : 0);
        l = (l % n + n) % n;
        r = (r % n + n) % n;
        if(abs(lb - rb) >= 2) {
            cmd[qi] = {0, n-1, qi};
        } else if(lb == rb) {
            cmd[qi] = {l, r, qi};
        } else {
            cmd[qi] = {l, n + r, qi};
        }
    }
    sort(cmd, cmd + q);
    n *= 2; // 扩展后的数组长度为原长度的两倍
    // 处理每个位置，维护树状数组和最后出现的位置
    for(int i=0, qi=0; i < n; ++i) {
        int color = a[i];
        if(last.count(color)) {
            add(last[color] + 1, -1);
        }
        add(i + 1, 1);
        last[color] = i;
        // 处理所有右端点等于当前i的查询
        while (qi < q && cmd[qi].r == i) {
            int current_l = cmd[qi].l;
            ans[cmd[qi].i] = query(i + 1) - query(current_l);
            qi++;
        }
    }
    // 输出所有查询结果
    for(int i=0; i<q; ++i) {
        cout << ans[i] << '\n';
    }
    return 0;
}
```

#### OPPO2024秋招研发岗

##### oppo杯手机diy大赛

> 共有n个评委，每个评委为小欧的作品的外观和性能分别打了分数。
>
> 为了分数更加有效，每个指标的分数都将分别去除最高分和最低分之后计算剩下分数的平均数即为指标的分数，然后求出这两个指标分数的平均数，即为最终的分数。
>
> 有一个评委可能由于徇私舞弊失去评价资格。小欧想知道，如果是第i个评委失去资格，她最终能获得多少分？你需要回答i=1,2,...,n的答案。
>
> 第一行输入一个正整数n，代表评委的数量。
> 接下来的n行，每行输入两个正整数$a_i$和$b_i$，代表该评委给小欧作品的外观分数和性能分数。
>
> $4\le n\le10^5$，$1\le a_i,b_i\le 10^9$。
>
> 输出n行，第i行输出一个浮点数，代表第i个评委失去资格后，小欧最终的分数。
> 如果你输出的答案精度和标准答案的相对误差不超过10^{-5}，则认为答案正确。
>
> ```
> 4
> 1 1
> 2 3
> 3 2
> 4 1
> ```
>
> ```
> 2.5
> 2
> 1.5
> 2
> ```

```go
package main

import "fmt"

func main() {
	var n int
	fmt.Scan(&n)
	type score struct {
		max1, max2, min1, min2 int
		sum                    int64
	}
	s1 := score{min1: 1 << 30, min2: 1 << 30}
	s2 := score{min1: 1 << 30, min2: 1 << 30}
	add := func(s *score, v int) {
		s.sum += int64(v)
		if v >= s.max1 {
			s.max2 = s.max1
			s.max1 = v
		} else if v >= s.max2 {
			s.max2 = v
		}
		if v <= s.min1 {
			s.min2 = s.min1
			s.min1 = v
		} else if v <= s.min2 {
			s.min2 = v
		}
	}
	a := make([]int, n)
	b := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Scan(&a[i], &b[i])
		add(&s1, a[i])
		add(&s2, b[i])
	}
	stat := func(s *score, v int) float64 {
		avg := s.sum - int64(v)
		if v != s.max1 {
			avg -= int64(s.max1)
		} else {
			avg -= int64(s.max2)
		}
		if v != s.min1 {
			avg -= int64(s.min1)
		} else {
			avg -= int64(s.min2)
		}
		return float64(avg) / float64(n-3)
	}
	for i := 0; i < n; i++ {
		resa, resb := stat(&s1, a[i]), stat(&s2, b[i])
		res := (resa + resb) / 2
		fmt.Println(res)
	}
}
```

##### 小欧的字符串判定

> 小欧拿到了两个字符串s和t，她有一个目标字符串target。小欧希望每一位从s或者t的对应位置的字符中二选一生成target，你能告诉小欧她最终能达成目的吗 $1\le n\le100$ 字符串长度，输入四行(n, s, t, target)，输出 Yes / No
>
> ```
> 3
> abc
> bad
> aac
> ```
>
> ```
> Yes
> ```
>
> ```
> 2
> ab
> bb
> aa
> ```
>
> ```
> No
> ```

```go
package main

import "fmt"

func main() {
	var n int
	fmt.Scan(&n)
	var s, t, target string
	fmt.Scan(&s, &t, &target)
	for i := 0; i < n; i++ {
		if !(s[i] == target[i] || t[i] == target[i]) {
			fmt.Println("No")
			return
		}
	}
	fmt.Println("Yes")
}
```

#### 阿里云2024秋招算法岗第一批笔试

##### 小红的字符串修改

> 小红有一个由小写字母构成的字符串 s，每次她可以把其中一个任意一个字母替换成其在字母表中相邻的字母，例如把 'a' 替换成 'b' 或者 'z'。现在小红想知道，最少需要替换多少次，使得 s 成为 t 的子串。
>
> 如果字符串 t 可以通过从字符串 s 的开头删除若干（可能为零或全部）字符以及从结尾删除若干（可能为零或全部）字符得到，则字符串 t 是字符串 s 的子串。
>
> 输入两行，s, t；长度 $|s|\le|t|\le10^3$。
>
> 在一行上输出一个整数，代表最少需要替换的次数。
>
> ```
> abc
> abbc
> ```
>
> ```
> 1
> ```
>
> ```
> zzzzzz
> xyzabc
> ```
>
> ```
> 9
> ```

枚举即可。

```go
package main

import "fmt"

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
func main() {
	var s, t string
	fmt.Scan(&s, &t)
	ans := int(1e9)
	n, m := len(s), len(t)
	for lt, rt := 0, n-1; rt < m; lt, rt = lt+1, rt+1 {
		cnt := 0
		for i := 0; i < n; i++ {
			c1, c2 := int(s[i]-'a'), int(t[lt+i]-'a')
			d1 := int(abs(c1 - c2))
			d2 := int(abs(c1 + 26 - c2))
			d3 := int(abs(26 - c1 + c2))
			cnt += min(min(d1, d2), d3)
		}
		ans = min(ans, cnt)
	}
	fmt.Println(ans)
}

/*
uhyxfldiji
bbgkrifblcaegilmoyxo
40
*/
```

##### 小歪和大富翁2.0

> 小歪在玩《大富翁》游戏，游戏中 $n$ 个城市围成一圈，编号从 0 到 $n-1$，即第 $n-1$ 个城市的下一个城市是第 $0$ 个城市。第 $i$ 个城市上有一个数字 $a_i$，表示**第一次**到达第 i 个城市可以获得 $a_i$ 枚金币。
> 每一轮开始时小歪会获得 4 张卡牌，分别可以跳跃 1、2、3、4 个城市，例如小歪可以从城市一跳跃 3 个城市到达城市四。当小歪使用完这 4 张卡牌后，会开启新的一轮。
> 初始时，小歪拥有 0 枚金币，小歪想知道她从第零个城市出发（出发时不会获得金币），经过 k 轮后最多可以获得多少枚金币。
>
> 第一行输入两个整数 $n,k(10\le n\le10^5,1\le k\le10^9)$，保证 $n$ 是 $10$ 的倍数。
>
> 第二行输入 $n$ 个整数 $a_1,\cdots,a_n(-10^9\le a_i\le10^9)$，表示第一次到达城市 $0$ 到 $n-1$ 可以获得的金币数量。
>
> 在一行上输出一个整数，代表小歪能获得的最多金币数量。
>
> ```
> 10 1
> -1 -1 2 3 4 -9 -9 -1 3 -1
> ```
>
> ```
> 9
> ```
>
> 最优的方法是：
>
> 第 1 步：使用跳跃 3 的卡牌，从 0 跳到 3 ，获得 3 枚金币；
>
> 第 2 步：使用跳跃 1 的卡牌，从 3 跳到 4 ，获得 4 枚金币，共有 7 枚金币；
>
> 第 3 步：使用跳跃 4 的卡牌，从 4 跳到 8 ，获得 3 枚金币，共有 10 枚金币；
>
> 第 4 步：使用跳跃 2 的卡牌，从 8 跳到 0 ，获得 -1 枚金币，共有 9 枚金币。
>
> ```
> 10 2
> -1 -1 2 3 4 -9 -9 -1 3 -1
> ```
>
> ```
> 10
> ```
>
> 最优的方法是：
> 第 1 步：使用跳跃 3 的卡牌，从 0 跳到 3 ，获得 3 枚金币；
> 第 2 步：使用跳跃 1 的卡牌，从 3 跳到 4 ，获得 4 枚金币，共有 7 枚金币；
> 第 3 步：使用跳跃 4 的卡牌，从 4 跳到 8 ，获得 3 枚金币，共有 10 枚金币；
> 第 4 步：使用跳跃 2 的卡牌，从 8 跳到 0 ，获得 -1 枚金币，共有 9 枚金币。
> 第 5 步：使用跳跃 2 的卡牌，从 0 跳到 2 ，获得 2 枚金币，共有 11 枚金币；
> 第 6 步：使用跳跃 1 的卡牌，从 2 跳到 3 ，获得 0 枚金币（不是第一次到达），共有 11 枚金币；
> 第 7 步：使用跳跃 4 的卡牌，从 3 跳到 7 ，获得 -1 枚金币，共有 10 枚金币；
> 第 8 步：使用跳跃 3 的卡牌，从 7 跳到 0 ，获得 0 枚金币（不是第一次到达），共有 10 枚金币。

先处理出 $4!$ 种跳跃方案，然后使用 BFS 枚举可知，在 $4$ 步之内一定可以覆盖完 $10$ 个城市。所以对 $10$ 个城市的每组，直接枚举 BFS 方案看哪个最大即可。

```go
package main

import (
	"fmt"
)

var way [24][4]int
var waybit [24]int

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
func max(a, b int64) int64 {
	if a > b {
		return a
	}
	return b
}

func main() {
	// DFS
	cnt := 0 // cnt = 4!
	for i := 1; i <= 4; i++ {
		for j := 1; j <= 4; j++ {
			for k := 1; k <= 4; k++ {
				for l := 1; l <= 4; l++ {
					if i+j+k+l == 10 && i*j*k*l == 24 {
						way[cnt][0] = i
						way[cnt][1] = j + way[cnt][0]
						way[cnt][2] = k + way[cnt][1]
						way[cnt][3] = l + way[cnt][2]
						for h := 0; h < 4; h++ {
							waybit[cnt] |= 1 << (way[cnt][h] - 1)
						}
						cnt++
					}
				}
			}
		}
	}

	// BFS -> 不超过 4 次 k 可以解决全部问题
	q := []int{0}
	vis := [1024][]int{{}}
	for len(q) > 0 {
		u := q[0]
		q = q[1:]
		for i := 0; i < cnt; i++ {
			v := waybit[i] | u
			if vis[v] != nil {
				continue
			}
			vis[v] = append(vis[v], vis[u]...)
			vis[v] = append(vis[v], i)
			q = append(q, v)
			// fmt.Println(v, vis[v]) -> max len = 4
		}
	}

	ways := [5][]int{}
	for i := 0; i < 1024; i++ {
		ways[len(vis[i])] = append(ways[len(vis[i])], i)
	}

	var n, k int
	fmt.Scan(&n, &k)
	a := make([]int64, n+1)
	for i := 0; i < n; i++ {
		fmt.Scan(&a[i])
	}
	a[n] = a[0]
	var ans int64
	bas := k / (n / 10)
	bas_add := k % (n / 10)
	for h := 0; h < n; h += 10 {
		tn := bas
		if h/10 < bas_add {
			tn++
		}
		maxProfit := int64(-1e10)
		for t := 1; t <= min(4, tn); t++ {
			for i := 0; i < len(ways[t]); i++ {
				b := ways[t][i]
				var profit int64
				for j := 0; j < 10; j++ {
					if (b>>j)&1 == 1 {
						profit += a[h+j+1]
					}
				}
				maxProfit = max(maxProfit, profit)
			}
		}
		ans += maxProfit
	}
	fmt.Println(ans)
}
```

#### 阿里云2024秋招研发岗第一批笔试

##### 小红闯关

> 红在玩一个游戏，这个游戏有 n 个关卡，通过第 i 个关卡需要消耗 $a_i$ 个单位时间，小红必须按从前往后的顺序通过每一个关卡。
>  每通过 k 个关卡，小红会获得一个跳关道具，跳关道具可以在任意一个关卡使用，使用跳关道具后可以不消耗时间直接通过关卡。
> 小红想知道她通过这 n 个关卡，最少需要多少时间。
>
> 第一行输入两个整数 $n,k(1\le n,k\le10^5)$ 代表关卡数量和获得跳关道具的条件。
>
> 第二行输入 $n$ 个整数 $a_1,\cdots, a_n(1\le a_i\le10^5)$ 代表通过每个关卡需要消耗的时间。
>
> 在一行上输出一个整数，表示小红通过这 $n$ 个关卡所需的最少时间。
>
> ```
> 3 2
> 1 3 2
> ```
>
> ```
> 4
> ```
>
> ```
> 6 2
> 1 1 4 5 1 4
> ```
>
> ```
> 7
> ```
>
> ```
> 5 1
> 2 4 5 1 3
> ```
>
> ```
> 2
> ```

倒序遍历，在获得跳关后删掉大根堆的堆顶。

```go
package main

import (
	"container/heap"
	"fmt"
)

// 定义堆元素类型
type IntHeap []int

// 实现heap.Interface接口的方法
func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] < h[j] } // 最小堆
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}

func main() {
	var n, k int
	fmt.Scan(&n, &k)
	a := make([]int, n+1)
	for i := 1; i <= n; i++ {
		fmt.Scan(&a[i])
	}

	// 初始化堆
	h := &IntHeap{}
	heap.Init(h)

	for i := n; i >= 1; i-- {
		if i%k == 0 && h.Len() > 0 {
			heap.Pop(h)
		}
		heap.Push(h, -a[i]) // 使用负数实现最大堆效果
	}

	var ans int64
	for h.Len() > 0 {
		v := heap.Pop(h).(int)
		ans += int64(-v)
	}
	fmt.Println(ans)
}
```

##### 小苯的子串删除

> 小苯有一个长度为 $n$ 的数字串 $s$，他想要将 $s$ 变为 $3$ 的倍数。为此，他可以进行最多一次操作：
>
> - 选择一段区间 $[l,r](1\le l\le r\le n)$，删除 $s_l,\cdots, s_r$ 这一段数位。
>
> 他想知道有多少种不同的删除区间方案，使得 s 是 3 的倍数。请你帮帮他吧。
>
> 第一行输入一个整数 $n(1\le n\le2\times10^{5})$，表示字符串长度。
>
> 第二行输入一个长度为 $n$ 且仅包含数字的字符串 $s$。
>
> 在一行上输出输出一个整数，表示不同的删除方案数。
>
> ```
> 4
> 1233
> ```
>
> ```
> 7
> ```
>
> 共有七种删除方案（注意，不删除/全删除也是删除方案）。

因为 $10^i\equiv1(\bmod3)$，所以等价于和为 $3$ 的子段。前缀和+bin计数优化枚举即可。

```go
package main

import (
	"fmt"
)

func main() {
	var n int
	fmt.Scan(&n)
	var s string
	fmt.Scan(&s)
	dsum := 0
	for i := 0; i < n; i++ {
		dsum += int(s[i] - '0')
	}
	dsum = dsum % 3 // 凑多少
	cnt := [3]int64{1}
	var ans int64
	if dsum == 0 {
		ans++
	}
	if false { // brute check
		ans0 := ans
		for i := 0; i < n; i++ {
			sum := 0
			for j := i; j >= 0; j-- {
				sum += int(s[j] - '0')
				if (dsum-sum%3+3)%3 == 0 {
					ans0++
				}
			}

		}
		fmt.Println(ans0)
	}
	sum := 0
	for i := 0; i < n; i++ {
		sum += int(s[i] - '0')
		// dsum - (sum - x) = 0 -> x = sum - dsum
		ans += cnt[(sum%3-dsum+3)%3]
		cnt[sum%3]++
	}
	fmt.Println(ans)
}
```

##### 小红的完全平方数

> 小红有一个长度为 n 的整数数组 $a$，如果从数组中任选两个数 $a_i,a_j,i\neq j$，他们的乘积都是完全平方数，那么这个数组就是好数组。
>
> 如果现在的数组不是一个好数组，小红可以执行任意多次操作：
>
> - 从数组里选择一个数，将其乘以一个正整数 $x$
>
> 她想知道，最少需要多少次操作才能使数组变成好数组。
>
> 如果一个数可以被表示为一个整数的平方，那么这个数就是完全平方数。
>
> 第一行输入一个整数 $n\left(1 \leq n \leq 10^5\right)$ 代表数组中元素的数量。
> 第二行输入 n 个整数 $a_1, a_2, \dots, a_n\left(1 \leq a_i \leq 10^6\right)$ 代表数组中的元素。
>
> 在一行上输出一个整数，代表最少需要的操作次数。

完全平方数等价于所有质因数出现次数都是偶数的数。

把所有数去掉偶数次质因数后得到 $b$，原问题等价于使得 $b$ 数组完全相等，即求都变成众数肯定是最小的。

```python
import math
from collections import defaultdict

def square_free_part(x):
    factors = {}
    while x % 2 == 0: # 看成卡常的质因数分解
        factors[2] = factors.get(2, 0) + 1
        x = x // 2
    i = 3
    while i * i <= x:
        while x % i == 0:
            factors[i] = factors.get(i, 0) + 1
            x = x // i
        i += 2
    if x > 2:
        factors[x] = 1
    square_free = 1
    for p, exp in factors.items():
        if exp % 2 == 1:
            square_free *= p
    return square_free

def min_operations(n, a):
    sf = [square_free_part(x) for x in a]
    count = defaultdict(int)
    for s in sf:
        count[s] += 1
    max_count = max(count.values())
    return n - max_count

n = int(input())
a = list(map(int, input().split()))

print(min_operations(n, a))
```



> 错误思路：把每个质因数的每个数的次数都变成奇数次或偶数次，多个质因数组合起来搞(TLE)。

#### 2024年淘天集团春招研发岗笔试

##### 小苯的区间删除

> 小苯有一个长度为 n 的数组 a，他想要使得数组 a 有序（单调不降）。
> 为此，他**必须选择一段**区间 $[l,r](1\le l\le r\le n)$，将数组的这一段删除，其他的部分（如果存在的话）就按顺序拼在一起。
>
> 现在他想知道有多少种不同的选择区间的方案。
>
> 注：小苯认为，空数组也满足有序，即你可以选择 $[1,n]$ 这个区间。
>
> 第一行一个正整数 $n(1\le n\le2\times10^5)$，表示数组的长度。
>
> 第二行 $n$ 个正整数 $a_i(1\le a_i\le 10^9)$ 表示数组 $a$。
>
> 输出一行一个正整数表示答案。
>
> ```
> 3
> 1 2 3
> ```
>
> ```
> 6
> ```
>
> ```
> 5
> 1 3 2 2 5
> ```
>
> ```
> 10
> ```

先确定原数组的最长前后缀有序长度；从后缀第一个无序的地方开始遍历右端点 r，那么要在有序子数组里二分查找到第一个 >= nums[r+1] 的下标，l 从最左到这个范围都可以选。可以看力扣2972 / CF1167E

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	var n int
	fmt.Scan(&n)
	a := make([]int, n+1)
	for i := 0; i < n; i++ {
		fmt.Scan(&a[i])
	}
	a[n] = int(1.1e9)
	var ans int64
	inc, dsc := 0, n-1
	for i := 1; i < n; i++ {
		if a[i] >= a[i-1] {
			inc++
		} else {
			break
		}
	}
	for i := n - 2; i >= 0; i-- {
		if a[i] <= a[i+1] {
			dsc--
		} else {
			break
		}
	}
	r := dsc - 1
	if r < 0 {
		r = 0
	}
	// fmt.Println(inc, dsc, a, r)
	for ; r < n; r++ {
		lim := inc
		if lim > r {
			lim = r
		}
		l := sort.SearchInts(a[:lim+1], a[r+1])
		if l > r {
			l = r
		}
		ans += int64(l + 1)
		// fmt.Println(l, r, a[r+1], ans)
	}
	fmt.Println(ans)
}
```

##### 小苯的比赛上分

> 有一款著名的大型多人电子竞技游戏网站“喜爱福”，网站通常会举办一些比赛。通常一名参赛选手只有一个账号，但不难猜到，总会有人“开小号”上分。
> 小苯就是一位该游戏的忠实玩家，他总共有 n 个账号，每个账号的分数分别为 ai。
>
> 他深谙游戏中一位著名玩家 stlk 的一句名言：“只要你永远打分更低的号，那么你的 maxRating 单调不降”。（maxRating 指一名玩家分最高的账号的分数）
>
> 现在我们记录了小苯 m 次的比赛记录，已知小苯每次都会谨记 stlk 的名言，从而使用分数最低的账号参赛，现在我们想知道小苯每次参赛后，他的 maxRating 是多少，请你编写代码来算算吧。
>
> 第一行两个正整数 $n,m(1\le n,m\le10^5)$，分别表示小苯的账号个数，和小苯新参加的比赛记录数。
>
> 第二行 $n$ 个整数 $a_i(0\le a_i\le10^9)$，表示小苯每个账号目前的分数。
>
> 第三行 $m$ 个整数 $b_j(0\le b_j\le10^9)$ 分别表示小苯每次比赛后，分数的变化值。（例如如果小苯使用分数为 $x$ 的账号参赛，那么他在参加完第 $j$ 场比赛后，该账号分数会变为 $x+b_j$。）
>
> 输出包含 m 行，每行一个整数，表示小苯参与完第 j 场比赛后，他的 maxRating 的值。
>
> ```
> 5 6
> 1145 1500 1600 1538 1222
> 10 400 500 1000 2000 10000
> ```
>
> ```
> 1600
> 1600
> 1722
> 2500
> 3538
> 11555
> ```

multiset 动态维护最大：

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    int n, m;
	cin >> n >> m;
	multiset<int> s;
	for (int i = 0, a; i < n; i++) {
	    cin >> a;
		s.insert(a);
	}
	for (int i = 0, b; i < m; i++) {
		int a = *s.begin();
		s.erase(s.begin());
	    cin >> b;
		s.insert(a+b);
		cout << *s.rbegin() << '\n';
	}
}
```

也可以堆，最大就是每次变化分数部分不断更新的 max 值。

```python
import heapq

n, m = map(int, input().split())
scores = list(map(int, input().split()))
changes = list(map(int, input().split()))

max_rating = max(scores)
heap = [(score, i) for i, score in enumerate(scores)]
heapq.heapify(heap)

for change in changes:
    min_score, min_index = heapq.heappop(heap)
    new_score = min_score + change
    scores[min_index] = new_score
    max_rating = max(max_rating, new_score)
    heapq.heappush(heap, (new_score, min_index))
    print(max_rating)
```

##### 小苯的魔法染色

> 小红面前有一个长为 n 的墙 a，（墙由一个个格子构成，方便起见用一个字符串表示），小红想将墙 a 染成全红色的，因此她找到了小苯。小苯是一个魔法师，可以对墙进行施法。墙上施法后的部分会被染红。
>
> 施法的具体过程：首先，小苯会选择一段区间 [l,r] (1≤l≤r≤n)，接着立马，墙上的[l,r][*l*,*r*] 这段区间就会被染红。例如 a=WRWWR，小苯选择 [1,3] 后，a 就会变成 RRRWR。（其中 R 表示红色，W 表示白色。）
>
> 小苯可以施法不超过 m 次，但小红不想小苯因使用魔法太多而走火入魔，因此她限制小苯每一次选择施法的区间长度都必须在 k 以内。
>
> （区间 [l,r] 的长度为 r−l+1。）
>
> 现在小苯想知道自己施法能使得墙全部被染红的最小 k 值是多少，请你帮帮他吧。
>
> 输入包含两行。
> 第一行两个正整数 $n, m\ (1 \leq m \leq n \leq 2\times 10^5)$，分别表示数组 a 的长度和小苯施法的最多次数。
> 第二行一个长度为 n 的字符串，表示墙的初始颜色。（保证只出现 "W"和"R"两种字符）
>
> 输出包含一行一个正整数，表示  k 的最小值。
>
> ```
> 5 2
> WRWWR
> ```
>
> ```
> 2
> ```

二分答案。

```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	var n, m int
	fmt.Scan(&n, &m)
	var s string
	fmt.Scan(&s)
	if strings.Count(s, "W") == 0 {
		fmt.Println(0)
		return
	}
	lf, rf, ans := 1, n, n
	for lf <= rf {
		k := (lf + rf) >> 1
		cnt, last := 0, -1
		for i := 0; i < n; i++ {
			if s[i] == 'W' && i > last {
				cnt++
				last = i + k - 1
			}
		}
		if cnt <= m {
			ans = k
			rf = k - 1
		} else {
			lf = k + 1
		}
	}
	fmt.Println(ans)
}
```

