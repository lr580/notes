所有面试算法题。

# 目录

### 杂项

> [题目名] 代表题目名未知，这里的题目和题解另见他处。

- 好友推荐系统 2

  图论 模拟

- 防护设备 华为2(200分)

  BFS 二分答案

- [消息队列] 优酷/盒马25校招 python

  数据结构

- **磁盘的写入策略** 华为3

  > 不会

- [花呗] 蚂蚁24秋招 python

  数据结构 / 模拟

- [SVM] 蚂蚁24秋招 python

  > 机器学习

- [加法等式字符串] 蚂蚁24秋招 python

  计数 思维/数学

- **村落基站建设** java

  二叉树上DP

- [美食特征值] python

  贪心 

- <u>[表达式插入一个数字]</u> python

  模拟 eval 枚举 字符串 数学

### 牛客

- 美团2024春招第一场笔试

  1. 小美的平衡矩阵

     二维前缀和

  2. 小美的数组询问

     签到 (快读快写)

  3. 小美的MT

     签到

  4. 小美的朋友关系

     并查集 逆向 离散化

  5. 小美的区间删除

     数论 (前缀和+二分 / 滑动窗口)
  
- 美团2024秋招第一场笔试

  11. 小美的密码
  
      签到 (STL)
  
  12. 小美的数组删除
  
      枚举 mex
  
  13. 小美的彩带
  
      离散化 + 莫队 / <u>权值树状数组</u>

# 题目

## 杂项

> 此处题目图片暂不公开。考虑以后有需要 OCR

### 笔试杂题

大部分无法交题，不知道是否AC

#### sample

##### 好友推荐系统

![image-20241010101128472](img/image-20241010101128472.png)

![image-20241010101230458](img/image-20241010101230458.png)

![image-20241010101254829](img/image-20241010101254829.png)

模拟即可

##### 防护设备

![image-20241010101431803](img/image-20241010101431803.png)

![image-20241010101452116](img/image-20241010101452116.png)

二分答案+BFS

#### 24-10-09

##### [消息队列]

![image-20241010101533161](img/image-20241010101533161.png)

![image-20241010101552963](img/image-20241010101552963.png)

![image-20241010101610526](img/image-20241010101610526.png)

我的思路见代码

```python
from collections import deque
n = int(input())
q = [deque() for i in range(101)]
q0 = deque() # 总队列
outed = set() # 所有被取的消息的 i
for i in range(n):
    line = input().split()
    opt = line[0]
    if opt == 'in':
        t = int(line[1])
        s = line[2]
        q0.append((s, t, i))
        q[t].append((s, i))
    else:
        p = int(line[1])
        if p != 0:
            if len(q[p]) == 0:
                print(-1)
            else:
                s, j = q[p].popleft()
                outed.add(j)
                print(s)
        else:
            s = t = -1
            while len(q0) > 0:
                s1, t1, j = q0.popleft()
                if j not in outed:
                    s, t = s1, t1
                    break
            if t == -1:
                print(-1)
            else:
                assert q[t][0][0] == s
                q[t].popleft()
                outed.add(j)
                print(s)
```

这个样例过了

```
15
out 0
out 66
in 66 xyh
in 99 ivyhole
out 3
out 99
in 3 starry
in 6 sky
in 66 starrysky
out 66
out 0
out 3
out 66
out 0
out 0
```

```
-1
-1
-1
ivyhole
xyh
starry
-1
starrysky
sky
-1
```

##### 磁盘的写入策略

![image-20241010101831756](img/image-20241010101831756.png)

![image-20241010101845822](img/image-20241010101845822.png)

不会。

#### 24-10-10 蚂蚁24秋招

##### [花呗]

![image-20241010134528152](img/image-20241010134528152.png)

![image-20241010134534883](img/image-20241010134534883.png)

```java
package opack;

import java.util.HashMap;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        HashMap<String, Integer> limit = new HashMap<>(); // 额度
        HashMap<String, Integer> borrow = new HashMap<>(); // 实际借了多少
        String names[] = new String[n]; // 保持输出顺序
        for(int i=0;i<n;i++) {
            String str = sc.next();
            int m = sc.nextInt();
            limit.put(str, m);
            borrow.put(str, 0);
            names[i] = str;
        }
        int q = sc.nextInt();
        for(int i=0;i<q;i++) {
            String op = sc.next();
            String str = sc.next();
            int x = sc.nextInt();
            if(!limit.containsKey(str)) {
                continue;
            }
            int money = borrow.get(str); // 欠多少
            if(op.equals("+")) { // 还
                if(money < x) {
                    continue;
                }
                borrow.put(str, money - x);
            } else { // 借
                if(money + x >= limit.get(str)) {
                    continue;
                }
                borrow.put(str, money + x);
            }
        }
        for(String name : names) {
            int money = limit.get(name) - borrow.get(name); // 剩余额度
            System.out.println(name + " " + money);
        }
    }
}
/*
3
kou 10000
kotori 28000
ranko 5000
4
- kou 5000
+ kotori 10000
+ kou 2000
- yukari 10000
*/
```

```python
n = int(input())  
limit = {}  
borrow = {}  
names = []  

for i in range(n):
    str_name, m = input().split()
    m = int(m)
    limit[str_name] = m
    borrow[str_name] = 0
    names.append(str_name)

q = int(input())  
for i in range(q):
    op, str_name, x = input().split()
    x = int(x)

    if str_name not in limit:
        continue  

    money = borrow[str_name]  

    if op == "+":  
        if money < x:
            continue  
        borrow[str_name] = money - x
    elif op == "-":  
        if money + x >= limit[str_name]:
            continue  
        borrow[str_name] = money + x


for name in names:
    money = limit[name] - borrow[name]  
    print(f"{name} {money}")
```

##### [SVM]

![image-20241010134731089](img/image-20241010134731089.png)

##### [加法等式字符串]

![image-20241010134804802](img/image-20241010134804802.png)

```python
s = input()
eq_idx = s.find('=')
# suma = int(s[eq_idx+1:])
a = s[:eq_idx].split('+')
'''
case1: abc..+xyz..=xbc..+ayz.. 即所有同位可以换
case2: abc..+xaz..=abc..+xaz.. 即所有不同位同数可以换
'''
cnt = [[0 for i in range(11)] for j in range(11)] # cnt[i][j] 是第 i 位的第 j 个数有几个
count_d = [0 for i in range(11)] # 第 i 位有几个数
count_v = [0 for i in range(11)] # 有几个 i
ans = 0
for num in a:
    n = len(num)
    for i,v in enumerate(num):
        d = n - i - 1 # 第几位
        v = int(v)
        c1 = count_d[d] # case1
        c2 = count_v[v] - cnt[d][v] # case2
        ans += c1 + c2
        cnt[d][v] += 1
        count_d[d] += 1
        count_v[v] += 1
print(ans)

'''
12+12+3=27
1  1
 2  2
 2    3
    2 3

5+10+3=18
5  0
5    3
   0 3
   
111+111=222 (ans=1+2+3+4+5)

123+456+789=1368 (ans=3+3+3)
'''
```

#### 24-10-16盒马秋招

##### [消息队列]

跟上面的题一模一样，AC 了

![image-20241016225527558](img/image-20241016225527558.png)

![image-20241016225536329](img/image-20241016225536329.png)

![image-20241016225539836](img/image-20241016225539836.png)

#### 24-10-23

##### 2.村落基站建设

![image-20241023195239981](img/image-20241023195239981.png)

![image-20241023195247533](img/image-20241023195247533.png)

![image-20241023195255417](img/image-20241023195255417.png)

我的代码：(正确性证明：除非 i 是叶子结点，此时 `dp[i][0]` 不合法，其他情况一定 `i` 子树的 0/1 都是合法的)

```java
package opack;
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String line = sc.nextLine();
        String[] elements = line.split(" ");
        int n = elements.length;
        int a[] = new int[n+1];
        for(int i=0;i<n;i++) {
            a[i+1] = Integer.parseInt(elements[i]);
        }
        if(n==1 && a[1]==1) {
            System.out.println(1);
            return;
        }
        int dp[][] = new int[n+1][2];
        for(int i=n;i>=1;i--) {
            if(a[i]==0) continue;
            int l=i*2, r=i*2+1, lexist=0, rexist=0; 
            if(l<=n && a[l]==1) lexist=1;
            if(r<=n && a[r]==1) rexist=1;
            if(lexist==0 && rexist==0) {
                dp[i][0] = 0;
                dp[i][1] = 1;
            } else if(lexist==1 && rexist==1) {
                dp[i][0] = Math.min(dp[l][1]+dp[r][0], dp[l][0]+dp[r][1]);
                dp[i][0] = Math.min(dp[i][0], dp[l][1]+dp[r][1]);
                dp[i][1] = 1 + dp[i][0];
                dp[i][1] = Math.min(dp[i][1], dp[l][0]+dp[r][0]+1);
            } else if(lexist==1) {
                dp[i][0] = dp[l][1];
                dp[i][1] = 1 + Math.min(dp[l][0], dp[l][1]);
            } else if(rexist==1) {
                dp[i][0] = dp[r][1];
                dp[i][1] = 1 + Math.min(dp[r][0], dp[r][1]);
            }
        }
        System.out.println(Math.min(dp[1][0], dp[1][1]));
    }
}
//1 1 1 1 0 1 1 -> 2
//1 1 0 1 0 0 0 -> 1
//1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
//1 1 0 1 0 0 0 1
//1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1
//1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
//1 1
```

WA: 65 分

考虑左倾树(长=6)，应该是 2，结果是3

参考代码：(不一定AC)

![image-20241023195355786](img/image-20241023195355786.png)

AC 代码：

![image-20241023203145743](img/image-20241023203145743.png)

其中 `f[i,1,j]` 与 `dp[i,j]` 一样，`f[i,0,0]` 是当前点没放，当如果父节点放了当前就合法(等待父亲激活)的状况，其中 `f[i,1,0]` 是它的儿子有 1。(后话)其实感觉不如写成 `dp[n+1][3]` 就是了，这样还能 for for 取 min

```
dp[i][0]表示当前i子树当前第i个点不建立基站，但是它的儿子有基站(即i子树合法)的最小基站数
dp[i][1]表示当前i子树当前第i个点建立基站的最小基站数
dp2[i]表示当前i子树第i个点不建立基站，且儿子也不建立基站，当前子树的最小基站数(dp2本身不合法，但是dp[f][1]可以取dp2作儿子使得f合法)
初始值是叶节点s(dp[s][1]=1,dp2[s]=0,且dp[s][0]无解设为无穷)
对单个儿子的直接按这个儿子按DP含义易得转移
对两个儿子的，dp[i][0]可以取儿子l/r任意一个有基站或都有，3种情况
对dp[i][1]，儿子任取3x3=9种情况(dp[0],dp[1],dp2)^2
答案就是根节点的dp最小值
```

AC 否未知的两个改版代码：然后最后只给了 65

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String line = sc.nextLine();
        String[] elements = line.split(" ");
        int n = elements.length;
        int a[] = new int[n+4];
        for(int i=0;i<n;i++) {
            a[i+1] = Integer.parseInt(elements[i]);
        }
        int dp[][] = new int[n+1][3], dp2[] = new int[n+1];
        for(int i=n;i>=1;i--) {
            if(a[i]==0) continue;
            int l=i*2, r=i*2+1, lexist=0, rexist=0; 
            if(l<=n && a[l]==1) lexist=1;
            if(r<=n && a[r]==1) rexist=1;
            dp[i][1] = Integer.MAX_VALUE / 4;
            if(lexist==0 && rexist==0) {
                dp[i][0] = Integer.MAX_VALUE / 4;
                dp[i][1] = 1;
                dp[i][2] = 0;
            } else if(lexist==1 && rexist==1) {
                dp[i][0] = Math.min(dp[l][1]+dp[r][0], dp[l][0]+dp[r][1]);
                dp[i][0] = Math.min(dp[i][0], dp[l][1]+dp[r][1]);
                for(int jl=0;jl<3;jl++) for(int jr=0;jr<3;jr++)
                    dp[i][1] = Math.min(dp[i][1], dp[l][jl]+dp[r][jr]+1);
                dp[i][2] = dp[l][0] + dp[r][0];
            } else if(lexist==1) {
                dp[i][0] = dp[l][1];
                for(int j=0;j<3;j++) dp[i][1]=Math.min(dp[i][1], 1+dp[l][j]);
                dp[i][2] = dp[l][0];
            } else if(rexist==1) {
                dp[i][0] = dp[r][1];
                for(int j=0;j<3;j++) dp[i][1]=Math.min(dp[i][1], 1+dp[r][j]);
                dp[i][2] = dp[r][0];
            }
        }
        System.out.println(Math.min(dp[1][0], dp[1][1]));
    }
}
```

```java
package opack; //提交版
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String line = sc.nextLine();
        String[] elements = line.split(" ");
        int n = elements.length;
        int a[] = new int[n+4];
        for(int i=0;i<n;i++) {
            a[i+1] = Integer.parseInt(elements[i]);
        }
//        if(a[1] == 1 && a[2] == 0 && a[3] == 0) {
//            System.out.println(1);
//            return;
//        }
        int dp[][] = new int[n+1][2], dp2[] = new int[n+1];
        for(int i=n;i>=1;i--) {
            if(a[i]==0) continue;
            int l=i*2, r=i*2+1, lexist=0, rexist=0; 
            if(l<=n && a[l]==1) lexist=1;
            if(r<=n && a[r]==1) rexist=1;
            if(lexist==0 && rexist==0) {
                dp[i][0] = Integer.MAX_VALUE / 4;
                dp[i][1] = 1;
                dp2[i] = 0;
            } else if(lexist==1 && rexist==1) {
                dp[i][0] = Math.min(dp[l][1]+dp[r][0], dp[l][0]+dp[r][1]);
                dp[i][0] = Math.min(dp[i][0], dp[l][1]+dp[r][1]);
                dp[i][1] = 1 + dp[i][0];
                dp[i][1] = Math.min(dp[i][1], dp[l][0]+dp[r][0]+1);
                dp[i][1] = Math.min(dp[i][1], dp2[l]+dp2[r]+1);
                dp[i][1] = Math.min(dp[i][1], dp2[l]+dp[r][0]+1);
                dp[i][1] = Math.min(dp[i][1], dp2[l]+dp[r][1]+1);
                dp[i][1] = Math.min(dp[i][1], dp[l][0]+dp2[r]+1);
                dp[i][1] = Math.min(dp[i][1], dp[l][1]+dp2[r]+1);
                dp2[i] = dp[l][0] + dp[r][0];
            } else if(lexist==1) {
                dp[i][0] = dp[l][1];
                dp[i][1] = 1 + Math.min(Math.min(dp[l][0], dp[l][1]), dp2[l]);
                dp2[i] = dp[l][0];
            } else if(rexist==1) {
                dp[i][0] = dp[r][1];
                dp[i][1] = 1 + Math.min(Math.min(dp[r][0], dp[r][1]), dp2[r]);
                dp2[i] = dp[r][0];
            }
        }
        System.out.println(Math.min(dp[1][0], dp[1][1]));
    }
}
//1 1 1 1 0 1 1 -> 2
//1 1 0 1 0 0 0 -> 1
//1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
//->5
//1 1 0 1 0 0 0 1
//->2
//1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1
//1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
//1 1
//1 1 0 1
//1 1 1 1 1 0 1 1 0 0 1
```

#### 24-11-02

##### [美食特征值]

![image-20241102215142850](img/image-20241102215142850.png)

对每个重复值x，用已知最大值m加上去，得到新的最大值并消除了该重复值
x原本在[1,m]，加了m在[1+m,2m]之内，不会落在原区间
以此类推，如果还有第二个重复值y在[1,m]，用新的m(即m+x)加上去得到的值一定不会落在[1,m+x]，至少在m+1+x或以上

```python
n=int(input())
a=[int(i) for i in input().split()]
# a.sort(reverse=True)
m=max(a)
ans=0
d=set()
for i,x in enumerate(a):
    if x not in d:
        d.add(x)
    else:
        ans+=1
        a[i]+=m
        assert a[i] not in d
        d.add(a[i])
        m=max(m,a[i])
assert len(set(a)) == len(a)
print(ans)
```

##### [表达式插入一个数字]

![image-20241102215349932](img/image-20241102215349932.png)

暴力的话会超时，是因为eval是On的，字符串插入字符得到新字符串也是O(n)的，一共对O(n)个位子每个位置尝试10次，每次尝试On，所以复杂度是O(10T*n*n)，可能会被卡掉

所以用一种局部尝试的办法来做，因为每个数字<1e9，所以对一个数字的插入方案最多有`(9+1)*10=100个`，对每个数字单独修改，考虑它对整体的变化如果对x修改，那么`...+a+b+c*d*...*x*...*e*f+g+h+...`，里，发现只有跟x相关的连乘积受到影响，所以只需要修改这个连乘积的值，其他部分不变，看看修改后是否等式相等

这样做主要是把字符串拼接的复杂度优化掉了，也不需要每次都eval
那么枚举修改的次数还是O((10n)的，每次修改是O1的，故复杂度变成了O(10Tn)

9% AC 代码：

```python
T = int(input())
for _ in range(T):
    eq = input()
    leq, req = eq.split('=')
    lval, rval = eval(leq), eval(req)
    if lval == rval:
        print('Yes')
        continue
    def f(eq):
        add_eq = eq.split('+')
        mul_eq = []
        for sub_eq in add_eq:
            sub_val = eval(sub_eq)
            mul_eq.append([sub_val, []])
            for sub_sub_eq in sub_eq.split('*'):
                mul_eq[-1][1].append(sub_sub_eq)
        return mul_eq
    leq = f(leq)
    req = f(req)
    def g(eq, lval, rval):
        for g in eq:
            k = g[0]
            for x in g[1]:
                k2 = 10**len(x)
                xl = 0
                xr = int(x)
                for d in x+'0':
                    for j in range(10):
                        newx = xl*k2*10+j*k2+xr
                        newk = k // int(x) * newx
                        if lval - k + newk == rval:
                            print(g[1],x,newx)
                            return True
                    xl = xl * 10 + int(d)
                    k2 //= 10
                    xr = xr - k2 * int(d)
        return False
    ok = g(leq, lval, rval) or g(req, rval, lval)
    print('Yes' if ok else 'No')
```

> 暴力：还挺快的，就是爆零
>
> 不过我本机跑最大数据发现其实暴力也挺快的，最大数据量1秒多也能跑完，感觉暴力也行才对怎么会0%呢我觉得有点奇怪
>
> ```python
> T = int(input())
> for _ in range(T):
>  eq = input()
>  leq, req = eq.split('=')
>  lval, rval = eval(leq), eval(req)
>  if lval == rval:
>      print('Yes')
>      continue
>  def g(leq, rval):
>      for i in range(1+len(leq)):
>          l = 1 if (i<len(leq) and leq[i].isdigit()) else 0
>          for j in range(l,10):
>              new_leq = leq[:i] + str(j) + leq[i:]
>              if eval(new_leq) == rval:
>                  return True
>      return False
>  ok = g(leq, rval) or g(req, lval)
>  print('Yes' if ok else 'No')
> ```

我的测试数据：

```python
'''
6
16=1+2*3
7*8*9=54
1+1=1+22
4*6=22+2
15+7=1+2
11+1=1+5
'''
'''
Yes
Yes
No
Yes
Yes
No
'''

'''
2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2=2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*29
2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2=2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*299
2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2=2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*4*1
6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7=6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*68+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7
6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7=6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*688+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7*6+7
9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9=9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9
9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+89+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9=9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9
9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9=9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+100
9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9=9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+9+1000
89898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898*3+1=898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898982*3+1
289898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898*3+1=89898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898*3+1
'''
```

对拍：

```python
def solve(eq):
    leq, req = eq.split('=')
    lval, rval = eval(leq), eval(req)
    if lval == rval:
        return 'Yes'
    def f(eq):
        add_eq = eq.split('+')
        mul_eq = []
        for sub_eq in add_eq:
            sub_val = eval(sub_eq)
            mul_eq.append([sub_val, []])
            for sub_sub_eq in sub_eq.split('*'):
                mul_eq[-1][1].append(sub_sub_eq)
        return mul_eq
    leq = f(leq)
    req = f(req)
    def g(eq, lval, rval):
        for g in eq:
            k = g[0]
            for x in g[1]:
                k2 = 10**len(x)
                xl = 0
                xr = int(x)
                for d in x+'0':
                    for j in range(10):
                        newx = xl*k2*10+j*k2+xr
                        newk = k // int(x) * newx
                        if lval - k + newk == rval:
                            return True
                    xl = xl * 10 + int(d)
                    k2 //= 10
                    xr = xr - k2 * int(d)
        return False
    ok = g(leq, lval, rval) or g(req, rval, lval)
    return 'Yes' if ok else 'No'
def solve2(eq):
    leq, req = eq.split('=')
    lval, rval = eval(leq), eval(req)
    if lval == rval:
        return 'Yes'
    def g(leq, rval):
        for i in range(1+len(leq)):
            l = 1 if (i<len(leq) and leq[i].isdigit()) else 0
            for j in range(l,10):
                new_leq = leq[:i] + str(j) + leq[i:]
                if eval(new_leq) == rval:
                    return True
        return False
    ok = g(leq, rval) or g(req, lval)
    return 'Yes' if ok else 'No'
from random import randint, choice
mn=1000
def random_eq(n, lim=int(1e9)):
    nums = [str(randint(1,lim)) for i in range(n)]
    ope = [choice('*+') for i in range(n-1)]
    return ''.join([nums[i]+ope[i] for i in range(n-1)])+nums[-1]
for i in range(100):
    n = randint(1, mn)
    leq = random_eq(n)
    m = randint(0, n)
    while True:
        req = leq[:m] + str(randint(0,9)) + leq[m:]
        try:
            eval(req)
            break
        except:
            pass
    if randint(0,1):
        eq = leq+'='+req
    else:
        eq = req+'='+leq
    ans = solve(eq)
    # print(eq, ans)
    if ans != 'Yes':
        print(eq)
        print('equal answers as not equal', ans)
        break
for i in range(100):
    leq = req = '1'
    while leq == req:
        leq = random_eq(randint(1,mn))
        req = random_eq(randint(1,mn))
    eq = leq + '=' + req
    ans = solve(eq)
    if ans != 'No':
        print(eq)
        print('(possibly) not equal answers as equal')
        break
```

## 牛客

#### 美团2024春招第一场笔试

##### 小美的平衡矩阵

[题目](https://www.nowcoder.com/exam/test/85806188/submission?examPageSource=Company&pid=55750560&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26tagIds%3D179&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91)

> 小美拿到了一个 $n \times n$ 的矩阵，其中每个元素是 0 或者 1。小美认为一个矩形区域是完美的，当且仅当该区域内 0 的数量恰好等于 1 的数量。
>
> 现在，小美希望你回答有多少个 $i \times i$ 的完美矩形区域。你需要回答 $1 \leq i \leq n$ 的所有答案。
>
> 第一行输入一个正整数 $n$，代表矩阵大小。  
> 接下来的 $n$ 行，每行输入一个长度为 $n$ 的 01 串，用来表示矩阵。  
> $1 \leq n \leq 200$
>
> 输出 $n$ 行，第 $i$ 行输出 $i \times i$ 的完美矩形区域的数量。
>
> ```
> 4
> 1010
> 0101
> 1100
> 0011
> ```
>
> ```
> 0
> 7
> 0
> 1
> ```

二维前缀和，枚举端点，复杂度 $O(n^3)$。

```c++
import java.util.Scanner;
import java.util.ArrayList;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        String a[] = new String[n];
        for(int i=0;i<n;++i) {
            a[i] = in.next();
        }
        int s[][] = new int[n+1][n+1];
        for(int i=1;i<=n;++i) {
            for(int j=1;j<=n;++j) {
                s[i][j] = s[i-1][j] +s[i][j-1] - s[i-1][j-1] + (a[i-1].charAt(j-1) - '0');
            }
        }
        for(int i=1;i<=n;++i) {
            int cnt = 0;
            for(int x=i;x<=n;++x) {
                for(int y=i;y<=n;++y) {
                    int num1 = s[x][y] - s[x-i][y] - s[x][y-i] + s[x-i][y-i];
                    int num0 = i*i - num1;
                    cnt += num1 == num0 ? 1 : 0;
                }
            }
            System.out.println(cnt);
        }
    }
}
```

##### 小美的数组询问

> 小美拿到了一个由正整数组成的数组，但其中有一些元素是未知的（用 0 来表示）。现在小美想知道，如果那些未知的元素在区间 $[l, r]$ 范围内随机取值的话，数组所有元素之和的最小值和最大值分别是多少？共有 $q$ 次询问。
> 
> - 第一行输入两个正整数 $n, q$，代表数组大小和询问次数。
> - 第二行输入 $n$ 个整数 $a_i$，其中如果输入的 $a_i$ 为 0，那么说明 $a_i$ 是未知的。
> - 接下来的 $q$ 行，每行输入两个正整数 $l, r$，代表一次询问。
> 
> 限制条件：
> - $1 \leq n, q \leq 10^5$  
> - $0 \leq a_i \leq 10^9$  
> - $1 \leq l \leq r \leq 10^9$
> 
> 输出 $q$ 行，每行输出两个正整数，代表所有元素之和的最小值和最大值。
> 
> 输入例子：
> ```
> 3 2
> 1 0 3
> 1 2
>4 4
> ```
> 输出例子：
> ```
> 5 6
>8 8
> ```
> 只有第二个元素是未知的。 
> 第一次询问，数组最小的和是 $1 + 1 + 3 = 5$，最大的和是 $1 + 2 + 3 = 6$。 
>第二次询问，显然数组的元素和必然为 $8$。

java 要快读，不然可能会超时。

```java
import java.util.Scanner;
import java.io.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    static StreamTokenizer scanner = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

    public static int nextInt() throws IOException {// 快约一倍
        scanner.nextToken();
        return (int) scanner.nval;
    }

    public static long nextLong() throws IOException {
        scanner.nextToken();
        return (long) scanner.nval;
    }

    public static void main(String[] args) throws IOException {
       // Scanner in = new Scanner(System.in);
        int num0 = 0;
        long suma = 0;
        int n = nextInt();
        int q = nextInt();
        for(int i=0;i<n;++i) {
            int a = nextInt();
            if(a==0) {
                ++num0;
            }else{
                suma+=a;
            }
        }
        while(q-->0) {
            long l=nextLong(), r=nextLong();
            out.print((suma+l*num0)+" ");
            out.println(suma+r*num0);
        }
        out.close();
    }
}
```

##### 小美的MT

> MT 是美团的缩写，因此小美很喜欢这两个字母。现在小美拿到了一个仅由大写字母组成字符串，她可以最多操作 $k$ 次，每次可以修改任意一个字符。小美想知道，操作结束后最多共有多少个 'M' 和 'T' 字符？
>
> - 第一行输入两个正整数 $n, k$，代表字符串长度和操作次数。
> - 第二行输入一个长度为 $n$ 的、仅由大写字母组成的字符串。
>
> 限制条件：
> - $1 \leq k \leq n \leq 10^5$
>
> 输出操作结束后最多共有多少个 'M' 和 'T' 字符。
>
> ```
> 5 2
> MTUAN
> ```
>
> ```
> 4
> ```
>
> 修改第三个和第五个字符，形成的字符串为 MTTAM，这样共有 4 个'M'和'T'。

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt(), k = in.nextInt();
        String s = in.next();
        int cnt = 0;
        for(int i=0;i<n;++i) {
            char c = s.charAt(i);
            cnt += (c=='M'||c=='T') ? 1 : 0;
            //System.out.println(cnt);
        }
        System.out.println(Math.min(n, cnt+k));
    }
}
```

##### 小美的朋友关系

> 小美认为，在人际交往中，随着时间的流逝，朋友的关系会慢慢变淡，最终朋友关系就淡忘了。现在初始有一些朋友关系，存在一些事件会导致两个人淡忘了他们的朋友关系。小美想知道某一时刻中，某两人是否可以通过朋友介绍互相认识？
>
> 事件共有 2 种：
> 1. `1 u v`：代表编号 $u$ 的人和编号 $v$ 的人淡忘了他们的朋友关系。
> 2. `2 u v`：代表小美查询编号 $u$ 的人和编号 $v$ 的人是否能通过朋友介绍互相认识。
>
> > 注：介绍可以有多层，比如 2 号把 1 号介绍给 3 号，然后 3 号再把 1 号介绍给 4 号，这样 1 号和 4 号就认识了。
>
> - 第一行输入三个正整数 $n, m, q$，代表总人数，初始的朋友关系数量，发生的事件数量。
> - 接下来的 $m$ 行，每行输入两个正整数 $u, v$，代表初始编号 $u$ 的人和编号 $v$ 的人是朋友关系。
> - 接下来的 $q$ 行，每行输入三个正整数 $op, u, v$，含义如题目描述所述。
>
> 限制条件：
> - $1 \leq n \leq 10^9$
> - $1 \leq m, q \leq 10^5$
> - $1 \leq u, v \leq n$
> - $1 \leq op \leq 2$
> - 保证至少存在一次查询操作。
>
> 对于每次 `2` 号操作，输出一行字符串代表查询的答案。如果编号 $u$ 的人和编号 $v$ 的人能通过朋友介绍互相认识，则输出 "Yes"。否则输出 "No"。
>
> ```
> 5 3 5
> 1 2
> 2 3
> 4 5
> 1 1 5
> 2 1 3
> 2 1 4
> 1 1 2
> 2 1 3
> ```
>
> ```
> Yes
> No
> No
> ```
>
> 第一次事件，1 号和 5 号本来就不是朋友，所以无事发生。
> 第二次事件是询问，1 号和 3 号可以通过 2 号的介绍认识。
> 第三次事件是询问，显然 1 号和 4 号无法互相认识。
> 第四次事件，1 号和 2 号淡忘了。
> 第五次事件，此时 1 号无法再经过 2 号和 3 号互相认识了。

离散化。对不在询问里的初始朋友关系，并查集直接设置，逆序遍历询问，一边处理一边逆向遗忘；加特判缝缝补补修WA所以很乱。Java 可以快读快写。

```java
import java.util.Scanner;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.HashMap;
import java.io.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    static StreamTokenizer scanner = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

    public static int nextInt() throws IOException {// 快约一倍
        scanner.nextToken();
        return (int) scanner.nval;
    }

    public static long nextLong() throws IOException {
        scanner.nextToken();
        return (long) scanner.nval;
    }

    static int fa[], n1;
    static int findFa(int x0) {
        int x=hget(x0);
        if(x>=n1) {
            //System.out.println("!!!"+x0+" "+n1+" "+x);
            return (int)(1e9+7)+x0;
        }
        //System.out.println("?"+x0+" "+n1+" "+x);
        while(x!=fa[x]) {
            x=fa[x]=fa[fa[x]];
        }
        return x;
    }
    static HashMap<Integer, Integer> h2;
    static int hget(int x) {
        if(!h2.containsKey(x)) {
            h2.put(x, h2.size());
        }
        return h2.get(x);
    }
    public static void main(String[] args) throws IOException {
        //Scanner in = new Scanner(System.in);
        int n = nextInt(), m = nextInt(), q = nextInt();
        int cmd[][] = new int[q][4];
        HashSet<Long> h = new HashSet<>();
        int nn = (int)(1e9+7);
        h2 = new HashMap<>();
        for(int i=0;i<m;++i) {
            int u = nextInt(), v = nextInt();
            int x = Math.min(u, v), y = Math.max(u, v);
            hget(x);
            hget(y);
            h.add((long)x*nn+y);
        }
        n1 = h2.size();
        for(int i=0;i<q;++i) {
            cmd[i][0] = nextInt();
            int u = nextInt(), v = nextInt();
            int x = Math.min(u, v), y = Math.max(u, v);
            boolean valid = h.contains((long)x*nn+y);
            cmd[i][1] = x;
            cmd[i][2] = y;
            hget(x);
            hget(y);
            if(valid) {
                if(cmd[i][0] == 1) {
                    h.remove((long)x*nn+y);
                }
            }else {
                cmd[i][3]=1;
            }
        }
        
        // for(int x:h2.keySet()) {
        //     System.out.println(x+" "+ h2.get(x));
        // }
        fa = new int[n1];
        for(int i=0;i<n1;++i) {
            fa[i]=i;
        }
        for(Long pr:h) {
            int u=(int)(pr/nn), v=(int)(pr%nn);
            fa[findFa(u)]=findFa(v);
        }
        ArrayList<Boolean> ans = new ArrayList<>();
        for(int i=q-1;i>=0;--i) {
            int u=findFa(cmd[i][1]), v=findFa(cmd[i][2]);
            //System.out.println("?");
            if(cmd[i][0]==1) {
                if(cmd[i][3]==1) {
                    continue;
                }
                if(u>=n1||v>=n1) continue;
                fa[u]=v;
            }else {
                if(u>=n1||v>=n1) {
                    ans.add(false);
                    continue;
                }
                ans.add(fa[u]==fa[v]);
            }
        }
        for(int i=ans.size()-1;i>=0;--i) {
            out.println(ans.get(i)?"Yes":"No");
        }
        out.close();
    }
}
```

##### 小美的区间删除

> 从一个大小为 $n$ 的数组中删除一个区间，以使得剩余所有元素的乘积末尾至少有 $k$ 个 0。小美想知道一共有多少种不同的删除方案。
>
> - 第一行输入两个正整数 $n, k$。
> - 第二行输入 $n$ 个正整数 $a_i$，代表小美拿到的数组。
>
> 限制条件：
> - $1 \leq n, k \leq 10^5$  
> - $1 \leq a_i \leq 10^9$
>
> 输出一个整数，代表删除的方案数。
>
> ```
> 5 2
> 2 5 3 4 20
> ```
>
> ```
> 4
> ```
>
> 第一个方案，删除[3]。
> 第二个方案，删除[4]。
> 第三个方案，删除[3,4]。
> 第四个方案，删除[2]。

0数量=2因子数和5因子数的最小值。

解法一：前缀和处理，然后枚举每一个区间右端点并二分得到左端点。

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt(), k = in.nextInt();
        int s2[] = new int[n+1], s5[] = new int[n+1];
        for(int i=1;i<=n;++i) {
            int a = in.nextInt();
            while(a%2==0) {
                ++s2[i];
                a/=2;
            }
            while(a%5==0) {
                ++s5[i];
                a/=5;
            }
            //System.out.println(s2[i]+" "+s5[i]);
            s2[i]+=s2[i-1];
            s5[i]+=s5[i-1];
        }
        //System.out.println(s2[n]+" "+s5[n]);
        long ans=0;
        for(int r=1;r<=n;++r) {
            int lf=1, rf=r, l=r+1;
            while(lf<=rf) {
                int cf=(lf+rf)>>1;
                int m2 = s2[r] - s2[cf-1];
                int m5 = s5[r] - s5[cf-1];
                //System.out.println(cf+" "+r+" "+m2+" "+m5);
                int n0 = Math.min(s2[n]-m2, s5[n]-m5);
                if(n0>=k) {
                    l=cf;
                    rf=cf-1;
                }else{
                    lf=cf+1;
                }
            }
            //System.out.println(l+" "+r);
            ans+=Math.max(0, r-l+1);
        }
        System.out.println(ans);
    }
}
```

解法二：滑动窗口。

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt(), k = in.nextInt();
        int n2[] = new int[n], n5[] = new int[n];
        int s2=0,s5=0;
        for(int i=0;i<n;++i) {
            int a = in.nextInt();
            while(a%2==0) {
                ++n2[i];
                a/=2;
            }
            while(a%5==0) {
                ++n5[i];
                a/=5;
            }
            s2+=n2[i];
            s5+=n5[i];
        }
        long ans=0;
        int c2=0,c5=0;
        for(int r=0,l=0;r<n;++r) {
            c2+=n2[r];
            c5+=n5[r];
            while(l<=r&&Math.min(s5-c5,s2-c2)<k) {
                c2-=n2[l];
                c5-=n5[l];
                l+=1;
            }
            ans+=Math.max(0,r-l+1);
        }
        System.out.println(ans);
    }
}
```

#### 美团2024秋招第一场笔试

##### 小美的密码

> # 问题描述
>
> 小美准备登录美团，需要输入密码。小美忘记了密码，只记得密码可能是 `n` 个字符串中的一个。小美会按照密码的长度从小到大依次尝试每个字符串，对于相同长度的字符串，小美随机尝试，并且相同的密码只会尝试一次。小美想知道，她最少需要尝试多少次才能登录成功，最多需要尝试多少次才能登录成功。
>
> 小美不会重新尝试已经尝试过的字符串。成功登录后会立即停止尝试。
>
> - 第一行输入一个整数 `n`（`1 ≤ n ≤ 1000`），代表密码字符串的个数。
> - 第二行输入一个只由小写字母组成的字符串 `s`（`1 ≤ |s| ≤ 1000`），代表正确的密码。
> - 接下来 `n` 行，每行输入一个长度不超过 `1000` 的字符串，代表小美记得的密码。
>
> 在一行上输出两个整数，表示最少和最多尝试次数。
>
> ```
> 4
> ab
> abc
> ab
> ac
> ac
> ```
>
> ```
> 1 2
> ```
>
> 小美可能按照 ["ab", "ac", "abc"] 的顺序尝试，第一次尝试成功，也可能按照 ["ac", "ab", "abc"] 的顺序尝试，第二次尝试成功。
>
> 小美在尝试 "ac" 发现不正确后不会继续尝试 "ac"。

签到。

```java
import java.util.Scanner;
import java.util.TreeMap;
import java.util.HashSet;
import java.util.Map;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        TreeMap<Integer, Integer> m = new TreeMap<>();
        HashSet<String> p = new HashSet<>();
        String t = in.next();
        for(int i=0;i<n;++i) {
            p.add(in.next());
        }
        int cnt2 = -1;
        for(String s : p) {
            if (t.equals(s)) {
                ++cnt2;
            }
            int l = s.length();
            m.put(l, 1+m.getOrDefault(l,0));
        }
        int l = t.length(), cnt = 0;
        for(Map.Entry<Integer, Integer> it : m.entrySet()) {
            int l2 = it.getKey(), s = it.getValue();
            if(l2 < l) {
                cnt += s;
            } else {
                System.out.println((cnt+1)+" "+(cnt+s-cnt2));
                break;
            }
        }
    }
}
```

##### 小美的数组删除

> 小美有一个长度为 $ n $ 的数组 $ a_1, a_2, \dots, a_n $，他可以对数组进行如下操作：
>
> - **删除第一个元素 $ a_1 $**，同时数组的长度减一，花费为 $ x $。
> - **删除整个数组**，花费为 $ k \times \text{MEX}(a) $（其中 $ \text{MEX}(a) $ 表示 $ a $ 中未出现过的最小非负整数。例如 $[0,1,2,4]$ 的 $ \text{MEX} $ 为 $ 3 $）。
>
> 小美想知道将数组 $ a $ 全部清空的最小代价是多少，请你帮帮他吧。
>
> 每个测试文件均包含多组测试数据。第一行输入一个整数 $ T $（$ 1 \le T \le 1000 $）代表数据组数，每组测试数据描述如下：
>
> - 第一行输入三个正整数 $ n, k, x $（$ 1 \leq n \leq 2 \times 10^5 $，$ 1 \leq k, x \leq 10^9 $），分别代表数组中的元素数量、删除整个数组的花费系数、删除单个元素的花费。
> - 第二行输入 $ n $ 个整数 $ a_1, a_2, \dots, a_n $（$ 0 \leq a_i \leq n $），表示数组元素。
> - 除此之外，保证所有的 $ n $ 之和不超过 $ 2 \times 10^5 $。
>
> 对于每一组测试数据，在一行上输出一个整数，表示将数组中所有元素全部删除的最小花费。
>
> ```
> 1
> 6 3 3
> 4 5 2 3 1 0
> ```
>
> ```
> 15
> ```
>
> - 若不执行操作一就全部删除，$ \text{MEX}\{4,5,2,3,1,0\} = 6 $，花费 $ 18 $；
> - 若执行一次操作一后全部删除，$ \text{MEX}\{5,2,3,1,0\} = 4 $，花费 $ 3 + 12 $；
> - 若执行两次操作一后全部删除，$ \text{MEX}\{2,3,1,0\} = 4 $，花费 $ 6 + 12 $；
> - 若执行三次操作一后全部删除，$ \text{MEX}\{3,1,0\} = 2 $，花费 $ 9 + 6 $；
> - 若执行四次操作一后全部删除，$ \text{MEX}\{1,0\} = 2 $，花费 $ 12 + 6 $；
> - 若执行五次操作一后全部删除，$ \text{MEX}\{0\} = 1 $，花费 $ 15 + 3 $；
> - 若执行六次操作一，$ \text{MEX}\{\} = 0 $，花费 $ 18 $。
>

倒序遍历枚举，set 维护 MEX

```java
import java.util.Scanner;
import java.util.HashSet;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int T = in.nextInt();
        while(T-->0) {
            int n = in.nextInt(), k = in.nextInt(), x = in.nextInt();
            int a[] = new int[n];
            for(int i=0;i<n;++i) {
                a[i] = in.nextInt();
            }
            HashSet<Integer> h = new HashSet<>();
            long ans = (long)n * x;
            int mex = 0;
            for(int i=n-1;i>=0;--i) {
                h.add(a[i]);
                while(h.contains(mex)) {
                    ++mex;
                }
                ans = Math.min(ans, (long)i*x + (long)k*mex);
            }
            System.out.println(ans);
        }
    }
}
```

##### 小美的彩带

> 小美的彩带是由一条长度为 $ n $ 的彩带无限循环得到的。彩带的每一个位置都有一个颜色，用 $ a_i $ 表示。因此当 $ i > n $ 时，$ a_i = a_{i-n} $。
>
> 小美每次会从左往右或从右往左剪一段长度为 $ x $ 的彩带，她想知道每次剪下来的彩带有多少种颜色。
>
> - 第一行输入两个整数 $ n, q $（$ 1 \leq n, q \leq 2 \times 10^5 $），分别代表彩带长度和剪彩带次数。
> - 第二行输入 $ n $ 个整数 $ a_1, a_2, \dots, a_n $（$ 1 \leq a_i \leq 10^9 $），代表彩带每一个位置的颜色。
> - 此后 $ q $ 行，每行输入一个字符 $ c $ 和一个整数 $ x $（$ 1 \leq x \leq 10^9 $，$ c \in \{ \text{'L'}, \text{'R'} \} $），代表裁剪方向和裁剪长度。其中：
>   - `'L'` 表示从左往右剪，
>   - `'R'` 表示从右往左剪。
>
> 对于每一次裁剪彩带，在一行上输出一个整数，代表剪下来的彩带中颜色的数量。
>
> ```
> 6 3
> 1 1 4 5 1 4
> L 2
> L 3
> R 12
> ```
>
> ```
> 1
> 3
> 3
> ```
>
> 1. 第一次剪彩带，剪下来的是 $[1, 1]$，有 $\{1\}$ 这 1 种颜色； 
> 2. 第二次剪彩带，剪下来的是 $[4, 5, 1]$，有 $\{1, 4, 5\}$ 这 3 种颜色； 
> 3. 第三次剪彩带，剪下来的是 $[1, 1, 4, 5, 1, 4, 1, 1, 4, 5, 1, 4]$，有 $\{1, 4, 5\}$ 这 3 种颜色。 

可以看看当前属于第几个取模，注意负数-1不然0这一块多一块。

莫队处理，记得加inline，把unmap用离散化换掉说不定更快。可能不过可能过，看评测抖动

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5+3;
int a[maxn*2], sq, ans[maxn];
struct query {
    int l, r, i;
    bool operator<(const query &x) const
    {
        if (l / sq != x.l / sq)
            return l < x.l;
        if (l / sq & 1)
            return r < x.r;
        return r > x.r;
    }
} cmd[maxn];
unordered_map<int,int> cnt;
int sum;
inline void add(int i) {
    sum += cnt[a[i]]++ == 0;
}
inline void del(int i) {
    sum -= --cnt[a[i]] == 0;
}
signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int n, q;
    cin >> n >> q;
    for(int i=0;i<n; ++i) cin >> a[i];
    for(int i=0;i<n; ++i) a[i+n]=a[i];
    int li = 0, ri = n - 1;
    for(int qi=0;qi<q;++qi) {
        char cm;
        int len,l,r;
        cin >> cm >> len;
        if(cm=='L') {
            l=li, r=li+len-1;
            li=(li+len)%n;
        }else{
            r=ri, l=ri-len+1;
            ri=(ri-len%n+n)%n;
        }
        int lb=l/n-(l<0), rb=r/n-(r<0);
        // cout << l << " " << r << " " << lb << " " << rb << " : ";
        l=(l%n+n)%n, r=(r%n+n)%n;
        if(abs(lb-rb)>=2) {
            cmd[qi] = {0, n-1, qi};
        } else if(lb==rb) {
            cmd[qi] = {l, r, qi};
        } else {
            cmd[qi] = {l, n+r, qi};
        }
    }
    sq=sqrt(n*2);
    sort(cmd, cmd+q);
    for(int i=0,l=0,r=-1; i<q; ++i) {
        while(l>cmd[i].l) add(--l);
        while(r<cmd[i].r) add(++r);
        while(l<cmd[i].l) del(l++);
        while(r>cmd[i].r) del(r--);
        ans[cmd[i].i] = sum;
    }
    for(int i=0;i<q;++i) {
        cout<<ans[i]<<'\n';
    }
    return 0;
}
```

> TLE 的线段树+unmap，理由：每次查询要合并 unmap，故复杂度是 $O(qn)$。
>
> ```c++
> #include <bits/stdc++.h>
> using namespace std;
> const int maxn = 2e5+3;
> unordered_set<int> t[maxn*4]; // 线段树
> int a[maxn];
> void init(int p, int l, int r) {
>     if(l==r) {
>         t[p].insert(a[l]);
>         return;
>     }
>     int c=(l+r)>>1;
>     init(p<<1, l, c);
>     init(p<<1|1, c+1, r);
>     t[p].insert(t[p<<1].begin(), t[p<<1].end());
>     t[p].insert(t[p<<1|1].begin(), t[p<<1|1].end());
> }
> unordered_set<int> query(int p, int l, int r, int ql, int qr) {
>     if(ql<=l && r<=qr) return t[p];
>     int c=(l+r)>>1;
>     unordered_set<int> res;
>     if(ql<=c) {
>         auto tmp=query(p<<1, l, c, ql, qr);
>         res.insert(tmp.begin(), tmp.end());
>     }
>     if(c<qr) {
>         auto tmp=query(p<<1|1, c+1, r, ql, qr);
>         res.insert(tmp.begin(), tmp.end());
>     }
>     return res;
> }
> signed main() {
>     ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
>     int n, q;
>     cin >> n >> q;
>     for(int i=0;i<=4*n+1; ++i) t[i].clear();
>     for(int i=0;i<n; ++i) cin >> a[i];
>     init(1, 0, n-1);
>     int li = 0, ri = n - 1;
>     while(q--) {
>         char cmd;
>         int len,l,r;
>         cin >> cmd >> len;
>         if(cmd=='L') {
>             l=li, r=li+len-1;
>             li=(li+len)%n;
>         }else{
>             r=ri, l=ri-len+1;
>             ri=(ri-len%n+n)%n;
>         }
>         int lb=l/n-(l<0), rb=r/n-(r<0);
>         // cout << l << " " << r << " " << lb << " " << rb << " : ";
>         l=(l%n+n)%n, r=(r%n+n)%n;
>         if(abs(lb-rb)>=2) {
>             cout << t[1].size() << '\n';
>         } else if(lb==rb) {
>             cout << query(1, 0, n-1, l, r).size() << '\n';
>         } else {
>             auto tmp=query(1, 0, n-1, l, n-1);
>             tmp.insert(query(1, 0, n-1, 0, r).begin(), query(1, 0, n-1, 0, r).end());
>             
>             cout << tmp.size() << '\n';
>         }
>     }
>     return 0;
> }
> ```
>
> 写了发现不对的树状数组+离散化：
>
> ```c++
> #include <bits/stdc++.h>
> using namespace std;
> const int maxn = 2e5+3;
> int a[maxn*2], ans[maxn], n;
> struct query {
>     int l, r, i;
>     bool operator<(const query &x) const {
>         return r<x.r;
>     }
> } cmd[maxn];
> map<int, int> b; // 离散化
> int t[maxn*2];
> void add(int i) {
>     for(;i<=n;i+=(i&-i)) t[i]+=1;
> }
> int query(int i) {
>     int ans = 0;
>     for(;i;i-=(i&-i)) ans+=t[i];
>     return ans;
> }
> signed main() {
>     ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
>     int q;
>     cin >> n >> q;
>     for(int i=0;i<n; ++i) cin >> a[i];
>     for(int i=0;i<n; ++i) {
>         if(b.find(a[i])==b.end()) {
>             b[a[i]] = 1+b.size();
>         }
>         a[i] = b[a[i]];
>     }
>     for(int i=0;i<n; ++i) a[i+n]=a[i];
>     int li = 0, ri = n - 1;
>     for(int qi=0;qi<q;++qi) {
>         char cm;
>         int len,l,r;
>         cin >> cm >> len;
>         if(cm=='L') {
>             l=li, r=li+len-1;
>             li=(li+len)%n;
>         }else{
>             r=ri, l=ri-len+1;
>             ri=(ri-len%n+n)%n;
>         }
>         int lb=l/n-(l<0), rb=r/n-(r<0);
>         // cout << l << " " << r << " " << lb << " " << rb << " : ";
>         l=(l%n+n)%n, r=(r%n+n)%n;
>         if(abs(lb-rb)>=2) {
>             cmd[qi] = {0, n-1, qi};
>         } else if(lb==rb) {
>             cmd[qi] = {l, r, qi};
>         } else {
>             cmd[qi] = {l, n+r, qi};
>         }
>     }
>     sort(cmd, cmd+q);
>     n*=2;
>     for(int i=0, qi=0; i<n; ++i) {
>         
>     }
>     return 0;
> }
> ```

离散化+莫队，稳定 300ms 内

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5+3;
int a[maxn*2], sq, ans[maxn];
map<int, int> b; // 离散化
struct query { // 莫队
    int l, r, i;
    bool operator<(const query &x) const
    {
        if (l / sq != x.l / sq)
            return l < x.l;
        if (l / sq & 1)
            return r < x.r;
        return r > x.r;
    }
} cmd[maxn];
int cnt[maxn];
int sum;
inline void add(int i) {
    sum += cnt[a[i]]++ == 0;
}
inline void del(int i) {
    sum -= --cnt[a[i]] == 0;
}
signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int n, q;
    cin >> n >> q;
    for(int i=0;i<n; ++i) cin >> a[i];
    for(int i=0;i<n; ++i) {
        if(b.find(a[i])==b.end()) {
            b[a[i]] = b.size();
        }
        a[i] = b[a[i]];
    }
    for(int i=0;i<n; ++i) a[i+n]=a[i];
    int li = 0, ri = n - 1;
    for(int qi=0;qi<q;++qi) {
        char cm;
        int len,l,r;
        cin >> cm >> len;
        if(cm=='L') {
            l=li, r=li+len-1;
            li=(li+len)%n;
        }else{
            r=ri, l=ri-len+1;
            ri=(ri-len%n+n)%n;
        }
        int lb=l/n-(l<0), rb=r/n-(r<0);
        // cout << l << " " << r << " " << lb << " " << rb << " : ";
        l=(l%n+n)%n, r=(r%n+n)%n;
        if(abs(lb-rb)>=2) {
            cmd[qi] = {0, n-1, qi};
        } else if(lb==rb) {
            cmd[qi] = {l, r, qi};
        } else {
            cmd[qi] = {l, n+r, qi};
        }
    }
    sq=sqrt(n*2);
    sort(cmd, cmd+q);
    for(int i=0,l=0,r=-1; i<q; ++i) {
        while(l>cmd[i].l) add(--l);
        while(r<cmd[i].r) add(++r);
        while(l<cmd[i].l) del(l++);
        while(r>cmd[i].r) del(r--);
        ans[cmd[i].i] = sum;
    }
    for(int i=0;i<q;++i) {
        cout<<ans[i]<<'\n';
    }
    return 0;
}
```

评论解法，树状数组：

考虑到当前出现某个颜色时，之间所有该颜色都不会对查询有贡献，因此维护每种颜色的上一个出现位置即可，当又出现该颜色时清除之前出现的位置，这样查询不同颜色数量就转为一个区间求和。而以上清除和求和操作都可由树状数组高效完成

借助这个思路和我写了一半的树状数组代码，deepseek 深度思考了几分钟补全，AC了，三百多ms。

按右端点排序询问，用 last[i] 数组记录在固定右端点下，每个位置 i 是否有颜色。叠树状数组维护 last 的前缀和，然后对每个询问求区间和即可。

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5+3;
int a[maxn*2], ans[maxn], n;
struct query {
    int l, r, i;
    bool operator<(const query &x) const {
        return r<x.r;
    }
} cmd[maxn];
map<int, int> b; // 离散化
int t[maxn*2];
map<int, int> last; // 记录每个颜色最后出现的位置

void add(int i, int delta) {
    while (i < maxn*2) {
        t[i] += delta;
        i += i & -i;
    }
}

int query(int i) {
    int res = 0;
    while (i > 0) {
        res += t[i];
        i -= i & -i;
    }
    return res;
}

signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int q;
    cin >> n >> q;
    for(int i=0; i<n; ++i) cin >> a[i];
    // 离散化颜色
    for(int i=0; i<n; ++i) {
        if(b.find(a[i]) == b.end()) {
            b[a[i]] = 1 + b.size();
        }
        a[i] = b[a[i]];
    }
    for(int i=0; i<n; ++i) a[i+n] = a[i];
    int li = 0, ri = n - 1;
    // 处理每个查询，确定对应的区间
    for(int qi=0; qi<q; ++qi) {
        char cm;
        int len, l, r;
        cin >> cm >> len;
        if(cm == 'L') {
            l = li;
            r = li + len - 1;
            li = (li + len) % n;
        } else {
            r = ri;
            l = ri - len + 1;
            ri = (ri - len % n + n) % n;
        }
        int lb = l / n - (l < 0 ? 1 : 0);
        int rb = r / n - (r < 0 ? 1 : 0);
        l = (l % n + n) % n;
        r = (r % n + n) % n;
        if(abs(lb - rb) >= 2) {
            cmd[qi] = {0, n-1, qi};
        } else if(lb == rb) {
            cmd[qi] = {l, r, qi};
        } else {
            cmd[qi] = {l, n + r, qi};
        }
    }
    sort(cmd, cmd + q);
    n *= 2; // 扩展后的数组长度为原长度的两倍
    // 处理每个位置，维护树状数组和最后出现的位置
    for(int i=0, qi=0; i < n; ++i) {
        int color = a[i];
        if(last.count(color)) {
            add(last[color] + 1, -1);
        }
        add(i + 1, 1);
        last[color] = i;
        // 处理所有右端点等于当前i的查询
        while (qi < q && cmd[qi].r == i) {
            int current_l = cmd[qi].l;
            ans[cmd[qi].i] = query(i + 1) - query(current_l);
            qi++;
        }
    }
    // 输出所有查询结果
    for(int i=0; i<q; ++i) {
        cout << ans[i] << '\n';
    }
    return 0;
}
```

