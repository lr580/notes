> 阅读前的前置知识：`(C/C++),(PYTHON),(JAVA),HTML,CSS,JS`

# node.js

与前端相关的，如部署前端框架项目等，参见 `web.md-node`

## 概述

### 概念

简单的说 Node.js 就是运行在服务端的 JavaScript。

nodejs 构成：ECMAScript + node内置 api，没有 DOM 和 BOM。

> 由于语法与 js 相似度高，相同部分不再赘述，翻阅 `web.md`。
>
> 浏览器：js = ECMAScript + BOM + DOM，服务器：js = ECMAScript + node系统内置核心模块

可以实现：web 服务端、命令行工具、爬虫、桌面应用程序等

npm 是 Node.js 的包管理工具 (Node Package Manager)

npx 的作用是在本地安装并运行一个 Node.js 包 (Node Package Executor)

组成成分：

1. **引入 required 模块：**我们可以使用 **require** 指令来载入 Node.js 模块。
2. **创建服务器：**服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。
3. **接收请求与响应请求** 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。



### 安装使用

#### windows

安装参见菜鸟教程。[nodejs官网](https://nodejs.org/zh-cn/)

查看是否已经安装：

```shell
node -v
```

交互式(类似python IDLE)命令行：(输入 `.exit` 或 ctrl+d 退出)

```shell
node
```

> 如，进入后可以输入 `console.log("Hell world!")`

运行代码 `js` 文件，如：

```js
//gishw.js
console.log('白茶。')
```

```shell
node gishw.js
```

vscode 插件对的话，可以直接 f5 或其他方法(code runner ctrl+shift+n)运行。

#### linux

linux [参见](https://nodejs.org/en/download/package-manager)

对着做即可，如安装 20 的：

```sh
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
nvm install 20
node -v # should print `v20.14.0`
npm -v # should print `10.7.0`
```

请不要使用 apt 安装。

### npm

#### 基本

> 专门收集模块工具包的网站 [链接](https://www.npmjs.cn/)。

npm 可以用来获取第三方包，以及发布自己的包。不需要单独安装 npm，装 node 会附带。

> cnpm 是国内镜像的 npm

查看版本：

```shell
npm -v
```

升级 npm：(可以简写为 `-g`)

```shell
npm install npm --global
```

本地安装是：(全局安装加上 `-g`)(install 可以简写为 `i`)

```shell
npm install
# 或 npm i
npm install 包名 --save # 写到 package.json
```

> 如：(特定版本用 `@` 如 `express@4.17.1`)(最新版本是 `@next`)
>
> ```shell
> npm install express -g
> ```

查看局部/全局已安装的包：(`-g` 全局)

```sh
npm list
```

卸载：

```shell
npm uninstall 模块名 # npm uni
```

更新：

```sh
npm update 模块名
```

创建模块：(不交互式创建，使用默认值就 `-y`；结果是生成 `package.json`)

```sh
npm init
```

> 模块包含的信息：
>
> - name 包名
> - version 版本号
> - description 描述
> - homepage 该包的官网url
> - author 作者
> - contribotors 其他贡献者
> - dependencies 依赖包列表(未安装自动装到 `node_module/`)
> - repository 代码仓库(git/svn)
> - main 主文件入口，使得 require 加载该文件，默认是 `index.js`
> - keywords 关键字

运行：

```sh
npm run dev
```

> 关闭运行：(windows)
>
> ```sh
> tasklist | findstr "npm run dev"
> taskkill /F /PID <PID>
> ```



部署一个静态 HTML (本机 live 运行或挂服务器防止跨域)，一般生成到 `build/`：

```sh
npm run build
```

将其部署到 github 的 `gh-pages` 分支：(需要有 `.git` 文件，即 git init 过)

```sh
npm install --save gh-pages
npm run build
gh-pages -d build # build 是目录名
```



#### nodemon

```sh
npm i -g nodemon
```

传统运行方法 `node app.js` 代码被修改后要手动重启项目。

而 nodemon 在修改代码时会监听，然后自动重启项目。运行：`nodemon app.js`



#### nrm

npm registry manager 镜像源管理工具。

```sh
npm i -g nrm
```

查看源：

```sh
nrm ls
```

换源：

```sh
nrm use taobao
```

### package.json

##### 基本

一个大括号然后若干 key (字符串): value。

其中，scripts 的 key 下面定义一个对象（大括号），表示`npm run xxx` 的 `xxx` 究竟运行什么。例如：

```json
"scripts": {
    "dev": "umi dev",
    "build": "umi build",
    "postinstall": "umi setup",
    "setup": "umi setup",
    "start": "npm run dev",
    "deploy": "gh-pages -d docs"
},
```

##### 变量

以 UMI 为例，将原本是 `.umirc.ts` 的：

```typescript
import { defineConfig } from "umi";

export default defineConfig({
  // base: "/docs", // 本地
  // publicPath: "/docs/", // 本地
  base: "/typeCGame", // githubpages
  publicPath: "/typeCGame/", // githubpages
  title: "三金打字",
  outputPath: 'docs',
  routes: [
    { path: "/", component: "App" }
  ],
  npmClient: 'yarn',
});
```

修改为：

```typescript
import { defineConfig } from "umi";

export default defineConfig({
  base: process.env.DEPLOY_ENV === 'local' ? "/docs" : "/typeCGame",
  publicPath: process.env.DEPLOY_ENV === 'local' ? "/docs/" : "/typeCGame/",
  title: "三金打字",
  outputPath: 'docs',
  routes: [
    { path: "/", component: "App" }
  ],
  npmClient: 'yarn',
});
```

安装依赖：(deploy.yml)

```sh
npm install --save-dev cross-env
```

在 `package.json` 的 scripts 添加：

```json
"build:local": "cross-env DEPLOY_ENV=local umi build"
```

本地运行：

```sh
npm run build:local
```

同理，对 dev 的话：

```json
"dev:local": "cross-env DEPLOY_ENV=local umi dev",
```

```sh
npm run dev:local
```



### yarn

Yet Another Resource Negotiator。JS 包管理工具。[官网](https://yarnpkg.com/en/docs)，[中文官网](https://yarn.bootcss.com/)



#### 基本

安装：

```sh
npm i -g yarn
```

检查安装完毕：

```sh
yarn --version
```

![image-20230105182243488](img/image-20230105182243488.png)

### github page

静态网页部署。

以 [typeCGame](https://github.com/lr580/typeCGame) 为例。参照该项目 README.md 配好环境，可以本地自测。

在项目根目录新建 `.github/workflows/` 的任意 `xxx.yml`。实现功能：每次 push 后自动在项目仓库执行 `npm run build`，并将生成的 `docs/`(原本是 `build/`) 自动部署到 `gh-pages`，有多种写法，一种写法为：

```yml
name: Build and Deploy
on: [push]
permissions:
  contents: write
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout 🛎️
        uses: actions/checkout@v4

      - name: Install and Build 🔧 
        run: |
          npm i
          npm run build

      - name: Deploy 🚀
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          folder: docs # The folder the action should deploy.
```

请务必在 `.gitignore` 添加对 `docs/` 的忽略，否则部署以仓库 `docs/` 为准而不是生成的 `docs/`。

之后在  仓库 settings 找到 pages，找到 build and deployment，source 选 deploy from a branch，其 branch 选 gh-pages，选 / (root)，点 save，那么每次该分支发生变化会自动发生 github action 重新部署。

以本仓库为例，部署结果在：[https://lr580.github.io/typeCGame/](https://lr580.github.io/typeCGame/)。

### 协同

一般项目共享前，把 `node_modules` 忽略，然后共享到代码仓库。因为有 `package.json`，对方执行

```sh
npm install
```

会根据该文件自动装包

可以在其下添加字段：

```js
"scripts":{
  "test":"echo \"Error: no test specified\" && exit 1",
  "start":"node app.js",
  "dev":"node test.js",
  "build":"node build.js"
},
```

然后执行 `npm run start` 即等于执行 `start` 对应的内容(当然不是单纯的，会加一些前后内容)



## 基本语法

### 模块

#### 基本

一个 js 文件就是一个模块，作用域私有，内部变量和函数只有当前文件可用。

别人要用模块，以对象形式用 `exports` 或 `module.exports` 导出；别人引入时用 `require` 来引入。

模块定义规范：

- AMD 规范。require.js (只在浏览器端)
- CMD 规范。 Sea.js (只在浏览器端)
- CommonJS 的 Modules 规范：NodeJS (只在服务器端)
- ES6 模块化规范 import \.\.\. from \.\.\. (node不支持)

以 CommonJS 为例，一个模块 `m1.js` 可以用下面两种方法之一定义要导出的内容：

```js
//导出方法一
exports.num = 580;
exports.fn = function () {
    console.log(1437);
}
```

```js
//导出方法二
var num2 = 582;
module.exports = {
    num: 581,
    fn: function () {
        console.log(1438)
    },
    num2
};
```

另一个调用模块的代码文件 `m2.js`：

```js
const m1 = require("./m1.js"); //同目录下
console.log(m1.num);
m1.fn();
```

运行 `m2.js` 即可看到效果。

其中，`exports` 是 `module.exports` 的引用。且 `this` 对象就是 `exports` 对象。不等于 `global` 全局对象。即：

```js
console.log(exports === module.exports); //T
console.log(this === exports); //T
console.log(this === global); //F
```

> global 是全局变量。如 console, setTimeout 是其成员
>
> ```js
> let b = 580;
> var c = 581;
> const d = 582;//下均undef
> console.log(global.b, global.c, global.d);
> global.a = 583;
> console.log(a);
> console.log(process.argv);//node命令所在位置,当前代码文件所在路径,(如果有)main参数
> console.log(process.arch);//系统位数，如 x64
> ```





#### babel+ES6

> Babel 是一个 JavaScript 编译器，它可以将 JavaScript 代码转换成向后兼容的版本。Babel 可以转换新的 JavaScript 语法，也可以将新的 JavaScript 语法转换成旧的语法，以便在不支持新语法的浏览器或运行环境中运行。(chatGPT)

安装：(会在当前目录下下载内容)

```shell
npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node
npm install --save @babel/polyfill
```

创建 `babel.config.js` 配置该插件：

```js
const presets = [
    ["@babel/env", {
        targets: {
            edge: "17",
            firefox: "60",
            chrome: "67",
            safari: "11.1"
        }
    }]
]
module.exports = { presets }
```

使用如下命令执行一般的 js 代码：

```shell
npx babel-node ./index.js
```

因此，可以用 ES6 语法了。即如 `m3.js` 如下：

```js
export const num = 581;
export function fn () {
    console.log(233);
}
```

`m4.js` 如下，并按上面格式运行 `m4.js`：

```js
import { num, fn } from "./m3.js";
console.log(num);
fn();
```

缺点是速度显然比常规跑代码(秒出)要慢(这个要几秒)。



#### 内置

三种模块：内置模块、自己写的模块、第三方模块(npm)

常用内置模块：[详见]()

- `fs` 文件操作
- `http` 网络操作
- `path` 路径操作
- `querystring` 查询参数解析
- `url` URL解析

导入方法，如：

```js
const fs = require('fs');
```



##### path

常见常量和函数：

```js
const path = require("path");
console.log(__dirname);//绝对路径(不含文件名)
console.log(__filename);//绝对路径(含文件名)
console.log(path.extname(__filename))//后缀('.xx')
console.log(path.basename(__filename))//文件名+后缀
console.log(path.parse(__filename))//对象
//root:, dir:, base:, ext:, name: (base=name+ext)
console.log(path.parse(__filename)['name'])
console.log(path.join(__dirname, 'm1.js'))
console.log(path.join(__dirname, 'a', 'm1.js'))
```



##### fs

###### 同步读取

等读完才执行后面的代码。

```js
const fs = require("fs");
const path = require("path");
let data1 = fs.readFileSync("1.txt");//Buffer
console.log(data1.toString());
let data2 = fs.readFileSync(path.join(__dirname, "2.txt"));//绝对路径
console.log(data2.toString());
console.log("Done");//同步表征
//可以填多一个参数'utf8',则返回字符串而不是buffer,下同or'utf-8'
```

###### 异步读取

```js
const fs = require("fs");
fs.readFile('1.txt', 'utf8', (err, data) => {
    if (err) {
        console.err(err);
        return;
    }
    console.log(data);
});
console.log('异步表征');
```

###### 写入

```js
const fs = require("fs");
fs.writeFileSync('10.txt', '你好小笼包谢谢再见');
console.log('Done1');
fs.writeFile('11.txt', '依托答辩', (err) => {
    console.log(err);//null
    console.log('Done2');
});//想加utf8的话插入到第二个参数位
console.log('异步表征');
```

###### 其他

重命名：

```js
fs.renameSync('11.txt', '12.txt');//旧,新
```

获取一个目录所有文件：

```js
let names = fs.readdirSync(__dirname);//数组
for (let i in names) {//文件和文件夹名字(文件就basename)
    console.log(names[i]);
}
```





###### 举例

实现文件 `c=a+b`，要求并发。

```js
const fs = require("fs");
//在保证并发的情况下同步
var d1 = undefined, d2 = undefined;
function write() {
    if (d1 && d2) {
        fs.writeFileSync('3.txt', d1 + d2);
    }
};
fs.readFile('1.txt', 'utf8', (err, data) => {
    console.log('read 1');
    d1 = data; write();
});
fs.readFile('2.txt', 'utf8', (err, data) => {
    console.log('read 2');
    d2 = data; write();
});
```



##### http

###### 基本

四个步骤：

1. 导入 http 模块
2. 定义服务器程序接口
3. 创建服务器对象
4. 调用服务器的监听方法，让服务器监听浏览器请求

搭建一个 hello world 服务器，凡是有请求都返回一句话

```js
const http = require('http');
//不要端口冲突如mysql3306 mongodb27017
const port = 15800;
//req:请求 res:响应
const server = http.createServer((req, res) => {
    res.setHeader('Content-type', 'text/html;charset=utf-8');
    res.write('不要回答！');
    res.end();
});
server.listen(port, () => {
    console.log('服务器已开启');
});
```

运行后，在浏览器输入 `localhost:15800` 得到不要回答的响应。

> end 表示最后一次写，上述代码等价于：
>
> ```js
> res.write('不要');
> res.write('回')
> res.end('答！');
> ```

> 如果想要浏览器可以 get，以 chrome 为例，需要解决跨域问题 CORS，一种方案是，对 chrome 快捷键右击属性，设起始位置为 x。则目标后面添加 ` --args --disable-web-security --user-data-dir=x`。左移 x 是字符串不需要引号，如目标 `"C:\Program Files\Google\Chrome\Application\chrome.exe" --args --disable-web-security --user-data-dir=C:\Program Files\Google\Chrome\Application`
>
> 一个更好的办法：添加 chrome 插件 CORS Unblock，[下载地址](https://chrome.google.com/webstore/detail/cors-unblock/lfhmikememgdcahcdlaciloancbhjino/related?hl=zh-CN)

一个 get 的例子：

```html
<script src="js/jquery.js"></script>
<script>
    $.ajax({
        url:'http://localhost:15800',
        type:'get',
        success:(data)=>{
            console.log(data);
        },
        error:(xhr,status,error)=>{console.log(error);}
    });
</script>
```



###### 获取请求信息

```js
const url = require('url');
const http = require('http');
const server = http.createServer((req, res) => {
    console.log('url:', req.url);
    console.log('method:', req.method);
    let obj = url.parse(req.url, true);
    //第二个参数是一个布尔值，表示是否将查询字符串解析为对象。默认为 true。(chatGPT)
    //第三个参数是一个布尔值，表示是否将不带协议的 URL 解析为相对路径。默认为 false。
    console.log('query:', obj.query);
    req.on('data', (postData) => {
        console.log('data:', postData.toString());
    });
    res.setHeader('Content-type', 'text/html;charset=utf-8');
    res.end('这一点都不好玩');
});
server.listen(15800, () => { console.log('pending'); });
```

例如传送：`http://localhost:15800/?a=1&b=32c`，得到输出：

```js
url: /?a=1&b=32c
method: GET
query: [Object: null prototype] { a: '1', b: '32c' }
```

假设写一个 post：

```html
<script src="js/jquery.js"></script>
<script>
    $.ajax({
    url:'http://localhost:15800',
    type:'post',
    data:{a:'c',b:4},
    success:(data)=>{
        console.log(data);
    },
    error:(xhr,status,error)=>{console.log(error);}
});
</script>
```

输出的 data 为 `data: a=c&b=4`, query 是 null



> ```js
> const http = require('http');
> const querystring = require('querystring');
> let server = http.createServer((req, res) => {
>  var str = '';
>  req.on('data', function (data) { str += data; })
>  req.on('end', function () {
>      console.log('str:', str);
>      let json = querystring.parse(str);
>      console.log('json:', json);
>  });
>  res.end('白茶');
> });
> server.listen(15800);
> ```
>
> 输出：
>
> ```js
> str: a=c&b=4
> json: [Object: null prototype] { a: 'c', b: '4' }
> ```



###### web服务器

返回 HTML 形式的数据即可。

```js
const http = require('http');
const fs = require('fs');
let server = http.createServer((req, res) => {
    res.setHeader('Content-type', 'text/html;charset=utf-8');
    if (req.url === '/' || req.url === '/index.html') {
        let ct = fs.readFileSync('index.html');
        res.end(ct);
    }//else if
    else {
        res.end("404 NOT FOUND");
    }
});
server.listen(15800);
```

则直接 `http://localhost:15800` 即可



##### util

###### promisify

将一个异步函数改造成一个 Promise。

```js
const util = require('util');
const fs = require('fs');
var f = util.promisify(fs.readFile);
f('./1.txt', 'utf8').then((data) => {
    console.log(data);
    return f('./2.txt', 'utf8');
}).then((data) => {
    console.log(data);
});
//或 Promise.all
Promise.all([
    f('./1.txt', 'utf8'), f('./2.txt', 'utf8')
]).then((data) => {
    console.log(data[0], data[1]);
});
```





#### 第三方

##### md5

```js
const md5 = require('md5');
console.log(md5('白茶'));
```



##### express

web 开发框架。[官网](http://www.expressjs.com.cn)。可以搭建：

- Web 网站服务器。对外提供 web 网页资源。
- API 接口服务器。对外提供 API 接口。

###### 基本

```js
const express = require('express');
const app = express();
app.get('/user', function (req, res) {
    res.send({ name: '白茶', id: 581 });
});
app.post('/user', function (req, res) {
    res.send('post');//建议返回obj
});
app.listen(15800, () => { console.log('Started'); });

```

获取 get URL 参数：

```js
app.get('/user', function (req, res) {
    console.log(req.query);//得到object,key:val
    res.send({ name: req.query.name, id: 581 });
});
```

获取层级参数(动态参数)：(如 `http://127.0.0.1:15800/user/1/baicha`)

```js
app.get('/user/:id/:name', function (req, res) {
    console.log(req.params);
    res.send({ name: req.params.name, id: req.params.id });
});
```

托管若干个静态资源：取一个文件夹作为根目录，可以访问该目录下的所有文件(按URL路径)

```js
app.use(express.static('resource'));
```

> 设该目录下(即当前运行目录下的 `resource/index.html`, `resources/sub/another.html`)，则可以输入 `http://127.0.0.1:15800/index.html`, `http://127.0.0.1:15800/sub/another.html`
>
> 当前目录用 `__dirname` 绝对
>
> 可以挂载路径前缀，`app.use("/res", express.static('resource'));`



###### 路由

路由即映射关系，路径对应页面。指客户端请求与服务器处理函数的映射关系。分为请求的类型、请求的 URL 地址、处理函数：

```js
app.methods(path, handle)
```

上文的 get 和 post 实际上就是路由。其中 methods 就是请求的类型。将路由直接挂载在 app 上。

为了方便管理众多模块，建议将路由分模块，即：

1. 创建路由模块对应的 `.js` 文件
2. 调用 `express.Router()` 创建路由对象
3. 将路由对象挂载具体路由
4. 调用 `module.exports` 向外共享路由对象
5. 用 `app.use()` 注册路由模块

例如创建模块如下：(`expuser.js`)

```js
const express = require('express')
const router = express.Router()
router.get('/user/list', function (req, res) {
    res.send('假装是列表');
});
module.exports = router;
```

```js
const express = require('express');
const app = express();
const userRouter = require('./expuser.js');
app.use(userRouter);
app.listen(15800);
```

如果要给模块加前缀，可以：`app.use('/a1',userRouter)`，则需要访问 `a1/user/list`。



###### 中间件

middleware。业务处理的中间处理环节。可以认为时预处理。中间件的实现形式：

```js
app.get("/",function(req,res,next)){next();}
```

如：

```js
const express = require('express');
const app = express();
app.use(function (req, res, next) {
    console.log('预处理');
    next();
});
app.get("/", (req, res) => {console.log(1); res.send('这是①个首页'); })
app.listen(15800);
```

可以通过中间件往 req 里塞东西(新属性)来达到数据流传递的作用

如果想要中间件局部生效，可以 `app.get(路径,中间件函数,处理函数本体)`

多个中间件，就 `函数1,函数2` 或 `[函数1,函数2]` 去替换上述中间件函数位置。注意：

1. 一定要在路由之前注册中间件
2. 客户端发来的请求可以连续调用多个中间件，执行完记得 next
3. 调用 next 后不要再写别的东西
4. 多个中间件共享 res, req

中间件的分类：

1. 应用级别 `app.use, app.get, app.post` (全局中间件，局部中间件)

2. 路由级别 `router.use`。绑定的主体对象不同

3. 错误级别 `(err,req,res,next)` 函数参数。捕获错误和主动的 throw。必须在所有路由之后，listen之前

   ```js
   const express = require('express');
   const app = express();
   app.get("/", (req, res) => { throw new Error('QwQ'); });
   app.get("/user", (req, res) => { res.send("哈哈"); });
   app.use((err, req, res, next) => { res.send(`错误:${err.message}`); });
   app.listen(15800);
   ```

4. Express 内置

   1. `express.static`
   2. `express.json` 解析请求的数据(4.16.0+)
   3. `express.urlencoded` 解析 URL-encoded 格式请求体(4.16.0+)

   ```js
   const express = require('express');
   const app = express();
   app.use(express.json());//至少要后者才可输出body
   app.use(express.urlencoded({ extended: false }));
   app.post("/", (req, res) => {
       console.log(req.body);
       res.send('ok');
   });
   app.listen(15800);
   //如输出 [Object: null prototype] { a: 'c', b: '4' }
   ```

5. 第三方

   如 body-parser，是 urlencoded 的封装来源，有：

   ```js
   const parser = require('body-parser');
   app.use(parser.urlencoded({ extended: false }));
   ```



###### 监听

数据量比较大，客户端会分批发送。则会触发多次 `data` 事件，最后一次发送触发 `end` 事件。需要对 `data` 拼接。即在处理函数里，对 `req` 绑定两个函数：

```js
let str='';
req.on('data',(chunk)=>{str+=chunk;});
req.on('end',()=>{console.log('处理str');});
```

通常，可以在中间件实现，并将 end 结果挂载到 req 的新属性里



###### 跨域

CORS cross-origin resource sharing

只有支持 XMLHttpRequest Level2 的浏览器才能正常访问开启了 CORS 服务端接口，如 IE10+， Chrome4+, FireFox3.5+

安装 `cors` 模块后，可：

```js
const cors = require('cors');
app.use(cors());
```

可以添加头：

```js
res.setHeader('Access-Control-Allow-Origin','*');//*可以换成完整url,表示只允许来自该url的请求
```

这是因为默认 CORS 只支持客户端向服务端发送 9 种请求头，而其不在生命力。可以添加：

```js
res.setHeader('Access-Control-Allow-Methods','POST, GET, DELETE, HEAD')
//默认没有delete,三大简单请求外需要预检
res.setHeader('Access-Control-Allow-Methods', '*');//简单省事
res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-Custom-Header');
```

> 简单请求：只发送一次请求。
>
> 预检请求：option 预检请求一次，然后再请求一次

jsonp 是通过 script src 属性请求服务器数据，服务器返回函数调用。不属于 Ajax，没有 XMLHttprequest，只支持 get。防止冲突配置 jsonp：

```js
app.geet('/api/jsonp', (req,res)=>{});//不视为jsp接口的接口
app.use(cors())
app.geet('/api/get', (req,res)=>{});
```

通常而言 jsonp 的函数为：

```js
const funcName = req.query.callback;
const data = {}; //...
const scriptStr = `${funcName}(${JSON.stringify(data)})`;
res.send(scriptStr);
```

网页请求：

```js
$.ajax({
    method:'GET',
    url:'http:127.0.0.1:15800/api/jsonp',
    dataType:'jsonp',
    success:function(res){console.log(res);}
})
```



###### template

模板引擎。对 html 字符串用一种快捷方式填充数据。要填充的部分起止是 `{{}}`，里面可以是任意表达式(取属性、三元、逻辑、算术等)

含 html 标签结构的内容，用 `{{@ value}}`

`{{if value}} 如果需要输出 {{else if value2}} 如果 {{/if}}`

`{{each arr}} {{$index}} {{$value}} {{/each}}`

`{{value | filtername}}` 管道操作符，上一个输出作下一个输入，过滤器：

```js
template.default.imports.filterName =  function(value){return 结果;}
```

```html
<script type="text/html" id="tmp">放模板HTML的内容</script>
<script src="template-web.js"></script>
<script>
    var obj = {}; //可以填进去的变量名及其值
    var str = template('tmp', obj);
    document.body.innerHTML = str;
</script>
```



##### moment

```js
const moment = require('moment');
for (let i = 0; i < 3; ++i) {
    let d = +new Date();//正号强转时间戳
    // console.log(d);
    let d2 = moment(d);
    // console.log(d2);//Obj
    let res = d2.format('YYYY-MM-DD HH:mm:ss SSSS');
    console.log(res);//string
}
```



##### mysql

###### 查

```js
const mysql = require('mysql');
const db = mysql.createPool({
    host: '127.0.0.1',
    user: 'root',
    password: psw,
    database: 'easydb',
});//db.querySQL内有没有分号都行
db.query('select * from t_user;', (err, data) => {
    if (err) {
        console.log(err.message); return;
    }
    for (let i of data) {//取某一列
        console.log(i.user_id);
    }
    db.end();//断开连接
});
```

填参版本：

```js
async function f() {
    await new Promise((reso) => {
        db.query('insert into tb values (?)', 580, (err, res) => {
            console.log(res.affectedRows);
            reso();
        });
    });
    await new Promise((reso) => {
        db.query('select count(*) as num from tb where id>=? and id<=?', [10, 1000], (err, res) => {
            console.log(res[0].num);
            reso();
        });
    });
    db.end();
}
f();
```



###### 改

回调地狱：

```js
const outiferr = err => { if (err) { console.log(err); } };
//注意异步关系，使用回调地狱或异步处理
db.query('create table if not exists tb (id int);', (err, res) => {
    outiferr(err);
    db.query('insert into tb values (4),(5)', (err, res) => {
        outiferr(err);
        console.log(res.affectedRows);
    });
});
```

不要地狱：

```js
db.query('delete from tb where id>=4', async function (err, res) {
    await new Promise((reso) => {
        db.query('insert into tb values (4),(5)', (err, res) => {
            console.log('ins', res.affectedRows);
            reso();
        });
    });
    await new Promise((reso) => {
        db.query('update tb set id=6 where id=5;', (err, res) => {
            console.log('upd', res.affectedRows);
            reso();
        });
    });
    console.log('del', res.affectedRows);
    db.end();
});//可以判affectedRows测试是否修改成功
```



##### js-cookie

因为 HTTP 无状态，而 Cookie 是存在浏览器不超过 4KB 的字符串，由名称、值、有效期安全性适用范围属性等组成，各域名独立，每次发起请求时，会自动把当前域名所有未过期 Cookie 发送。即特点为：自动发送、域名独立、过期时限、大小限制。

```js
const Cookies = require('js-cookie');
Cookies.set('key', val);
Cookies.set('key', val, {expires:7});//7天
Cookies.set('key', val, {expires:7/24/24/60*1});//1min
Cookies.set('key', val, {expires:7,path:''});//当前页面
Cookies.get('name');
Cookies.get();//全部
Cookies.remove（'key',{path:''});//不存在的删除不会报错也不返回
```

![image-20230103174837035](img/image-20230103174837035.png)



##### express-session

###### 基本

web 的开发模式有前后端分离、服务器渲染两种方式。

服务器渲染：前端耗时少、有利于SEO(Search Engine Optimization 的缩写，意思是搜索引擎优化。SEO 是指对网站进行优化，以便获得更高的搜索引擎排名，从而使网站在搜索引擎结果页中更容易被用户发现)(chatGPT)；但占用服务器资源，开发效率低。

前后端分离依赖 Ajax，后端只提供 API 接口。开发体验、用户体验好、减轻服务器渲染压力，但不利于 SEO(因为爬虫难爬，但可以用 Vue, React 等前端框架的 SSR(server sided render)解决)

可以复合，如首屏服务器渲染，其他页面前后端分离。

服务器渲染使用 Session 认证机制，前后端分离推荐使用 JWT 认证机制。

session 是存在服务端的，且通常每次关闭服务器就消失；cookie 是存在客户端的。session 需要配合 cookie，即客户端用 cookie 存 session 的值。cookie 不支持跨域访问。所以涉及跨域时不能用。

一个简单例子：

```js
const express = require('express');
const app = express();
const session = require('express-session');
app.use(session({
    secret: 'anything',
    resave: false,
    saveUninitialized: true,
}));
app.get("/", (req, res) => {
    // console.log(req.session);
    console.log(req.session.val);
    req.session.val = Math.random();
    console.log(req.session.val);
    res.send('这是一个网页');
});
app.listen(15800);
```

清空：

```js
res.session.destroy();
```

![image-20230103174910240](img/image-20230103174910240.png)



##### jsonwebtoken

JWT json web token。适合处理跨域+身份认证。

![image-20230103175248702](img/image-20230103175248702.png)

JWT 的组成：头部、有效载荷、签名(通常都是加密字符串)，以 `.` 分隔，即 `Header.Payload.Signature`。载荷是真正要传送的内容。加密是为了保证客户端无法伪造。

一个验证 JWT 的例子，服务端：

```js
const jwt = require('jsonwebtoken');
const { expressjwt } = require('express-jwt');
const express = require('express');
const cors = require('cors');
const app = express();
const secretKey = '114514'
app.use(cors());
//api不需要鉴权
app.use(expressjwt({ secret: secretKey, algorithms: ["HS256"] }).unless({ path: [/^\/api\//] }));
app.use((err, req, res, next) => {
    if (err.name === 'UnauthorizedError') {
        return res.send({ status: 401, message: '无效的token' });
    }
    res.send({ status: 500, message: '未知错误' });
});
app.post("/api/login", function (req, res) {
    res.send({
        status: 200,
        message: '登陆成功',
        token: jwt.sign({ name: '白茶' }, secretKey, { expiresIn: "1h" })
    });
});
app.post('/oth/info', (req, res) => {
    res.send({
        status: 200,
        message: '获取成功',
        
    });
});
app.listen(15800);
```

客户端：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <script src="js/jquery.js"></script>
        <script>
        function next(token){
            $.ajax({
                url:'http://localhost:15800/oth/info',            
                type:'post',
                data:{a:'你好',b:4},
                success:(data)=>{
                    console.log(data);
                },
                // beforeSend:function(xhr){
                //     console.log(token);
                //     xhr.setRequestHeader('Authorization', 'Bearer 114514');  
                // },
                error:(xhr,status,error)=>{console.log(error);},
                headers:{
                    'Authorization': 'Bearer '+token,
                }
            });
        }
        $.ajax({
            url:'http://localhost:15800/api/login',            
            type:'post',
            data:{a:'你好',b:4},
            success:(data)=>{
                console.log(data);
                next(data.token);
            },
            error:(xhr,status,error)=>{console.log(error);}
        });
        </script>
    </head>
    <body></body>
</html>
```



##### bcryptjs

随机盐加密。

```js
const bcrypt = require('bcryptjs');
//8是随机盐长度,每次结果不一样(默认10)
console.log(bcrypt.hashSync('白茶', 8));
console.log(bcrypt.hashSync('白茶', 8));
console.log(bcrypt.compareSync(
    bcrypt.hashSync('白茶'),bcrypt.hashSync('白茶')
));//false
```



##### joi

```sh
yarn add joi@17.4.2
yarn add '@escook/express-joi'
```

表单拦截和合法性验证，如：

```js
let a = joi.string().alphanum().min(1).max(10).required() //用户名
let b = joi.string().pattern(/^[\S]{3,12}$/).required()
router.post('/reg',expressJoi({body:{a,b}}), 主处理函数)
```



##### axios

promise 风格的 get 和 post

```js
const axios = require('axios');
axios.get('http:localhost:15800/user?name=白茶').then((res) => {
    console.log('get', res.data);
});
axios.post('http:localhost:15800/user', { name: 1 }).then((res) => {
    console.log('post', res.data);
});
axios.get('http:localhost:15800/userr').then((res) => {
    console.log('ok');
}).catch((err) => { console.log('err'); });
async function getUser() {
    try {
        let { data: data1 } = await axios.get('http:localhost:15800/user?name=果冻');
        console.log('get2', data1);
        let { data: data2 } = await axios.get('http:localhost:15800/userr');//err
    } catch (err) { console.error('err2'); }
}
getUser();
```





### 数据类型

#### Buffer

专门存放二进制数据缓冲区。

```js
let buf1 = Buffer.from([97, 98, 99]);//abc
console.log(buf1);
console.log(buf1.toString());

let buf2 = Buffer.from("白茶果冻");
console.log(buf2);
console.log(buf2.toString());

let buf3 = Buffer.alloc(10);//10字符
buf3.write("禾枫");
console.log(buf3);//用了6个(3*2)
console.log(buf3.toString());
```



# PHP

## 概述

Personal Home Page  / Hypertext Preprocessor

多平台，兼容多服务器、多数据库、协议

PHP代码不是由Web服务器来执行，而是由PHP应用程序服务器负责解析。因此，从本质上来说，PHP是一种HTML代码生成器

## 使用

### 安装

#### windows

照着课件来

Zend 安装遇到 `已安装此产品的另一版本` 提示时，直接找缓存目录 `C:\ProgramData\Package Cache` ，按时间找最近的一个，点开看到安装包继续安装 [参考资料](https://blog.csdn.net/chb_1_2/article/details/88932088)

改windows-preferences-php-code style-code templates-code-simple php file-edit 修改为模板：

```php+HTML
<!DOCTYPE html>
<html>

<head>
    <meta charset='UTF-8'>
    <title></title>
</head>

<body>
    <?php
    echo "Hello World!"
    ?>
</body>

</html>
```

修改zend默认服务器配置：windows-preferences-php-servers-进行更改即可

vsc 格式化插件：PHP Intelephense

配置 php.ini ，开启拓展：

```ini
extesion_dir = "目录/php7/ext"
extension=php_pdo_mysql.dll
extension=php_mysqli.dll
```

若 mysql 为 8.0 ，对要登录的账号设置，如：

```mysql
use mysql;
alter user root@localhost identified with mysql_native_password by '123456';
flush privileges;
```





## 基本语法

### 基本格式

代码文件是`.php`。上面允许出现HTML语法。

php脚本的长标志是`<?php ?>`，注释同C语言格式。

单行代码可以不用分号，多行一定要。缩进格式同C语言。

> 在php的配置文件（php.ini）中有一个short_open_tag的值，开启以后可以使用PHP的短标签：`<? ?>`
>
> PHP 5.4以后，总会被识别并且合法，而不管short_open_tag的设置是什么

开启短标签后，可以用`<?=`代替`<?echo`。

在标记之外的地方写什么都被认为是 HTML 语句。

用户定义的类和函数、内置的结构以及关键字，如echo、while、class等，是不区分大小的；而变量是区分大小写的。

可以用 C++ 风格注释，也可以用 Shell 风格注释 (即 `#` 单行注释)。对行文档性注释的开头结尾分别是 `/**` ， `*/` 。

如：

```php
<?php echo "123"?>
<?= "123" ?>  //这两行代码等效
```

> [php7新特性参见这里](https://www.runoob.com/php/php7-new-features.html)

### 变量

#### 命名规则

变量以`$`开头。命名规则与C类似。创建和使用与PYTHON类似(弱类型)。如：

```php
<?php
$lr=580;
echo $lr*2;
?>
```

不能是保留字：

![image-20220513155543154](img/image-20220513155543154.png)

可以用 `unset(变量名)` 销毁一个变量，如 `unset($x)` 



#### 作用域

##### local

即函数的局部变量

##### global

函数外定义的变量都有全局作用域。可以跨段使用，如：

```php
<?php$x=3;?>
<?=$x?>//$x写成x暴毙
```

函数内使用全局变量需要global关键字。如：

```php
<?php
$x=5; /*运行环境：SCNUOJ */
function f()
{
    global $x; //没有这一行，即使没有下一行也会报错(但是可以$x=1)
    ++$x;
    echo $x; //1
    echo " ";
}
f();
echo $x; //5
?>
```

事实上全局变量是存在字典`$GLOBALS`里的，即全局`$x`等效`于$GLOBALS['x']`。

```php
<?php
$x=5;
$y=10;
function myTest()
{
    $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];
} 
myTest();
echo $y;
?>
```

> 注：在SCNUOJ上跑不动这个代码，原因未知。



##### static

同C语言static。如：

```php
<?php
function myTest()
{
    static $x=0;
    echo $x;
    $x++;
    echo PHP_EOL; // 换行符，同HTML一样，输出等于一个空格
}
 
myTest();
myTest();
myTest();
?>
```



##### parameter

参数作用域。



#### 数据类型

有String,Integer,Float,Boolean,Array,Object,NULL

三大类：标量数据类型、复合数据类型和特殊数据类型。

`var_dump()`函数输出变量数据类型和值。如：

```php
<?php
$x=1;
var_dump($x);//int(1)
?>
```



##### 字符串

###### 定义

可以单双引号。区别：

1. 双引号可以自带变量占位
2. 双引号内`\`转义，单引号代表普通字符(所以`'\n'`是错误的)
3. 单引号内可以不转义地用双引号，反之相反
4. 单引号处理速度略快于双引号

举例：

```php
<?php
$a = '\n12\n34';
$b = "\\n12\\n34";
echo $a,'<br/>',$b, '<br/>';
echo "$a, $b",'<br/>','$a, $b';
?>
```

可以定义多行字符，以`<<<EOF`开始，以`EOF;`结束。然后中间任意文本，如：

```php
<?php
$name="lr580"; 
$a= <<<EOF
        abc$name
            "1 23
EOF;
// 结束需要独立一行且前后不能空格
//里面的引号就是输出可显示的引号，换行和tab没用，空格有用
echo $a;
?>
```



###### 运算

不支持`+`运算符。(能`+`运算的都是数值).但支持并置运算符进行字符串连接。

```php
<?php
$t1="nice";
echo $t1.' lad!';
?>
```

支持`strlen`函数。返回长度。

```php
<?php
echo strlen("lr580");
echo strlen("你好"); //中文字符3个长度
?>
```

支持`strpos`函数，返回子串出现位置。查无返回FALSE。

可以直接比较，用 `==`，和不等号。如：

```php
<?php
//加X防止转整数比较
echo "X123">"X1200";
echo "X123"=="X123";
echo "X1233"<"X12a";
```



> [更多运算函数](https://www.runoob.com/php/php-ref-string.html)



##### 整数

三种赋值方法，十进制，十六进制 `0x`，八进制前导 `0` ，二进制前导 `0b` 。进制可以前导负，如 `-0b` 。

支持四则运算，除法不是整除，零除报错，取模(浮点数会强转整数，右操作数是负数等同于正数)，位运算。

数据范围是C的signed long long。

PHP不支持无符号整型，其字长用常量PHP_INT_SIZE表示，自PHP 4.4.0和PHP 5.0.5后，最大值用常量 PHP_INT_MAX表示，最小值在PHP 7.0.0 及以后的版本中用常量PHP_INT_MIN表示。



##### 浮点数

同一般程序语言的赋值方法和运算方法。字长与平台有关。在PHP 4.0以前的版本中，浮点型数据的标识为double，也叫做双精度浮点数，在使用过程中，float与double，以及 real 没有区别。



##### 布尔值

TRUE或FALSE，不区分大小写。echo输出true为1，false啥也不输出

整数0、浮点数0.0 (都含负0)、空字符串和字符串“0” (不含`-0`)、没有成员的数组、特殊类型NULL等，都可以表示“假”

```php
<?php
$x=TRue;
echo $x;
?>
```

##### NULL

不区分大小写。以下都是NULL：被赋值为NULL；没有被赋值的变量；使用unset进行类型转换后的返回值。

```php
<?php
$x=null;
$y;
var_dump($x);
echo $x; //nothing
// echo $y; //$y不仅不可以输出，也不可以vardump，不然都会报错
$xx = 1;
$x4 = (unset)$xx;
echo $x4;
?>
```



##### resource

资源类型

资源是一种特殊的变量类型，它保存着对外部数据源的引用，如文件、数据库连接等，直到通信结束。
只有PHP脚本中，负责将资源绑定到变量的函数才能返回资源，无法将其他数据类型转换成资源类型。
资源变量里并不真正保存一个值，实际只保存了一个指针。在使用资源时，系统会自动启用垃圾回收机制，释放不再使用的资源，避免内存的无效消耗。

如：

```php
$v = fopen('index.php', 'r');
var_dump($v);
```



##### callable

需要回调的函数。如：

```php
function giz($name)
{
    echo "Hello $name<br/>";
}
function add(callable $f, $a, $b)
{
    echo $a . $b;
    $f($a);
    $f($b);
}
add('giz', 'baicha', 'hefeng');
```



##### 其他

PHP7支持以下：

nullable 可空

函数返回值的 void 类型

iterable 伪类型



#### 常量

##### 普通常量

使用`define()`定义常量，第一个参数字符串，名字；第二个参数值，第三个参数若true，大小写默认敏感。

只能是标量数据类型。常量必须先定义、然后再使用，并且与值只能绑定一次。

常量是全局的。如：

```php
<?php
function f()
{
    define("lr",580);
}
f();
echo lr;
?>
```

也可以用const。调用输出常量名或 `constant('常量名')`

使用const关键字定义常量，声明语句必须处于最上层的作用域内。也就是说，不能使用该方法在函数、循环以及if语句内定义常量。

如：

```php
<?php
const x=3;
echo x;
echo constant('x');//二者等效
?>
```

也可以用 `constant(字符串)` 来动态调用不同的常量。

```php
define('baicha', 'QwQ');
define('jinle', '>_<');
$a = ['baicha', 'jinle'];
echo constant($a[time() % 2]);
```



##### 预定义常量

PHP的系统预定义常量，包括内核预定义常量与标准预定义常量，它们可以在程序中直接使用。
需要注意的是，系统预定义常量往往由不同的扩展库定义，因此，只有加载了相应的扩展库，某些常量才可以使用。

![image-20220513164554884](img/image-20220513164554884.png)



##### 魔术常量

值随着它们在代码中的位置改变而改变。不区分大小写。

`__LINE__`是当前在脚本.php文件中的行数

`__FILE__`是当前文件绝对路径

`__DIR__`是当前文件所在目录的绝对路径(不含后缀`/`)，等价于`dirname(__FILE__)`

`__FUNCTION__`是当前函数的名字(不在函数内调用是输出空)。PHP5起得到的值区分大小写，PHP4中总是小写的。(PHP4.3.0新增)

`__CLASS__`返回类的名字。同PHP5起区分大小写。PHP5.4起对trait也起作用(调用 trait 方法的类的名字)。同理类外无输出。

`__METHOD__`方法名。对函数也可用。

`__NAMESPACE__`命名空间名称。PHP5.3.0。未定义(`namespace 空间名;`)时为空。

`__TRAIT__`



#### 运算

##### 逻辑

###### 比较相等

有`==`,`===`

> 细则：
>
> ![image-20211007194417871](img/image-20211007194417871.png)
>
> ![image-20211007194437384](img/image-20211007194437384.png)
>
> ![image-20211007194450604](img/image-20211007194450604.png)
>
> ![image-20211007194458827](img/image-20211007194458827.png)



###### 不等号

不等于是`<>`或`!=`，其他同C。绝对不等于是`!==`。



###### 逻辑运算

`and`,`or`,`xor`,`&&`,`||`,`!`



###### 三元运算

PHP5.3起，可以省略中间部分而写成`expr1?:expr2`

PHP7+版本有运算符`expr1??expe2`，当且仅当`expr1`为NULL返回`expr2`，否则返回`expr1`。



###### 组合比较

`$a<=>$b`，若`$a>$b`，返回$1$，若`$a<$b`，返回$-1$，否则返回$0$



##### 优先级

| 结合方向 | 运算符                                                   | 附加信息                 |
| :------- | :------------------------------------------------------- | :----------------------- |
| 无       | clone new                                                | clone 和 new             |
| 左       | [                                                        | array()                  |
| 右       | ++ -- ~ (int) (float) (string) (array) (object) (bool) @ | 类型和递增／递减         |
| 无       | instanceof                                               | 类型                     |
| 右       | !                                                        | 逻辑运算符               |
| 左       | * / %                                                    | 算术运算符               |
| 左       | + – .                                                    | 算术运算符和字符串运算符 |
| 左       | << >>                                                    | 位运算符                 |
| 无       | `== != === !== <>`                                       | 比较运算符               |
| 左       | &                                                        | 位运算符和引用           |
| 左       | ^                                                        | 位运算符                 |
| 左       | \|                                                       | 位运算符                 |
| 左       | &&                                                       | 逻辑运算符               |
| 左       | \|\|                                                     | 逻辑运算符               |
| 左       | ? :                                                      | 三元运算符               |
| 右       | = += -= *= /= .= %= &= \|= ^= <<= >>= =>                 | 赋值运算符               |
| 左       | and                                                      | 逻辑运算符               |
| 左       | xor                                                      | 逻辑运算符               |
| 左       | or                                                       | 逻辑运算符               |
| 左       | ,                                                        | 多处用到                 |

注意：or,and和||&&优先级不一样，虽然效果相同。如：

```php
<?php
// 优先级： &&  >  =  >  and
// 优先级： ||  >  =  >  or
 
$a = 3;
$b = false;
$c = $a or $b;
var_dump($c);          // 这里的 $c 为 int 值3，而不是 boolean 值 true
$d = $a || $b;
var_dump($d);          //这里的 $d 就是 boolean 值 true 
?>
```



#### 数组

有数值数组，关联数组(类似PYTHON字典)和多维数组。

> [完整参考手册](https://www.runoob.com/php/php-ref-array.html)

##### 创建

构造数值函数`array(值, ...)`，自动分配，下标从0递增。也可以用 `[]` 语法。

也可以手动分配，如PYTHON。即`$数组变量[下标]=值`。如果不填，默认为max下标+1。

构造关联数组：`array(键=>值, ...)`，`$数组变量[键]=值` 。注意键 `1` 与 `'1'` 等效，以此类推。键可以是字符串。键可以是标量，不能是数组等。

数值和关联可以混用。

如：

```php
<?php
$x=array(1,3,5);
echo $x[0]+($x[1]*$x[2]);
$x[6]=7;
echo $x[6]+count($x);//11
?>
```

```php
<?php
$x=array('lr'=>580,'bc'=>998);
$x['awa']=13;
echo count($x),' ',$x['awa']+$x['bc'];
?>
```

```php
<?php
$cars = array
(
    array("Volvo",100,96),
    array("BMW",60,59),
    array("Toyota",110,100)
);
?>
```



##### 遍历

用`foreach($数组 as $键变量=>$值变量)`或`foreach($数组 as $值变量)`，如：

```php
<?php
$x=array(1,-1);
foreach($x as $key=>$v)
{
    echo $key,' ', $v, '<br/>';
}
$y=array('lr'=>580,'bc'=>998);
foreach($y as $key=>$v)
{
    echo $key,' ', $v, '<br/>';
}
?>
```

直接输出整个数组用`var_dump`或`print_r`，不用`echo`。



##### 运算

`+`运算符取交集，如果都有某个下标，取左操作数的，如：

```php
<?php
$x=array(1,2);
$y=array(3,2=>4);
var_dump($x);
echo '<br/>';
print_r($y);
echo '<br/>';
print_r($x+$y);//1,2,4
?>
```

`==`当且仅当有相同的键值对。

`===`在上述前提下还要求顺序相同。

类推定义`!=,<>,!==`。如：

```php
<?php
$x=array(1,2);
$y=array(1=>2,0=>1);
echo $x==$y?'yes':'no','<br/>',$x===$y?'yes':'no';
?>
```





##### 函数

`is_array($数组)`判定是否是数组

`count($数组)`长度取元素数量。

`sort($数组)`升序排序，`rsort`降序。

	`asort`根据关联数组值升序，`ksort`根据关联数组键。
	
	同理有：`arsort,krsort`。

`end`将内部指针指向数组中的最后一个元素，并输出

> - [current()](https://www.runoob.com/php/func-array-current.html) - 返回数组中的当前元素的值。
> - [next()](https://www.runoob.com/php/func-array-next.html) - 将内部指针指向数组中的下一个元素，并输出。
> - [prev()](https://www.runoob.com/php/func-array-prev.html) - 将内部指针指向数组中的上一个元素，并输出。
> - [reset()](https://www.runoob.com/php/func-array-reset.html) - 将内部指针指向数组中的第一个元素，并输出。
> - [each()](https://www.runoob.com/php/func-array-each.html) - 返回当前元素的键名和键值，并将内部指针向前移动。

`in_array(一些值,$数组)`，可以有第三个参数表示是否区分大小写

如：

```php
<?php
$arr=array('a','B','A'); //ASCII顺序
sort($arr);
print_r($arr);
?>
```



#### 超级全局变量

- $GLOBALS

- $_SERVER

  包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。如有属性`PHP_SELF,SERVER_NAME,HTTP_HOST,HTTP_REFERER,HTTP_USER_AGENT,SCRIPT_NAME`

- $_REQUEST

  收集HTML表单提交的数据。

- $_POST

  收集HTML表单提交的数据。

- $_GET

  收集HTML表单提交的数据。

- $_FILES

- $_ENV

- $_COOKIE

- $_SESSION



> [表单相关参见](https://www.runoob.com/php/php-forms.html)



##### _SERVER

详细：

| 元素/代码                       | 描述                                                         |
| :------------------------------ | :----------------------------------------------------------- |
| $_SERVER['PHP_SELF']            | 当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $_SERVER['PHP_SELF'] 将得到 /test.php/foo.bar。__FILE__ 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 |
| $_SERVER['GATEWAY_INTERFACE']   | 服务器使用的 CGI 规范的版本；例如，"CGI/1.1"。               |
| $_SERVER['SERVER_ADDR']         | 当前运行脚本所在的服务器的 IP 地址。                         |
| $_SERVER['SERVER_NAME']         | 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: www.runoob.com) |
| $_SERVER['SERVER_SOFTWARE']     | 服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache/2.2.24) |
| $_SERVER['SERVER_PROTOCOL']     | 请求页面时通信协议的名称和版本。例如，"HTTP/1.0"。           |
| $_SERVER['REQUEST_METHOD']      | 访问页面使用的请求方法；例如，"GET", "HEAD"，"POST"，"PUT"。 |
| $_SERVER['REQUEST_TIME']        | 请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496)   |
| $_SERVER['QUERY_STRING']        | query string（查询字符串），如果有的话，通过它进行页面访问。 |
| $_SERVER['HTTP_ACCEPT']         | 当前请求头中 Accept: 项的内容，如果存在的话。                |
| $_SERVER['HTTP_ACCEPT_CHARSET'] | 当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如："iso-8859-1,*,utf-8"。 |
| $_SERVER['HTTP_HOST']           | 当前请求头中 Host: 项的内容，如果存在的话。                  |
| $_SERVER['HTTP_REFERER']        | 引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。) |
| $_SERVER['HTTPS']               | 如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。      |
| $_SERVER['REMOTE_ADDR']         | 浏览当前页面的用户的 IP 地址。                               |
| $_SERVER['REMOTE_HOST']         | 浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。 |
| $_SERVER['REMOTE_PORT']         | 用户机器上连接到 Web 服务器所使用的端口号。                  |
| $_SERVER['SCRIPT_FILENAME']     | 当前执行脚本的绝对路径。                                     |
| $_SERVER['SERVER_ADMIN']        | 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：someone@runoob.com) |
| $_SERVER['SERVER_PORT']         | Web 服务器使用的端口。默认值为 "80"。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。 |
| $_SERVER['SERVER_SIGNATURE']    | 包含了服务器版本和虚拟主机名的字符串。                       |
| $_SERVER['PATH_TRANSLATED']     | 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 |
| $_SERVER['SCRIPT_NAME']         | 包含当前脚本的路径。这在页面需要指向自己时非常有用。__FILE__ 常量包含当前脚本(例如包含文件)的完整路径和文件名。 |
| $_SERVER['SCRIPT_URI']          | URI 用来指定要访问的页面。例如 "/index.html"。               |



##### \_REQUEST

预定义的 \$_REQUEST 变量包含了 \$\_GET、\$\_POST 和 \$\_COOKIE 的内容。

\$\_REQUEST 变量可用来收集通过 GET 和 POST 方法发送的表单数据。

举例：

```php
<!DOCTYPE html>
<html>
<body>

<form method="post" action="<?php echo $_SERVER['PHP_SELF'];?>">
Name: <input type="text" name="fname">
<input type="submit">
</form>

<?php 
$name = htmlspecialchars($_REQUEST['fname']); 
echo $name; 
?>

</body>
</html>
```



##### _POST

举例：

```php+HTML
<!DOCTYPE html>
<html>
<body>

<form method="post" action="<?php echo $_SERVER['PHP_SELF'];?>">
Name: <input type="text" name="fname">
<input type="submit">
</form>

<?php 
$name = htmlspecialchars($_POST['fname']); 
echo $name; 
?>

</body>
</html>
```



##### _GET

举例：

```html
<html>
<body>
<a href="test_get.php?subject=PHP&web=runoob.com">Test $GET</a>
</body>
</html>
```

```php+HTML
<!DOCTYPE html>
<html>
<body>

<a href="test_get.php?subject=PHP&web=runoob.com">测试 $_GET</a>

</body>
</html>
```



##### _COOKIE

是关联数组。通常用`isset`函数查找某个键值是否存在。

操作函数：`setcookie(键,值,过期时间)`

删除即更改过期时间为当前之前的时间即可，如：

```php
<?php
// 设置 cookie 过期时间为过去 1 小时
setcookie("user", "", time()-3600);
?>
```



##### _SESSION

PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。

> （未核实）该信息是临时的，在用户离开网站后将被删除。

删除某些 session 数据，可以使用 unset() 或 session_destroy() 函数。后者彻底删除全部session数据。



#### 对象

##### 概述

定义用`class`关键字(语法类似java)。成员属性用`var`关键字，可以声明初始值。

新建变量用`new 类名`，如果没有构造函数可以不写括号。访问变量的成员都用`->`操作符。

`$this`表示self指针，用`$this->`运算符访问成员属性。

构造函数是`__construct`，析构函数是`__destruct`。子类构造方法不能自动调用父类的构造方法。

继承用`extends`，不支持多继承。`parent`关键字加`::`访问父类。

访问控制关键字同C：

> - **public（公有）：**公有的类成员可以在任何地方被访问。
> - **protected（受保护）：**受保护的类成员则可以被其自身以及其子类和父类访问。
> - **private（私有）：**私有的类成员则只能被其定义所在的类访问。

(有关键字时可以不声明`var`，`var`认为是共有)。成员函数不设置控制关键字默认为公有。子类不能重定义私有成员，其他可以。

接口的语法同JAVA。显然类中必须实现接口中定义的所有方法。

常成员(常量)用`const`定义，调用为`类名::常量名`或`$实例名::常量名`，或字符串值为类名的：`$字符串::常量名`。常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。

抽象类语法同JAVA。

> 继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。
>
> 此外，子类方法可以包含父类抽象方法中不存在的可选参数。
>
> 例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则也是可以正常运行的。

静态成员语法同java。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。调用为`类名::静态成员`

> 自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static。

final语法同JAVA。类为final不可继承。

如：

```php
<?php
/**
 * Define MyClass
 */
class MyClass
{
    public $public = 'Public';
    protected $protected = 'Protected';
    private $private = 'Private';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj = new MyClass();
echo $obj->public; // 这行能被正常执行
echo $obj->protected; // 这行会产生一个致命错误
echo $obj->private; // 这行也会产生一个致命错误
$obj->printHello(); // 输出 Public、Protected 和 Private


/**
 * Define MyClass2
 */
class MyClass2 extends MyClass
{
    // 可以对 public 和 protected 进行重定义，但 private 而不能
    protected $protected = 'Protected2';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj2 = new MyClass2();
echo $obj2->public; // 这行能被正常执行
echo $obj2->private; // 未定义 private
echo $obj2->protected; // 这行会产生一个致命错误
$obj2->printHello(); // 输出 Public、Protected2 和 Undefined

?>
```

```php
<?php
abstract class AbstractClass
{
    // 我们的抽象方法仅需要定义需要的参数
    abstract protected function prefixName($name);

}

class ConcreteClass extends AbstractClass
{

    // 我们的子类可以定义父类签名中不存在的可选参数
    public function prefixName($name, $separator = ".") {
        if ($name == "Pacman") {
            $prefix = "Mr";
        } elseif ($name == "Pacwoman") {
            $prefix = "Mrs";
        } else {
            $prefix = "";
        }
        return "{$prefix}{$separator} {$name}";
    }
}

$class = new ConcreteClass;
echo $class->prefixName("Pacman"), "\n";
echo $class->prefixName("Pacwoman"), "\n";
?>
```



##### trait

一种代码复用的方法。

声明：`trait 名字{}`，调用：`use 名字;`

如：

```php
<?php
class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}
 
trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}
 
class MyHelloWorld extends Base {
    use SayWorld;
}
 
$o = new MyHelloWorld();
$o->sayHello();
?>
```



#### 可变变量

`$普通变量` ，如 `$$x` 。那么这个变量的变量名是可以变化的。（初始赋值是变，再改就不动了）

```php
$name = "lr580";
$$name = 580;
echo $lr580;
$name = "baicha";
echo $baicha; //NULL
echo $lr580; //可以
$baicha = 233; //重新赋值
echo $$name; //233
echo $baicha; //233
echo $lr580; //580
```

换言之就是跟一个数组一样的用法，即 `$key` 。然后 `$$` 就是当前指向的 key 。



#### 传引用

跟 C++ 一样，赋值时只要 `$x = &$y` 那么 `$x` 就是传引用

通过引用赋值定义的变量与原变量并不是表示同一个内存单元，而仅仅是其值相互关联而已。所以，若对原变量使用销毁(unset)操作，则不会导致引用变量的消失。销毁操作后，仅仅是取消了2个变量值的关联，如：

```php
$x = 580;
$y = &$x;
unset($x);
var_dump($y);
```



#### 运算符

除法默认是浮点除。

![image-20220513173643295](img/image-20220513173643295.png)

如：

```php
echo 1 <=> 2, 2 <=> 2, 3 <=> 2, null ?? 1 ?? 2, 3 ?? null;
```

逻辑运算可以用 `&&,||,!` 以及 `and,or,xor,not` ，返回布尔值。

位运算跟 C 一样。

其他：

`instanceof` 判断一个对象是否是某个类的对象。类型运算符。

\` 运算符会把反引号内内容作为操作系统系统命令执行并返回结果。执行运算符。

@ 错误抑制运算符，报错不输出。

类型转换：显式转换有 `setType(), intval(), floatval(), strval()` 和强转。

如：

```php
class people
{
};
$x = new people();
echo $x instanceof object; //false
echo "|";
echo $x instanceof people;
```

```php
@(1 / 0);
1 / 0;
```

```php
$x1 = 1 / 3;
settype($x1, 'string');
var_dump($x1);
$x2 = '580LR2';
settype($x2, 'int');
var_dump($x2); //580
$x3 = 10;
settype($x3, 'object');
var_dump($x3); //有一个属性 scalar
$x4 = 'QwQ';
settype($x4, 'array');
var_dump($x4); //首元素是它
```

```php
echo intval(5 / 3); //1
$x1 = 3;
var_dump((object)$x1);
var_dump((array)$x1); //同settype
```



### 流程控制

#### 条件判断

##### if

使用`if(),elseif(),else()`，大括号括起来语句(或不括起来单行)，语法大同C。`elseif`写成`else if`也行。

##### switch

语法同C。case可以是字符串或浮点数。如：

```php
<?php
$x=3.1;
switch($x)
{
    case 3.1:
        echo 'awa';
}
?>
```



#### 循环

`for`,`while`和`do...while`格式同C。

有`foreach($数组 as $下标变量 => $值变量)`。



#### 函数

以字母或下划线开头（不能以数字开头）。

创建语法：

```php
function 函数名(参数)
{
    
}
```

可以有默认参数。如：

```php
<?php
function f($x=1)
{
    echo $x;
}
f();
f(2);
?>
```

可以传引用，如`function foo(&$bar){...`

用函数作参数(callable)见变量-数据类型-callable



#### 命名空间

##### 定义

未定义命名空间时，所有常量、类和函数放在全局空间。

文件包含命名空间时，必须在所有其他代码之前声明：`namespace 空间名;`或`namespace 名{代码块}`。第二种解法常用于一个代码文件有多个空间时。

全局代码用无名的`namespace{}`。声明了之后整个文件部分都必须在任何一个命名空间或全局代码大括号内，不能在别的地方。

调用命名空间：`空间名\空间内的内容名`

如：

```php
<?php
namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace { // 全局代码
session_start();
$a = MyProject\connect();
echo MyProject\Connection::start();
}
?>
```

有命名空间后，声明空间前唯一合法的代码是`declare`，如：

```php
<?php
declare(encoding='UTF-8'); //定义多个命名空间和不包含在命名空间中的代码
namespace {...
?>
```

可以定义子空间，如`namespace MyProject\Sub\Level`。

全局变量可以使用完全限定名称调用，如全局函数`f`可写作调用`\f()`，常量、类等同理。



##### 引用

`use 命名空间`

`use 命名空间 as 别名`

可以用关键字`namespace`显式访问当前命名空间及其子空间的元素，等价类的`self`操作符。

如：

```php
<?php
namespace MyProject;

use blah\blah as mine; // 引入了 blah\blah 命名空间，并定义了个别名mine

mine\mine(); // 调用函数 blah\blah\mine()
namespace\blah\mine(); // 调用函数 MyProject\blah\mine()

namespace\func(); // 调用函数 MyProject\func()
namespace\sub\func(); // 调用函数 MyProject\sub\func()
namespace\cname::method(); // 调用 MyProject\cname 类的静态方法
$a = new namespace\sub\cname(); // 实例化 MyProject\sub\cname 类的对象
$b = namespace\CONSTANT; // 将常量 MyProject\CONSTANT 的值赋给 $b
?>
```

```php
<?php
namespace\func(); // calls function func()
namespace\sub\func(); // calls function sub\func()
namespace\cname::method(); // calls static method "method" of class cname
$a = new namespace\sub\cname(); // instantiates object of class sub\cname
$b = namespace\CONSTANT; // assigns value of constant CONSTANT to $b
?>
```

```php
<?php
namespace foo;
use My\Full\Classname as Another;

// 下面的例子与 use My\Full\NSname as NSname 相同
use My\Full\NSname;

// 导入一个全局类
use \ArrayObject;

$obj = new namespace\Another; // 实例化 foo\Another 对象
$obj = new Another; // 实例化 My\Full\Classname　对象
NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func
$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象
// 如果不使用 "use \ArrayObject" ，则实例化一个 foo\ArrayObject 对象
?>
```

```php
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // 实例化 My\Full\Classname 对象
NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func
?>
```

甚至可以用字符串动态生成命名空间对象：

```php
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // 实例化一个 My\Full\Classname 对象
$a = 'Another';
$obj = new $a;      // 实际化一个 Another 对象
?>
```

> 名称解析遵循下列规则：
>
> 1. 对完全限定名称的函数，类和常量的调用在编译时解析。例如 *new \A\B* 解析为类 *A\B*。
>
> 2. 所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 *A\B\C* 被导入为 *C*，那么对 *C\D\e()* 的调用就会被转换为 *A\B\C\D\e()*。
>
> 3. 在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 *A\B* 内部调用 *C\D\e()*，则 *C\D\e()* 会被转换为 *A\B\C\D\e()* 。
>
> 4. 非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 *A\B\C* 导入为C，则 *new C()* 被转换为 *new A\B\C()* 。
>
> 5. 在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数
>
> 
>
>    foo()
>
> 
>
>    的调用是这样解析的：
>
>    1. 在当前命名空间中查找名为 *A\B\foo()* 的函数
>    2. 尝试查找并调用 *全局(global)* 空间中的函数 *foo()*。
>
> 6. 在命名空间（例如
>
>    A\B
>
>    ）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用
>
> 
>
>    new C()
>
> 
>
>    及
>
> 
>
>    new D\E()
>
> 
>
>    的解析过程：
>
> 
>
>    new C()
>
>    的解析:
>
>    1. 在当前命名空间中查找*A\B\C*类。
>    2. 尝试自动装载类*A\B\C*。
>
>    new D\E()
>
>    的解析:
>
>    1. 在类名称前面加上当前命名空间名称变成：*A\B\D\E*，然后查找该类。
>    2. 尝试自动装载类 *A\B\D\E*。
>
>    为了引用全局命名空间中的全局类，必须使用完全限定名称
>
> 
>
>    new \C()



#### 包含文件

使用`include`或`require`操作符加上字符串文件名，表示在此处插入别的文件的代码。

> 这两个操作符的区别在于
>
> ①错误处理方式：
>
> - require 生成`E_COMPILE_ERROR`，错误发生后脚本停止执行
> - include 生成`E_WARNING`，错误发生后脚本继续执行
>
> ②位置：
>
> - require 一般放在文件最前面，程序执行前先导入要引用的文件
> - include 一般放在程序的流程控制中，程序执行时碰到才会引用
>
> [更多区别](https://www.runoob.com/w3cnote/php-different-include-and-require.html)

如：

```php
<?php
$color='red'; //vars.php
$car='BMW';
?>
```

```php+HTML
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>
<h1>欢迎来到我的主页!</h1>
<?php 
include 'vars.php';
echo "I have a $color $car"; // I have a red BMW
?>
</body>
</html>
```



#### 错误处理

##### 错误处理函数

`set_error_handler(处理函数名字符串)`，设置自定义错误处理程序，当触发了报错时执行。可选参数是规定显示何种错误报告级别的用户定义错误。默认是 `"E_ALL"`。

错误处理函数格式：

```php
error_function(error_level,error_message,
error_file,error_line,error_context)
```

| 参数          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| error_level   | 必需。为用户定义的错误规定错误报告级别。必须是一个数字。参见下面的表格：错误报告级别。 |
| error_message | 必需。为用户定义的错误规定错误消息。                         |
| error_file    | 可选。规定错误发生的文件名。                                 |
| error_line    | 可选。规定错误发生的行号。                                   |
| error_context | 可选。规定一个数组，包含了当错误发生时在用的每个变量以及它们的值。 |

`trigger_error($msg,[$level])`函数触发一个报错，调用设置的错误处理函数，传入对应参数。触发能执行的前提是设置了自定义错误处理函数。

如：

```php
<?php
 // 用户定义的错误处理函数
 function myErrorHandler($errno, $errstr, $errfile, $errline) {
     echo "<b>Custom error:</b> [$errno] $errstr<br>";
     echo " Error on line $errline in $errfile<br>";
 }

 // 设置用户定义的错误处理函数
 set_error_handler("myErrorHandler");

 $test=2;

 // 触发错误
 if ($test>1) {
     trigger_error("A custom error has been triggered");
 }
 ?> 
```

```php
<?php
// 错误处理函数
function customError($errno, $errstr)
{
    echo "<b>Error:</b> [$errno] $errstr<br>";
    echo "已通知网站管理员";
    error_log("Error: [$errno] $errstr",1,
    "someone@example.com","From: webmaster@example.com");
}

// 设置错误处理函数
set_error_handler("customError",E_USER_WARNING);

// 触发错误
$test=2;
if ($test>1)
{
    trigger_error("变量值必须小于等于 1",E_USER_WARNING);
}
?>
```

```php
<?php
function myException($exception)
{
    echo "<b>Exception:</b> " , $exception->getMessage();
}
 
set_exception_handler('myException');
 
throw new Exception('Uncaught Exception occurred');
?>
```



> [详见](https://www.w3school.com.cn/php/php_ref_error.asp)



##### 异常

> 异常处理用于在指定的错误（异常）情况发生时改变脚本的正常流程。这种情况称为异常。
>
> 当异常被触发时，通常会发生：
>
> - 当前代码状态被保存
> - 代码执行被切换到预定义（自定义）的异常处理器函数
> - 根据情况，处理器也许会从保存的代码状态重新开始执行代码，终止脚本执行，或从代码中另外的位置继续执行脚本

当异常被抛出时，其后的代码不会继续执行，PHP 会尝试查找匹配的 "catch" 代码块。

如果异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么将发生一个严重的错误（致命错误），并且输出 "Uncaught Exception" （未捕获异常）的错误消息/直接服务器内部错误(SCNUOJ环境)。

如：

```php
<?php
throw new Exception("Value must be 1 or below");
?>
```

格式：

```php
try
{
    ...
}
catch(错误类 $变量) //若干个catch
{
    
}
```

`set_exception_handler()` 函数可设置处理所有未捕获异常的用户定义函数。函数参数是一个错误处理函数名，该函数需要处理一个参数，该参数为异常实例。

异常具有的方法有：`getLine`,`getFile`,`getMessage`。

抛出异常的语句为`throw new 异常类(构造函数参数)`

如：

```php
<?php
// 创建一个有异常处理的函数
function checkNum($number)
{
    if($number>1)
    {
        throw new Exception("变量值必须小于等于 1");
    }
        return true;
}
    
// 在 try 块 触发异常
try
{
    checkNum(2);
    // 如果抛出异常，以下文本不会输出
    echo '如果输出该内容，说明 $number 变量';
}
// 捕获异常
catch(Exception $e)
{
    echo 'Message: ' .$e->getMessage();
}
?>
```

可以定义自定义异常类如：

```php
<?php
class customException extends Exception
{
    public function errorMessage()
    {
        // 错误信息
        $errorMsg = '错误行号 '.$this->getLine().' in '.$this->getFile()
        .': <b>'.$this->getMessage().'</b> 不是一个合法的 E-Mail 地址';
        return $errorMsg;
    }
}
?>
```





### 内建函数

##### 变量操作

###### isset

检测变量是否设置，并且不是 `null`

如果一次传入多个参数，那么 isset() 只有在全部参数都以被设置时返回 `true` 计算过程从左至右，中途遇到没有设置的变量时就会立即停止。

###### unset

销毁若干个变量(可变参数)。

如果是全局变量，在函数中销毁，只在函数生效。但对`$_GLOBALS`则全局生效。

如果是引用参数变量，只在函数内销毁。

如果是函数静态变量，只在此次生效，下次调用还在。

如：

```php
<?php
$x=1;
unset($x);
echo empty($x);
?>
```



###### filter_var

检测变量是否符合过滤器要求。如果成功，则返回已过滤的数据，如果失败，则返回 false。

第一个参数是待检验变量，第二个是过滤器ID。

如：

```php
<?php
if(!filter_var("someone@example....com", FILTER_VALIDATE_EMAIL))
 {
 echo("E-mail is not valid");
 }
else
 {
 echo("E-mail is valid");
 }
?>
```

```php
<?php
$int = 123;
 
if(!filter_var($int, FILTER_VALIDATE_INT))
{
    echo("不是一个合法的整数");
}
else
{
    echo("是个合法的整数");
}
?>
```

```php
<?php
$var=300;
 
$int_options = array(
    "options"=>array
    (
        "min_range"=>0,
        "max_range"=>256
    )
);
 
if(!filter_var($var, FILTER_VALIDATE_INT, $int_options))
{
    echo("不是一个合法的整数");
}
else
{
    echo("是个合法的整数");
}
?>
```

```php
<?php
$filters = array
(
    "name" => array
    (
        "filter"=>FILTER_SANITIZE_STRING
    ),
    "age" => array
    (
        "filter"=>FILTER_VALIDATE_INT,
        "options"=>array
        (
            "min_range"=>1,
            "max_range"=>120
        )
    ),
    "email"=> FILTER_VALIDATE_EMAIL
);
 
$result = filter_input_array(INPUT_GET, $filters);
 
if (!$result["age"])
{
    echo("年龄必须在 1 到 120 之间。<br>");
}
elseif(!$result["email"])
{
    echo("E-Mail 不合法<br>");
}
else
{
    echo("输入正确");
}
?>
```



过滤器分类：

Validating 过滤器：

- 用于验证用户输入
- 严格的格式规则（比如 URL 或 E-Mail 验证）
- 如果成功则返回预期的类型，如果失败则返回 FALSE

Sanitizing 过滤器：

- 用于允许或禁止字符串中指定的字符
- 无数据格式规则
- 始终返回字符串



通过使用 FILTER_CALLBACK 过滤器，可以调用自定义的函数，把它作为一个过滤器来使用。

```php
<?php
function convertSpace($string)
{
    return str_replace("_", ".", $string);
}
 
$string = "www_runoob_com!";
 
echo filter_var($string, FILTER_CALLBACK,
array("options"=>"convertSpace"));
?>
```



> [过滤器参见这里](https://www.w3school.com.cn/php/php_ref_filter.asp)
>
> - filter_var() - 通过一个指定的过滤器来过滤单一的变量
> - filter_var_array() - 通过相同的或不同的过滤器来过滤多个变量
> - filter_input - 获取一个输入变量，并对它进行过滤
> - filter_input_array - 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤
>
> [过滤器使用](https://www.runoob.com/php/php-filter.html)
>
> [更多举例](https://www.runoob.com/php/php-filter-advanced.html)



##### 字符处理

###### htmlspecialchars

将HTML标签失效。例如字符串里有`<b></b>`，将会直接输出，而不是渲染加粗。

失效字符包括：`&,",',<,>`，转化为`&amp,&qpot,&#039,&lt,&gt`



###### trim

去除手尾空白字符。



###### stripslashes

去除所有`\`，如：

```php
<?php
echo stripslashes('1\2\n3'); //12n3
// echo stripslashes("1\2\n3"); //nope
?>
```



###### empty

是否为空。变量为$0$、空字符、不存在或NULL时为真。如：

```php
<?php
echo empty($t);
echo empty('');
echo empty(NULL); //都是true
echo empty(0);
echo empty(1);
echo empty(0.0);
?>
```



###### preg_match

正则表达式匹配。参数为`$pattern,$subject,[$matches(array),[$flags]]`。`$matches[0]`包含于整个模式匹配的文本，`$matches[1]`包含第一个括号的子模式匹配文本。相当于返回的数组。

正则表达式文本格式同json。

如：

```php
if (!preg_match("/^[a-zA-Z ]*$/",$name)) {
  $nameErr = "只允许字母和空格"; 
}
```

常用正则：

- 邮箱 `/([\w\-]+\@[\w\-]+\.[\w\-]+)/`

  `/^\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/`
- URL `/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&@#\/%?=~_|!:,.;]*[-a-z0-9+&@#\/%=~_|]/`



###### explode

字符串分割，第一个参数是分割符，第二个参数是字符串变量。可选第三个参数表示结果数组元素限制最大数。



###### strpos

即find，第一个参数是被查找串，第二个参数是要查找的子串。大小写敏感。失败返回false。

大小写不敏感用`stripos`，倒找用`strrpos,strripos`。



##### 日期时间

###### date

> [时间日期参考手册](https://www.runoob.com/php/func-date-date.html)

第一个参数是字符串输出格式，`Y,m,d`代表年(四位)月($[01,12]$)日($01,31$)，其他字符代表本身的含义。返回字符串。第二个参数是整数时间戳，可缺省。如：

```php
<?php
echo date('Y/m/d H:i:s');
?>
```



> 具体格式有：
>
> | `format` 字符        | 说明                                                         | 返回值例子                                                   |
> | :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
> | *日*                 | ---                                                          | ---                                                          |
> | *d*                  | 月份中的第几天，有前导零的 2 位数字                          | *01* 到 *31*                                                 |
> | *D*                  | 星期中的第几天，文本表示，3 个字母                           | *Mon* 到 *Sun*                                               |
> | *j*                  | 月份中的第几天，没有前导零                                   | *1* 到 *31*                                                  |
> | *l*（"L"的小写字母） | 星期几，完整的文本格式                                       | *Sunday* 到 *Saturday*                                       |
> | *N*                  | ISO-8601 格式数字表示的星期中的第几天（PHP 5.1.0 新加）      | *1*（表示星期一）到 *7*（表示星期天）                        |
> | *S*                  | 每月天数后面的英文后缀，2 个字符                             | *st*，*nd*，*rd* 或者 *th*。可以和 *j* 一起用                |
> | *w*                  | 星期中的第几天，数字表示                                     | *0*（表示星期天）到 *6*（表示星期六）                        |
> | *z*                  | 年份中的第几天                                               | *0* 到 *365*                                                 |
> | *星期*               | ---                                                          | ---                                                          |
> | *W*                  | ISO-8601 格式年份中的第几周，每周从星期一开始（PHP 4.1.0 新加的） | 例如：*42*（当年的第 42 周）                                 |
> | *月*                 | ---                                                          | ---                                                          |
> | *F*                  | 月份，完整的文本格式，例如 January 或者 March                | *January* 到 *December*                                      |
> | *m*                  | 数字表示的月份，有前导零                                     | *01* 到 *12*                                                 |
> | *M*                  | 三个字母缩写表示的月份                                       | *Jan* 到 *Dec*                                               |
> | *n*                  | 数字表示的月份，没有前导零                                   | *1* 到 *12*                                                  |
> | *t*                  | 给定月份所应有的天数                                         | *28* 到 *31*                                                 |
> | *年*                 | ---                                                          | ---                                                          |
> | *L*                  | 是否为闰年                                                   | 如果是闰年为 *1*，否则为 *0*                                 |
> | *o*                  | ISO-8601 格式年份数字。这和 *Y* 的值相同，只除了如果 ISO 的星期数（*W*）属于前一年或下一年，则用那一年。（PHP 5.1.0 新加） | Examples: *1999* or *2003*                                   |
> | *Y*                  | 4 位数字完整表示的年份                                       | 例如：*1999* 或 *2003*                                       |
> | *y*                  | 2 位数字表示的年份                                           | 例如：*99* 或 *03*                                           |
> | *时间*               | ---                                                          | ---                                                          |
> | *a*                  | 小写的上午和下午值                                           | *am* 或 *pm*                                                 |
> | *A*                  | 大写的上午和下午值                                           | *AM* 或 *PM*                                                 |
> | *B*                  | Swatch Internet 标准时                                       | *000* 到 *999*                                               |
> | *g*                  | 小时，12 小时格式，没有前导零                                | *1* 到 *12*                                                  |
> | *G*                  | 小时，24 小时格式，没有前导零                                | *0* 到 *23*                                                  |
> | *h*                  | 小时，12 小时格式，有前导零                                  | *01* 到 *12*                                                 |
> | *H*                  | 小时，24 小时格式，有前导零                                  | *00* 到 *23*                                                 |
> | *i*                  | 有前导零的分钟数                                             | *00* 到 *59*>                                                |
> | *s*                  | 秒数，有前导零                                               | *00* 到 *59*>                                                |
> | *u*                  | 毫秒 （PHP 5.2.2 新加）。需要注意的是 **date()** 函数总是返回 *000000* 因为它只接受 integer 参数， 而 DateTime::format() 才支持毫秒。 | 示例: *654321*                                               |
> | *时区*               | ---                                                          | ---                                                          |
> | *e*                  | 时区标识（PHP 5.1.0 新加）                                   | 例如：*UTC*，*GMT*，*Atlantic/Azores*                        |
> | *I*                  | 是否为夏令时                                                 | 如果是夏令时为 *1*，否则为 *0*                               |
> | *O*                  | 与格林威治时间相差的小时数                                   | 例如：*+0200*                                                |
> | *P*                  | 与格林威治时间（GMT）的差别，小时和分钟之间有冒号分隔（PHP 5.1.3 新加） | 例如：*+02:00*                                               |
> | *T*                  | 本机所在的时区                                               | 例如：*EST*，*MDT*（【译者注】在 Windows 下为完整文本格式，例如"Eastern Standard Time"，中文版会显示"中国标准时间"）。 |
> | *Z*                  | 时差偏移量的秒数。UTC 西边的时区偏移量总是负的，UTC 东边的时区偏移量总是正的。 | *-43200* 到 *43200*                                          |
> | *完整的日期／时间*   | ---                                                          | ---                                                          |
> | *c*                  | ISO 8601 格式的日期（PHP 5 新加）                            | 2004-02-12T15:19:21+00:00                                    |
> | *r*                  | RFC 822 格式的日期                                           | 例如：*Thu, 21 Dec 2000 16:01:07 +0200*                      |
> | *U*                  | 从 Unix 纪元（January 1 1970 00:00:00 GMT）开始至今的秒数    | 参见 time()                                                  |



##### JSON

###### json_encode

对传入变量进行JSON编码。成功返回数据，否则false。

> 有可选参数：由以下常量组成的二进制掩码 JSON_HEX_QUOT, JSON_HEX_TAG, JSON_HEX_AMP, JSON_HEX_APOS, JSON_NUMERIC_CHECK, JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES, JSON_FORCE_OBJECT, JSON_PRESERVE_ZERO_FRACTION, JSON_UNESCAPED_UNICODE, JSON_PARTIAL_OUTPUT_ON_ERROR。
>
> JSON_UNESCAPED_UNICODE 选项跳过中文编码

如：

```php
<?php
   $arr = array('a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5);
   echo json_encode($arr);
?>
```



###### json_decode

解码并转化为php变量。

`mixed json_decode ($json_string [,$assoc = false [, $depth = 512 [, $options = 0 ]]])`

- **json_string**: 待解码的 JSON 字符串，必须是 UTF-8 编码数据
- **assoc**: 当该参数为 TRUE 时，将返回数组，FALSE 时返回对象。
- **depth**: 整数类型的参数，它指定递归深度
- **options**: 二进制掩码，目前只支持 JSON_BIGINT_AS_STRING 。



##### 流程控制

###### exit

`exit($msg)`。`die`的别名。输出一条消息并结束执行当前脚本`.php`文件。

###### exec

执行本地指令，如 `exec('python test.py')`。

也可以用 `shell_exec`



##### 文件操作

###### file_exists

文件或目录是否存在

###### move_uploaded_file

将上传的文件(参数1)移动到新位置(参数2)。若成功，则返回 true，否则返回 false。参数1一般是`$_FILES[表单控件name属性]["tmp_name"]`

> 如果目标文件已经存在，将会被覆盖



##### 配置控制

###### ini_set

修改配置文件，如显示报错：

```php
ini_set('display_errors',1);
```



##### cookie

```php
setcookie($key, $value);
echo $_COOKIE[$key];
```



##### session

```php
session_start();
$_SESSION['views']=1;
echo "浏览量：". $_SESSION['views'];
if(isset($_SESSION['views']))
{
    unset($_SESSION['views']);
}
session_destroy(); //重置 session，失去所有已存储的 session 数据
```





### 输入输出

#### 标准输出

##### echo

一次输出一个或多个字符串，多个用逗号隔开，输出时等效于echo多次，不会有分割符，无返回值

可以用echo或echo()，即关键字语法或函数语法

输出效果同js的document.write，所以可以用标签，甚至可以直接在字符串里输出变量：

```php
<?php
echo "<h1>这是","一个标题</h1>";
echo 1e9+7,PHP_EOL,"1"+'234'; //注意字符输出235
echo(1/3); //很多位
//注意加了括号就只能有一个参数了
// echo "s"+"y"; 没有字符串+运算符
?>
```

```php
<?php $x="lr580";echo "I am $x";?> //注意php和$x之间有空格
```

一般而言用`'<br/>'`代表换行。

实现特定秒后自动跳转：[参考](https://blog.csdn.net/qq_36527174/article/details/111574534) (下文例子3秒)

```php
echo "<meta http-equiv='refresh' content ='3;url=index.html'>";
```





##### print

一次输出一个字符串，返回值为1，比echo慢。用法语法完全同echo。



##### print_r

打印变量，以更容易理解的形式展示。常用于输出一个数组。



##### var_dump



##### var_export

`var_export` 可以将一个数组转为一个字符串不同于`var_dump` , `var_export` 并不会输出数据的类型以及字符大小等,只会简单把数组的key跟value拼接成一个字符串



##### 常量

PHP_EOL 换行符



#### 表单I/O

##### POST

默认情况下，POST 方法的发送信息的量最大值为 8 MB（可通过设置 php.ini 文件中的 post_max_size 进行更改）。

在前端，提交的`post`表单，提交后跳转到其`action`指向的网页，并传入提交信息。用`$_POST[键]`即可得到这些信息，如：

```html
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>
 
<form action="welcome.php" method="post">
名字: <input type="text" name="fname">
年龄: <input type="text" name="age">
<input type="submit" value="提交">
</form>
 
</body>
</html>
```

```php
欢迎<?php echo $_POST["fname"]; ?>!<br>
你的年龄是 <?php echo $_POST["age"]; ?>  岁。
```

对自己搭的服务器，可能需要配置：

```php
header("Access-Control-Allow-Origin:*");
header("Access-Control-Allow-Methods:GET,POST");
```



##### GET

HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的

如：

```HTML
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>

<form action="welcome.php" method="get">
名字: <input type="text" name="fname">
年龄: <input type="text" name="age">
<input type="submit" value="提交">
</form>

</body>
</html>
```

```php+HTML
欢迎 <?php echo $_GET["fname"]; ?>!<br>
你的年龄是 <?php echo $_GET["age"]; ?>  岁。
```



##### 表单控件

###### 下拉菜单

可以通过后端`.php`代码创建下拉菜单。单选举例：表单使用 GET 方式获取数据，action 属性值为空表示提交到当前脚本，我们可以通过 select 的 name 属性获取下拉菜单的值。

```php+HTML
<?php //按下提交后 if $q部分显示
$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';
if($q) {
        if($q =='RUNOOB') {
                echo '菜鸟教程<br>http://www.runoob.com';
        } else if($q =='GOOGLE') {
                echo 'Google 搜索<br>http://www.google.com';
        } else if($q =='TAOBAO') {
                echo '淘宝<br>http://www.taobao.com';
        }
} else { //按下提交前下面部分显示
?>
<form action="" method="get"> 
    <select name="q">
    <option value="">选择一个站点:</option>
    <option value="RUNOOB">Runoob</option>
    <option value="GOOGLE">Google</option>
    <option value="TAOBAO">Taobao</option>
    </select>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```

多选举例：

```php+HTML
<?php
$q = isset($_POST['q'])? $_POST['q'] : '';
if(is_array($q)) {
    $sites = array(
            'RUNOOB' => '菜鸟教程: http://www.runoob.com',
            'GOOGLE' => 'Google 搜索: http://www.google.com',
            'TAOBAO' => '淘宝: http://www.taobao.com',
    );
    foreach($q as $val) {
        // PHP_EOL 为常量，用于换行
        echo $sites[$val] . PHP_EOL;
    }
      
} else {
?>
<form action="" method="post"> 
    <select multiple="multiple" name="q[]">
    <option value="">选择一个站点:</option>
    <option value="RUNOOB">Runoob</option>
    <option value="GOOGLE">Google</option>
    <option value="TAOBAO">Taobao</option>
    </select>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



###### 单选按钮

```php+HTML
<?php
$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';
if($q) {
        if($q =='RUNOOB') {
                echo '菜鸟教程<br>http://www.runoob.com';
        } else if($q =='GOOGLE') {
                echo 'Google 搜索<br>http://www.google.com';
        } else if($q =='TAOBAO') {
                echo '淘宝<br>http://www.taobao.com';
        }
} else {
?><form action="" method="get"> 
    <input type="radio" name="q" value="RUNOOB" />Runoob
    <input type="radio" name="q" value="GOOGLE" />Google
    <input type="radio" name="q" value="TAOBAO" />Taobao
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



###### 复选框

```php+HTML
<?php
$q = isset($_POST['q'])? $_POST['q'] : '';
if(is_array($q)) {
    $sites = array(
            'RUNOOB' => '菜鸟教程: http://www.runoob.com',
            'GOOGLE' => 'Google 搜索: http://www.google.com',
            'TAOBAO' => '淘宝: http://www.taobao.com',
    );
    foreach($q as $val) {
        // PHP_EOL 为常量，用于换行
        echo $sites[$val] . PHP_EOL;
    }
      
} else {
?><form action="" method="post"> 
    <input type="checkbox" name="q[]" value="RUNOOB"> Runoob<br> 
    <input type="checkbox" name="q[]" value="GOOGLE"> Google<br> 
    <input type="checkbox" name="q[]" value="TAOBAO"> Taobao<br>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



##### 表单检验

> 当黑客使用跨网站脚本的HTTP链接来攻击时，$_SERVER["PHP_SELF"]服务器变量也会被植入脚本，所以下面两段代码中不安全：
>
> ```php+HTML
> <form method="post" action="<?php echo $_SERVER["PHP_SELF"];?>">
> ```
>
> ```php+HTML
> <form method="post" action="test_form.php">
> ```
>
> 对于下面的代码，网址为`http://www.runoob.com/test_form.php/%22%3E%3Cscript%3Ealert('hacked')%3C/script%3E`时，解析为：
>
> ```html
> <form method="post" action="test_form.php/"><script>alert('hacked')</script>
> ```
>
> 因此，用`htmlspecialchars()`来避免攻击：
>
> ```php+HTML
> <form method="post" action="<?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?>">
> ```
>
> 此外可以用`trim()`函数去除空白字符。

一般而言，综上所述，使用三件套自定义函数：

```php
function test_input($data) {
  $data = trim($data);
  $data = stripslashes($data);
  $data = htmlspecialchars($data);
  return $data;
}
```

检验空的代码示例：

```php+HTML
<form method="post" action="<?php echo htmlspecialchars($_SERVER['PHP_SELF']);?>"> 
   名字: <input type="text" name="name">
   <span class="error">* <?php echo $nameErr;?></span>
   <input type="submit" name="submit" value="Submit"> 
</form>
```

```php
<?php
// 定义变量并默认设为空值
$nameErr = "";
$name = "";

if ($_SERVER["REQUEST_METHOD"] == "POST") {
  if (empty($_POST["name"])) {
    $nameErr = "名字是必需的。";
  } else {
    $name = test_input($_POST["name"]);
  }
}
?>
```



#### 文件I/O

##### 读写

使用`fopen(路径,模式)`。打开失败返回$0$(false)，否则返回文件流。

记得关闭`fclose($文件流)`。

模式有：

| 模式 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| r    | 只读。在文件的开头开始。                                     |
| r+   | 读/写。在文件的开头开始。                                    |
| w    | 只写。打开并清空文件的内容；如果文件不存在，则创建新文件。   |
| w+   | 读/写。打开并清空文件的内容；如果文件不存在，则创建新文件。  |
| a    | 追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。 |
| a+   | 读/追加。通过向文件末尾写内容，来保持文件内容。              |
| x    | 只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。  |
| x+   | 读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 |

如：

```php
<?php
$file=fopen("welcome.txt","r") or exit("Unable to open file!");
?>
```

有`feof($file)`。

逐行读取用`fgets($file)`。

逐字符用`fgetc`

> [更多请参考这里](https://www.runoob.com/php/php-ref-filesystem.html)



##### 上传

用户上传文件到服务器，前端脚本示例：

```html
<form action="upload_file.php" method="post" enctype="multipart/form-data">
    <label for="file">文件名：</label>
    <input type="file" name="file" id="file"><br>
    <input type="submit" name="submit" value="提交">
</form>
```

上传后，全局变量`$_FILES`可以看到文件。一维键是表单的`input`的`name`，二维键可以是：

- `$_FILES["file"]["name"]` - 上传文件的名称

- `$_FILES["file"]["type"] `- 上传文件的类型

  如：`"image/gif"`

- `$_FILES["file"]["size"]` - 上传文件的大小，以字节计

- `$_FILES["file"]["tmp_name"]` - 存储在服务器的文件的临时副本的名称

- `$_FILES["file"]["error"]` - 由文件上传导致的错误代码

要保存上传的文件，需要拷贝到另外的位置。不然脚本结束就会消失。



如：

```php
<?php
// 允许上传的图片后缀
$allowedExts = array("gif", "jpeg", "jpg", "png");
$temp = explode(".", $_FILES["file"]["name"]);
echo $_FILES["file"]["size"];
$extension = end($temp);     // 获取文件后缀名
if ((($_FILES["file"]["type"] == "image/gif")
|| ($_FILES["file"]["type"] == "image/jpeg")
|| ($_FILES["file"]["type"] == "image/jpg")
|| ($_FILES["file"]["type"] == "image/pjpeg")
|| ($_FILES["file"]["type"] == "image/x-png")
|| ($_FILES["file"]["type"] == "image/png"))
&& ($_FILES["file"]["size"] < 204800)   // 小于 200 kb
&& in_array($extension, $allowedExts))
{
    if ($_FILES["file"]["error"] > 0)
    {
        echo "错误：: " . $_FILES["file"]["error"] . "<br>";
    }
    else
    {
        echo "上传文件名: " . $_FILES["file"]["name"] . "<br>";
        echo "文件类型: " . $_FILES["file"]["type"] . "<br>";
        echo "文件大小: " . ($_FILES["file"]["size"] / 1024) . " kB<br>";
        echo "文件临时存储的位置: " . $_FILES["file"]["tmp_name"] . "<br>";
        
        // 判断当前目录下的 upload 目录是否存在该文件
        // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777
        if (file_exists("upload/" . $_FILES["file"]["name"]))
        {
            echo $_FILES["file"]["name"] . " 文件已经存在。 ";
        }
        else
        {
            // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下
            move_uploaded_file($_FILES["file"]["tmp_name"], "upload/" . $_FILES["file"]["name"]);
            echo "文件存储在: " . "upload/" . $_FILES["file"]["name"];
        }
    }
}
else
{
    echo "非法的文件格式";
}
?>
```



#### 邮件

mail() 函数用于从脚本中发送电子邮件。数需要一个已安装且正在运行的邮件系统(如：sendmail、postfix、qmail等)。所用的程序通过在 php.ini 文件中的配置设置进行定义。

> [请参见这里](https://www.runoob.com/php/php-mail.html) 下一节还有防止`E-mail`注入的例子



## 功能

### MySQL

#### mysqli

##### 链接

链接到数据库：

`mysqli_connect(host, username, password, dbname,port, socket);`

| 参数       | 描述                                        |
| :--------- | :------------------------------------------ |
| *host*     | 可选。规定主机名或 IP 地址。                |
| *username* | 可选。规定 MySQL 用户名。                   |
| *password* | 可选。规定 MySQL 密码。                     |
| *dbname*   | 可选。规定默认使用的数据库。                |
| *port*     | 可选。规定尝试连接到 MySQL 服务器的端口号。 |
| *socket*   | 可选。规定 socket 或要使用的已命名 pipe。   |

成功链接到 MySQL 后返回连接标识，失败返回 FALSE 。

断开链接：

`bool mysqli_close ( mysqli $link )`

关闭指定的连接标识所关联的到 MySQL 服务器的非持久连接。如果没有指定 link_identifier，则关闭上一个打开的连接。

通常不需要使用 `mysqli_close()`，因为已打开的非持久连接会在脚本执行完毕后自动关闭。

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
    die('Could not connect: ' . mysqli_error());
}
echo '数据库连接成功！';
mysqli_close($conn);
?>
```



##### 报错输出

`mysqli_error(connection)`，返回字符串



##### 语句执行

mysqli_query 函数来创建或者删除 MySQL 数据库。

该函数有两个参数，在执行成功时返回 TRUE，否则返回 FALSE。

`mysqli_query(connection,query,resultmode);`

| 参数         | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| *connection* | 必需。规定要使用的 MySQL 连接。                              |
| *query*      | 必需，规定查询字符串。                                       |
| *resultmode* | 可选。一个常量。可以是下列值中的任意一个：MYSQLI_USE_RESULT（如果需要检索大量数据，请使用这个）MYSQLI_STORE_RESULT（默认） |

可以执行的指令有：

- 数据库创建、删除
- 数据表创建、删除、查询
- 数据插入

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die('连接错误: ' . mysqli_error($conn));
}
echo '连接成功<br />';
$sql = 'CREATE DATABASE RUNOOB';
$retval = mysqli_query($conn,$sql );
if(! $retval )
{
    die('创建数据库失败: ' . mysqli_error($conn));
}
echo "数据库 RUNOOB 创建成功\n";
mysqli_close($conn);
?>
```

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die('连接失败: ' . mysqli_error($conn));
}
echo '连接成功<br />';
// 设置编码，防止中文乱码
mysqli_query($conn , "set names utf8");
 
$runoob_title = '学习 Python';
$runoob_author = 'RUNOOB.COM';
$submission_date = '2016-03-06';
 
$sql = "INSERT INTO runoob_tbl ".
        "(runoob_title,runoob_author, submission_date) ".
        "VALUES ".
        "('$runoob_title','$runoob_author','$submission_date')";
 
 
mysqli_select_db( $conn, 'RUNOOB' );
$retval = mysqli_query( $conn, $sql );
if(! $retval )
{
  die('无法插入数据: ' . mysqli_error($conn));
}
echo "数据插入成功\n";
mysqli_close($conn);
?>
```





##### 数据库选择

`mysqli_select_db(connection,dbname);`

即等效于`use`。

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
    die('连接失败: ' . mysqli_error($conn));
}
echo '连接成功';
mysqli_select_db($conn, 'RUNOOB' );
mysqli_close($conn);
?>
```



##### 数据查询

首先用`mysqli_query`取`mysql`查询语句的返回值，然后用：

`mysqli_fetch_array(connection, 返回值)`获得所有查询的数据。

从结果集中取得一行作为关联数组，或数字数组，或二者兼有 返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。

可以设置第二个参数为`MYSQLI_ASSOC`，将返回列名作为数组索引。



#### 对象式mysqli

#### 例子

##### 注册登录1

###### conn.php

```php
<?php //conn.php
header("Access-Control-Allow-Origin:*");
header("Access-Control-Allow-Methods:GET,POST");
function salt($str){
    return md5($str.'QwQ'.$str);
}
function getCode($id,$secret){
    return salt($id.$secret);
}
$dbname='cv';
$dbuser='l';
$dbpsw='1';
// if(!$conn) {
//     return;
// }
$conn = new mysqli('localhost', $dbuser, $dbpsw, $dbname);
if($conn->connect_error) {
    die('Could not connect: ' . $conn->connect_error);
}
```

###### register.php

```php
<?php //register.php
include "conn.php";
// $name = json_encode($_POST['name']);
// $password = json_encode($_POST['password']);
$name = $_POST['name'];
$password = $_POST['password'];
if (!strlen($name)){
    echo json_encode(array('state'=>'用户名为空'));
    return;
}
if (!strlen($password)){
    echo json_encode(array('state'=>'密码为空'));
    return;
}
$password=salt($password);
// $result = $conn->query("select * from `user` where id="); #不防SQL注入
$stmt = $conn->prepare("select * from `user` where name=?");
$stmt->bind_param('s',$name);
$stmt->execute();
$result = $stmt->get_result();
// if(!$result){
//     echo json_encode(array('state'=>'用户已存在'));
//     return;
// }
if($row=$result->fetch_assoc()){
    echo json_encode(array('state'=>'用户已存在'));
    return;
}
$stmt->close();

$stmt2 = $conn->prepare('insert into `user` (name, secret) values (?,?)');
$stmt2->bind_param('ss',$name,$password);
$stmt2->execute();
$stmt2->close();

$stmt3 = $conn->prepare('select id from `user` where name=?');
$stmt3->bind_param('s',$name);
$stmt3->execute();
$result = $stmt3->get_result();
$row=$result->fetch_assoc();
$id=$row['id'];
$stmt3->close();

echo json_encode(array('state'=>'ok','code'=>getCode($id,$password)));

// echo json_encode(array('state'=>'ok'));
// echo array('state'=>'ok');
```

###### login.php

```php
<?php
include "conn.php";
$name = $_POST['name'];
$password = $_POST['password'];
if (!strlen($name)){
    echo json_encode(array('state'=>'用户名为空'));
    return;
}
if (!strlen($password)){
    echo json_encode(array('state'=>'密码为空'));
    return;
}
$password=salt($password);

$stmt4 = $conn->prepare("select * from `user` where name=? and secret=?");
ini_set('display_errors',1);
$stmt4->bind_param('ss',$name,$password);
$stmt4->execute();
$result = $stmt4->get_result();
$row=$result->fetch_assoc();

if(!$row){
    echo json_encode(array('state'=>'用户或密码不正确'));
    return;
}
$stmt4->close();

$id=$row['id'];
echo json_encode(array('state'=>'ok','code'=>getCode($id,$password)));

/*
error_reporting(E_ALL);
function f(){
    $_error = error_get_last();
    if ($_error && in_array($_error['type'], array(1, 4, 16, 64, 256, 4096, E_ALL))) {
              header("Content-Type: text/html; charset=utf-8");
              echo '<font color=red>代码出错：</font></br>';
              echo '致命错误:' . $_error['message'] . '</br>';
              echo '文件:' . $_error['file'] . '</br>';
              echo '在第' . $_error['line'] . '行</br>';
    }
}
register_shutdown_function(f);
*/
```

###### index.php

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="jqueryc.js"></script>
  <script>
    function register(){
      let name = $('[name="name"]').val();
      let password = $('[name="password"]').val();
      $.post("register.php",{
        name:name,
        password:password,
      },function(res){
        let obj = JSON.parse(res);
        $('#board').html(obj.state + " " + obj.code);
      });
    }
    function login(){
      let name = $('[name="name"]').val();
      let password = $('[name="password"]').val();
      $.post("login.php",{
        name:name,
        password:password,
      },function(res){
        alert(res);
        let obj = JSON.parse(res);
        $('#board').html(obj.state + " " + obj.code);
      });
    }
  </script>
</head>
<body>
  <h1 align="center">这是一个服务器主页</h1>
  <h4 align="right">--powered by lr580</h4>
  <form>
    用户名：<input type="text" name="name">
    密码：<input type="text" name="password">
    <input type="button" value="注册" onclick="register();">
    <input type="button" value="登录" onclick="login();">
  </form>
  <div id="board"></div>
</body>
</html>
```





## 框架

### ThinkPHP

#### 安装和配置

##### 初始化

环境要求

- PHP 版本在 5.4.0 或以上

- 配置里开启(有 `;` 开头注释的删掉注释符号 `;` ，没有就加)

  ```ini
  extension=php_pdo_mysql.dll
  extension=php_mbstring.dll
  extension=php_curl.dll
  
  [mbstring]
  mbstring.language = Chinese
  mbstring.internal_encoding = UTF-8
  mbstring.encoding_translation = On
  mbstring.http_input = UTF-8
  mbstring.http_output = UTF-8
  mbstring.detect_order = UTF-8
  mbstring.substitute_character = none
  ```

免安装， [官网](http://www.thinkphp.cn/down.html) 下载 ，如 `thinkphp_5.0.24_full` 

将 `tp5` 文件夹复制到 `AppServ/www` ，调试输入：`http://localhost:88/tp5/public/` ，预期能访问到一个主页



##### 配置

显然当前根目录是 `AppServ/www/` 代表 `/`

5.0 版本自带入口文件在 `public/index.php` 

该文件定义了应用目录 APP_PATH 和加载 ThinkPHP 框架的入口文件

显然根据内含代码可以发现该 `index.php` 的源代码位于 `application/index/controller/index.php`



开启调试模式：在 `application/config.php` ，改 `app_debug` 。调试模式在异常的时候可以显示尽可能多的信息，所以对性能有一定的影响



##### 项目新建

将 `tp5` 文件夹复制到自己的项目里，作为基础

可以根目录新建一个 `index.php` 并输入：

```c++
<?php
define('APP_PATH',    __DIR__ . '/application/');
require     __DIR__ . '/thinkphp/start.php';
?>
```



> 可以在根目录下 cmd 输入命令新建样例模块：
>
> ```shell
> php think build --module 模块名
> ```



##### 数据库配置

在 `application/database.php` ，按照提示设置数据库连接即可。

取消 `Db::table` 警告，在 vscode 设置输入 `intelephense languageConstraints` ，取消勾选即可。

如果使用了多个模块且每个模块都用不同的数据库连接，那么每个模块下面单独配置，如： `application/模块名/database.php` ，可以自己新建，如：

```php
return [ 
 	// 服务器地址
	'hostname'  => '192.168.190.129',
 	// 数据库名
    'database'  => 'testdb',
 ];
```





#### 基本概念

##### 目录结构

![image-20220424155126332](img/image-20220424155126332.png)

![image-20220424155136373](img/image-20220424155136373.png)

![image-20220424155142376](img/image-20220424155142376.png)

在根目录下用命令行输出指令，生成展示模块 `demo` ：

```shell
php think build --module demo
```



##### 模块



##### 控制器

关系：一个模块有多个控制器，一个控制器有多个方法

命名规范：驼峰命名法(首字母大写)，调用时每个单词转化为 `_` 间隔

新建一个名为 `Index` 的控制器(命名不能出现大小写 `controller`)，放在 `application/模块名/controller/控制器名.php` ，格式：

```php
<?php
namespace app\index\controller;
class Index
{
    public function index()
    {
        return 'Hello World!';
    }
}
```

控制器可以继承。方法可以定义参数。参数相当于URL参数，如：

```php
<?php
namespace app\index\controller;
class Index
{
    public function index($name='World!'){
        	return	'Hello ' . $name;
    }
}
```

然后根据 `index.php?name=输入的东西` 不同，就等于传入不同的 `$name` 

只有 public 类型的方法才是可以通过URL访问的。要调用哪个方法，就直接 HTML 里打这个方法名，如：

>  `index.php/index/index/hello`  (假设在上述代码定义了这个函数)
>  表示 `Index` 模块的 `index` 控制类的 `hello` 方法
>
>  `http://localhost:88/tp5/?name=baicha`



##### 视图

在 `application/模块名` 创建目录 `view` ，尝试添加一个与控制类名字相同的目录名，然后在目录里添加一个 `html` 文件，随便写点内容，如果有变量，用 `{$变量名}` 表示占位。如在 `application/index/hello.html` ：

```html
<div>Ohh, it's {$visitor}</div>
```

使用控制器渲染变量，需要继承 `Controller` 类，如：

```php
<?php
namespace app\index\controller;
use think\Controller;
class Index extends Controller{
    public function hello($name = 'lr580')    {
        $this->assign('visitor', $name);
        return $this->fetch();
    }
}

```

然后打开网页，如：`http://localhost:88/tp5/index.php/index/index/hello?name=QwQ`



如果写成 `return view();` 也行，同理地只需要保证确实有这一个视图即可，区别在于没有参数。



#### 基本语法

##### 控制器

###### 报错输出

```php
$this->error(错误信息str);
```

遇到后弹窗(URL后面的html变成了当前方法名.html)，有自带样式，默认3秒后回到原页面。可以用全称 url ，以导向其他网站，如 oi-wiki 。

```php
if(empty(session('email'))){
       $this->error('请先登录!','index/login/login');
}
```

###### 成功回显

```php
$this->success('注册成功, 跳转到主页', url('index/index'));
```

没有第二个参数就本来在哪回到哪里

###### 重定向

是助手函数，不需要引入就能用。 

```php
$this->redirect(url('index/index'));
```

```php
$this->redirect('index/index');
```

默认使用 302 跳转，可以传第二个参数输入 301 。



##### 视图

###### Controller类

> 可以通过继承Controller类的方式来创建视图类，在新版本中，控制器类可以无需继承Controller类，此时需要自己实例化视图类

对 Contoller 类，可以调用方法：

- `fetch` 渲染html模板输出。如果带参数，参数名就是放在 `view` 文件夹里的 html 名(不带后缀)，不带参数就以当前函数名作为参数。

- `display` 直接输出 HTML 文本，等效于直接 return 。即如：

  ```php+HTML
  return "<h1>QwQ $name</h1>";
  return $this->display("<h1>QwQ $name</h1>");
  ```

- `assign` ，第一个参数是 key ，第二个是 value ，渲染一个变量





助手函数： `view([模板文件],[模板变量],[模板替换])` ，不管继承不继承都可以用。如：`view();view("hello");view("userview/hello")` ，最后一个是同一模块下另一个文件夹内的模板。不带参数就是以自己为参数。

对模板变量，用 `[key=>val]` 形式。

对模板替换，把模板文件内任意(可不在`{}`)key字符串替换为value。



###### PHP语法

在视图代码里，语法用 `{}` 括起来，有：

- PHP变量的常规调用 (直接嵌HTML里进行文本乃至URL拼接都行)

- `foreach $数组变量 as $迭代变量` 开头和 `/foreach` 结尾，如：

  ```php+HTML
  {foreach $result as $flower}
  <table><tr><td>{$flower.fname}</td></tr></table>
  {/foreach}
  ```

- `if condition=""` ， `else`  ， `/if` ，运算符可以是 `eq` 等，如：

  ```php+HTML
  {if condition="$Think.session.email eq ''"}
  <a href="{:url('login/login')}" style="font-size:x-small;text-decoration:none;">登录</a>&nbsp;&nbsp; 
  {else}
  <a href="{:url('login/logOut')}" style="font-size:x-small;text-decoration:none;">退出</a>&nbsp;&nbsp; 
  {/if}
  ```

- `:url('控制器名/方法名')` 超链接(也可以再加一个前缀 `模块名/` ) ，(不区分大小写)，如：

  ```html
  <a href="{:url('order/showorder')}" > QwQ </a>
  ```

- `include file="路径"/` 导入一个HTML (import功能)，如：

  ```php
  {include file="./public/common/top.html"/}
  ```
  
- `volist name="数组名" id="迭代变量名"` `/volist` ，像 Python 的 for，如：

   ```php+HTML
   {volist name="result" id="cart"}
   	<td>{$cart.flowerID}</td>
   {/volist}
   ```

  

其他，如 `__ROOT__` 全局变量。更多系统变量参见 [这里](https://www.kancloud.cn/manual/thinkphp5/125004)

支持输出 `$_SERVER`、`$_ENV`、 `$_POST`、 `$_GET`、 `$_REQUEST`、`$_SESSION`和 `$_COOKIE`变量。

![image-20220517160535460](img/image-20220517160535460.png)

![image-20220517160549072](img/image-20220517160549072.png)



###### 内置标签

普通标签用 `{}` 括起来，中间有空格或者换行则被视为**非模板标签**直接输出。还有可以是 `{ /}` 或 `{}  {/   }` 。

可以在配置参数修改定界符，默认就是上文的 `{}` 。如：

```php
'template'  => [
    // 模板引擎
    'type'   => 'think',
    // 普通标签开始标记 
    'tpl_begin' =>    '{',
    // 普通标签结束标记
    'tpl_end'   =>    '}'        
],
```

标签里可以直接塞一个变量，或它的属性，如 `{$x}, {$x.name}` 



###### 数组遍历

可以用 volist 标签实现循环输出数组。该标签的属性 name 接变量名， id 接遍历时作为遍历变量名， offset 是起始下标， length 是遍历次数， empty 是为空输出。如：

```html
{volist name="result" id="flower" offset="5" length="10" empty="无数据"}
	{$flower.flowerID}:{$flower.fname}
{/volist}
```

可以套子标签 eq ，属性 name 是操作名，对下标运算， value 是比较值。比如换行：

```html
{volist name="result" id="vo" mod="5" }
{$vo.name}
{eq name="mod" value="4"}<br/>{/eq}
{/volist}
```

注意 id 是一个变量，即可以 `{$id名}` 。缺省为 `i` 。



foreach 类似，但是只有 name, item, key(默认为 key) 。也是普通遍历。如

```html
{foreach name="result" item="flower" key="k"}
{$k}|{$flower.id}:{$flower.name}
{/foreach}
```



for：

```html
{for start="开始值" end="结束值" comparison="" step="步进值" name="循环变量名"}{/for}
```

name 默认是 i ，步进默认是 1。会写解析为 for PHP语句。



###### 选择判断

switch 标签，可以接属性 name 代表选择值。内置标签 case 有属性 value ，有 default 标签。

```php+HTML
{switch name="$admin.level"}
    {case value="1"}admin{/case}
    {case value="2"}user{/case}
    {default /}default
{/switch}
```

case 可以设置 break 属性为 0，使得逻辑跟 C++ 的 switch 一样：

```php+HTML
{foreach $result as $admin}
{switch name="$admin.level"}
    {case value="1" break="0"}admin{/case}
    {case value="2"}user{/case}
    {default /}default
{/switch}
{/foreach}
```

name 可以使用函数、系统变量、参数，如 get 的一个属性： `Think.get.userId` ，传入靠 `?userId=xxx` 

value 属性可以用 `|` 分割，如：

```php+HTML
{switch name="Think.get.type"}
    {case value="gif|png|jpg"}图像格式{/case}
    {default /}其他格式
{/switch}
```



可以用 if ，有属性名 condition 接表达式。有内嵌配套的 elseif 和  else 如：

```php+HTML
{foreach $result as $admin}
{if condition="$admin.level eq 1"}
    <h2>admin</h2>
{elseif condition="($admin.level == 2) or ($admin.level>10)"/}
    <h2>user</h2>
{else/}
	<h2>default</h2>   
{/if}
{/foreach}
```

可以用 php 代码在 condition 里：

```php+HTML
{if condition="strtoupper($user['name']) eq 'THINKPHP5'"}
<h2>ThinkPHP5</h2>
{else /} 
<h2>other Framework</h2>
{/if}
```

三者等效：

```php+HTML
{if condition="表达式"}
{if (表达式)}
{if 表达式}
```



###### 比较标签

标签名可以是 `eq` , `equal` , `neq` , `notequal` , `gt` , `egt` ( $\ge$ ) , `lt` , `elt` , `heq` (恒等于) , `nheq` 。用法参数跟 eq 基本一样，如：

```php+HTML
{eq name="name" value="value"}value{/eq}
```

也可以用内嵌 else ，如：

```php+HTML
{eq name="name" value="value"}
相等
{else/}
不相等
{/eq}
```

用函数：

```php+HTML
{eq name="$user['name']|strlen" value='9'}
    <h2>长度=9</h2>
{/eq}
```

用变量：

```php+HTML
{eq name="$user.name" value="$a"}{$user.name}{/eq}
```

用统一标签，用 type 指明类型：

```php+HTML
{compare name="name" value="5" type="eq"}value{/compare}
```



范围判断用标签： `in` , `notin` , `between` , `notbetween` ，如：

```php+HTML
{in name="id" value="1,2,3"}
id在范围内
{/in}
```

对 between ，可以是整数、字符等。

```php+HTML
{between name="id" value="A,Z"} <!--或如 "1,5"-->
输出内容1
{/between}
```

可以用 range 标签统一，如：

```php+HTML
{range name="id" value="1,2,3" type="in"}
输出内容1
{/range}
```



present , `notpresent` 接属性 name ，判定某个变量是否已经定义。

empty, `notepmty` 判断是否为空。

```php+HTML
{empty name="Think.get.name"}
$_GET['name']为空值
{/empty}
```



##### Session

[参考](https://blog.csdn.net/qq_37675827/article/details/77978396)

```php
use think\Session;
```

如：

```php
$rs = Session::get('email')
```



当然也可以暴力用原生的，即 `session('email')`



##### 表单

> 貌似是基本语法，而不是ThinkPHP语法

###### 数据获取

在控制器方法里使用，如：

```php
input('post.email') //对应post的form表单，name=email的表单项
```

###### 数据存储

如：

```php
session('email', $rs['email']);
```



##### 数据库

###### 动态连接

可以不事先配置，而是动态定义，，使用 `Db::connect` 然后一个数组参数(跟配置一样)，如：

```php
Db::connect([
    // 数据库类型
    'type'        => 'mysql',
    // 数据库连接DSN配置
    'dsn'         => '',
    // 服务器地址
    'hostname'    => '127.0.0.1',
    // 数据库名
    'database'    => 'thinkphp',
    // 数据库用户名
    'username'    => 'root',
    // 数据库密码
    'password'    => '',
    // 数据库连接端口
    'hostport'    => '',
    // 数据库连接参数
    'params'      => [],
    // 数据库编码默认采用utf8
    'charset'     => 'utf8',
    // 数据库表前缀
    'prefix'      => 'think_',
]);
```

也可以使用字符串，URL形式，`数据库类型://用户名:密码@数据库地址:数据库端口/数据库名#字符集`，  如：

```php
Db::connect('mysql://root:123456@localhost:3306/flower#utf8');
```

返回一个变量，用这个变量不断调用数据库函数即可实现数据库功能 



###### 基础

在配置好数据库的基础上，在控制器方法，进行读取，例如：

```php
use think\Db;
//...
Db::name(名字str)->find(); //返回读取单行数据
Db::table(名字str)->select(); //读取多行数据
->order(关键字str,'desc') //排序，在table后接
```

name 与 table 的区别在于，若配置项有 `prefix` ， name ， db() 会加上前缀， table 不会

find 找单行，不存在返回 null ； select 找数据集，不存在返回空数组。

value 只返回某一列(属性)，找单次，找不到 null ； column 返回某一列值，找不到返回空数组

可以加 distinct(true) 来去重

可以加 order 来排序

> 综合示例：`->distinct(true)->field('value')->select()`

> ```php
> $data=Db::table('think_user')->where('id',1)->value('name');
> // 返回数组
> $data=Db::table('think_user')->where('name','like','%thinkphp')->column('name');
> // 指定索引
> $data=Db::table('think_user')->where('name','like','%thinkphp')->column('name','id');
> ```

> ```php
> public function index()
> {
>  $fclass = Db::table('flower')->distinct('true')->field('fclass')->select();
>  $this->assign('fclasses', $fclass);
>  $fname = input('post.fname');
>  $fcls = input('post.fclass');
>  $minprice = input('post.minprice');
>  $maxprice = input('post.maxprice');
>  if (empty($maxprice)) {
>      $maxprice = 114514;
>  }
>  if (empty($minprice)) {
>      $minprice = 0;
>  }
>  $searchstr = "yourprice between $minprice and $maxprice";
>  if (!empty($fcls)) {
>      $searchstr .= " and fclass='$fcls'";
>  }
>  if (!empty($fname)) {
>      $searchstr .= " and fname like '%$fname%'";
>  }
>  $data = Db::table('flower')->where($searchstr)->order('SelledNum desc')->select();
>  $this->assign('flowers', $data);
>  return $this->fetch();
> }
> ```



在 HTML 进行php语句操作，如：

```html
{foreach $result as $mem}
<tr><td>{$mem.email}</td>
	<td>{$mem.mname}</td>
	<td>{$mem.mobile}</td>
</tr>
{/foreach}
```

> 例如：
>
> ```php
> <?php
> 
> namespace app\index\controller;
> 
> use think\Controller;
> use think\Db;
> 
> class Index extends Controller
> {
>  public function hellodb()
>  {
>      $data = Db::table('myorder')->select();
>      $this->assign('res', $data);
>      return $this->fetch();
>  }
> }
> ```
>
> ```html
> <table>
>  <tr>
>      <th>orderID</th>
>      <th>custID</th>
>  </tr>
>  {foreach $res as $it}
>  <tr>
>      <td>{$it.orderID}</td>
>      <td>{$it.custID}</td>
>  </tr>
>  {/foreach}
> </table>
> ```



###### 分页

先使用分页查询，如：

```php
$list = Db::name('user')->where('status',1)->paginate(10);
$data = Db::table('flower')->order('SelledNum','desc')->paginate(5);
```

使用 paginate 函数：

![image-20220424161841250](img/image-20220424161841250.png)

例如：

```php
public function showflower(){
    $data = Db::table('flower')->order('SelledNum','desc')->paginate(5);
    $this->assign('result',$data);
    $page=$data->render();
    $this->assign('page',$page);
    return $this->fetch();
}
```

导航使用一次标志即可：

```html
<div class="page">{$page}</div>
```

为了修改分页的样式，可以更改 `thinkphp/library/think/paginator/driver/` 的 `Bootstrap.php` ，如改为：

> ```php
> <?php
> // +----------------------------------------------------------------------
> // | ThinkPHP [ WE CAN DO IT JUST THINK ]
> // +----------------------------------------------------------------------
> // | Copyright (c) 2006~2018 http://thinkphp.cn All rights reserved.
> // +----------------------------------------------------------------------
> // | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )
> // +----------------------------------------------------------------------
> // | Author: zhangyajun <448901948@qq.com>
> // +----------------------------------------------------------------------
> 
> namespace think\paginator\driver;
> 
> use think\Paginator;
> 
> class Bootstrap extends Paginator
> {
>  /*
>      * 上一页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getPreviousButton($text = "上一页")
>     {
> 
>         if ($this->currentPage() <= 1) {
>             return $this->getDisabledTextWrapper($text);
>         }
> 
>         $url = $this->url(
>             $this->currentPage() - 1
>             );
> 
>         return $this->getPageLinkWrapper($url, $text);
>     }
> 
>     /**
>      * 下一页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getNextButton($text = '下一页')
>     {
>         if (!$this->hasMore) {
>             return $this->getDisabledTextWrapper($text);
>         }
> 
>         $url = $this->url($this->currentPage() + 1);
> 
>         return $this->getPageLinkWrapper($url, $text);
>     }
> 
>     /**
>      * 首页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getFirstButton($text = '首页')
>     {
>         $nowPage = $this->rollPage;//计算分页临时变量
>         //当  总页数大于定义的页数时  且  当前页数大于前几页时  显示首页
>         if ($this->lastPage > $this->showPage && $this->currentPage > $nowPage) {
> 
>             $url = $this->url(1);
> 
>             return $this->getPageLinkWrapper($url, $text);
>         }
>     }
> 
>     /**
>      * 末页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getLastButton($text = '末页')
>     {
>         $nowPage = $this->rollPage;//计算分页临时变量
> 
>         //当  总页数大于定义的页数时  且  当前页数小于最后的几页时  显示末页
>         if ($this->lastPage > $this->showPage && $this->currentPage < ($this->lastPage - $nowPage)) {
> 
>             $url = $this->url($this->lastPage);
> 
>             return $this->getPageLinkWrapper($url, $text);
>         }
>     }
> 
>     /**
>      * 页码按钮
>      * @return string
>      */
>     protected function getLinks()
>     {
>         if ($this->simple)
>             return '';
> 
>             $block = [
>                 'first'  => null,
>                 'slider' => null,
>                 'last'   => null
>             ];
> 
>             $side   = 3;
>             $window = $side * 2;
> 
>             if ($this->lastPage < $window + 6) {
>                 $block['first'] = $this->getUrlRange(1, $this->lastPage);
>             } elseif ($this->currentPage <= $window) {
>                 $block['first'] = $this->getUrlRange(1, $window + 2);
>                 $block['last']  = $this->getUrlRange($this->lastPage - 1, $this->lastPage);
>             } elseif ($this->currentPage > ($this->lastPage - $window)) {
>                 $block['first'] = $this->getUrlRange(1, 2);
>                 $block['last']  = $this->getUrlRange($this->lastPage - ($window + 2), $this->lastPage);
>             } else {
>                 $block['first']  = $this->getUrlRange(1, 2);
>                 $block['slider'] = $this->getUrlRange($this->currentPage - $side, $this->currentPage + $side);
>                 $block['last']   = $this->getUrlRange($this->lastPage - 1, $this->lastPage);
>             }
> 
>             $html = '';
> 
>             if (is_array($block['first'])) {
>                 $html .= $this->getUrlLinks($block['first']);
>             }
> 
>             if (is_array($block['slider'])) {
>                 $html .= $this->getDots();
>                 $html .= $this->getUrlLinks($block['slider']);
>             }
> 
>             if (is_array($block['last'])) {
>                 $html .= $this->getDots();
>                 $html .= $this->getUrlLinks($block['last']);
>             }
> 
>             return $html;
>     }
> 
>     /**
>      * 渲染分页html
>      * @return mixed
>      */
>     public function render()
>     {
>         if ($this->hasPages()) {
>             if ($this->simple) {
>                 return sprintf(
>                     '%s %s',
>                     $this->getPreviousButton(),
>                     $this->getNextButton()
>                     );
>             } else {
>                 return sprintf(
>                     '%s %s %s',
>                     $this->getPreviousButton(),
>                     $this->getLinks(),
>                     $this->getNextButton()
>                     );
>             }
>         }
>     }
> 
>     /**
>      * 生成一个可点击的按钮
>      *
>      * @param  string $url
>      * @param  int    $page
>      * @return string
>      */
>     protected function getAvailablePageWrapper($url, $page)
>     {
>         return '&nbsp;&nbsp;<a href="' . htmlentities($url) . '">' . $page . '</a>&nbsp;&nbsp;';
>     }
> 
>     /**
>      * 生成一个禁用的按钮
>      *
>      * @param  string $text
>      * @return string
>      */
>     protected function getDisabledTextWrapper($text)
>     {
>         return '<span>&nbsp;&nbsp;' . $text . '&nbsp;&nbsp;</span>';
>     }
> 
>     /**
>      * 生成一个激活的按钮
>      *
>      * @param  string $text
>      * @return string
>      */
>     protected function getActivePageWrapper($text)
>     {
>         return '<span>&nbsp;&nbsp;' . $text . '&nbsp;&nbsp;</span>';
>     }
> 
>     /**
>      * 生成省略号按钮
>      *
>      * @return string
>      */
>     protected function getDots()
>     {
>         return $this->getDisabledTextWrapper('...');
>     }
> 
>     /**
>      * 批量生成页码按钮.
>      *
>      * @param  array $urls
>      * @return string
>      */
>     protected function getUrlLinks(array $urls)
>     {
>         $html = '';
> 
>         foreach ($urls as $page => $url) {
>             $html .= $this->getPageLinkWrapper($url, $page);
>         }
> 
>         return $html;
>     }
> 
>     /**
>      * 生成普通页码按钮
>      *
>      * @param  string $url
>      * @param  int    $page
>      * @return string
>      */
>     protected function getPageLinkWrapper($url, $page)
>     {
>         if ($page == $this->currentPage()) {
>             return $this->getActivePageWrapper($page);
>         }
> 
>         return $this->getAvailablePageWrapper($url, $page);
>     }
>     }
> 
> ```



###### 复杂查询

`->view(表名str,列名str(, 条件))` ，列名str里内部逗号分隔表示多个列

`->where(列名str, 运算符str, 运算数)`  (可以叠多个where，显然)

最后 `->select()` 或 `->find()` 

如：

```php
public function view1()
{
    $conn=Db::connect('mysql://root:123456@localhost:3306/student#utf8');
    dump('OK');
    $data = $conn->view('S', 'SNO,SNAME')->view('SC', 'GRADE', 'SC.SNO=S.SNO')
        ->view('C', 'CNO,CNAME', 'SC.CNO=C.CNO')
        ->where('GRADE', '>', 80)
        ->select();
    $this->assign("results", $data);
    return $this->fetch();
}
```

多个条件 and 为：

```php
Db::table('think_user')->where('name&uname','like','%thinkphp')->find(); // % 是 SQL通配符
```

多个 or 用 whereOr ：

```php
Db::table('think_user')->where('name','like','%thinkphp')->whereOr('email','tp@163.com')->find();
```

也可以用 `|` ：

```php
Db::table('think_user')->where('name|title','like','%thinkphp')->find();
```

混合且，或，用括号搞顺序。

![image-20220429160653178](img/image-20220429160653178.png)



###### 查询语法

```php
where('字段名','表达式','查询条件');
whereOr('字段名','表达式','查询条件');
```

表达式语法：(都是字符串)(查询条件就可以不是字符串) 

```
EQ、=	等于（=）  //如果只写两个参数，where('字段名','查询条件') 也是 EQ
NEQ、<>	不等于（<>）
GT、>	大于（>）
EGT、>=	大于等于（>=）
LT、<	小于（<）
ELT、<=	小于等于（<=）
LIKE	模糊查询
[NOT] BETWEEN	（不在）区间查询
[NOT] IN	（不在）IN 查询
[NOT] NULL	查询字段是否（不）是NULL  //这时没有查询条件
[NOT] EXISTS	EXISTS查询
EXP	表达式查询，支持SQL语法，后接函数使用
> time	时间比较
< time	时间比较
between time	时间比较
not between time	时间比较
```

5.0.4  支持对同一个字段多次调用查询方法  

EXP 举例：

```php
where('id','exp',' IN (1,3,8) ');
```

综合举例：

```php
Db::table('think_user')->where('name|title','like','thinkphp%')->where('create_time&update_time','>',0)->find();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' OR `title` LIKE 'thinkphp%' ) AND ( `create_time` > 0 AND `update_time` > 0 ) LIMIT 1
> ```



区间查询是一种同一字段多个查询条件的简化写法：

区间查询的查询条件必须使用数组定义方式，支持所有的查询表达式。

```php
Db::table('think_user')->where('name',['like','thinkphp%'],['like','%thinkphp'])->where('id',['>',0],['<>',10],'or')->find();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' AND `name` LIKE '%thinkphp' ) AND ( `id` > 0 OR `id` <> 10 ) LIMIT 1
> ```



批量查询

```php
Db::table('think_user')
    ->where([
        'name'  =>  ['like','thinkphp%'],
        'title' =>  ['like','%thinkphp'],
        'id'    =>  ['>',0],
        'status'=>  1
    ])
    ->select();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE `name` LIKE 'thinkphp%' AND `title` LIKE '%thinkphp' AND `id` > 0 AND `status` = '1'
> ```



可以用箭头混合叠起来用上述的全部东西，如：

> ```php
> Db::table('think_user')
>  ->where('name',['like','thinkphp%'],['like','%thinkphp'])
>  ->where(function($query){
>      $query->where('id',['<',10],['>',100],'or');
>  })
>  ->select();
> ```
>
> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' AND `name` LIKE '%thinkphp' ) AND ( `id` < 10 or `id` > 100 )
> ```



可以套原生：

```php
Db::table('think_user')->where('id > 0 AND name LIKE "thinkphp%"')->select();
```



可以占位符：

```php
Db::table('think_user')
    ->where('id > :id AND name LIKE :name ',['id'=>0, 'name'=>'thinkphp%'])
    ->select();
```



> V5.0.4+开始，ThinkPHP支持对同一个字段多次调用查询条件
>
> ```php
> Db::table('think_user')
>  ->where('name','like','%think%')
>  ->where('name','like','%php%')
>  ->where('id','in',[1,5,80,50])
>  ->where('id','>',10)
>  ->find();
> ```



可以定义别名：

```php
$data = $conn->view(['S'=>'Stu'], ['SNO'=>'Stu_No','SNAME'=>'Stu_Name'])
    ->view('SC', ['GRADE'=>'score'], 'SC.SNO=Stu.SNO')
    ->view('C', 'CNO,CNAME', 'SC.CNO=C.CNO')
    ->where('GRADE', '>', 80)
    ->select();
```

> 对应：
>
> ```sql
> Select  Stu.SNO  as Stu_No,Stu.SNAME as Stu_Nname,SC.GRADE as score 
> From  S Stu inner join SC on SC.SNO=Stu.SNO inner join C on SC.CNO=C.CNO
> Where grade>80;
> ```



###### 模型类

如果在某个模型类里面定义了connection属性的话，则该模型操作的时候会自动连接给定的数据库连接，而不是配置文件中设置的默认连接信息，通常用于某些数据表位于当前数据库连接之外的其它数据库。格式同配置里的数据即这是一个数组或字符串格式。如：

```php
//在模型里单独设置数据库连接信息
namespace app\index\model;
use think\Model;
class User extends Model
{
    protected $connection = [
        // 数据库类型
        'type'        => 'mysql',
        // 数据库连接DSN配置
        'dsn'         => '',
        // 服务器地址
        'hostname'    => '127.0.0.1',
        // 数据库名
        'database'     => 'flower',
        // 数据库用户名
        'username'    => 'root',
        // 数据库密码
        'password'    => '12345678',
        // 数据库连接端口
        'hostport'    => '',
        // 数据库连接参数
        'params'     =>[],
        // 数据库编码默认采用utf8
        'charset'     => 'utf8',
        // 数据库表前缀
        'prefix'      => 'think_',
    ];
}

```

```php
protected $connection = 'mysql://root:12345678@localhost:3306/flower#utf8';
```

需要注意的是，ThinkPHP的数据库连接是**惰性**的，所以并不是在实例化的时候就连接数据库，而是在有实际的数据操作的时候才会去连接数据库。



###### 原生操作

query 和 execute 两个方法，分别用于查询和写入，直接使用 SQL 语句

除了查询都用 execute (如更新)。查询返回 array ，下标从 0 开始，值是对象型数组，其key和value对应查询。execute方法的返回值是影响的行数

支持 `?` 参数绑定和命名占位符 `:名字` 绑定，如：

```php
Db::query('select * from think_user where id=?',[8]);    // id=8
Db::execute('insert into think_user (name, email) values (?, ?)',['thinkphp','tp5@163.com']);
```

```php
Db::query('select * from think_user where id=:id',['id'=>8]);
Db::execute('insert into think_user (name, email) 
values (:name, :email)',['name'=>'thinkphp','email'=>'tp5@163.com']);
```

```php
$result=Db::execute('insert into think_user(id,name,email)	values(null,"thinkphp","tp@163.com")');
dump($result);
```

如：

```html
<form action="{:url('index/create')}" name="f" method="post">
<table border="1">
<tr><td>name:</td><td><input type="text" name="name" value="a1"></td></tr>
<tr><td>email:</td><td><input type="text" name="email" value="a1@163com"></td></tr>
<tr><td>score:</td><td><input type="text" name="score" value="91"></td></tr>
<tr><td colspan="2"><input type="submit" value="添加"></td></tr>
</table>
</form>
```

```php
public function create(){
        $name = input('post.name');
        $email=input('post.email');
        $score=input('post.score');
        Db::execute("insert into think_user(id,name,email,score) 
            values(null,'".$name."','".$email."','".$score."')");
        $this->success('添加成功',url('index/index')); 
    }
}
```



```html
<br/>
<a href="{:url('index/add')}">添加</a>
<br/><br/>
<table border="1">
<tr><th>name</th><th>email</th><th>score</th><th>修改</th><th>删除</th></tr>
{volist name="$result" id="row"}
<tr>
	<td>{$row.name}</td>
	<td>{$row.email}</td>
	<td>{$row.score}</td>
	<td><a href="{:url('index/update')}?id={$row.id}">修改</a></td>
	<td><a href="{:url('index/delete')}?id={$row.id}">删除</a></td>
</tr>	
{/volist}
</table>
```

```html
<form action="{:url('index/doUpdate')}" name="f" method="post">
{foreach $result as $user}
<table border="1">
<input type="hidden" name="id" value="{$user.id}">
<tr><td>name:</td><td><input type="text" name="name" value="{$user.name}"></td></tr>
<tr><td>email:</td><td><input type="text" name="email" value="{$user.email}"></td></tr>
<tr><td>score:</td><td><input type="text" name="score" value="{$user.score}"></td></tr>
<tr><td colspan="2"><input type="submit" value="修改"></td></tr>
</table>
{/foreach}
</form>
```

```php
public function update(){
    $id=input('get.id');
    $user=Db::query("select * from think_user where id=$id");
    dump($user);
    $this->assign('result',$user);
    return $this->fetch();
}
public function doUpdate(){
    $id = input('post.id');
    $name = input('post.name');
    $email=input('post.email');
    $score=input('post.score');
    Db::execute("update think_user 
            set name='$name',
            email='$email',
            score='$score' 
            where id=$id");       
    $this->success('修改成功',url('index/index'));
}

```



###### 表格信息

使用getTableInfo可以获取表信息，信息类型 包括 fields,type,bind,pk，以数组的形式展示，可以指定某个信息进行获取

```php
// 获取`think_user`表所有信息
Db::getTableInfo('think_user');
// 获取`think_user`表所有字段
Db::getTableInfo('think_user', 'fields');
// 获取`think_user`表所有字段的类型
Db::getTableInfo('think_user', 'type');
// 获取`think_user`表的主键
Db::getTableInfo('think_user', 'pk');
```



###### 助手函数

`db(数据表名)` = 前缀 + 数据表名选择。可选参数：第二个参数为数据库的连接参数，留空数组(默认)表示采用数据库配置文件的配置；第三个参数是一个布尔值，默认值是false，如果设置为true表示每次都会重新连接数据库。db函数如果采用相同的链接，可以设置第三个参数false.

> 一个MySQL好似只能同时有至多150个连接



###### 其他查询

使用**查询对象**进行查询，例如：

```php
$query = new \think\db\Query();
$query->table('think_user')->where('name','like','%thinkphp');
// $data=Db::find($query);
$data=Db::select($query);
dump($data);
```

或者直接使用闭包函数查询，例如：

```php
$data=Db::select(function($query){
    $query->table('think_user')->where('name','like','%thinkphp');
});
dump($data);
```



###### 聚合查询

内置方法，可以填参数(也可以不填)代表要统计的字段名：count, max, min, avg, sum

如：

```php
Db::table('think_user')->count();
Db::table('think_user')->where('score>0')->min('score');
```



###### 子查询

使用 select 方法且填参数 false ，表示不进行查询只是返回构建SQL (dump 输出得到语句)

那么使用字符串连接符，如 `'(' . $变量 . ') 子表名'` 为 table 参数，就可以子查询了

```php
$subQuery = $conn->table('SC')
    ->field('SNO,GRADE')
    ->where('CNO','=','k5')
    ->select(false);

$data = $conn->table('('.$subQuery.') a')
    ->view('S','SNO,SNAME','a.SNO=S.SNO')
    ->where('a.GRADE','>',80)
    ->select();
```

也可以用 fetchSql 方法，表示不进行查询而只是返回构建的SQL语句，并且不仅仅支持select，而是支持所有的CURD查询。用法： `->fetchSql(true)->select()` ，得到的还是一样的，后面套子表用法跟上面一样。

调用buildSql方法后不会进行实际的查询操作，而只是生成该次查询的SQL语句（为了避免混淆，结果上会在SQL两边加上括号），我们在后续的查询中直接调用。(字符串连接时可以不用括号了，直接子表名)。调用就查询时把 select 换成 buildSql

如果需要 IN/EXISTS 查询，需要用函数闭包，如：

```php
$data = $conn->table('S')
    ->where('SNO','IN',function($query){
        $query->table('SC')->where('CNO','k5')->field('SNO');
    })
    ->select();
```

```php
$data = $conn->table('S')
    ->where(function($query){
        $query->table('SC')
            ->where('CNO','k5')
            ->where('S.SNO=SC.SNO');
    },'exists')
    ->select(); 
```



###### 管理数据

插入：

```php
$data = ['name' => 'zhangsan', 'email' => 'zs@163.com'];
Db::table('think_user')->insert($data);
```

insert 方法添加数据成功返回添加成功的条数，insert 正常情况返回 1

返回新增数据的自增主键，可以使用：

```php
$userId = Db::name('user')->getLastInsID();
```

或直接合并，插入并返回 (成功返回添加数据的自增主键)：

```php
Db::name('user')->insertGetId($data);
```

多条就二维数组， insertAll ，返回添加数据成功返回添加成功的条数



更新：

返回影响数据的条数，没修改任何数据返回 0

```php
Db::table('think_user')->where('id', 1)->update(['name' => 'tp5_1']);
```

若更新的数据包含主键，不需要 where ：

```php
Db::table('think_user')->update(['name' => 'thinkphp','id'=>1]);
```

只更新一个字段，返回影响数据的条数：

```php
Db::table('think_user')->where('id',1)->setField('name', 'thinkphp');
```

setInc/setDec 如不加第二个参数，默认值为1：

```php
Db::table('think_user')->where('id', 1)->setInc('score');
```

支持延时更新，如果需要延时更新则传入第三个参数，单位为秒



删除：

根据主键删除直接传主键值（多个就数组），返回影响数据的条数，无则 0 ：

```php
Db::table('think_user')->delete(1);
Db::table('think_user')->delete([1,2,3]);
```

也可以 where ：

```php
Db::table('think_user')->where('name','bb')->delete();
Db::table('think_user')->where('id','<',10)->delete();
```



##### 模型类

模型类和 Db 类的区别主要在于对象的封装， Db 类的查询默认返回的是数组（或者集合），而模型类返回的是当前的模型对象实例（或者集合），模型是比 Db 类更高级的数据封装，支持模型关联、模型事件。

###### 定义

要放在 `application/模块/model/模型类名.php` ，如：

```php
namespace app\index\model;
use	think\Model;
class 模型类名 extends Model
{
}
```

大多情况下无需为模型定义任何的属性和方法即可完成基础的操作。

模型会自动对应一个数据表，规范是：

```php
数据表前缀+当前的模型类名（不含命名空间）
```

如果你的模型命名不符合这一数据表对应规范，可以给当前模型定义单独的数据表，包括两种方式。

如：

```php
namespace app\index\model;
use think\Model;
class User extends Model{
// 设置完整的数据表（包含前缀）
	protected $table = 'think_user';
}
```

```php
namespace app\index\model;
use think\Model;
class User extends Model
{
// 设置数据表（不含前缀）
	protected $name ='member';
}
```

果当前模型类需要使用不同的数据库连接，可以定义模型的 connection 属性。即

```php
protected $connection = 按照数据库链接的数组/DSN格式来就行;
```

有一种方式可以让你省去别名定义，系统支持统一对控制器类添加 Controller 后缀，修改配置参数**：**

```php
//是否启用控制器类后缀
'controller_suffix'      =>  true,
```



###### 方法

成员属性就是数据库读出来的每个属性。还有方法如下(含静态方法)：



增加数据：

执行 save 操作都是执行的数据库 insert 操作，如果你需要实例化执行save 执行数据库的 update 操作，请确保在save方法之前调用 isUpdate 方法，如：

```php
$user->isUpdate()->save(); //isUpdate填false
```

静态 create 方法可以传入数组或者标准对象，可以在外部统一赋值后传入，当然也可以直接传入表单数据

可以搞成一个数组，然后用 saveAll 传数组

可以用 return getError 方法的返回值得到报错内容



查询数据：

静态 get 方法，传主键值，返回当前的模型对象实例。如果没有传入任何值的话，则表示获取第一条数据。

模型的 get 方法和 Db 类的 find 方法返回结果的区别在于， Db 类默认返回的只是数组（注意这里说的默认，其实仍然可以设置为对象），而模型的 get 方法查询返回的一定是当前的模型对象实例。但是系统为模型实现了 ArrayAccess 接口，因此仍然可以通过数组的方式访问对象实例。

静态 getBy属性名 方法，传值返回实例。注意命名法。每个单词大写，get除外。或者传一个数组，key => value 形式。

查询构建器：静态方法 where ，第一个参数属性，第二个值(或第二个运算符，第三个值，就跟之前的 where 方法用法一样的)，然后再套无参数的 find 。

全部读取用 all ，然后 for 一下就好了。这个也可以传一个数组，key => value 形式作为查询条件。



更新数据：

先查询得到对象，然后直接暴力改，然后用一下 save 即可。

默认情况下，查询模型数据后返回的模型实例执行 save 操作都是执行的数据库 update 操作，如果你需要实例化模型类后执行 save 执行数据库的 insert 操作，请确保在save方法之前调用 isUpdate 方法。

ActiveRecord 模式的更新数据方式需要首先读取对应的数据，如果需要更高效的方法可以搞一个对象，然后静态方法 update 传进去就行。



删除数据：

先查询得到对象，然后跑一下 delete 方法就行。查到的对象是数组就 for 进去一个一个的 delete 。

也可以用静态方法 destroy(主键)



###### 增数据

> 在当前文件中给 app\index\model\User 模型定义了一个别名 UserModel 是为了避免和当前的app\index\controller\User 产生冲突，如果你当前的控制器类不是 User 的话可以不需要定义UserModel 别名

直接操作对应的控制器类就行，不需要对模型类搞别的东西了。如：

```php
<?php
namespace app\index\controller;
use think\Controller;
use app\index\model\User as UserModel;
class User extends Controller
{//	新增用户数据
	public function add(){
		$user=new UserModel();
		$user->name	= '流年';
		$user->email='thinkphp@qq.com';
		$user->birthday ='1977-03-05';
		if($user->save()){
			return '用户['.$user->name.':'.$user->id.']新增成功';
		}else	{
			return	$user->getError();
		}
	}
}
```

> 如果加了控制器类后缀，那么：
>
> ```php
> <?php
> namespace app\index\controller;
> use think\Controller;
> use app\index\model\User;
> class UserController extends Controller
> {//	新增用户数据
> 	public function add(){
> 		$user=new User();
> 		$user->name= '方圆圆';
> 		$user->email='thinkphp@qq.com';
> 		$user->birthday ='1999-05-20';
> 		if($user->save()){
> 			return '用户['.$user->name.':'.$user->id.']新增成功';
> 		}else	{
> 			return	$user->getError();
> 		}
> 	}
> }
> ```

> 关于 isUpdate：
>
> ```php
> //添加数据
> public function addu()
> {
>  $user=new UserModel();
>  $user->id=15;
>  $user->name='刘晨';
>  $user->email='liuchen@gmail.com';
>  if(false!==$user->isUpdate(false)->save()){
>      return '添加用户成功';
>  }else{
>      return $user->getError();
>  }
> }
> ```
>
> 使用 create 方法：
>
> ```php
> <?php
> namespace app\index\controller;
> use think\Controller;
> use app\index\model\User as UserModel;
> class User extends Controller
> {
> // 新增用户数据
>  public function add()
>  {
>      $user['name'] = '李丽';
>      $user['email'] = 'lili@qq.com';
>      $user['birthday'] = '2015-04-02';
>      if ($result=UserModel::create($user)) {
>          return '用户['.$result->name.':'.$result->id.']新增成功';
>      } else {
>          return '新增出错';
>      }
>  }
> }
> 
> ```

调用如 `http://localhost:89/MyModel/index.php/index/user/add`



###### 查数据

```php
//	读取用户数据
public function read($id='')
{
    $user=UserModel::get($id);
    echo $user->name.'<br/>';
    echo $user->email.'<br/>';
    echo $user->birthday.'<br/>';
}
public function read3()
{
    $user = UserModel::getByEmail('thinkphp@qq.com');
    echo $user->name.'<br/>';
    echo $user->email.'<br/>';
    echo $user->birthday.'<br/>';
}
public function read4()
{
    $user = UserModel::get(['name'=>'李丽']);
    echo $user->name . '<br/>';
    echo $user->email . '<br/>';
    echo $user->birthday . '<br/>';
}
public function read5()
{
    $user =	UserModel::where('name','李丽')->find();
    echo $user->name.'<br/>';
    echo $user->email.'<br/>';
    echo $user->birthday.'<br/>';
}
public function readall()
{
    $list=UserModel::all();
    foreach	($list as $user)	{
        echo $user->id.'<br/>';
        echo $user->name.'<br/>';
        echo $user->email.'<br/>';
        echo $user->birthday.'<br/>';
        echo '----------------------------------<br/>';
    }
}

```

如： `http://localhost:89/MyModel/index/user/read/?id=1`



###### 改数据

```php
public function update($id)
{
    $user=UserModel::get($id);
    $user->name='刘晨';
    $user->email='liuchen@gmail.com';
    if(false!==$user->save()){
        return '更新用户成功';
    }else{
        return $user->getError();
    }
}
```

如： `http://localhost:89/MyModel/index/user/update?id=3`



###### 删数据

```php
public function delete($id)
{
    $user=UserModel::get($id);
    if($user){
        $user->delete();
        return '删除用户成功';
    }else{
        return '删除的用户不存在';
    }
}
public function delete3()
{
    $users= UserModel::where('id','>',6)->select();
    foreach($users as $user){
        if($user){
            $user->delete();
            echo $user->id.'删除成功</br>';
        }else{
            echo '删除的用户不存在';
        }
    }
}
public function delete2($id)
{
    $result	= UserModel::destroy($id);
    if($result){
        return '删除用户成功';
    }else{
        return '删除的用户不存在';
    }
}

```



###### 关联模型

一对一关系：

对 Model 类，其自带方法(可以 `$this->` 调用)有 `hasOne` ，参数是表名、外键名、被关联表属性名。

自带方法 belongsTo ，参数是数据表名。

```php
<?php
namespace app\index\model;
use think\Model;
class User extends Model
{
    public function user_address(){
        return $this->hasOne('user_address','user_id','id');
    }  
}// user_id是外键名，user_address表中的user_id，关联user表的id，
// 而id是user_address表中的主键
```

```php
public function user(){
    return $this->belongsTo('user');
}
```



一对多关系：

hasMany。belongsTo也行。

```php
return $this->hasMany('Sc','sno','id');
//sno是外键，成绩表sc中的sno，关联student表的sno，id是sc表中的主键
return $this->belongsTo('student');
```



多对多关系：

belongsToMany，参数是：关联模型名、中间表名(不用写前缀)、外键名、当前模型关联外键

```php
return $this->belongsToMany('course','sc','cno','sno');
```



创建关联模型就直接如上 return 即可



这个被返回的玩意可以用 save 等增删改查玩意，可以用 attach(模型实例)，也可以 detach(实例) 。

```php
namespace app\index\model;
use think\Model;
class Student extends Model{ 
    public function sc(){
        return $this->hasMany('Sc','sno','id');
    }
    
    public function Course(){
        return $this->belongsToMany('course','Sc','cno','sno');
    }
}
```

```php
namespace app\index\model;
use think\Model;
class Course extends Model{       
    public function Student(){
        return $this->belongsToManay('student','Sc','sno','cno');
    }
}
```

```php
namespace app\index\model;
use think\Model;
class Sc extends Model{
    public function student(){
        return $this->belongsTo('student');
    }
}
```

```php
<?php
namespace app\index\controller;
use think\Controller;
use app\index\model\Student;
class Index extends Controller
{
    public function addRelate($sname='李强'){
        $student=Student::getBySname($sname);
        $res=$student->Course()->save(['cname'=>'计算机组成原理','teacher'=>'吴昊']);
        if($res){
            echo "新增成功";
        }
    }
```

```php
namespace app\index\controller;
use think\Controller;
use app\index\model\Student;
use app\index\model\Course;
class Index extends Controller
{
  public function addRelate1($sname='李强',$cname='编译原理') {
        $student=Student::getBySname($sname);
        $course = Course::getByCname($cname);
        $res=$student->Course()->attach($course);
        if($res){
            echo "关联成功";
        }
    }
```

```php
<?php
namespace app\index\controller;
use think\Controller;
use app\index\model\Student;
use app\index\model\Course;
class Index extends Controller
{
    public function detach(){
        $student=Student::getBySname('李强');
        $course = Course::getByCname('计算机组成原理');
        $res=$student->Course()->detach($course);
        if(!$res){
            echo "取消成功";
        }
    }

```

```php
public function show1(){
    $students = Student::all();
    foreach ($students as $student) {       
        echo "=================1对多显示==============<br/>";   
        echo '姓名：'.$student->sname.'，学号：'.$student->sno.'，所选课程成绩:<br/>';
        foreach ($student->sc as $sc) {
            if ($student->sno == $sc->sno){
                echo '课程ID：' . $sc->cno . '<br/>';
                echo 'GRADE：' . $sc->grade . '<br/>';
                echo '-----------------------<br/>';
            }
        }
    }
}

```

```php
public function show2(){
    $students = Student::all();
    foreach ($students as $student) { //多对多显示 
        echo '===================多对多显示================<br/>';
        echo '姓名：'.$student->sname.'，学号：'.$student->sno.'，所选修课程:<br/>';
        foreach ($student->Course as $course) {
            echo '课程编号：'. $course->cno.'<br/>';
            echo '课程名称：'. $course->cname . '<br/>';
            echo '任课老师：' . $course->teacher . '<br/>';
            echo '-----------------------<br/>';            
        }
    }
}

```

不知道有什么用。



##### URL

###### pageinfo

ThinkPHP 采用单一入口模式访问应用，对应用的所有请求都定向到应用的入口文件。

页面跳转需要进入 `\traits\controller\Jump` ，而继承 `Controller` 有这个，不需要额外引入。

301和302都是HTTP状态的编码，都代表着某个URL发生了转移。

1) 301跳转，也叫“永久性转移”，301会把原网页权重转移到重定向目标的网站上面,搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。二次请求。

2) 302跳转也称为，“临时性跳转”。搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。一次请求。

可以用 success, error 和 redirect 。

标准 URL 格式：(pathinfo格式)

```shell
http://serverName:端口号/index.php/模块/控制器/操作
```

模块是 application 下子目录，官方的规范是目录名小写，因此模块全部采用小写命名，无论URL是否开启大小写转换，模块名都会强制小写。URL地址中的控制器和操作名是不区分大小写的。

驼峰命名的控制器如 `HelloWorld` ，在 url 输入 `hello_world` 。

如果希望严格区分大小写访问（或者要支持驼峰法进行控制器访问），可以在应用配置文件中”application/config.php”中设置：

```php
// 关闭URL自动转换（支持驼峰访问控制器）
'url_convert' => false,
```

关闭URL自动转换之后，必须使用下面的URL地址访问（控制器名称必须严格使用控制器类的名称，不包含控制器后缀）：

```plain
http://localhost:89/TestTP/index.php/index/HelloWorld/index
```

操作方法的访问本身不会受URL自动转换的影响，但会影响默认的模板渲染输出。



如果我们直接访问入口文件的话，由于URL中没有模块、控制器和操作，因此系统会访问默认模块（index）下面的默认控制器（Index）的默认操作（index），如下面等效：

```plain
http://localhost:89/TestTP/index.php
http://localhost:89/TestTP/index.php/index/index/index
```

传入参数：

```text
http://localhost:89/TestTP/index.php/index/index/hello/name/thinkphp
http://localhost:89/TestTP/index.php/index/index/hello/?name=thinkphp
```



不支持 pathinfo 的话可以用兼容方式：

```html
http://localhost:89/TestTP/index.php?s=/index/Index/hello
```

其中变量 s 的名称如果改为u，则访问的是默认的控制器和index方法。s可以配置的。

TP5.0不再支持普通的URL访问方式，所以下面的访问是无效的：

```
http://localhost:89/TestTP/index.php?m=index&c=index&a=hello
```



###### 参数

pageinfo 方法来写，顺序任意；或 ?：

```phpw
http://localhost:89/TestTP/index.php/index/index/hello/name/tp5
http://localhost:89/TestTP/index.php/index/index/hello1/name/tp5/city/guangzhou 
http://localhost:89/TestTP/index.php/index/index/hello1?name=tp5&city=guangzhou
```

 还可以进一步对URL地址做简化，前提就是我们必须明确参数的顺序代表的变量，我们更改下URL参数的获取方式，把应用配置文件中的 url_param_type 参数的值修改如下：

```php
// 按照参数顺序获取
'url_param_type' => 1,
```

省略后：

```php1
http://localhost:89/TestTP/index.php/index/index/hello1/tp5/shanghai
```

按顺序绑定参数的话，操作方法的参数只能使用URL pathinfo变量，而不能使用get或者post变量。(即?格式)



###### index.php

可以去掉URL地址里面的入口文件 index.php ，但是需要额外配置WEB服务器的重写规则。

以 Apache 为例，需要在入口文件的同级（index.php所在文件夹）添加 .htaccess 文件（官方默认自带了该文件），内容如下：

```htaccess
<IfModule mod_rewrite.c>
Options +FollowSymlinks -Multiviews
RewriteEngine on
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]
</IfModule>
```

用 phpstudy 则：

```htaccess
<IfModule mod_rewrite.c>
Options +FollowSymlinks -Multiviews
RewriteEngine on
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1]
</IfModule>
```

用 nginx 在 `nginx.conf` ：

```js
location / { // …..省略部分代码
    if (!-e $request_filename) {
    	rewrite ^(.*)$ /index.php?s=/$1 last;
    	break;
    }
}

```

去掉后，如：

```php1
http://localhost:89/TestTP/index/index/index
http://localhost:89/TestTP/index/index/hello
```

隐藏后可以用去掉和不去掉两种写法来写。



###### 路由

我们在路由定义文件（ application/route.php ）里面添加一些路由规则，如下：

```php
return [
    // 添加路由规则 路由到 index控制器的hello操作方法
    'hello/[:name]' => 'index/index/hello',
];
```

该路由规则表示所有 hello 开头的并且带参数的访问都会路由到 index 控制器的 hello 操作方法。中括号表示可选。

可以恒简化：

```php1
http://localhost:89/TestTP/index/index/hello/name/tp5
http://localhost:89/TestTP/hello/tp5
```

定义路由规则后，原来的URL地址将会失效，变成非法请求。



动态，在路由配置文件开头添加：

```php
use think\Route;
Route::rule('hello/[:name]', 'index/hello');
```

完成的效果和使用配置方式定义是一样的。

无论是配置方式还是通过Route类的方法定义路由，都统一放到路由配置文件 application/route.php文件中。

提示：注意路由配置不支持在模块配置文件中设置。



若需要完整匹配：

```php
return [
    // 路由参数name为可选
    'hello/[:name]$' => 'index/hello',
];
```

那么：

```abc
http://localhost:89/TestTP/hello   // 正确匹配
http://localhost:89/TestTP/hello/tp5    // 正确匹配
http://localhost:88/TestTP/hello/val/value // 不会匹配
```



闭包：

```php
return [
    // 定义闭包
    'hello/[:name]' => function ($name) {
    	return 'Hello,' . $name . '!';
    },
];
```

或：

```php
use think\Route;
    Route::rule('hello/[:name]', function ($name) {
    	return 'Hello,' . $name . '!';
});
```

闭包函数的参数就是路由规则中定义的变量。



###### 分割符

如果需要改变URL地址中的 pathinfo 参数分隔符，只需要在应用配置文件（application/config.php ）中设置：

```php
// 设置pathinfo分隔符
'pathinfo_depr' => '-',
```

路由规则定义无需做任何改变，我们就可以访问下面的地址：

```a
http://localhost:88/TestTP/hello-tp5
```



###### 路由参数

我们还可以约束路由规则的请求类型或者URL后缀之类的条件，例如：

```php
return [
    // 定义路由的请求类型和后缀
    'hello/[:name]' => ['index/hello', ['method' => 'get', 'ext' => 'html']],
];
```

上面定义的路由规则限制了必须是 get 请求，而且后缀必须是 html 的，所以下面的访问地址：

```ab
http://localhost:89/TestTP/hello    // 无效
http://localhost:89/TestTP/hello.html // 有效
```



###### 变量规则

如：

```php
<?php
namespace app\index\controller;

class Blog
{
    public function get($id){
        return '查看id=' . $id . '的内容';
    }
    public function read($name){
        return '查看name=' . $name . '的内容';
    }
    public function archive($year, $month){
        return '查看' . $year . '/' . $month . '的归档内容';
    }    
}
```

规则：

```php
return [
    'blog/:year/:month' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}', 'month' => '\d{2}']],
    'blog/:id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
    'blog/:name' => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
];
```

如：

```phpa
http://localhost:89/TestTP/blog/5
http://localhost:89/TestTP/blog/thinkphp
http://localhost:89/TestTP/blog/2015/05
```

简化：

```php
return [
'[blog]' => [
    ':year/:month' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}', 'month' => '\d{2}']],
    ':id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
    ':name' => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
],
];

```

对 `blog-<year>-<month>` 这样的非正常规范，我们需要使用 <变量名> 这样的变量定义方式，而不是

:变量名 方式。如：

```php
return [
'blog/:id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
'blog/:name' => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
'blog-<year>-<month>' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}',
'month' => '\d{2}']],
];

```

简单起见，我们还可以把变量规则统一定义，例如：

```php
return [
// 全局变量规则定义
'__pattern__' => [
'name' => '\w+',
'id' => '\d+',
'year' => '\d{4}',
'month' => '\d{2}',
],
// 路由规则定义
'blog/:id' => 'blog/get',
'blog/:name' => 'blog/read',
'blog-<year>-<month>' => 'blog/archive',
];

```

在 \_\_pattern\_\_ 中定义的变量规则我们称之为全局变量规则，在路由规则里面定义的变量规则我们称之为局部变量规则，如果一个变量同时定义了全局规则和局部规则的话，当前的局部规则会覆盖全局规则的。



###### Url类

定义路由规则之后，我们可以通过Url类来方便的生成实际的URL地址（路由地址）

```php
// 输出 blog/thinkphp
Url::build('blog/read', 'name=thinkphp');
Url::build('blog/read', ['name' => 'thinkphp']);

Url::build('blog/archive', 'year=2015&month=05');
Url::build('blog/archive', ['year' => '2015', 'month' => '05']);
```

url助手函数简化：

```php
url('blog/read', 'name=thinkphp');
```

```html
<a href="{:url('blog/read','name=thinkphp')}">跳转</a>
```



##### 请求响应

###### input

助手函数。

```php
input('提交类型.变量名/修饰符');
```

s 字符串，d 整型，b布尔值，a数组，f浮点

如：

```php
$num = input('post.num/d');
manage = input('post.manage/a');
$str = implode(',', $manage);
```



###### Request

> ThinkPHP5 的架构设计和之前版本的主要区别之一就在于增加了 Request 请求对象和 Response 响应对象的概念

请求对象。Request 对象的作用是与客户端交互，收集客户端的Form、Cookies、超链接，或者收集服务器端的环境变量。

Request对象是从客户端向服务器发出请求，包括用户提交的信息以及客户端的一些信息。客户端可通过HTML表单或在网页地址后面提供参数的方法提交数据，然后通过Request对象的相关方法来获取这些数据。

Request的各种方法主要用来处理客户端浏览器提交的请求中的各项参数和选项。

ThinkPHP5 的 Request 对象由 think\Request 类完成。

Request 对象的一个主要职责是统一和更安全地获取当前的请求信息，最好是需要避免直接操作 \$_GET 、\$\_POST 、 \$\_REQUEST 、 \$\_SESSION 、 \$\_COOKIE ，甚至 \$\_FILES 等全局变量，而是统一使用Request 对象提供的方法来获取请求变量。

一种少用的方法：

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello($name = 'World') {
        $request = Request::instance();
		// 获取当前URL地址 不含域名
		echo 'url: ' . $request->url() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```

返回值距离：

```sdsd
/TestTP/index.php/index/index/hello?name='abc'
```

当继承 think\\Controller 时，可以改为 `$this->request->url()` ，也不用 use 和 instance 。

如果没有继承 think\Controller ，则可以使用 Request 对象注入的方式来简化调用：

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request, $name = 'World')    {
		echo 'url: ' . $request->url() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```

hello方法的request参数是系统自动注入的，而不需要通过URL请求传入。



可以给Request请求对象绑定属性，方便全局调用，例如我们可以在公共控制器中绑定当前登录的用户模型到请求对象：

```php
<?php
namespace app\index\controller;
use app\index\model\User;
use think\Controller;
use think\Request;
use think\Session;
class Base extends Controller{
	public function  _initialize(){
        $user = User::get(Session::get('user_id'));
        Request::instance()->bind('user', $user);
    }
}
```

```php
<?php
namespace app\index\controller;
use app\index\controller\Base;
use think\Request;
class Index extends Base{
	public function index(Request $request)    {
		echo $request->user->id;
		echo $request->user->name;
    }
}
```



###### request助手

```php
<?php
namespace app\index\controller;
class Index{
	public function hello($name = 'World')    {
		// 获取当前URL地址 不含域名
		echo 'url: ' . request()->url() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```



###### param

系统推荐使用 param 方法统一获取当前请求变量，该方法最大的优势是让你不需要区分当前请求类型而使用不同的全局变量或者方法

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
    public function hello(Request $request)    {
        echo '请求参数：';
        dump($request->param());
        echo 'name:' . $request->param('name');
    }
}
```

dump 那一行还可以简化为： `dump(input());`

param 方法获取的参数会自动判断当前的请求，以 POST 请求为例的话，参数的优先级别为：路由变量 > 当前请求变量（\$\_POST变量） \> \$\_GET变量

注意：这里的路由变量指的是路由规则里面定义的变量或者 PATH\_INFO 地址中的变量。路由变量无法使用get 方法或者 \$\_GET 变量获取。

param 方法支持变量的过滤和默认值：

```php
echo 'name:' . $request->param('name', 'World', 'strtolower');
echo '<br/>test:' . $request->param('test', 'thinkphp', 'strtoupper');
```

防止代码注入，在 `application/config.php` ：

```php
'default_filter' => 'htmlspecialchars ',
```



###### 其他输入

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request) {
		echo 'GET参数：';
       dump($request->get());
		echo 'GET参数：name';
       dump($request->get('name'));
		echo 'POST参数：name';
        dump($request->post('name'));
		echo 'cookie参数：name';
        dump($request->cookie('name'));
		echo '上传文件信息：image';
        dump($request->file('image'));
    }
}
```

写法二：

```php
<?php
namespace app\index\controller;
class Index{
	public function hello()    {
		echo 'GET参数：';
        dump(input('get.'));
		echo 'GET参数：name';
        dump(input('get.name'));
		echo 'POST参数：name';
        dump(input('post.name'));
		echo 'cookie参数：name';
        dump(input('cookie.name'));
		echo '上传文件信息：image';
        dump(input('file.image'));
    }
}
```

![image-20220524164459786](img/image-20220524164459786.png)

除了 file 都支持默认值和过滤方式。



###### 请求参数

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request) {
		echo '请求方法：' . $request->method() . '<br/>';
		echo '资源类型：' . $request->type() . '<br/>';
		echo '访问IP：' . $request->ip() . '<br/>';
		echo '是否AJax请求：' . var_export($request->isAjax(), true) . '<br/>';
		echo '请求参数：';
        dump($request->param());
		echo '请求参数：仅包含name';
        dump($request->only(['name']));
		echo '请求参数：排除name';
        dump($request->except(['name']));
    }
}
```

`var_export` 可以将一个数组转为一个字符串不同于`var_dump` , `var_export` 并不会输出数据的类型以及字符大小等,只会简单把数组的key跟value拼接成一个字符串



###### URL信息

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request, $name = 'World'){
		// 获取当前域名
		echo 'domain: ' . $request->domain() . '<br/>';
		// 获取当前入口文件
		echo 'file: ' . $request->baseFile() . '<br/>';
		// 获取当前URL地址 不含域名
		echo 'url: ' . $request->url() . '<br/>';
		// 获取包含域名的完整URL地址
		echo 'url with domain: ' . $request->url(true) . '<br/>';
		// 获取当前URL地址 不含QUERY_STRING
		echo 'url without query: ' . $request->baseUrl() . '<br/>';
		// 获取URL访问的ROOT地址
		echo 'root:' . $request->root() . '<br/>';
		// 获取URL访问的ROOT地址
		echo 'root with domain: ' . $request->root(true) . '<br/>';
		// 获取URL地址中的PATH_INFO信息
		echo 'pathinfo: ' . $request->pathinfo() . '<br/>';
		// 获取URL地址中的PATH_INFO信息 不含后缀
		echo 'pathinfo: ' . $request->path() . '<br/>';
		// 获取URL地址中的后缀信息
		echo 'ext: ' . $request->ext() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```

![image-20220524164802059](img/image-20220524164802059.png)

url、baseUrl、baseFile、root方法如果传入true，表示获取包含域名的地址。



###### MCV信息

```php
public function hello(Request $request, $name = 'World') {
		echo '模块：' . $request->module();
		echo '<br/>控制器：' . $request->controller();
		echo '<br/>操作：' . $request->action();
    }
```

controller方法获取的是驼峰命名的实际的控制器名，其它都是小写返回。



###### Response

Response 对象用于动态响应客户端请示,通常用于输出数据给客户端或者浏览器。

ThinkPHP5 的 Response 响应对象由 think\\Response 类或者子类完成

大多数情况，我们不需要关注 Response 对象本身，只需要在控制器的操作方法中返回数据即可，系统会根据 default_return_type 和 default_ajax_return 配置决定响应输出的类型。

默认的自动响应输出会自动判断是否 AJAX 请求，如果是的话会自动输出 default_ajax_return 配置的输出类型。

```php
<?php
namespace app\index\controller;
class Index{
	public function test(){
		$data = ['name' => 'thinkphp', 'status' => '1'];
		return $data;
	}
}
```

若修改配置文件：

```php
// 默认输出类型
'default_return_type' => 'json',
```

那么上文访问会保存一个 json 。改为 xml 就保存一个 xml 。

手动输出控制：

```php
<?php
namespace app\index\controller;
use think\Controller;
class Index{
    public function test(){
        $data = ['name' => 'thinkphp', 'status' => '1'];
        return json($data);
    }  
}
```

![image-20220524165137668](img/image-20220524165137668.png)



##### 事务

`mysql` 的 `myisam` 不支持， `unnodb` 支持。

###### transaction

发生异常自动回滚。

自动控制事务处理：

```php
Db::transaction(function(){
    //执行语句
    //Db::table('think_user')->find(1);
    //Db::table('think_user')->delete(1);
});
```

手动，如：

```php
Db::startTrans();
try{
    Db::table('think_user')->find(1);
    Db::table('think_user')->delete(1);
    // 提交事务
    Db::commit();    
} catch (\Exception $e) {
    // 回滚事务
    Db::rollback();
}
```

注意在事务操作的时候，确保你的数据库连接是相同的。



##### 文件

###### 定义

使用 `think\File`。创建一个控制器：

```php
<?php
namespace app\index\controller;
use think\controller;
use think\Request;
class Upload extends Controller{ 
    // 文件上传表单
    public function index()    {
        return $this->fetch();
    }
    // 文件上传提交
    public function up(Request $request)    {
        // 获取表单上传文件
        $file = $request->file('file');
        if (empty($file)) {
            $this->error('请选择上传文件');
        }
        // 移动到框架应用根目录/public/uploads/ 目录下
        $info = $file->move(ROOT_PATH . 'public' . DS . 'uploads');
        if ($info) {
            $this->success('文件上传成功：' . $info->getRealPath());
        } else {
            // 上传失败获取错误信息
            $this->error($file->getError());
        }
    }
}
```

HTML：

```html
<!doctype html>
<html><head>
<meta charset="UTF-8">
<title>文件上传示例</title>
</head><body>
	<h2>文件上传示例</h2>
	<FORM method="post" enctype="multipart/form-data" action="{:url('up')}">
		选择文件：<INPUT type="file"  name="file"><br/> 
		<INPUT type="submit" value="提交">
	</FORM>
</body>
</html>
```

默认的上传文件会按照当前的日期自动保存



###### 验证

可以嵌套使用。如：

```php
$info=$file->validate(['ext'=>'jpg,png'])->move(ROOT_PATH	.'public'.DS.'uploads');
```

![image-20220607160002845](img/image-20220607160002845.png)

不只是检验后缀，强行改后缀也会说是错的。文件上传验证用到了 **exif 扩展**，如果没有开启请自行开启。



###### 验证类

统一使用验证类 think\Validate 对表单进行验证，也可以直接使用控制器类 think\Controller 的 validate 方法进行上传文件验证

```php
// 文件上传提交
    public function up(Request $request){
 		$file = $request->file('file');
        // 上传文件验证
        $result = $this->validate(['file' => $file],
            ['file' => 'require|image'], 
            ['file.require' => '请选择上传文件','file.image' => '非法图像文件']);
        if (true !== $result) {
            $this->error($result);
        }
        // 移动到框架应用根目录/public/uploads/ 目录下
        $info = $file->move(ROOT_PATH.'public'.DS .'uploads');
        if ($info) {
            $this->success('文件上传成功：'. $info->getRealPath());
        } else {
            // 上传失败获取错误信息
            $this->error($file->getError());
        }
    }

```

由于设置了 require 验证规则（表示必须上传文件），所以如果没有选择任何文件直接提交的话，页面会提示报错。

![image-20220607160214083](img/image-20220607160214083.png)



###### 保存规则

rule 方法设置。

![image-20220607160312054](img/image-20220607160312054.png)

其中md5和sha1规则会自动以散列值的前两个字符作为子目录，后面的散列值作为文件名。

```php
$info = $file->rule('md5')->move(ROOT_PATH . 'public' . DS . 'uploads');
$info=$file->rule('uniqid')->move(ROOT_PATH	.'public'.DS.'uploads');
```

这里使用了 uniqid 函数来生成唯一的ID命名上传文件，如果必要，还可以支持使用闭包定义规则，例如：

```php
// 移动到框架应用根目录/public/uploads/ 目录下
	$info = $file->rule(function ($file) {
    // 使用自定义的文件保存规则
    return $file->getInfo('type').uniqid();
})->move(ROOT_PATH . 'public' . DS . 'uploads');
```

如果希望指定某个文件的保存文件名，还可以直接使用：

```php
// 移动到框架应用根目录/public/uploads/test.后缀 目录下
$info = $file->move(ROOT_PATH . 'public' . DS . 'uploads', 'test');
```

如果希望保持上传文件的原文件名保存，则可以使用：

```php
$info = $file->move(ROOT_PATH . 'public' . DS . 'uploads', '');
```

默认同名覆盖，不想覆盖就：

```php
$file->move(ROOT_PATH . 'public' . DS . 'uploads', true, false);
```

要获取上传的保存文件名(不含路径)，可以调用返回对象的 getSaveName 方法：

```php
$info = $file->rule('md5')->move(ROOT_PATH . 'public' . DS . 'uploads','');
if ($info) {
    echo $info->getSaveName();
} else {
    $this->error($file->getError());
}
```



###### 多文件

如表单。

```html
<h2>多文件上传示例</h2>
<FORM	method="post" enctype="multipart/form-data" action="{:url('up1')}">
<input	type="file"	name="image[]"	/>	<br>	
<input	type="file"	name="image[]"	/>	<br>	
<input	type="file"	name="image[]"	/>	<br>	
<INPUT	type="submit"	class="btn"	value="	提交">
</FORM>
```

```php
public function up1(Request $request)    {
    // 获取表单上传文件
    $files = $request->file('image');
    $item = [];
    foreach ($files as $file) {
        // 移动到框架应用根目录/public/uploads/ 目录下
        $info = $file->move(ROOT_PATH . 'public' . DS . 'uploads');
        if ($info) {
            $item[] = $info->getRealPath();
        } else {
            // 上传失败获取错误信息
            $this->error($file->getError());
        }
    }
    $this->success('文件上传成功' . implode('<br/>', $item));
}
```



###### 文件操作

上传成功后返回的是 File 对象，除了可以使用 SplFileObject 的属性和方法之外，还可以使用File类自身提供的下列方法，便于进行后续的文件处理（例如对图像文件进行剪裁处理或者移动到远程服务器）。

![image-20220607160712006](img/image-20220607160712006.png)

```php
public function up(Request $request) {
    $file = $request->file('file');
    $info = $file->move(ROOT_PATH . 'public' . DS . 'uploads');
    if ($info) {
        // 移动文件到FTP服务器
        $link = ftp_connect('212.45.5.78');
        ftp_login($link, 'root', 'password');
        /* 移动文件 */
        $path = ftp_pwd($link) . '/uploads/';
        if	(!ftp_put($link,$path.$info->getFilename(),	$info->getRealPath(),FTP_BINARY)){
            $this->error('文件上传保存错误！');
        }
    } else {
        // 上传失败获取错误信息
        $this->error($file->getError());
    }
}
```





##### 库

###### 验证码

修改 `php.ini` 配置，增加(取消注释号`;`)：

```ini
extension_dir="./"
extension_dir="ext"
```

添加一个拓展包：

```ini
extension=php_openssl.dll
```

添加：

```ini
openssl.cafile=
```

下载并放置：`AppServ\php7\verify\cacert.pem` 

thinkphp5.0版本安装验证码类库,必须安装1.* 版本，安装2.0版将会出错。

使用 composer，在应用根目录：

```shell
composer require topthink/think-captcha  1.*
```



### Yii

[教程](https://dev.mysql.com/downloads/windows/installer/8.0.html)