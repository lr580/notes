## 目录

### 第一场

- G Lexicographical Maximum

  签到(模拟-字符串)

- A Villages: Landlines

  签到(模拟-区间交)

- D Mocha and Railgun

  计算几何

- I Chiitoitsu

  期望DP
  
- C Grab the Seat!

  枚举 + 几何优化
  
- J Serval and Essay

  启发式合并 / 随机化
  
- H Fly

### 第二场

- G Link with Monotonic Subsequence

  构造 LIS

- J Link with Arithmetic Progression

  三分/二次函数极值/线性回归 等差数列
  
- D Link with Game Glitch

  对数 最大环(负环) 二分答案

### 第三场

- C Concatenation

  排序 字典序 / trie

- A Ancestor

  LCA ST表/前缀和

- J Journey

  单源最短路

### 其他

#### 码加加模拟3

- A 对称

  思维 位运算

- B 连接

  数学 数位 思维

- C 装铅笔

  线段树

- D 加法

  二分 数学

- E 小Z和小J随机游走

- F 小Z和小J玩游戏

#### 码加加初赛

- A 标识符

  小模拟 字符串

- B 消去

  思维 贪心 栈

- C 小Z和小P探大案

  数学

- D 小Z和小P玩Wordle

  [二分图匹配]

- E 城墙

  [矩阵树定理 高斯消元]

- F 土豆田

#### 码加加复赛

- A 归零

  构造

- B 飞行棋

  前缀和 期望DP 方程组求解(轮换对称)

- C 小Z和小J排排列

  数学

- D 树

  欧拉函数 树 

- E 取模机器

- F 小Z和小J恶作剧 (原题洛谷P5227)

  线段树分治 / LCT / 可撤销并查集 / 哈希+线性基

- G 小Z和小J爱旅行

- H 挑战群同构

#### 赛氪夏季赛

- K 真假英雄

  种类并查集

- F String

  字符串 子序列 编辑距离

- J 大富翁

  模拟 签到

- H Travel

  最短路

- E Preview

  DP 线段树

- D Poly [原题为NOIP模拟赛-多边形](https://blog.csdn.net/UISG103/article/details/77422364)

  计算几何

- I Tree 原题为旅行路线(JZOJ5052)

  trie + 广义后缀自动机

- B Path 原题为CF的E.bricks(div1 E, CF2800)

   二分图 最大独立集

## 第一场

赛时排名117，赛时过了四题，其中A,D是我过的。

> 比赛日志：
>
> 一开始，我在看A题，然后队友发现签到题是G题，队友就把G过掉了，然后我不征求意见自己直接上把A切掉了，20分钟这样过了两题，排名暂时居于21。然后能看的题目，后面就比较零散了，有一道I题看起来很复杂，实际上就是一个概率问题，然后我们就打算去搞这道题。研究了很久，然后发现D题很多人过，我一眼结论，但是想着可能队友写而且不一定对，所以还没写。后来队友启发可以旋转等效，然后看着好像队友也不擅长，我就写了，然后盲猜垂直，直接用比较危险的不懂的三角函数，寄了。然后想不出为什么，卡了十多分钟，想想不如试试再加个平行看看，竟然对了……很奇怪。两个小时多这样了。然后因为自己对取模公式(a/b+c/d)理解有误，所以没敢用DP来做I题，然后一直在想排列组合解法，然后解不出来。队友用DP搞过了。后面，剩下差不多两个钟。但是，剩下的题都看了一遍，队友在做的H题数位DP啥的我没有思路，不想做，然后其他题也没思路，就是看着简单，但是其实还是不知道怎么做。四点多润了

### G Lexicographical Maximum

比较显然的小模拟，若原串是 $n-1$ 个 $9$ 和 $1$ 个任意字符，直接输出；否则输出 $n-1$ 个 $9$，可以特判一下个位数。

个人代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
ll cnt9, n;
char s[1000010];
signed main()
{
    scanf("%s", s + 1);
    n = strlen(s + 1);
    for (ll i = 1; i <= n; ++i)
    {
        if (s[i] == '9')
        {
            ++cnt9;
            continue;
        }
        break;
    }
    if (n == 1)
    {
        putchar(s[1]);
    }
    else if (cnt9 >= n - 1)
    {
        for (ll i = 1; i < n; ++i)
        {
            putchar('9');
        }
        putchar(s[n]);
    }
    else
    {
        for (ll i = 1; i < n; ++i)
        {
            putchar('9');
        }
    }
    return 0;
}
```

队友赛时代码：直接利用字符串自带的大小比较

```c++
cout << max(s, string(s.size()-1, '9'));
```



### A Villages: Landlines

题意很简单，就是给定 $n$ 个区间 $[x-r,x+r]$，将它们交为一个区间，至少需要再补多长的区间。那么排序后顺着扫就行。

代码：(去除赛时写的冗余部分)

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
#define mn 200010
pair<ll, ll> a[mn], prv;
ll ans, n;
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        ll x, r;
        sc(x), sc(r);
        a[i].first = x - r;
        a[i].second = x + r;
    }
    sort(a + 1, a + 1 + n);
    prv = a[1];
    for (ll i = 2; i <= n; ++i)
    {
        if (a[i].first <= prv.second) // merge
        {
            prv.second = max(a[i].second, prv.second);
            prv.first = min(a[i].first, prv.first);
        }
        else // not merge
        {
            ans += a[i].first - prv.second;
            prv = a[i];
        }
    }
    printf("%lld", ans);
    return 0;
}
```



### D Mocha and Railgun

赛时取垂直和平行的最大值过掉了。赛时是根据队友启发直接把Q点旋转到了坐标轴x正半轴再继续考虑，这时候直接把base拉到了x轴求一次，然后不行，又作了一个平行的取max，过了。公式就是弧度 $l=\alpha\cdot r$，然后 $Rt\Delta$ 反三角取 $\alpha$ 即可。赛时AC代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
typedef double db;
ll t;
db r, d, x, y;
signed main()
{
    for (sc(t); t; t--)
    {
        scanf("%lf%lf%lf%lf", &r, &x, &y, &d);
        db k = sqrt(x * x + y * y);
        db ang1 = acos((k + d) / r);
        db ang2 = acos((k - d) / r);
        db ans = r * (ang2 - ang1);
        db ang3 = asin(d / r);
        db ans2 = 2 * r * ang3;
        ans = max(ans, ans2);
        printf("%.12lf\n", ans);
    }
    return 0;
}
```

平行是不需要的，只需要垂直。(即真实过题核心代码是：)

```c++
db k = sqrt(x * x + y * y);
db ang1 = acos((k + d) / r);
db ang2 = acos((k - d) / r);
db ans = r * (ang2 - ang1);
```

> 所以赛时第一次 WA 应该是在原点的特判炸了。

证明：重建系，把 base segment 建成 x 轴，如图：

![image-20220720153538202](img/image-20220720153538202.png)

那么 $Q$ 在 $x$ 轴的投影取值范围是 $[0,\sqrt{Q_x^2+Q_y^2}]$，分别在 $OQ$ 垂直与平行基线时取得。直观上来看，比较难看出来。这样转化之后，设 $Q$ 投影坐标是 $k,k\in [0,\sqrt{Q_x^2+Q_y^2}]$，如图所示：

![image-20220720154406589](img/image-20220720154406589.png)

不需要算出 $y_1,y_2$，只需要用余弦，那么答案为：
$$
ans=r\cdot(\arccos\dfrac{k-d}{r}+\arccos\dfrac{k+d}{r})
$$
求导，得：
$$
ans'=\left(
\dfrac1{\sqrt{1-\dfrac{(k+d)^2}{r^2}}}
-\dfrac1{\sqrt{1-\dfrac{(k-d)^2}{r^2}}}
\right)
$$
由于 $\arccos$ 内的东西 $< 1$，所以分母都大于零。转化为判断下面东西的正负：
$$
\sqrt{1-\dfrac{(k-d)^2}{r^2}}-\sqrt{1-\dfrac{(k+d)^2}{r^2}}
$$
显然 $(k-d)^2 \le (k+d)^2$，所以 $1-\dfrac{(k-d)^2}{r^2} \ge 1-\dfrac{(k+d)^2}{r^2}$，所以是正的。

所以一阶导恒非负，即原函数恒为增函数，即 $k=\sqrt{Q_x^2+Q_y^2}$ 时，答案最大，为：
$$
ans=r\cdot(\arccos\dfrac{\sqrt{Q_x^2+Q_y^2}-d}{r}+\arccos\dfrac{\sqrt{Q_x^2+Q_y^2}+d}{r})
$$


### I Chiitoitsu

抽象为有 $34$ 种颜色的球，每种 $4$ 个。一开始随机给你 $13$ 个，且保证最多每种颜色能得到 $2$ 个。每次能从剩余的球里随机拿一个，若此时凑够了 $7$ 种颜色每种两个球胜，否则永久丢弃随机一个球然后继续抽。给定初始 $13$ 个球，问期望抽多少次能得到答案。

首先，可以明确最佳策略是摸到的不是已有的就丢，否则随机丢一个落单的。因为这样丢掉的一定再不可能拿(再拿到也会再丢)，所以可以减少很多东西考虑，而且是最优的。那么答案有且仅有七种，即一开始有 $[0,6]$ 对同颜色的球。可以思考 DP 了。

首先复习一下取模公式，证明：($p$ 是质数)
$$
(a_1\div b_1+a_2\div b_2)\bmod p\equiv(a_1\div b_1\bmod p+a_2\div b_2\bmod p)\bmod p
$$
由于 $(a+b)\bmod p=(a\bmod p+b\bmod p)\bmod p$，故证毕。这说明 $DP$ 表达式是分子间可以随意进行加减乘除，从而证明了模除下 $DP$ 的有效性。

设 $dp_{i,j}$ 是当前还有 $i$ 个球，还差 $j$ 对时还需要期望回合是多少。显然 $dp_{i,0}=0$。有 $7-j$ 个对代表有 $13-2(7-j)=2j-1$ 个单，随便抽一个中奖率为 $6j-3$，故有：
$$
dp_{i,j}=\dfrac{i-36+6j}{i}dp_{i-1,j}+\dfrac{36-6j}{i}dp_{i-1,j-1}+1
$$
故复杂度为 $O(7\cdot34\cdot4+t)$。

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
ll mod = 1e9 + 7;
ll qpow(ll a, ll b = mod - 2)
{
    ll r = 1;
    for (; b; b >>= 1)
    {
        if (b & 1)
        {
            r = r * a % mod;
        }
        a = a * a % mod;
    }
    return r;
}
ll dp[200][10];
ll dfs(ll i, ll j)
{
    if (j == 0)
    {
        return 0;
    }
    if (dp[i][j])
    {
        return dp[i][j];
    }
    ll t = 6 * j - 3;
    if (i > t)
    {
        ll v = (i - t + mod) * qpow(i) % mod * dfs(i - 1, j) % mod;
        v = (v + t * qpow(i) % mod * dfs(i - 1, j - 1)) % mod;
        dp[i][j] = (v + 1) % mod;
    }
    else if (i == t)
    {
        dp[i][j] = (1 + dfs(i - 1, j - 1)) % mod;
    }
    return dp[i][j];
}
signed main()
{
    ll t;
    sc(t);
    for (ll g = 1; g <= t; ++g)
    {
        map<ll, ll> h;
        char s[40] = {};
        scanf("%s", s);
        for (ll i = 0; i < 26; i += 2)
        {
            h[1000 * s[i] + s[i + 1]]++;
        }
        ll cnt = 0;
        for (auto i : h)
        {
            cnt += i.second == 2;
        }
        printf("Case #%lld: %lld\n", g, dfs(34 * 4 - 13, 7 - cnt));
    }
    return 0;
}
```

只能说这道题是会的，败在了取模公式理解错误上，赛时我执意认为不能用 DP。



### C Grab the Seat!

对一个点，其所遮挡的点的区域是该点 $(x,y)$ 与黑板两端点 $(0,1),(0,m)$ 连线形成的区域。由此可知：①每一行只有最左边的点有影响，其他点可以忽略。②这些区域连线里，所有与 $(0,1)$ 的连线从下往上必然斜率越来越大，即每次只被最上边的点所影响；同理，所有与 $(0,m)$ 的连线从上往下斜率绝对值增大。如图所示：

![image-20220723004049661](img/image-20220723004049661.png)

对这两种情况所形成的区域，并一下即得答案。(据说李超树能多一个 log 做到，但我不会)

那么就可以写出代码，复杂度为 $O(nq)$，详见注释：

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
#define mn 200010
ll n, m, k, q, x[mn], y[mn], id, lf[mn], cnt[mn];
signed main()
{
    sc(n), sc(m), sc(k), sc(q);
    for (ll i = 1; i <= k; ++i)
    {
        sc(x[i]), sc(y[i]);
    }
    while (q--)
    {
        sc(id), sc(x[id]), sc(y[id]);
        for (ll i = 1; i <= m; ++i)
        {
            lf[i] = n + 1; //初始化每行最左边的人的x坐标
            cnt[i] = n;    //初始化每个位置都不被遮挡
        }
        for (ll i = 1; i <= k; ++i)
        {
            lf[y[i]] = min(lf[y[i]], x[i]); //读入最左边的人
        }

        //枚举从(0,1)出发的射线
        ll j = 0;                   //上一条最大斜率射线
        for (ll i = 1; i <= m; ++i) // i就是y
        {
            //如果这行有人，没有历史记录或斜率更大
            if (lf[i] != n + 1 && (!j || (lf[i] - 0) * (j - 1) < (lf[j] - 0) * (i - 1)))
            {
                j = i;
            }
            if (j == 1) //首行特判(k=0)只影响自己这一行
            {
                cnt[i] = i == 1 ? lf[i] - 1 : n;
            }
            else //没有过人就n,否则根据相似三角形求解(注意下取整所以额外-1)
            {    //(i-1)/(j-1)=?/lf[j]
                cnt[i] = j ? ((i - 1) * lf[j] - 1) / (j - 1) : n;
                cnt[i] = min(cnt[i], n); //小心越界
            }
        }

        //(0,m)
        j = 0;
        for (ll i = m; i >= 1; --i)
        {
            if (lf[i] != n + 1 && (!j || (lf[i] - 0) * (j - m) > (lf[j] - 0) * (i - m)))
            {
                j = i;
            }
            if (j == m) // update而不是直接覆盖
            {
                cnt[i] = min(cnt[i], i == m ? lf[i] - 1 : n);
            }
            else
            {
                ll v = j ? ((m - i) * lf[j] - 1) / (m - j) : n;
                cnt[i] = min({cnt[i], v, n});
            }
        }

        ll ans = 0;
        for (ll i = 1; i <= m; ++i)
        {
            ans += cnt[i];
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```



### J Serval and Essay

设 $u$ 点作为论证基础时所能推导出的结论集合为 $S_u$，不难发现，$u$ 是推导树的根节点，推导过程是建生成树的过程，所以若 $v\in S_u$，那么 $v$ 推导出来的 $S_v$ 一定是 $S_u$ 子集，即 $S_v\subseteq S_u$。

> 记 $u$ 推导过程的任一个拓扑序为 $w_1=u,w_2,\cdots,w_{|S_u|}$，记点 $x$ 为终点的有向边的起点集为 $I_x$，即能推导出 $x$ 必须满足全部条件集为 $I_x$(即题目输入的每一行)，那么对 $w_i(i > 1)$，因为它被推导出来了，所以 $I_{w_i}$ 都被推导出来了，即条件集一定在 $i$ 之前全部满足，即 $I_{w_i}\subseteq\{w_1,\cdots,w_{i-1}\}$。
>
> 若 $S_u,S_v$ 有交集，即 $S_u\cap S_v\neq\varnothing$。若 $u\neq v$，记最小满足 $u$ 的拓扑序的 $w_k\in S_u\cap S_v$ 的下标为 $k$，考虑 $w_k\neq u,w_k\neq v$ 时，所以需要满足 $w_k\in S_v$，这就是说 $I_{w_k}\in S_v$，否则从 $v$ 推不出 $k$。那么，就是说还存在比 $k$ 更小的满足 $\in S_u\in S_v$ 的，所以假设不成立。

即可以通过反证法严格推导出：若 $S_u\cap S_v\neq\varnothing$，则 $S_u\subseteq S_v$ 或 $S_v\subseteq S_u$。从直观来看，是很成立的。

> 不是很懂，为什么 $S_u\cap S_v\neq\varnothing$ 就是  $S_u\subseteq S_v$ 或 $S_v\subseteq S_u$，没看出这个证明 $k$ 跟这个结论有啥联系。我太菜了 QwQ

那么，根据推导结论，如果缩点 $S_i$ 为若干个点，那么 $S_u\subseteq S_v$ 时必然有 $S_v$ 是 $S_u$ 的祖先，从而得到森林。那么森林里最大树大小是答案。

那么解法呼之欲出，只需要把每个点能推出来的所有点合并到当前点上。先考虑一下如果暴力会怎样，就是每次对每个点 $u$，判断剩下的所有点 $v$，是否 $u$ 为根的并查集所有点覆盖了 $v$ 的前置条件，如果是就把 $v$ 合进去，形式化表示为：

> 那么可以用启发式合并来解，初始设 $S_u=u$，设 $T=V$。每次取 $T$ 的一点 $v$，若 $\exists u\in T,I_v\subseteq S_u$，即发现 $v$ 的前置条件都满足了，那么 $S_u$ 能够推导出 $S_v$，把 $S_u\cap S_v$ 更新为新的 $S_u$，并且将 $T$ 中删去 $v$。重复该过程直到找不到满足上述条件的 $u,v$。
>
> 任意时刻下任意 $T$ 的两点 $u,v$，满足 $S_u\cap S_v=\varnothing$。直观上很好理解，因为发现不满足时，作为子集的那个点 $v$ 都被拖走了。

可以发现，上面这么做的话，复杂度是严重超标的，至少是 $O(n^2)$，可能更高。所以考虑优化。

因为上述性质可知，形成的是森林，即每个点属于且仅属于一棵树。那么如果某个点已经被合并了，就可以把所有点

> 将所有 $S_u$ 看成一个点，向所有点出边终点除自己的所属集合连边，若 $I_v\subseteq S_u$，将 $S_u,S_v$ 启发式合并，合并出边。满足 $I_v\subseteq S_u$ 当且仅当合并后只有一条来自 $S_u$ 的入边。每个点最多被合并 $\log n$ 次。

视频题解思路：

- 如果有一个点只有一个前置条件，那么该点和前置条件可以合并为一个点，合并后重新设图(即删重边)，会使得可能会出现新的只有一个前置条件的点。这个就是找森林的过程。(这个是比较显然的策略，不看题解应该也能想到)
- 考虑优化上述策略，使得复杂度可以过题。暴力用 bitset 优化也不行。最坏情况下合并需要执行 $n-1$ 次，所以不可能遍历所有的边，考虑优化枚举边的过程。用 set 存边集，合并两点时，暴力合并它们的出边，得到新的出边集
- 阐述启发式合并的复杂度正确性：合并时，原集合是 $A,B$，合并时只需要遍历其中一个集合，将其纳入另一个集合即可，所以可以达到复杂度为 $O(\min(A,B))$。考虑最坏情况，即最终集合每次都是逆向均分为两个子集，那么类比归并排序，可知访问次数是 $O(n\log n)$。考虑 set 自身的复杂度，叠加复杂度为 $O(n\log^2n)$
- 实际上是 BFS，用队列存将要合并的点。那么可以保证一个正确的遍历顺序。

启发式合并：~~(有一说一不是特别懂，没有完全看明白，主要是不理解动态insert和erase是干嘛的)~~

复杂度是 $O((n+m)\log^2n)$。

官方题解复现：

> ```c++
> #include <bits/stdc++.h>
> using namespace std;
> #define sc(x) scanf("%lld", &x)
> typedef long long ll;
> #define mn 200010
> ll t, n, fa[mn], siz[mn];
> set<ll> tj[mn], to[mn];
> signed main()
> {
>     sc(t);
>     for (ll h = 1; h <= t; ++h)
>     {
>         sc(n);
>         for (ll i = 1; i <= n; ++i)
>         {
>             tj[i].clear();
>             to[i].clear();
>             fa[i] = i, siz[i] = 1;
>         }
>         ll ans = 0;
>         for (ll u = 1, m, v; u <= n; ++u)
>         {
>             sc(m);
>             while (m--)
>             {
>                 sc(v);
>                 tj[u].insert(v), to[v].insert(u);
>             }
>         }
>         auto findf = [&](ll x)
>         {
>             while (x != fa[x])
>             {
>                 x = fa[x] = fa[fa[x]];
>             }
>             return x;
>         };
>         for (ll i = 1; i <= n; ++i)
>         {
>             if (findf(i) == i)
>             {
>                 //因为>i还没遍历，所以唯一条件没遍历的话可以忽略
>                 if (tj[i].size() == 1 && *tj[i].begin() > i)
>                 {
>                     continue;
>                 }
>                 auto update = [&](ll k) //删掉冗余点
>                 {
>                     for (auto it = to[k].begin(); it != to[k].end(); ++it)
>                     {
>                         //不等于的话证明被合并走了，它不是并查集根
>                         //注意并查集根不等于推导拓扑的初始条件
>                         //不是根的话，根据不交推论，一定不需要再次计算了
>                         if (findf(*it) != *it)
>                         {
>                             it = to[k].erase(it); //删除后迭代器会更新
>                         }
>                     }
>                 };
>                 update(i);
>                 queue<ll> q;
>                 //还需要计算的能推出的点
>                 for (ll j : to[i])
>                 {
>                     q.push(j);
>                 }
>                 while (!q.empty())
>                 {
>                     ll p = q.front();
>                     q.pop();
>                     // while过程删掉了，可以跳过
>                     if (!to[i].count(p))
>                     {
>                         continue;
>                     }
>                     bool br = false; // goto作用
>                     for (auto it = tj[p].begin(); it != tj[p].end();)
>                     {
>                         //这个条件被推出来了
>                         if (findf(*it) == i)
>                         {
>                             it = tj[p].erase(it);
>                         }
>                         else //存在瓶颈，推导不出p
>                         {
>                             // to[i].insert(p);//题解无关代码，想不出有啥用
>                             br = true;
>                             break;
>                         }
>                     }
>                     if (!br) //能推导出p
>                     {
>                         auto merge = [&](ll x, ll y)
>                         {
>                             x = findf(x), y = findf(y);
>                             if (x != y)
>                             {
>                                 fa[x] = y, siz[y] += siz[x];
>                             }
>                         };
>                         merge(p, i);    //把p合到i为根上
>                         to[i].erase(p); //再也不需要管它了(否则会TLE)
>                         // update(p);//可能不需要这行代码
> 
>                         //循环推导
>                         for (ll j : to[p])
>                         {
>                             if (i != j)
>                             {
>                                 q.push(j);
>                                 to[i].insert(j); // a->b, b->c => a->c
>                             }
>                         }
>                     }
>                     tj[p].insert(i);
>                 }
>             }
>             ans = max(ans, siz[i]);
>         }
>         printf("Case #%lld: %lld\n", h, ans);
>     }
>     return 0;
> }
> ```
>

有更优实现，在 [这里](https://ac.nowcoder.com/acm/discuss/blogs?tagId=148378) 的 [Zechariah_2001](https://ac.nowcoder.com/profile/883382140)，这个比较好懂，跟视频一个思路：

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
#define mn 200010
set<ll> to[mn], from[mn];
ll fa[mn], siz[mn], t, n;
ll findf(ll x)
{
    while (x != fa[x])
    {
        x = fa[x] = fa[fa[x]];
    }
    return x;
}
void merges(ll u, ll v)
{
    u = findf(u), v = findf(v);
    if (u == v)
    {
        return;
    }
    if (to[u].size() < to[v].size()) //规定u比较大
    {
        swap(u, v);
    }
    fa[v] = u, siz[u] += siz[v];
    vector<pair<ll, ll>> mg; //下一轮BFS的点
    for (auto t : to[v])
    {
        to[u].insert(t);   //出边合并
        from[t].erase(v);  // v点被删了
        from[t].insert(u); // v等效成了u
        if (from[t].size() == 1)
        { //类似拓扑序BFS
            mg.push_back({t, u});
        }
    }
    for (auto [x, y] : mg)
    {
        merges(x, y);
    }
}
signed main()
{
    sc(t);
    for (ll h = 1; h <= t; ++h)
    {
        sc(n);
        for (ll i = 1; i <= n; ++i)
        {
            fa[i] = i, siz[i] = 1;
            from[i].clear(), to[i].clear();
        }
        for (ll u = 1, m, v; u <= n; ++u)
        {
            sc(m);
            while (m--)
            {
                sc(v);
                to[v].insert(u);
                from[u].insert(v);
            }
        }
        for (ll i = 1; i <= n; ++i)
        {
            if (from[i].size() == 1)
            {
                merges(*from[i].begin(), i);
            }
        }
        ll ans = 0;
        for (ll i = 1; i <= n; ++i)
        {
            ans = max(ans, siz[i]);
        }
        printf("Case #%lld: %lld\n", h, ans);
    }
    return 0;
}
```



> 随机化：随机顺序遍历原图，设最终森林是 $S$，则深度为 $x$ 的树 $S_u$ 的边预期被遍历次数是 $f(x)$，则 $f(1)=1,f(x)=1+\dfrac1x\sum_{i=1}^{x-1}f(i)$，原因未知。用积分估计求和，即近似 $f(x)=1+\dfrac1x\int_1^xf(x)dx$，可以解出 $f(x)=1+\ln x$，而该近似恒大于原函数，所以期望被遍历 $O(\log x)$ 次，复杂度是 $O(m\log n)$。
>
> 证明 $f(x)=1+\dfrac1x\int_1^xf(x)dx$ 解出 $f(x)=1+\ln x$：
>
> 1. 移项得
>    $$
>    x(f(x)-1)=\int_1^xf(x)dx
>    $$
>
> 2. 两边求导，得
>    $$
>    f(x)-1+xf'(x)=f(x)
>    $$
>
> 3. 移项得
>    $$
>    f'(x)=\dfrac1x
>    $$
>
> 4. 那么根据积分公式，显然，两边积分积回去得
>    $$
>    f(x)=\ln x+C
>    $$
>
> 5. 根据 $f(1)=1$ 得 $C=1$，故 $f(x)=1+\ln x$。证毕。
>
> ……不会实现，也没看懂。



### H Fly

大概是金牌题难度。

题意转化为有 $n$ 种物品的无限背包，物品体积为 $a_i$，背包容量为 $m$，问方案数。有 $k$ 个限制，第 $i$ 个限制要求第 $b_i$ 种物品的数量的二进制第 $c_i$ 位是 $0$。

$m$ 很大，显然不能直接真的上无限背包 DP。而限制条件里某些物品个数无法取。按位限制很容易想到数位 DP。那么可以想到二进制优化的背包问题，将物品拆分为 $1,2,\cdots,2^i$ 个物品进行 01 背包，而不能取就把这个数位的 $2^i$ 给 ban 掉。至此解决了限制问题。但是背包很大，01 背包还是背不出来。这样的物品数倒是 $n\log m$ 个了，但若暴力背包 DP 时间复杂度是 $O(nm\log m)$，空间复杂度是 $O(m)$，不可取。

若进行分组，把所有 $2^i$ 的物品都分到一组。分组后可以发现一个性质，第 $i$ (从 $0$ 算，位运算序数同)组物品体积和至少是 $2^i$ 的倍数，即第 $i$ 组不可能改变二进制位的前 $i-1$ 位。每一组内部单独是一个背包，然后组间也是一个背包，就像是背包套背包。

> 设有 $u_i$ 种方法，使得第一组选出来的体积和第 $i$ 位是 $1$；有 $v_i$ 种方法是 $0$。

设 $f_{i,j,k}$ 是前 $i$ 组选择的体积和除 $2^i$ 为 $j$，体积低 $i$ 位是否大于 $m$ 的低 $i$ 位的方案数。那么答案就是 $f_{n,0,0}$。除 $2^i$ 其实就是把二进制里 $1,2,\cdots, 2^i$ 个的这个个数再给消掉了，即表示为本身的单位体积和。

我们设一个背包体积为 $i$ 时方案数为 $a_i$，那么该背包可以表示为多项式 $a_ix^i$。把两个多项式相乘，就是合并两个背包。

设 $g_{i,j}$ 是第 $i$ 组物品体积和除 $2^i$ 得 $j$ 的方案数。对每一组，其背包表达式为 $\prod_{i\neq c_j}(1+x^{a_i})$。或表示为 $\prod_{全选}(1+x^{a_i})\div\prod_{限制}(1+x^{a_i})$，即全部求一个背包，限制 ban 掉的再求一个背包。这样的背包可以用分治NTT 计算。把一个多项式表示为 $[x^i]$。

因为没怎么听懂，所以不放代码了。因为队友有会 FFT/NTT 的，所以我就不补了 QwQ。



## 第二场

参赛了，在队友启发下回忆济南原题想出并独立做出J题，然后与队友合力做出D题。共过三题。

> 比赛日志：
>
> 开局不利，一开始有GK两题比较多人过。看G，构造，题目感觉有歧义，读不懂，然后看K，是一眼括号序列的DP，然后我对题意理解有误，我认为subsequence是连续的，就想着枚举m种左右，然后队友指出是不连续的，我盲猜跟卡特兰数有关，但是接下来我就不会了，然后DP太弱了，不想看，润去看别的题了。不久后G题意修了，队友去做了，半小时多一点过了。E感觉也是个DP，甚至有一点一眼卷积的直觉，然后也不是很想碰，所以看D，感觉是一个跟环路有关的问题，然后二分答案就出来了，然后想着n次最短路求最长路，发现复杂度很高，不是很现实，暂时放弃了。然后看到J题好像蛮多人过的，就去看看，自己推了蛮久没推出来，做过类似的，但是不太想翻，觉得不一样，然后在练车的队友说这题跟济南的一题很想，我就去翻了下做题记录，然后发现好像确实可以，就上了个求导求出中项最值，然后盲猜三分法可以求公差，然后一交一个WA，然后修了修二分边界改成两个常数，加高了精度，又交对了。此时两个小时多了。然后继续看D。我瞎搞DFS求最长路，随便找的模板，也不知道对不对，感觉很不靠谱，然后一交WA了两次，因为后来又手痒调精度去了，第一发二分边界都是错的。队友说可以试试拓扑求最长路进而求最大环，我不理解。然后我说可以用取对数解决连乘爆精度问题，然后就不需要比较质因数分解大小了。然后本来打算写拓扑了，队友突然想出可以求负环，因为题意刚好就是划分正负的，然后一写炸了，因为题目要求其实是所有环都是负环，但SPFA只能求存在负环。然后队友很妙地指出正负逆转，那么不存在负环就证明都是负环了。于是还是WA，调精度，撤long double都没用，然后我就发现可能是图没说连通导致的，需要求各个分量，于是改成了多次SPFA，然后发现TLE了，调了多次终于调出来了。此时还剩下24分钟。然后队友说L题能做，但我看不懂队友思路，于是遗憾退场。

### G Link with Monotonic Subsequence

通过暴力打表，可以发现有一种答案的规律是类似这样的：

```c+
1
1 2
2 3 1
3 4 1 2
3 4 5 1 2
4 5 6 1 2 3
5 6 7 2 3 4 1
6 7 8 3 4 5 1 2
7 8 9 4 5 6 1 2 3
```

而 $\max(lis(p),lds(p))$ 找规律是 $\lceil\sqrt n\rceil$。也就是可以构造分成 $\lceil\sqrt n\rceil$ 组，每组是升序的，然后逆序排列各个组。这样可以构造出满足 $lis=\lceil\sqrt n\rceil$，即是每组长度；而 $lds=\lceil\sqrt n\rceil$，因为 $lds$ 就是组数。

复杂度 $O(n)$。

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
ll t, n;
signed main()
{
    for (sc(t); t; --t)
    {
        sc(n);
        ll m = ceil(sqrt(n));
        for (ll i = 1, v = n; i <= m; ++i)
        {
            ll jb = max(1LL, v - m + 1);
            for (ll j = jb; j <= v; ++j)
            {
                printf("%lld ", j);
            }
            v = jb - 1;
        }
        printf("\n");
    }
    return 0;
}
```



### J Link with Arithmetic Progression

赛时思路：(严格证明见下文)

设原数组为 $x$，设目标等差数列的首项是 $x_0$。固定 $d$ 时，以 $x_0$ 为自变量，则代价为：
$$
f(x_0)=\sum_{i=1}^n(x_i-x_0)^2
$$
求导得：
$$
f'(x_0)=-2x_0\sum_{i=1}^nx_i+2nx_0
$$
令 $f'(x_0)=0$ 得 $x_0=\dfrac{\sum_{i=1}^nx_i}n$。所以函数极值在 $x_0=\dfrac{\sum_{i=1}^nx_i}n$ 取得。然后用三分法确定 $d$ 最小值，即得答案，复杂度为 $O(n\log w)$。

细节是注意二分边界开大一些，最好是极大常数。事实上，因为 $x_0$ 是二次函数，也可以再次三分的。

赛时 AC 代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
typedef long double db;
#define mn 1000010
ll t, n, a[mn];
db b[mn];
db solve(db v)
{
    db sum = 0, res = 0;
    for (ll i = 1; i <= n; ++i)
    {
        b[i] = a[i] - v * i;
        sum += b[i];
    }
    sum /= n;
    for (ll i = 1; i <= n; ++i)
    {
        res += (b[i] - sum) * (b[i] - sum);
    }
    return res;
}
signed main()
{
    for (sc(t); t; --t)
    {
        sc(n);
        db sum = 0;
        for (ll i = 1; i <= n; ++i)
        {
            sc(a[i]);
            sum += a[i];
        }
        db lf = -1e15, rf = 1e15, ans = 1e100;
        while (rf - lf > 1e-10)
        {
            db dt = (rf - lf) / 3;
            db cf1 = lf + dt, cf2 = rf - dt;
            db v1 = solve(cf1), v2 = solve(cf2);
            // printf("%Lf %Lf\n", cf1, cf2);
            if (v1 < v2)
            {
                ans = min(ans, v1);
                rf = cf2;
            }
            else
            {
                ans = min(ans, v2);
                lf = cf1;
            }
        }
        printf("%.12Lf\n", ans);
    }
    return 0;
}
```

严格证明：



### D Link with Game Glitch

题意转化为求图中最大环的大小，环权值是环上边的乘积，边权是 $\dfrac ca$。若最大环大于 $1$，可以无限刷物品。二分 $w$，每次使得边权是 $\dfrac{cw}a$，然后进行判断。

连乘会爆精度，可以通过取对数转化为连加，这样不会丢失比较大小的依据，即判断 $\prod a_i > 1$ 转化为 $\sum\ln a_i > \ln1=0$。那么转化为判断图上是否每个环都是负环。

SPFA 算法可以找图上是否存在负环。若建图时边权全部取相反数，那么此时图上不存在负环即都是正环。就表明每个环都是负环。

 注意细节是图可能非连通，跑 SPFA 需要跑多次。然后二分精度就锁在 $10^{-6}$ 就好了，太高了会 TLE。还想进一步优化就预处理 $\log$。复杂度是 $O(nm\log10^6 )$

赛时 AC 代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
typedef double db;
#define mn 20024
ll n, m, a[mn], b[mn], c[mn], d[mn];
struct edge
{
    ll to, nx;
    db w;
} e[mn * 2];
ll hd[mn], cnt;
void adde(ll u, ll v, db w)
{
    e[++cnt] = {v, hd[u], w};
    hd[u] = cnt;
}
db dis[mn];
ll vis[mn];
db r = 1, res;
ll cnts[mn];
bool spfa(ll s)
{
    queue<ll> q;
    dis[s] = 0;
    vis[s] = true;
    q.push(s);
    while (!q.empty())
    {
        ll u = q.front();
        q.pop();
        vis[u] = false;
        for (ll i = hd[u]; i; i = e[i].nx)
        {
            //db w = -log(r) - log(e[i].w); TLE
            db w = -log(r * e[i].w);
            ll v = e[i].to;
            if (dis[u] + w < dis[v])
            {
                dis[v] = dis[u] + w;
                if (!vis[v])
                {
                    if (++cnts[v] >= n)
                    {
                        return true;
                    }
                    vis[v] = true;
                    q.push(v);
                }
            }
        }
    }
    return false;
}
bool solve() // spfa
{
    for (ll i = 1; i <= n; ++i)
    {
        vis[i] = 0, dis[i] = 1e9, cnts[i] = 0;
    }
    for (ll i = 1; i <= n; ++i)
    {
        if (!vis[i])
        {
            if (spfa(i))
            {
                return true;
            }
        }
    }
    return false;
}
signed main()
{
    sc(n), sc(m);
    for (ll i = 1; i <= m; ++i)
    {
        sc(a[i]), sc(b[i]), sc(c[i]), sc(d[i]);
        adde(b[i], d[i], 1. * c[i] / a[i]);
    }
    db lf = 0, rf = 1;
    while (rf - lf > 1e-6)
    {
        r = (lf + rf) / 2;
        if (solve()) //没有负环，不行
        {
            rf = r;
        }
        else
        {
            res = r;
            lf = r;
        }
    }
    printf("%.12lf", res);
    return 0;
}
```







## 第三场

我和一个队友参赛了，另一个队友没空，跟上一场一样。我过了A和J题。共过三题。

> 比赛日志：
>
> 然后开局第一题，C题，大概是手写线性字典序排序的题，然后我打算直接去手写了，感觉复杂度没毛病，我打算分治，然后写到一半，还在debug，队友情报一发sort过掉了。但是此时，他RE了一发，且半小时多才过的。然后发现A题过得比较多，我想起LCA是有一些性质的，然后就想到是不是可以快复杂度的k次计算，然后就想到了两个区间计算，那么就是ST表，然后LCA刚好是可以LCA算的，得，出来了。用了欧拉序写O(1)LCA，然后第74分钟过掉了这道题。然后根据榜单，同时HJ能做，H多些人，但是是字符串，我不太懂，就去看J，看起来题意有点复杂，但好像就是一个最短路问题。然后，就开写了，其他都好判断，就直行有点绕，一开始是看成网格了，判定直行是对180度的两个邻点，它们有且仅有一个公共点，就连。然后用map写映射建图，然后TLE了。然后发现自己dijkstra写炸了导致push在if外，所以可以卡到O(nm)吧，改了，顺便改int了，还是炸。然后加了究极快读，打算换掉map为unmap，发现竟然pair int int会CE，又手写了重载，然后竟然WA了，然后我不是很理解，但是并且发现了直行不需要多余判断，直接连就行了。但我觉得判断也没事，不过这样可以省去O(4^3*n)为O(4n)。但是也不TLE啊。百思不得其解，但是这时候发现已经是可以BFS的，但是也不TLE啊，没必要，而且BFS要用unmap我觉得更危。于是，我想着这样耗下去不如交一发试试，然后就AC了，-3之后，在差不多三小时时过了第三道题。然后队友还在卡H，我说能不能FFT，队友后来发现不能，他一开始的线段树复杂度炸了是不对的。然后我看F，FH都没啥思路。队友说H可能是广义后缀自动机，但我们都不会，就放弃了。



## 其他

### 码加加模拟赛3

码加加系列的比赛，因为没有发现官方题解和补题通道，所以并不打算很详细的写补题记录，只是大抵地写一下比赛经历。引用部分均摘自我的比赛日志。

> 本来是五点半开始的，然后我大概差不多八点才开始看题，还剩下一个半小时的时间。瞎点熟悉OJ不小心交了一发空代码CE。然后一看A题，一眼盲猜全部与一下就是答案，猜对了。然后B题，读完题目，打算先打表找找规律，然后一找发现就是一个数称另一个数的位数，一开始还以为gcd什么的看样例。然后自己造几个样例检验，发现修正为左边的数乘右边加一的位数减一就是答案。也AC了，用时10分钟，相比之下A题才用时5分钟不到。然后C题，一眼线段树，发现甚至只需要区间修改和根节点min查询，十分钟从头手写切掉了。然后发现后面三题都不会，有点懵。看了比较久，然后断定F题很难做，就直接上了个暴力骗IOI部分分搞掉了30分。然后集中攻D题，想到一个思路是枚举不同秒的所有可能的差值变化，与一开始的差值变化作对比，用二进制枚举暴力打表，发现了规律，然后直接奇偶讨论加二分搜索，切掉了。这时还差半小时结束比赛。然后剩下时间，E题没有思路，先骗一个特殊情况部分分，直接暴力一个一个点顺序走，部分分全拿到20分。然后还差点时间，本着一种态度，于是坚持到结束。然后写了一个盲猜无依据纯偏分的先走下一个点再往回走的策略，又骗了多一个测试点，捞到了5分，不知道是哪个部分情况对了。然后还差四分钟，直接开摆了。

### 码加加初赛

> 五点半开始。第一题，字符串小模拟，打了一下一交80分，然后加上空串判定就满了，怪！六分多钟。第二题，看起来是什么简单贪心，就盲猜策略是暴力顺着操作2，留下的01交替串刚好是0/1/2的情况，一交一个0分，然后发现自己多组询问没有初始化，上一个询问的栈还在，一改过了。二十分钟不到。然后第三题，没啥思路，然后看样例盲猜答案连续，就打表看，果然如此，然后进而打表发现n=(y+1)/2附近基本上是对的，然后就盲猜就是这样的，于是直接上，然后一交一个60，发现判断分数炸long long了，改i128过了，截止目前差不多40分钟。然后第四题，比较难，然后看着是个字符串大模拟，而且不会处理，暴力都很麻烦，写了个一百多行的纯暴力，没有合理处理Y的情况，然后一交，一小时时，才40分。然后因为读题失误，所以一开始的代码很乱，就重写了一份，然后大模拟预处理后纯暴力DFS搜索，一交60分，此时又过了差不多半小时。然后暂时先不管了，看E，看不懂，甚至不知道样例怎么来的，生成树个数，提示说矩阵树定理，就写了个高斯消元矩阵求秩和按题意建图，暴力地拿到了35分，此时差不多八点，想继续找规律骗分找不出来，只好作罢。然后最后一题，数据随机，先是直接打了个二维前缀和差分暴力搜索，做了点特判特殊数据，然后一交30分，此时八点四，然后发现是题给读入模板里用的int炸了，强转long long得35分。然后，回头看别的题，没啥进展，又继续做这道题。然后用if-break优化，发现竟然直接上了70分，很神奇。此时还差一个钟。剩下的，然后想要再反转猜猜另一种特况，发现不行，还WA回了50分。然后交回去70的。发现比赛的榜是先按总分后按最后一题最后一次最高分时间来排，而不是最先一次，所以比较麻烦。没试过每道题是不是只取最高分。然后D题想剪枝看看能不能骗，加了个最无脑的剪枝，发现不行，还是60，把用时拉回了3.5h，如果同分排名就拉了。后来，再怎么挣扎也没有进展，就这样了。

### 码加加复赛

> 第一题就有点懵了，就去看了看下两道题，然后决定还是看回第一题吧，然后一开始的思路是把全部加起来，跟最后一个作对，发现会炸限定范围。然后想想，嗯，分块，然后每块内这么处理，然后就切掉了，竟然花了十三分钟。然后之后想到其实两两抵消就行了，奇数特判。然后第二题没啥思路，主要是有非线性部分，线性的倒是一眼前缀和优化DP。然后先润了，去看第三题，打了个表，立马发现了规律，于是给秒掉了。花了十分钟这样。然后往后的题更没思路，直接主要倒回去看第二题。然后写出了全部情况DP，并先写了个暴力记搜，想看看能不能搞出线性记忆，然后发现循环了引用了，推不出来。然后，干脆打个暴力模拟看看近似解，然后看看这一部分要怎么做，然后就发现好像m<=n时都是近似于整数的，并且进一步列了下DP方程，解了一下，发现确实是整数，然后直接猜结论了，认为初始就是n，然后之后一个前缀和优化顺着扫过去就行，线性的，走人。但是至此已经花了一个小时多十分钟了。然后往下看，D先不看，一眼觉得点分治，然后欧拉函数也不会算，润了。然后看E，以为全部M_i都在1e5内，然后又看到严格递减，一眼均摊线性，直接开数组做区间移位模拟，然后交上去发现WA了点，然后debug，发现，是移位时可能移位本身要循环下标的，不然可能移位左会超出。才40分，然后才发现只有M_n是1e5内的，于是想不出更好的解法。暂时逃了，此时已经差不多两个小时了。然后继续往下看，一道图论题，我的想法是直接骗，先写了个找桥，然后写了个BFS暴力，一交才35，发现多次询问vis没写好debug炸了，修好后一交45，然后修了修判重边，一交55，此时七点一了。之后花了不少时间去找模板，想把t=2也做过去，找oi-wiki有边双模板，但没有代码，感觉一时半会写不出来，然后去百度搜，看到洛谷有边双分量模板，但是嫁接过来发现不适用，样例都过不去。然后，竟然无意间得知了原题，于是就顺手推过去了，不过题解代码交上去，除去范围问题外才75，暴力没过，我想是加了重边的缘故，刚好我是判了重边的，我就合并了自己的代码namespace搞过去了。然后此时就知道ACF好像三题都是原题了，喜提原题杯。不过也已经还剩两小时不到了。然后打算先往回做，感觉没有信心能够把点分治写好，所以D题先打暴力了，因为觉得连乘后素数筛也无能为力，所以没打筛，然后，取模后的结果是不能扔去算欧拉函数的，所以只能想着用map存质因数分解了，那么复杂度自然我就觉得很危险，然后开了个O(1)LCA欧拉序枚举每一条路径，然后O(sqrt n)暴力跑欧拉，在还剩50分钟时一交一发才50分，还是没能骗到70分。然后想要换用unmap，还是没变。然后就去做倒数第二题了，没啥思路，知道可以转树，但是转完了可能是树形DP亦或是其他，我找不出怎么做，可以跳层的，很难处理。就先写了个next_permutation和栈处理括号序列得题目的LR数组，然后莽过去，发现才12分，然后修好了自己序号的bug，得到了20分，当然包括特判特殊数据的结果了。此时还剩下25分钟不到了。然后剩余时间，看数据觉得有n^2算法，然后树上不会做，因为能跳层，然后竟然想着能不能区间DP，还是想不出来，感觉不行。然后最后一题甚至看不懂，于是打了个全输出0的代码上去，自然没分。剩下时间，我也不会优化D题，无能为力了，坐牢二十分钟，结束。之后跟队友交流思路，发现D题可以O(nlogn)枚举，即j+=i这种双层循环来预处理赋予每个数的因数。倒数第二题则可以最长路n^3，但是也不高分。其他就没思路了。

### 赛氪夏季赛

> 开局看到题目只有JK是英文的，就倒序开题了。看到K是代码填空题，一眼是种类并查集的简单题，虽然不是很懂具体步骤，但是按照自己的经验填了上去，然后调了很久是计算答案那里，脑子抽了用ans+=max(ans,)去了，然后卡了几分钟，然后改成对当前人是敌/友取max，虽然我不是很理解为什么是这么填空的，然后就交了，就过了，用时十分钟。然后看榜发现F题能做，我想了几分钟，没啥思路，然后随便尝试策略，感觉好像是倒着扫，然后队友说了个最长后缀子序列，我就顺着这个思路猜测了一下，然后样例对了，我就去写这个策略了，于是过了题。然后看J题，做的人很多过的人很少，那么我猜有坑，跟之前的登神长阶一样。但是我跟队友都比较莽，我想了一个策略，我也没商量就直接交了。然后，此时H题题意读不懂，然后J我WA了。然后过了一会儿，J题突然一刷新发现题面悄悄被改过了，a_i>=1改成了a_i>=0，那么就知道是什么问题了，队友说已经有思路了，就他去写了。其实这时候我的正确策略应该是，如果题目读不懂，应该去推测题意或者可能的数据错误，然后顺着继续往下想解法的，而不是转去看别的题什么的。总之，J过了，然后此时一小时了。然后H题题意也改了，跟我猜的一样，就是求1到n的最短路，一开始没说，可能是周游，但是样例对不上。然后就想啊，应该不是MST问题，那么就大概是最短路了，然后想想修改一下求的过程，维护路长时也维护三条最长边，那么好像就出来了。我和我的队友同时想出了解法，并且我去做这道题。15分钟，我过掉了H题。队友看I，有一个树哈希的思路，但是无法解决经过根两端的路径，涉及顺序。然后我差不多题目都读了一遍了，我觉得B跟先修班最后一节课LYY教的二分图例题宫廷守卫有点像，就让队友去看B，因为他好像比较懂二分图。然后我去看别的题去了。队友还说有前缀和一样的DP思路。然后队友二分图挂了，我继而发现滑行线段不能交叉，然后发现这样会影响解法。然后我又想到最小路径覆盖，队友指出题意路径不能拐弯，不行。然后暂时没辙了。然后我看D去了，虽然我觉得I是点分治，但我不想写，因为太不熟练了，而且过题数很少。然后让队友看E，我看D，并且盲猜枚举勾股数。然后此时有说题意歧义大概就是最少边数优先，并且就是三角形或四边形。然后说需要考虑两个直角拼接为等腰，四边形就考虑正方形、长方形，并且可以考虑梯形。然后打表，添加了直角三角形转化的直角梯形，还是WA。然后说什么完全平方数，就一直在想怎么搞这个东西，想了很多方向。并且知道了勾股数三个之和一定是偶数，经验上。然后队友通过一些方法发现B题的原题是CF2800的div1 E题，甚至t宝赛时都没过的题目，然后因为知道原题，所以就过了。然后队友看E，我继续看D。D不知道为什么过的人特别多，根据经验怀疑有原题，要么就是比较简单。然后猜了很多发关于完全平方数的结论，不中用。然后打表枚举，发现不存在等边三角形。队友做E去了，DP，然后好像用离线和线段树优化，WA了，并且出题人又改样例。然后我帮debug，指出一个pair int int不知道有没有可能出现问题，然后队友自己修好了，此时还剩下40分钟。然后我又打表了一下一般三角形，发现奇数是有解的，有无理数相消的解。队友拼接两个直角三角形为一般三角形，还是不行。最后遗憾离场，只过了6题。