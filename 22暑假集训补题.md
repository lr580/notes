## 目录

### 第一场

- G Lexicographical Maximum

  签到(模拟-字符串)

- A Villages: Landlines

  签到(模拟-区间交)

- D Mocha and Railgun

  计算几何

- I Chiitoitsu

  期望DP
  
- C Grab the Seat!

  枚举 + 几何优化

### 其他

#### 码加加模拟3

- A 对称

  思维 位运算

- B 连接

  数学 数位 思维

- C 装铅笔

  线段树

- D 加法

  二分 数学

- E 小Z和小J随机游走

- F 小Z和小J玩游戏

#### 码加加初赛

- A 标识符

  小模拟 字符串

- B 消去

  思维 贪心 栈

- C 小Z和小P探大案

  数学

- D 小Z和小P玩Wordle

  [二分图匹配]

- E 城墙

  [矩阵树定理 高斯消元]

- F 土豆田

#### 码加加复赛

- A 归零

  构造

- B 飞行棋

  前缀和 期望DP 方程组求解(轮换对称)

- C 小Z和小J排排列

  数学

- D 树

  欧拉函数 树 

- E 取模机器

- F 小Z和小J恶作剧 (原题洛谷P5227)

  线段树分治 / LCT / 可撤销并查集 / 哈希+线性基

- G 小Z和小J爱旅行

- H 挑战群同构

## 第一场

赛时排名117，赛时过了四题，其中A,D是我过的。

> 比赛日志：
>
> 一开始，我在看A题，然后队友发现签到题是G题，队友就把G过掉了，然后我不征求意见自己直接上把A切掉了，20分钟这样过了两题，排名暂时居于21。然后能看的题目，后面就比较零散了，有一道I题看起来很复杂，实际上就是一个概率问题，然后我们就打算去搞这道题。研究了很久，然后发现D题很多人过，我一眼结论，但是想着可能队友写而且不一定对，所以还没写。后来队友启发可以旋转等效，然后看着好像队友也不擅长，我就写了，然后盲猜垂直，直接用比较危险的不懂的三角函数，寄了。然后想不出为什么，卡了十多分钟，想想不如试试再加个平行看看，竟然对了……很奇怪。两个小时多这样了。然后因为自己对取模公式(a/b+c/d)理解有误，所以没敢用DP来做I题，然后一直在想排列组合解法，然后解不出来。队友用DP搞过了。后面，剩下差不多两个钟。但是，剩下的题都看了一遍，队友在做的H题数位DP啥的我没有思路，不想做，然后其他题也没思路，就是看着简单，但是其实还是不知道怎么做。四点多润了

### G Lexicographical Maximum

比较显然的小模拟，若原串是 $n-1$ 个 $9$ 和 $1$ 个任意字符，直接输出；否则输出 $n-1$ 个 $9$，可以特判一下个位数。

个人代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
ll cnt9, n;
char s[1000010];
signed main()
{
    scanf("%s", s + 1);
    n = strlen(s + 1);
    for (ll i = 1; i <= n; ++i)
    {
        if (s[i] == '9')
        {
            ++cnt9;
            continue;
        }
        break;
    }
    if (n == 1)
    {
        putchar(s[1]);
    }
    else if (cnt9 >= n - 1)
    {
        for (ll i = 1; i < n; ++i)
        {
            putchar('9');
        }
        putchar(s[n]);
    }
    else
    {
        for (ll i = 1; i < n; ++i)
        {
            putchar('9');
        }
    }
    return 0;
}
```

队友赛时代码：直接利用字符串自带的大小比较

```c++
cout << max(s, string(s.size()-1, '9'));
```



### A Villages: Landlines

题意很简单，就是给定 $n$ 个区间 $[x-r,x+r]$，将它们交为一个区间，至少需要再补多长的区间。那么排序后顺着扫就行。

代码：(去除赛时写的冗余部分)

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
#define mn 200010
pair<ll, ll> a[mn], prv;
ll ans, n;
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        ll x, r;
        sc(x), sc(r);
        a[i].first = x - r;
        a[i].second = x + r;
    }
    sort(a + 1, a + 1 + n);
    prv = a[1];
    for (ll i = 2; i <= n; ++i)
    {
        if (a[i].first <= prv.second) // merge
        {
            prv.second = max(a[i].second, prv.second);
            prv.first = min(a[i].first, prv.first);
        }
        else // not merge
        {
            ans += a[i].first - prv.second;
            prv = a[i];
        }
    }
    printf("%lld", ans);
    return 0;
}
```



### D Mocha and Railgun

赛时取垂直和平行的最大值过掉了。赛时是根据队友启发直接把Q点旋转到了坐标轴x正半轴再继续考虑，这时候直接把base拉到了x轴求一次，然后不行，又作了一个平行的取max，过了。公式就是弧度 $l=\alpha\cdot r$，然后 $Rt\Delta$ 反三角取 $\alpha$ 即可。赛时AC代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
typedef double db;
ll t;
db r, d, x, y;
signed main()
{
    for (sc(t); t; t--)
    {
        scanf("%lf%lf%lf%lf", &r, &x, &y, &d);
        db k = sqrt(x * x + y * y);
        db ang1 = acos((k + d) / r);
        db ang2 = acos((k - d) / r);
        db ans = r * (ang2 - ang1);
        db ang3 = asin(d / r);
        db ans2 = 2 * r * ang3;
        ans = max(ans, ans2);
        printf("%.12lf\n", ans);
    }
    return 0;
}
```

平行是不需要的，只需要垂直。(即真实过题核心代码是：)

```c++
db k = sqrt(x * x + y * y);
db ang1 = acos((k + d) / r);
db ang2 = acos((k - d) / r);
db ans = r * (ang2 - ang1);
```

> 所以赛时第一次 WA 应该是在原点的特判炸了。

证明：重建系，把 base segment 建成 x 轴，如图：

![image-20220720153538202](img/image-20220720153538202.png)

那么 $Q$ 在 $x$ 轴的投影取值范围是 $[0,\sqrt{Q_x^2+Q_y^2}]$，分别在 $OQ$ 垂直与平行基线时取得。直观上来看，比较难看出来。这样转化之后，设 $Q$ 投影坐标是 $k,k\in [0,\sqrt{Q_x^2+Q_y^2}]$，如图所示：

![image-20220720154406589](img/image-20220720154406589.png)

不需要算出 $y_1,y_2$，只需要用余弦，那么答案为：
$$
ans=r\cdot(\arccos\dfrac{k-d}{r}+\arccos\dfrac{k+d}{r})
$$
求导，得：
$$
ans'=\left(
\dfrac1{\sqrt{1-\dfrac{(k+d)^2}{r^2}}}
-\dfrac1{\sqrt{1-\dfrac{(k-d)^2}{r^2}}}
\right)
$$
由于 $\arccos$ 内的东西 $< 1$，所以分母都大于零。转化为判断下面东西的正负：
$$
\sqrt{1-\dfrac{(k-d)^2}{r^2}}-\sqrt{1-\dfrac{(k+d)^2}{r^2}}
$$
显然 $(k-d)^2 \le (k+d)^2$，所以 $1-\dfrac{(k-d)^2}{r^2} \ge 1-\dfrac{(k+d)^2}{r^2}$，所以是正的。

所以一阶导恒非负，即原函数恒为增函数，即 $k=\sqrt{Q_x^2+Q_y^2}$ 时，答案最大，为：
$$
ans=r\cdot(\arccos\dfrac{\sqrt{Q_x^2+Q_y^2}-d}{r}+\arccos\dfrac{\sqrt{Q_x^2+Q_y^2}+d}{r})
$$


### I Chiitoitsu

抽象为有 $34$ 种颜色的球，每种 $4$ 个。一开始随机给你 $13$ 个，且保证最多每种颜色能得到 $2$ 个。每次能从剩余的球里随机拿一个，若此时凑够了 $7$ 种颜色每种两个球胜，否则永久丢弃随机一个球然后继续抽。给定初始 $13$ 个球，问期望抽多少次能得到答案。

首先，可以明确最佳策略是摸到的不是已有的就丢，否则随机丢一个落单的。因为这样丢掉的一定再不可能拿(再拿到也会再丢)，所以可以减少很多东西考虑，而且是最优的。那么答案有且仅有七种，即一开始有 $[0,6]$ 对同颜色的球。可以思考 DP 了。

首先复习一下取模公式，证明：($p$ 是质数)
$$
(a_1\div b_1+a_2\div b_2)\bmod p\equiv(a_1\div b_1\bmod p+a_2\div b_2\bmod p)\bmod p
$$
由于 $(a+b)\bmod p=(a\bmod p+b\bmod p)\bmod p$，故证毕。这说明 $DP$ 表达式是分子间可以随意进行加减乘除，从而证明了模除下 $DP$ 的有效性。

设 $dp_{i,j}$ 是当前还有 $i$ 个球，还差 $j$ 对时还需要期望回合是多少。显然 $dp_{i,0}=0$。有 $7-j$ 个对代表有 $13-2(7-j)=2j-1$ 个单，随便抽一个中奖率为 $6j-3$，故有：
$$
dp_{i,j}=\dfrac{i-36+6j}{i}dp_{i-1,j}+\dfrac{36-6j}{i}dp_{i-1,j-1}+1
$$
故复杂度为 $O(7\cdot34\cdot4+t)$。

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
ll mod = 1e9 + 7;
ll qpow(ll a, ll b = mod - 2)
{
    ll r = 1;
    for (; b; b >>= 1)
    {
        if (b & 1)
        {
            r = r * a % mod;
        }
        a = a * a % mod;
    }
    return r;
}
ll dp[200][10];
ll dfs(ll i, ll j)
{
    if (j == 0)
    {
        return 0;
    }
    if (dp[i][j])
    {
        return dp[i][j];
    }
    ll t = 6 * j - 3;
    if (i > t)
    {
        ll v = (i - t + mod) * qpow(i) % mod * dfs(i - 1, j) % mod;
        v = (v + t * qpow(i) % mod * dfs(i - 1, j - 1)) % mod;
        dp[i][j] = (v + 1) % mod;
    }
    else if (i == t)
    {
        dp[i][j] = (1 + dfs(i - 1, j - 1)) % mod;
    }
    return dp[i][j];
}
signed main()
{
    ll t;
    sc(t);
    for (ll g = 1; g <= t; ++g)
    {
        map<ll, ll> h;
        char s[40] = {};
        scanf("%s", s);
        for (ll i = 0; i < 26; i += 2)
        {
            h[1000 * s[i] + s[i + 1]]++;
        }
        ll cnt = 0;
        for (auto i : h)
        {
            cnt += i.second == 2;
        }
        printf("Case #%lld: %lld\n", g, dfs(34 * 4 - 13, 7 - cnt));
    }
    return 0;
}
```

只能说这道题是会的，败在了取模公式理解错误上，赛时我执意认为不能用 DP。



### C Grab the Seat!

对一个点，其所遮挡的点的区域是该点 $(x,y)$ 与黑板两端点 $(0,1),(0,m)$ 连线形成的区域。由此可知：①每一行只有最左边的点有影响，其他点可以忽略。②这些区域连线里，所有与 $(0,1)$ 的连线从下往上必然斜率越来越大，即每次只被最上边的点所影响；同理，所有与 $(0,m)$ 的连线从上往下斜率绝对值增大。如图所示：

![image-20220723004049661](img/image-20220723004049661.png)

对这两种情况所形成的区域，并一下即得答案。(据说李超树能多一个 log 做到，但我不会)

那么就可以写出代码，复杂度为 $O(nq)$，详见注释：

```c++
#include <bits/stdc++.h>
using namespace std;
#define sc(x) scanf("%lld", &x)
typedef long long ll;
#define mn 200010
ll n, m, k, q, x[mn], y[mn], id, lf[mn], cnt[mn];
signed main()
{
    sc(n), sc(m), sc(k), sc(q);
    for (ll i = 1; i <= k; ++i)
    {
        sc(x[i]), sc(y[i]);
    }
    while (q--)
    {
        sc(id), sc(x[id]), sc(y[id]);
        for (ll i = 1; i <= m; ++i)
        {
            lf[i] = n + 1; //初始化每行最左边的人的x坐标
            cnt[i] = n;    //初始化每个位置都不被遮挡
        }
        for (ll i = 1; i <= k; ++i)
        {
            lf[y[i]] = min(lf[y[i]], x[i]); //读入最左边的人
        }

        //枚举从(0,1)出发的射线
        ll j = 0;                   //上一条最大斜率射线
        for (ll i = 1; i <= m; ++i) // i就是y
        {
            //如果这行有人，没有历史记录或斜率更大
            if (lf[i] != n + 1 && (!j || (lf[i] - 0) * (j - 1) < (lf[j] - 0) * (i - 1)))
            {
                j = i;
            }
            if (j == 1) //首行特判(k=0)只影响自己这一行
            {
                cnt[i] = i == 1 ? lf[i] - 1 : n;
            }
            else //没有过人就n,否则根据相似三角形求解(注意下取整所以额外-1)
            {    //(i-1)/(j-1)=?/lf[j]
                cnt[i] = j ? ((i - 1) * lf[j] - 1) / (j - 1) : n;
                cnt[i] = min(cnt[i], n); //小心越界
            }
        }

        //(0,m)
        j = 0;
        for (ll i = m; i >= 1; --i)
        {
            if (lf[i] != n + 1 && (!j || (lf[i] - 0) * (j - m) > (lf[j] - 0) * (i - m)))
            {
                j = i;
            }
            if (j == m) // update而不是直接覆盖
            {
                cnt[i] = min(cnt[i], i == m ? lf[i] - 1 : n);
            }
            else
            {
                ll v = j ? ((m - i) * lf[j] - 1) / (m - j) : n;
                cnt[i] = min({cnt[i], v, n});
            }
        }

        ll ans = 0;
        for (ll i = 1; i <= m; ++i)
        {
            ans += cnt[i];
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```



## 其他

### 码加加模拟赛3

码加加系列的比赛，因为没有发现官方题解和补题通道，所以并不打算很详细的写补题记录，只是大抵地写一下比赛经历。引用部分均摘自我的比赛日志。

> 本来是五点半开始的，然后我大概差不多八点才开始看题，还剩下一个半小时的时间。瞎点熟悉OJ不小心交了一发空代码CE。然后一看A题，一眼盲猜全部与一下就是答案，猜对了。然后B题，读完题目，打算先打表找找规律，然后一找发现就是一个数称另一个数的位数，一开始还以为gcd什么的看样例。然后自己造几个样例检验，发现修正为左边的数乘右边加一的位数减一就是答案。也AC了，用时10分钟，相比之下A题才用时5分钟不到。然后C题，一眼线段树，发现甚至只需要区间修改和根节点min查询，十分钟从头手写切掉了。然后发现后面三题都不会，有点懵。看了比较久，然后断定F题很难做，就直接上了个暴力骗IOI部分分搞掉了30分。然后集中攻D题，想到一个思路是枚举不同秒的所有可能的差值变化，与一开始的差值变化作对比，用二进制枚举暴力打表，发现了规律，然后直接奇偶讨论加二分搜索，切掉了。这时还差半小时结束比赛。然后剩下时间，E题没有思路，先骗一个特殊情况部分分，直接暴力一个一个点顺序走，部分分全拿到20分。然后还差点时间，本着一种态度，于是坚持到结束。然后写了一个盲猜无依据纯偏分的先走下一个点再往回走的策略，又骗了多一个测试点，捞到了5分，不知道是哪个部分情况对了。然后还差四分钟，直接开摆了。

### 码加加初赛

> 五点半开始。第一题，字符串小模拟，打了一下一交80分，然后加上空串判定就满了，怪！六分多钟。第二题，看起来是什么简单贪心，就盲猜策略是暴力顺着操作2，留下的01交替串刚好是0/1/2的情况，一交一个0分，然后发现自己多组询问没有初始化，上一个询问的栈还在，一改过了。二十分钟不到。然后第三题，没啥思路，然后看样例盲猜答案连续，就打表看，果然如此，然后进而打表发现n=(y+1)/2附近基本上是对的，然后就盲猜就是这样的，于是直接上，然后一交一个60，发现判断分数炸long long了，改i128过了，截止目前差不多40分钟。然后第四题，比较难，然后看着是个字符串大模拟，而且不会处理，暴力都很麻烦，写了个一百多行的纯暴力，没有合理处理Y的情况，然后一交，一小时时，才40分。然后因为读题失误，所以一开始的代码很乱，就重写了一份，然后大模拟预处理后纯暴力DFS搜索，一交60分，此时又过了差不多半小时。然后暂时先不管了，看E，看不懂，甚至不知道样例怎么来的，生成树个数，提示说矩阵树定理，就写了个高斯消元矩阵求秩和按题意建图，暴力地拿到了35分，此时差不多八点，想继续找规律骗分找不出来，只好作罢。然后最后一题，数据随机，先是直接打了个二维前缀和差分暴力搜索，做了点特判特殊数据，然后一交30分，此时八点四，然后发现是题给读入模板里用的int炸了，强转long long得35分。然后，回头看别的题，没啥进展，又继续做这道题。然后用if-break优化，发现竟然直接上了70分，很神奇。此时还差一个钟。剩下的，然后想要再反转猜猜另一种特况，发现不行，还WA回了50分。然后交回去70的。发现比赛的榜是先按总分后按最后一题最后一次最高分时间来排，而不是最先一次，所以比较麻烦。没试过每道题是不是只取最高分。然后D题想剪枝看看能不能骗，加了个最无脑的剪枝，发现不行，还是60，把用时拉回了3.5h，如果同分排名就拉了。后来，再怎么挣扎也没有进展，就这样了。

### 码加加复赛

> 第一题就有点懵了，就去看了看下两道题，然后决定还是看回第一题吧，然后一开始的思路是把全部加起来，跟最后一个作对，发现会炸限定范围。然后想想，嗯，分块，然后每块内这么处理，然后就切掉了，竟然花了十三分钟。然后之后想到其实两两抵消就行了，奇数特判。然后第二题没啥思路，主要是有非线性部分，线性的倒是一眼前缀和优化DP。然后先润了，去看第三题，打了个表，立马发现了规律，于是给秒掉了。花了十分钟这样。然后往后的题更没思路，直接主要倒回去看第二题。然后写出了全部情况DP，并先写了个暴力记搜，想看看能不能搞出线性记忆，然后发现循环了引用了，推不出来。然后，干脆打个暴力模拟看看近似解，然后看看这一部分要怎么做，然后就发现好像m<=n时都是近似于整数的，并且进一步列了下DP方程，解了一下，发现确实是整数，然后直接猜结论了，认为初始就是n，然后之后一个前缀和优化顺着扫过去就行，线性的，走人。但是至此已经花了一个小时多十分钟了。然后往下看，D先不看，一眼觉得点分治，然后欧拉函数也不会算，润了。然后看E，以为全部M_i都在1e5内，然后又看到严格递减，一眼均摊线性，直接开数组做区间移位模拟，然后交上去发现WA了点，然后debug，发现，是移位时可能移位本身要循环下标的，不然可能移位左会超出。才40分，然后才发现只有M_n是1e5内的，于是想不出更好的解法。暂时逃了，此时已经差不多两个小时了。然后继续往下看，一道图论题，我的想法是直接骗，先写了个找桥，然后写了个BFS暴力，一交才35，发现多次询问vis没写好debug炸了，修好后一交45，然后修了修判重边，一交55，此时七点一了。之后花了不少时间去找模板，想把t=2也做过去，找oi-wiki有边双模板，但没有代码，感觉一时半会写不出来，然后去百度搜，看到洛谷有边双分量模板，但是嫁接过来发现不适用，样例都过不去。然后，竟然无意间得知了原题，于是就顺手推过去了，不过题解代码交上去，除去范围问题外才75，暴力没过，我想是加了重边的缘故，刚好我是判了重边的，我就合并了自己的代码namespace搞过去了。然后此时就知道ACF好像三题都是原题了，喜提原题杯。不过也已经还剩两小时不到了。然后打算先往回做，感觉没有信心能够把点分治写好，所以D题先打暴力了，因为觉得连乘后素数筛也无能为力，所以没打筛，然后，取模后的结果是不能扔去算欧拉函数的，所以只能想着用map存质因数分解了，那么复杂度自然我就觉得很危险，然后开了个O(1)LCA欧拉序枚举每一条路径，然后O(sqrt n)暴力跑欧拉，在还剩50分钟时一交一发才50分，还是没能骗到70分。然后想要换用unmap，还是没变。然后就去做倒数第二题了，没啥思路，知道可以转树，但是转完了可能是树形DP亦或是其他，我找不出怎么做，可以跳层的，很难处理。就先写了个next_permutation和栈处理括号序列得题目的LR数组，然后莽过去，发现才12分，然后修好了自己序号的bug，得到了20分，当然包括特判特殊数据的结果了。此时还剩下25分钟不到了。然后剩余时间，看数据觉得有n^2算法，然后树上不会做，因为能跳层，然后竟然想着能不能区间DP，还是想不出来，感觉不行。然后最后一题甚至看不懂，于是打了个全输出0的代码上去，自然没分。剩下时间，我也不会优化D题，无能为力了，坐牢二十分钟，结束。之后跟队友交流思路，发现D题可以O(nlogn)枚举，即j+=i这种双层循环来预处理赋予每个数的因数。倒数第二题则可以最长路n^3，但是也不高分。其他就没思路了。

### 赛氪夏季赛