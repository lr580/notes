<p align="right" style="font-size:18px;font-weight:900;color:chocolate"> --by 蒟蒻lr580 </p>

> 阅读前的前置知识：`(C/C++),(PYTHON),(JAVA),HTML,CSS,JS`

# PHP

## 概述

Personal Home Page  / Hypertext Preprocessor

多平台，兼容多服务器、多数据库、协议

PHP代码不是由Web服务器来执行，而是由PHP应用程序服务器负责解析。因此，从本质上来说，PHP是一种HTML代码生成器



## 使用

### 安装

#### windows

照着课件来

Zend 安装遇到 `已安装此产品的另一版本` 提示时，直接找缓存目录 `C:\ProgramData\Package Cache` ，按时间找最近的一个，点开看到安装包继续安装 [参考资料](https://blog.csdn.net/chb_1_2/article/details/88932088)

改windows-preferences-php-code style-code templates-code-simple php file-edit 修改为模板：

```php+HTML
<!DOCTYPE html>
<html>

<head>
    <meta charset='UTF-8'>
    <title></title>
</head>

<body>
    <?php
    echo "Hello World!"
    ?>
</body>

</html>
```

修改zend默认服务器配置：windows-preferences-php-servers-进行更改即可

vsc 格式化插件：PHP Intelephense

配置 php.ini ，开启拓展：

```ini
extesion_dir = "目录/php7/ext"
extension=php_pdo_mysql.dll
extension=php_mysqli.dll
```

若 mysql 为 8.0 ，对要登录的账号设置，如：

```mysql
use mysql;
alter user root@localhost identified with mysql_native_password by '123456';
flush privileges;
```





## 基本语法

### 基本格式

代码文件是`.php`。上面允许出现HTML语法。

php脚本的长标志是`<?php ?>`，注释同C语言格式。

单行代码可以不用分号，多行一定要。缩进格式同C语言。

> 在php的配置文件（php.ini）中有一个short_open_tag的值，开启以后可以使用PHP的短标签：`<? ?>`
>
> PHP 5.4以后，总会被识别并且合法，而不管short_open_tag的设置是什么

开启短标签后，可以用`<?=`代替`<?echo`。

在标记之外的地方写什么都被认为是 HTML 语句。

用户定义的类和函数、内置的结构以及关键字，如echo、while、class等，是不区分大小的；而变量是区分大小写的。

可以用 C++ 风格注释，也可以用 Shell 风格注释 (即 `#` 单行注释)。对行文档性注释的开头结尾分别是 `/**` ， `*/` 。

如：

```php
<?php echo "123"?>
<?= "123" ?>  //这两行代码等效
```

> [php7新特性参见这里](https://www.runoob.com/php/php7-new-features.html)

### 变量

#### 命名规则

变量以`$`开头。命名规则与C类似。创建和使用与PYTHON类似(弱类型)。如：

```php
<?php
$lr=580;
echo $lr*2;
?>
```

不能是保留字：

![image-20220513155543154](img/image-20220513155543154.png)

可以用 `unset(变量名)` 销毁一个变量，如 `unset($x)` 



#### 作用域

##### local

即函数的局部变量

##### global

函数外定义的变量都有全局作用域。可以跨段使用，如：

```php
<?php$x=3;?>
<?=$x?>//$x写成x暴毙
```

函数内使用全局变量需要global关键字。如：

```php
<?php
$x=5; /*运行环境：SCNUOJ */
function f()
{
    global $x; //没有这一行，即使没有下一行也会报错(但是可以$x=1)
    ++$x;
    echo $x; //1
    echo " ";
}
f();
echo $x; //5
?>
```

事实上全局变量是存在字典`$GLOBALS`里的，即全局`$x`等效`于$GLOBALS['x']`。

```php
<?php
$x=5;
$y=10;
function myTest()
{
    $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];
} 
myTest();
echo $y;
?>
```

> 注：在SCNUOJ上跑不动这个代码，原因未知。



##### static

同C语言static。如：

```php
<?php
function myTest()
{
    static $x=0;
    echo $x;
    $x++;
    echo PHP_EOL; // 换行符，同HTML一样，输出等于一个空格
}
 
myTest();
myTest();
myTest();
?>
```



##### parameter

参数作用域。



#### 数据类型

有String,Integer,Float,Boolean,Array,Object,NULL

三大类：标量数据类型、复合数据类型和特殊数据类型。

`var_dump()`函数输出变量数据类型和值。如：

```php
<?php
$x=1;
var_dump($x);//int(1)
?>
```



##### 字符串

###### 定义

可以单双引号。区别：

1. 双引号可以自带变量占位
2. 双引号内`\`转义，单引号代表普通字符(所以`'\n'`是错误的)
3. 单引号内可以不转义地用双引号，反之相反
4. 单引号处理速度略快于双引号

举例：

```php
<?php
$a = '\n12\n34';
$b = "\\n12\\n34";
echo $a,'<br/>',$b, '<br/>';
echo "$a, $b",'<br/>','$a, $b';
?>
```

可以定义多行字符，以`<<<EOF`开始，以`EOF;`结束。然后中间任意文本，如：

```php
<?php
$name="lr580"; 
$a= <<<EOF
        abc$name
            "1 23
EOF;
// 结束需要独立一行且前后不能空格
//里面的引号就是输出可显示的引号，换行和tab没用，空格有用
echo $a;
?>
```



###### 运算

不支持`+`运算符。(能`+`运算的都是数值).但支持并置运算符进行字符串连接。

```php
<?php
$t1="nice";
echo $t1.' lad!';
?>
```

支持`strlen`函数。返回长度。

```php
<?php
echo strlen("lr580");
echo strlen("你好"); //中文字符3个长度
?>
```

支持`strpos`函数，返回子串出现位置。查无返回FALSE。

可以直接比较，用 `==`，和不等号。如：

```php
<?php
//加X防止转整数比较
echo "X123">"X1200";
echo "X123"=="X123";
echo "X1233"<"X12a";
```



> [更多运算函数](https://www.runoob.com/php/php-ref-string.html)



##### 整数

三种赋值方法，十进制，十六进制 `0x`，八进制前导 `0` ，二进制前导 `0b` 。进制可以前导负，如 `-0b` 。

支持四则运算，除法不是整除，零除报错，取模(浮点数会强转整数，右操作数是负数等同于正数)，位运算。

数据范围是C的signed long long。

PHP不支持无符号整型，其字长用常量PHP_INT_SIZE表示，自PHP 4.4.0和PHP 5.0.5后，最大值用常量 PHP_INT_MAX表示，最小值在PHP 7.0.0 及以后的版本中用常量PHP_INT_MIN表示。



##### 浮点数

同一般程序语言的赋值方法和运算方法。字长与平台有关。在PHP 4.0以前的版本中，浮点型数据的标识为double，也叫做双精度浮点数，在使用过程中，float与double，以及 real 没有区别。



##### 布尔值

TRUE或FALSE，不区分大小写。echo输出true为1，false啥也不输出

整数0、浮点数0.0 (都含负0)、空字符串和字符串“0” (不含`-0`)、没有成员的数组、特殊类型NULL等，都可以表示“假”

```php
<?php
$x=TRue;
echo $x;
?>
```

##### NULL

不区分大小写。以下都是NULL：被赋值为NULL；没有被赋值的变量；使用unset进行类型转换后的返回值。

```php
<?php
$x=null;
$y;
var_dump($x);
echo $x; //nothing
// echo $y; //$y不仅不可以输出，也不可以vardump，不然都会报错
$xx = 1;
$x4 = (unset)$xx;
echo $x4;
?>
```



##### resource

资源类型

资源是一种特殊的变量类型，它保存着对外部数据源的引用，如文件、数据库连接等，直到通信结束。
只有PHP脚本中，负责将资源绑定到变量的函数才能返回资源，无法将其他数据类型转换成资源类型。
资源变量里并不真正保存一个值，实际只保存了一个指针。在使用资源时，系统会自动启用垃圾回收机制，释放不再使用的资源，避免内存的无效消耗。

如：

```php
$v = fopen('index.php', 'r');
var_dump($v);
```



##### callable

需要回调的函数。如：

```php
function giz($name)
{
    echo "Hello $name<br/>";
}
function add(callable $f, $a, $b)
{
    echo $a . $b;
    $f($a);
    $f($b);
}
add('giz', 'baicha', 'hefeng');
```



##### 其他

PHP7支持以下：

nullable 可空

函数返回值的 void 类型

iterable 伪类型



#### 常量

##### 普通常量

使用`define()`定义常量，第一个参数字符串，名字；第二个参数值，第三个参数若true，大小写默认敏感。

只能是标量数据类型。常量必须先定义、然后再使用，并且与值只能绑定一次。

常量是全局的。如：

```php
<?php
function f()
{
    define("lr",580);
}
f();
echo lr;
?>
```

也可以用const。调用输出常量名或 `constant('常量名')`

使用const关键字定义常量，声明语句必须处于最上层的作用域内。也就是说，不能使用该方法在函数、循环以及if语句内定义常量。

如：

```php
<?php
const x=3;
echo x;
echo constant('x');//二者等效
?>
```

也可以用 `constant(字符串)` 来动态调用不同的常量。

```php
define('baicha', 'QwQ');
define('jinle', '>_<');
$a = ['baicha', 'jinle'];
echo constant($a[time() % 2]);
```



##### 预定义常量

PHP的系统预定义常量，包括内核预定义常量与标准预定义常量，它们可以在程序中直接使用。
需要注意的是，系统预定义常量往往由不同的扩展库定义，因此，只有加载了相应的扩展库，某些常量才可以使用。

![image-20220513164554884](img/image-20220513164554884.png)



##### 魔术常量

值随着它们在代码中的位置改变而改变。不区分大小写。

`__LINE__`是当前在脚本.php文件中的行数

`__FILE__`是当前文件绝对路径

`__DIR__`是当前文件所在目录的绝对路径(不含后缀`/`)，等价于`dirname(__FILE__)`

`__FUNCTION__`是当前函数的名字(不在函数内调用是输出空)。PHP5起得到的值区分大小写，PHP4中总是小写的。(PHP4.3.0新增)

`__CLASS__`返回类的名字。同PHP5起区分大小写。PHP5.4起对trait也起作用(调用 trait 方法的类的名字)。同理类外无输出。

`__METHOD__`方法名。对函数也可用。

`__NAMESPACE__`命名空间名称。PHP5.3.0。未定义(`namespace 空间名;`)时为空。

`__TRAIT__`



#### 运算

##### 逻辑

###### 比较相等

有`==`,`===`

> 细则：
>
> ![image-20211007194417871](img/image-20211007194417871.png)
>
> ![image-20211007194437384](img/image-20211007194437384.png)
>
> ![image-20211007194450604](img/image-20211007194450604.png)
>
> ![image-20211007194458827](img/image-20211007194458827.png)



###### 不等号

不等于是`<>`或`!=`，其他同C。绝对不等于是`!==`。



###### 逻辑运算

`and`,`or`,`xor`,`&&`,`||`,`!`



###### 三元运算

PHP5.3起，可以省略中间部分而写成`expr1?:expr2`

PHP7+版本有运算符`expr1??expe2`，当且仅当`expr1`为NULL返回`expr2`，否则返回`expr1`。



###### 组合比较

`$a<=>$b`，若`$a>$b`，返回$1$，若`$a<$b`，返回$-1$，否则返回$0$



##### 优先级

| 结合方向 | 运算符                                                   | 附加信息                 |
| :------- | :------------------------------------------------------- | :----------------------- |
| 无       | clone new                                                | clone 和 new             |
| 左       | [                                                        | array()                  |
| 右       | ++ -- ~ (int) (float) (string) (array) (object) (bool) @ | 类型和递增／递减         |
| 无       | instanceof                                               | 类型                     |
| 右       | !                                                        | 逻辑运算符               |
| 左       | * / %                                                    | 算术运算符               |
| 左       | + – .                                                    | 算术运算符和字符串运算符 |
| 左       | << >>                                                    | 位运算符                 |
| 无       | `== != === !== <>`                                       | 比较运算符               |
| 左       | &                                                        | 位运算符和引用           |
| 左       | ^                                                        | 位运算符                 |
| 左       | \|                                                       | 位运算符                 |
| 左       | &&                                                       | 逻辑运算符               |
| 左       | \|\|                                                     | 逻辑运算符               |
| 左       | ? :                                                      | 三元运算符               |
| 右       | = += -= *= /= .= %= &= \|= ^= <<= >>= =>                 | 赋值运算符               |
| 左       | and                                                      | 逻辑运算符               |
| 左       | xor                                                      | 逻辑运算符               |
| 左       | or                                                       | 逻辑运算符               |
| 左       | ,                                                        | 多处用到                 |

注意：or,and和||&&优先级不一样，虽然效果相同。如：

```php
<?php
// 优先级： &&  >  =  >  and
// 优先级： ||  >  =  >  or
 
$a = 3;
$b = false;
$c = $a or $b;
var_dump($c);          // 这里的 $c 为 int 值3，而不是 boolean 值 true
$d = $a || $b;
var_dump($d);          //这里的 $d 就是 boolean 值 true 
?>
```



#### 数组

有数值数组，关联数组(类似PYTHON字典)和多维数组。

> [完整参考手册](https://www.runoob.com/php/php-ref-array.html)

##### 创建

构造数值函数`array(值, ...)`，自动分配，下标从0递增。也可以用 `[]` 语法。

也可以手动分配，如PYTHON。即`$数组变量[下标]=值`。如果不填，默认为max下标+1。

构造关联数组：`array(键=>值, ...)`，`$数组变量[键]=值` 。注意键 `1` 与 `'1'` 等效，以此类推。键可以是字符串。键可以是标量，不能是数组等。

数值和关联可以混用。

如：

```php
<?php
$x=array(1,3,5);
echo $x[0]+($x[1]*$x[2]);
$x[6]=7;
echo $x[6]+count($x);//11
?>
```

```php
<?php
$x=array('lr'=>580,'bc'=>998);
$x['awa']=13;
echo count($x),' ',$x['awa']+$x['bc'];
?>
```

```php
<?php
$cars = array
(
    array("Volvo",100,96),
    array("BMW",60,59),
    array("Toyota",110,100)
);
?>
```



##### 遍历

用`foreach($数组 as $键变量=>$值变量)`或`foreach($数组 as $值变量)`，如：

```php
<?php
$x=array(1,-1);
foreach($x as $key=>$v)
{
    echo $key,' ', $v, '<br/>';
}
$y=array('lr'=>580,'bc'=>998);
foreach($y as $key=>$v)
{
    echo $key,' ', $v, '<br/>';
}
?>
```

直接输出整个数组用`var_dump`或`print_r`，不用`echo`。



##### 运算

`+`运算符取交集，如果都有某个下标，取左操作数的，如：

```php
<?php
$x=array(1,2);
$y=array(3,2=>4);
var_dump($x);
echo '<br/>';
print_r($y);
echo '<br/>';
print_r($x+$y);//1,2,4
?>
```

`==`当且仅当有相同的键值对。

`===`在上述前提下还要求顺序相同。

类推定义`!=,<>,!==`。如：

```php
<?php
$x=array(1,2);
$y=array(1=>2,0=>1);
echo $x==$y?'yes':'no','<br/>',$x===$y?'yes':'no';
?>
```





##### 函数

`is_array($数组)`判定是否是数组

`count($数组)`长度取元素数量。

`sort($数组)`升序排序，`rsort`降序。

​	`asort`根据关联数组值升序，`ksort`根据关联数组键。

​	同理有：`arsort,krsort`。

`end`将内部指针指向数组中的最后一个元素，并输出

> - [current()](https://www.runoob.com/php/func-array-current.html) - 返回数组中的当前元素的值。
> - [next()](https://www.runoob.com/php/func-array-next.html) - 将内部指针指向数组中的下一个元素，并输出。
> - [prev()](https://www.runoob.com/php/func-array-prev.html) - 将内部指针指向数组中的上一个元素，并输出。
> - [reset()](https://www.runoob.com/php/func-array-reset.html) - 将内部指针指向数组中的第一个元素，并输出。
> - [each()](https://www.runoob.com/php/func-array-each.html) - 返回当前元素的键名和键值，并将内部指针向前移动。

`in_array(一些值,$数组)`，可以有第三个参数表示是否区分大小写

如：

```php
<?php
$arr=array('a','B','A'); //ASCII顺序
sort($arr);
print_r($arr);
?>
```



#### 超级全局变量

- $GLOBALS

- $_SERVER

  包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。如有属性`PHP_SELF,SERVER_NAME,HTTP_HOST,HTTP_REFERER,HTTP_USER_AGENT,SCRIPT_NAME`

- $_REQUEST

  收集HTML表单提交的数据。

- $_POST

  收集HTML表单提交的数据。

- $_GET

  收集HTML表单提交的数据。

- $_FILES

- $_ENV

- $_COOKIE

- $_SESSION



> [表单相关参见](https://www.runoob.com/php/php-forms.html)



##### _SERVER

详细：

| 元素/代码                       | 描述                                                         |
| :------------------------------ | :----------------------------------------------------------- |
| $_SERVER['PHP_SELF']            | 当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $_SERVER['PHP_SELF'] 将得到 /test.php/foo.bar。__FILE__ 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 |
| $_SERVER['GATEWAY_INTERFACE']   | 服务器使用的 CGI 规范的版本；例如，"CGI/1.1"。               |
| $_SERVER['SERVER_ADDR']         | 当前运行脚本所在的服务器的 IP 地址。                         |
| $_SERVER['SERVER_NAME']         | 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: www.runoob.com) |
| $_SERVER['SERVER_SOFTWARE']     | 服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache/2.2.24) |
| $_SERVER['SERVER_PROTOCOL']     | 请求页面时通信协议的名称和版本。例如，"HTTP/1.0"。           |
| $_SERVER['REQUEST_METHOD']      | 访问页面使用的请求方法；例如，"GET", "HEAD"，"POST"，"PUT"。 |
| $_SERVER['REQUEST_TIME']        | 请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496)   |
| $_SERVER['QUERY_STRING']        | query string（查询字符串），如果有的话，通过它进行页面访问。 |
| $_SERVER['HTTP_ACCEPT']         | 当前请求头中 Accept: 项的内容，如果存在的话。                |
| $_SERVER['HTTP_ACCEPT_CHARSET'] | 当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如："iso-8859-1,*,utf-8"。 |
| $_SERVER['HTTP_HOST']           | 当前请求头中 Host: 项的内容，如果存在的话。                  |
| $_SERVER['HTTP_REFERER']        | 引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。) |
| $_SERVER['HTTPS']               | 如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。      |
| $_SERVER['REMOTE_ADDR']         | 浏览当前页面的用户的 IP 地址。                               |
| $_SERVER['REMOTE_HOST']         | 浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。 |
| $_SERVER['REMOTE_PORT']         | 用户机器上连接到 Web 服务器所使用的端口号。                  |
| $_SERVER['SCRIPT_FILENAME']     | 当前执行脚本的绝对路径。                                     |
| $_SERVER['SERVER_ADMIN']        | 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：someone@runoob.com) |
| $_SERVER['SERVER_PORT']         | Web 服务器使用的端口。默认值为 "80"。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。 |
| $_SERVER['SERVER_SIGNATURE']    | 包含了服务器版本和虚拟主机名的字符串。                       |
| $_SERVER['PATH_TRANSLATED']     | 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 |
| $_SERVER['SCRIPT_NAME']         | 包含当前脚本的路径。这在页面需要指向自己时非常有用。__FILE__ 常量包含当前脚本(例如包含文件)的完整路径和文件名。 |
| $_SERVER['SCRIPT_URI']          | URI 用来指定要访问的页面。例如 "/index.html"。               |



##### \_REQUEST

预定义的 \$_REQUEST 变量包含了 ​\$\_GET、\$\_POST 和 \$\_COOKIE 的内容。

\$\_REQUEST 变量可用来收集通过 GET 和 POST 方法发送的表单数据。

举例：

```php
<!DOCTYPE html>
<html>
<body>

<form method="post" action="<?php echo $_SERVER['PHP_SELF'];?>">
Name: <input type="text" name="fname">
<input type="submit">
</form>

<?php 
$name = htmlspecialchars($_REQUEST['fname']); 
echo $name; 
?>

</body>
</html>
```



##### _POST

举例：

```php+HTML
<!DOCTYPE html>
<html>
<body>

<form method="post" action="<?php echo $_SERVER['PHP_SELF'];?>">
Name: <input type="text" name="fname">
<input type="submit">
</form>

<?php 
$name = htmlspecialchars($_POST['fname']); 
echo $name; 
?>

</body>
</html>
```



##### _GET

举例：

```html
<html>
<body>
<a href="test_get.php?subject=PHP&web=runoob.com">Test $GET</a>
</body>
</html>
```

```php+HTML
<!DOCTYPE html>
<html>
<body>

<a href="test_get.php?subject=PHP&web=runoob.com">测试 $_GET</a>

</body>
</html>
```



##### _COOKIE

是关联数组。通常用`isset`函数查找某个键值是否存在。

操作函数：`setcookie(键,值,过期时间)`

删除即更改过期时间为当前之前的时间即可，如：

```php
<?php
// 设置 cookie 过期时间为过去 1 小时
setcookie("user", "", time()-3600);
?>
```



##### _SESSION

PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。

> （未核实）该信息是临时的，在用户离开网站后将被删除。

删除某些 session 数据，可以使用 unset() 或 session_destroy() 函数。后者彻底删除全部session数据。



#### 对象

##### 概述

定义用`class`关键字(语法类似java)。成员属性用`var`关键字，可以声明初始值。

新建变量用`new 类名`，如果没有构造函数可以不写括号。访问变量的成员都用`->`操作符。

`$this`表示self指针，用`$this->`运算符访问成员属性。

构造函数是`__construct`，析构函数是`__destruct`。子类构造方法不能自动调用父类的构造方法。

继承用`extends`，不支持多继承。`parent`关键字加`::`访问父类。

访问控制关键字同C：

> - **public（公有）：**公有的类成员可以在任何地方被访问。
> - **protected（受保护）：**受保护的类成员则可以被其自身以及其子类和父类访问。
> - **private（私有）：**私有的类成员则只能被其定义所在的类访问。

(有关键字时可以不声明`var`，`var`认为是共有)。成员函数不设置控制关键字默认为公有。子类不能重定义私有成员，其他可以。

接口的语法同JAVA。显然类中必须实现接口中定义的所有方法。

常成员(常量)用`const`定义，调用为`类名::常量名`或`$实例名::常量名`，或字符串值为类名的：`$字符串::常量名`。常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。

抽象类语法同JAVA。

> 继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。
>
> 此外，子类方法可以包含父类抽象方法中不存在的可选参数。
>
> 例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则也是可以正常运行的。

静态成员语法同java。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。调用为`类名::静态成员`

> 自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static。

final语法同JAVA。类为final不可继承。

如：

```php
<?php
/**
 * Define MyClass
 */
class MyClass
{
    public $public = 'Public';
    protected $protected = 'Protected';
    private $private = 'Private';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj = new MyClass();
echo $obj->public; // 这行能被正常执行
echo $obj->protected; // 这行会产生一个致命错误
echo $obj->private; // 这行也会产生一个致命错误
$obj->printHello(); // 输出 Public、Protected 和 Private


/**
 * Define MyClass2
 */
class MyClass2 extends MyClass
{
    // 可以对 public 和 protected 进行重定义，但 private 而不能
    protected $protected = 'Protected2';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj2 = new MyClass2();
echo $obj2->public; // 这行能被正常执行
echo $obj2->private; // 未定义 private
echo $obj2->protected; // 这行会产生一个致命错误
$obj2->printHello(); // 输出 Public、Protected2 和 Undefined

?>
```

```php
<?php
abstract class AbstractClass
{
    // 我们的抽象方法仅需要定义需要的参数
    abstract protected function prefixName($name);

}

class ConcreteClass extends AbstractClass
{

    // 我们的子类可以定义父类签名中不存在的可选参数
    public function prefixName($name, $separator = ".") {
        if ($name == "Pacman") {
            $prefix = "Mr";
        } elseif ($name == "Pacwoman") {
            $prefix = "Mrs";
        } else {
            $prefix = "";
        }
        return "{$prefix}{$separator} {$name}";
    }
}

$class = new ConcreteClass;
echo $class->prefixName("Pacman"), "\n";
echo $class->prefixName("Pacwoman"), "\n";
?>
```



##### trait

一种代码复用的方法。

声明：`trait 名字{}`，调用：`use 名字;`

如：

```php
<?php
class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}
 
trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}
 
class MyHelloWorld extends Base {
    use SayWorld;
}
 
$o = new MyHelloWorld();
$o->sayHello();
?>
```



#### 可变变量

`$普通变量` ，如 `$$x` 。那么这个变量的变量名是可以变化的。（初始赋值是变，再改就不动了）

```php
$name = "lr580";
$$name = 580;
echo $lr580;
$name = "baicha";
echo $baicha; //NULL
echo $lr580; //可以
$baicha = 233; //重新赋值
echo $$name; //233
echo $baicha; //233
echo $lr580; //580
```

换言之就是跟一个数组一样的用法，即 `$key` 。然后 `$$` 就是当前指向的 key 。



#### 传引用

跟 C++ 一样，赋值时只要 `$x = &$y` 那么 `$x` 就是传引用

通过引用赋值定义的变量与原变量并不是表示同一个内存单元，而仅仅是其值相互关联而已。所以，若对原变量使用销毁(unset)操作，则不会导致引用变量的消失。销毁操作后，仅仅是取消了2个变量值的关联，如：

```php
$x = 580;
$y = &$x;
unset($x);
var_dump($y);
```



#### 运算符

除法默认是浮点除。

![image-20220513173643295](img/image-20220513173643295.png)

如：

```php
echo 1 <=> 2, 2 <=> 2, 3 <=> 2, null ?? 1 ?? 2, 3 ?? null;
```

逻辑运算可以用 `&&,||,!` 以及 `and,or,xor,not` ，返回布尔值。

位运算跟 C 一样。

其他：

`instanceof` 判断一个对象是否是某个类的对象。类型运算符。

\` 运算符会把反引号内内容作为操作系统系统命令执行并返回结果。执行运算符。

@ 错误抑制运算符，报错不输出。

类型转换：显式转换有 `setType(), intval(), floatval(), strval()` 和强转。

如：

```php
class people
{
};
$x = new people();
echo $x instanceof object; //false
echo "|";
echo $x instanceof people;
```

```php
@(1 / 0);
1 / 0;
```

```php
$x1 = 1 / 3;
settype($x1, 'string');
var_dump($x1);
$x2 = '580LR2';
settype($x2, 'int');
var_dump($x2); //580
$x3 = 10;
settype($x3, 'object');
var_dump($x3); //有一个属性 scalar
$x4 = 'QwQ';
settype($x4, 'array');
var_dump($x4); //首元素是它
```

```php
echo intval(5 / 3); //1
$x1 = 3;
var_dump((object)$x1);
var_dump((array)$x1); //同settype
```



### 流程控制

#### 条件判断

##### if

使用`if(),elseif(),else()`，大括号括起来语句(或不括起来单行)，语法大同C。`elseif`写成`else if`也行。

##### switch

语法同C。case可以是字符串或浮点数。如：

```php
<?php
$x=3.1;
switch($x)
{
    case 3.1:
        echo 'awa';
}
?>
```



#### 循环

`for`,`while`和`do...while`格式同C。

有`foreach($数组 as $下标变量 => $值变量)`。



#### 函数

以字母或下划线开头（不能以数字开头）。

创建语法：

```php
function 函数名(参数)
{
    
}
```

可以有默认参数。如：

```php
<?php
function f($x=1)
{
    echo $x;
}
f();
f(2);
?>
```

可以传引用，如`function foo(&$bar){...`

用函数作参数(callable)见变量-数据类型-callable



#### 命名空间

##### 定义

未定义命名空间时，所有常量、类和函数放在全局空间。

文件包含命名空间时，必须在所有其他代码之前声明：`namespace 空间名;`或`namespace 名{代码块}`。第二种解法常用于一个代码文件有多个空间时。

全局代码用无名的`namespace{}`。声明了之后整个文件部分都必须在任何一个命名空间或全局代码大括号内，不能在别的地方。

调用命名空间：`空间名\空间内的内容名`

如：

```php
<?php
namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace { // 全局代码
session_start();
$a = MyProject\connect();
echo MyProject\Connection::start();
}
?>
```

有命名空间后，声明空间前唯一合法的代码是`declare`，如：

```php
<?php
declare(encoding='UTF-8'); //定义多个命名空间和不包含在命名空间中的代码
namespace {...
?>
```

可以定义子空间，如`namespace MyProject\Sub\Level`。

全局变量可以使用完全限定名称调用，如全局函数`f`可写作调用`\f()`，常量、类等同理。



##### 引用

`use 命名空间`

`use 命名空间 as 别名`

可以用关键字`namespace`显式访问当前命名空间及其子空间的元素，等价类的`self`操作符。

如：

```php
<?php
namespace MyProject;

use blah\blah as mine; // 引入了 blah\blah 命名空间，并定义了个别名mine

mine\mine(); // 调用函数 blah\blah\mine()
namespace\blah\mine(); // 调用函数 MyProject\blah\mine()

namespace\func(); // 调用函数 MyProject\func()
namespace\sub\func(); // 调用函数 MyProject\sub\func()
namespace\cname::method(); // 调用 MyProject\cname 类的静态方法
$a = new namespace\sub\cname(); // 实例化 MyProject\sub\cname 类的对象
$b = namespace\CONSTANT; // 将常量 MyProject\CONSTANT 的值赋给 $b
?>
```

```php
<?php
namespace\func(); // calls function func()
namespace\sub\func(); // calls function sub\func()
namespace\cname::method(); // calls static method "method" of class cname
$a = new namespace\sub\cname(); // instantiates object of class sub\cname
$b = namespace\CONSTANT; // assigns value of constant CONSTANT to $b
?>
```

```php
<?php
namespace foo;
use My\Full\Classname as Another;

// 下面的例子与 use My\Full\NSname as NSname 相同
use My\Full\NSname;

// 导入一个全局类
use \ArrayObject;

$obj = new namespace\Another; // 实例化 foo\Another 对象
$obj = new Another; // 实例化 My\Full\Classname　对象
NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func
$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象
// 如果不使用 "use \ArrayObject" ，则实例化一个 foo\ArrayObject 对象
?>
```

```php
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // 实例化 My\Full\Classname 对象
NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func
?>
```

甚至可以用字符串动态生成命名空间对象：

```php
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // 实例化一个 My\Full\Classname 对象
$a = 'Another';
$obj = new $a;      // 实际化一个 Another 对象
?>
```

> 名称解析遵循下列规则：
>
> 1. 对完全限定名称的函数，类和常量的调用在编译时解析。例如 *new \A\B* 解析为类 *A\B*。
>
> 2. 所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 *A\B\C* 被导入为 *C*，那么对 *C\D\e()* 的调用就会被转换为 *A\B\C\D\e()*。
>
> 3. 在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 *A\B* 内部调用 *C\D\e()*，则 *C\D\e()* 会被转换为 *A\B\C\D\e()* 。
>
> 4. 非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 *A\B\C* 导入为C，则 *new C()* 被转换为 *new A\B\C()* 。
>
> 5. 在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数
>
>     
>
>    foo()
>
>     
>
>    的调用是这样解析的：
>
>    1. 在当前命名空间中查找名为 *A\B\foo()* 的函数
>    2. 尝试查找并调用 *全局(global)* 空间中的函数 *foo()*。
>
> 6. 在命名空间（例如
>
>    A\B
>
>    ）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用
>
>     
>
>    new C()
>
>     
>
>    及
>
>     
>
>    new D\E()
>
>     
>
>    的解析过程：
>
>     
>
>    new C()
>
>    的解析:
>
>    1. 在当前命名空间中查找*A\B\C*类。
>    2. 尝试自动装载类*A\B\C*。
>
>    new D\E()
>
>    的解析:
>
>    1. 在类名称前面加上当前命名空间名称变成：*A\B\D\E*，然后查找该类。
>    2. 尝试自动装载类 *A\B\D\E*。
>
>    为了引用全局命名空间中的全局类，必须使用完全限定名称
>
>     
>
>    new \C()



#### 包含文件

使用`include`或`require`操作符加上字符串文件名，表示在此处插入别的文件的代码。

> 这两个操作符的区别在于
>
> ①错误处理方式：
>
> - require 生成`E_COMPILE_ERROR`，错误发生后脚本停止执行
> - include 生成`E_WARNING`，错误发生后脚本继续执行
>
> ②位置：
>
> - require 一般放在文件最前面，程序执行前先导入要引用的文件
> - include 一般放在程序的流程控制中，程序执行时碰到才会引用
>
> [更多区别](https://www.runoob.com/w3cnote/php-different-include-and-require.html)

如：

```php
<?php
$color='red'; //vars.php
$car='BMW';
?>
```

```php+HTML
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>
<h1>欢迎来到我的主页!</h1>
<?php 
include 'vars.php';
echo "I have a $color $car"; // I have a red BMW
?>
</body>
</html>
```



#### 错误处理

##### 错误处理函数

`set_error_handler(处理函数名字符串)`，设置自定义错误处理程序，当触发了报错时执行。可选参数是规定显示何种错误报告级别的用户定义错误。默认是 `"E_ALL"`。

错误处理函数格式：

```php
error_function(error_level,error_message,
error_file,error_line,error_context)
```

| 参数          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| error_level   | 必需。为用户定义的错误规定错误报告级别。必须是一个数字。参见下面的表格：错误报告级别。 |
| error_message | 必需。为用户定义的错误规定错误消息。                         |
| error_file    | 可选。规定错误发生的文件名。                                 |
| error_line    | 可选。规定错误发生的行号。                                   |
| error_context | 可选。规定一个数组，包含了当错误发生时在用的每个变量以及它们的值。 |

`trigger_error($msg,[$level])`函数触发一个报错，调用设置的错误处理函数，传入对应参数。触发能执行的前提是设置了自定义错误处理函数。

如：

```php
<?php
 // 用户定义的错误处理函数
 function myErrorHandler($errno, $errstr, $errfile, $errline) {
     echo "<b>Custom error:</b> [$errno] $errstr<br>";
     echo " Error on line $errline in $errfile<br>";
 }

 // 设置用户定义的错误处理函数
 set_error_handler("myErrorHandler");

 $test=2;

 // 触发错误
 if ($test>1) {
     trigger_error("A custom error has been triggered");
 }
 ?> 
```

```php
<?php
// 错误处理函数
function customError($errno, $errstr)
{
    echo "<b>Error:</b> [$errno] $errstr<br>";
    echo "已通知网站管理员";
    error_log("Error: [$errno] $errstr",1,
    "someone@example.com","From: webmaster@example.com");
}

// 设置错误处理函数
set_error_handler("customError",E_USER_WARNING);

// 触发错误
$test=2;
if ($test>1)
{
    trigger_error("变量值必须小于等于 1",E_USER_WARNING);
}
?>
```

```php
<?php
function myException($exception)
{
    echo "<b>Exception:</b> " , $exception->getMessage();
}
 
set_exception_handler('myException');
 
throw new Exception('Uncaught Exception occurred');
?>
```



> [详见](https://www.w3school.com.cn/php/php_ref_error.asp)



##### 异常

> 异常处理用于在指定的错误（异常）情况发生时改变脚本的正常流程。这种情况称为异常。
>
> 当异常被触发时，通常会发生：
>
> - 当前代码状态被保存
> - 代码执行被切换到预定义（自定义）的异常处理器函数
> - 根据情况，处理器也许会从保存的代码状态重新开始执行代码，终止脚本执行，或从代码中另外的位置继续执行脚本

当异常被抛出时，其后的代码不会继续执行，PHP 会尝试查找匹配的 "catch" 代码块。

如果异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么将发生一个严重的错误（致命错误），并且输出 "Uncaught Exception" （未捕获异常）的错误消息/直接服务器内部错误(SCNUOJ环境)。

如：

```php
<?php
throw new Exception("Value must be 1 or below");
?>
```

格式：

```php
try
{
    ...
}
catch(错误类 $变量) //若干个catch
{
    
}
```

`set_exception_handler()` 函数可设置处理所有未捕获异常的用户定义函数。函数参数是一个错误处理函数名，该函数需要处理一个参数，该参数为异常实例。

异常具有的方法有：`getLine`,`getFile`,`getMessage`。

抛出异常的语句为`throw new 异常类(构造函数参数)`

如：

```php
<?php
// 创建一个有异常处理的函数
function checkNum($number)
{
    if($number>1)
    {
        throw new Exception("变量值必须小于等于 1");
    }
        return true;
}
    
// 在 try 块 触发异常
try
{
    checkNum(2);
    // 如果抛出异常，以下文本不会输出
    echo '如果输出该内容，说明 $number 变量';
}
// 捕获异常
catch(Exception $e)
{
    echo 'Message: ' .$e->getMessage();
}
?>
```

可以定义自定义异常类如：

```php
<?php
class customException extends Exception
{
    public function errorMessage()
    {
        // 错误信息
        $errorMsg = '错误行号 '.$this->getLine().' in '.$this->getFile()
        .': <b>'.$this->getMessage().'</b> 不是一个合法的 E-Mail 地址';
        return $errorMsg;
    }
}
?>
```





### 内建函数

##### 变量操作

###### isset

检测变量是否设置，并且不是 `null`

如果一次传入多个参数，那么 isset() 只有在全部参数都以被设置时返回 `true` 计算过程从左至右，中途遇到没有设置的变量时就会立即停止。

###### unset

销毁若干个变量(可变参数)。

如果是全局变量，在函数中销毁，只在函数生效。但对`$_GLOBALS`则全局生效。

如果是引用参数变量，只在函数内销毁。

如果是函数静态变量，只在此次生效，下次调用还在。

如：

```php
<?php
$x=1;
unset($x);
echo empty($x);
?>
```



###### filter_var

检测变量是否符合过滤器要求。如果成功，则返回已过滤的数据，如果失败，则返回 false。

第一个参数是待检验变量，第二个是过滤器ID。

如：

```php
<?php
if(!filter_var("someone@example....com", FILTER_VALIDATE_EMAIL))
 {
 echo("E-mail is not valid");
 }
else
 {
 echo("E-mail is valid");
 }
?>
```

```php
<?php
$int = 123;
 
if(!filter_var($int, FILTER_VALIDATE_INT))
{
    echo("不是一个合法的整数");
}
else
{
    echo("是个合法的整数");
}
?>
```

```php
<?php
$var=300;
 
$int_options = array(
    "options"=>array
    (
        "min_range"=>0,
        "max_range"=>256
    )
);
 
if(!filter_var($var, FILTER_VALIDATE_INT, $int_options))
{
    echo("不是一个合法的整数");
}
else
{
    echo("是个合法的整数");
}
?>
```

```php
<?php
$filters = array
(
    "name" => array
    (
        "filter"=>FILTER_SANITIZE_STRING
    ),
    "age" => array
    (
        "filter"=>FILTER_VALIDATE_INT,
        "options"=>array
        (
            "min_range"=>1,
            "max_range"=>120
        )
    ),
    "email"=> FILTER_VALIDATE_EMAIL
);
 
$result = filter_input_array(INPUT_GET, $filters);
 
if (!$result["age"])
{
    echo("年龄必须在 1 到 120 之间。<br>");
}
elseif(!$result["email"])
{
    echo("E-Mail 不合法<br>");
}
else
{
    echo("输入正确");
}
?>
```



过滤器分类：

Validating 过滤器：

- 用于验证用户输入
- 严格的格式规则（比如 URL 或 E-Mail 验证）
- 如果成功则返回预期的类型，如果失败则返回 FALSE

Sanitizing 过滤器：

- 用于允许或禁止字符串中指定的字符
- 无数据格式规则
- 始终返回字符串



通过使用 FILTER_CALLBACK 过滤器，可以调用自定义的函数，把它作为一个过滤器来使用。

```php
<?php
function convertSpace($string)
{
    return str_replace("_", ".", $string);
}
 
$string = "www_runoob_com!";
 
echo filter_var($string, FILTER_CALLBACK,
array("options"=>"convertSpace"));
?>
```



> [过滤器参见这里](https://www.w3school.com.cn/php/php_ref_filter.asp)
>
> - filter_var() - 通过一个指定的过滤器来过滤单一的变量
> - filter_var_array() - 通过相同的或不同的过滤器来过滤多个变量
> - filter_input - 获取一个输入变量，并对它进行过滤
> - filter_input_array - 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤
>
> [过滤器使用](https://www.runoob.com/php/php-filter.html)
>
> [更多举例](https://www.runoob.com/php/php-filter-advanced.html)



##### 字符处理

###### htmlspecialchars

将HTML标签失效。例如字符串里有`<b></b>`，将会直接输出，而不是渲染加粗。

失效字符包括：`&,",',<,>`，转化为`&amp,&qpot,&#039,&lt,&gt`



###### trim

去除手尾空白字符。



###### stripslashes

去除所有`\`，如：

```php
<?php
echo stripslashes('1\2\n3'); //12n3
// echo stripslashes("1\2\n3"); //nope
?>
```



###### empty

是否为空。变量为$0$、空字符、不存在或NULL时为真。如：

```php
<?php
echo empty($t);
echo empty('');
echo empty(NULL); //都是true
echo empty(0);
echo empty(1);
echo empty(0.0);
?>
```



###### preg_match

正则表达式匹配。参数为`$pattern,$subject,[$matches(array),[$flags]]`。`$matches[0]`包含于整个模式匹配的文本，`$matches[1]`包含第一个括号的子模式匹配文本。相当于返回的数组。

正则表达式文本格式同json。

如：

```php
if (!preg_match("/^[a-zA-Z ]*$/",$name)) {
  $nameErr = "只允许字母和空格"; 
}
```

常用正则：

- 邮箱 `/([\w\-]+\@[\w\-]+\.[\w\-]+)/`

  `/^\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/`
- URL `/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&@#\/%?=~_|!:,.;]*[-a-z0-9+&@#\/%=~_|]/`



###### explode

字符串分割，第一个参数是分割符，第二个参数是字符串变量。可选第三个参数表示结果数组元素限制最大数。



###### strpos

即find，第一个参数是被查找串，第二个参数是要查找的子串。大小写敏感。失败返回false。

大小写不敏感用`stripos`，倒找用`strrpos,strripos`。



##### 日期时间

###### date

> [时间日期参考手册](https://www.runoob.com/php/func-date-date.html)

第一个参数是字符串输出格式，`Y,m,d`代表年(四位)月($[01,12]$)日($01,31$)，其他字符代表本身的含义。返回字符串。第二个参数是整数时间戳，可缺省。如：

```php
<?php
echo date('Y/m/d H:i:s');
?>
```



> 具体格式有：
>
> | `format` 字符        | 说明                                                         | 返回值例子                                                   |
> | :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
> | *日*                 | ---                                                          | ---                                                          |
> | *d*                  | 月份中的第几天，有前导零的 2 位数字                          | *01* 到 *31*                                                 |
> | *D*                  | 星期中的第几天，文本表示，3 个字母                           | *Mon* 到 *Sun*                                               |
> | *j*                  | 月份中的第几天，没有前导零                                   | *1* 到 *31*                                                  |
> | *l*（"L"的小写字母） | 星期几，完整的文本格式                                       | *Sunday* 到 *Saturday*                                       |
> | *N*                  | ISO-8601 格式数字表示的星期中的第几天（PHP 5.1.0 新加）      | *1*（表示星期一）到 *7*（表示星期天）                        |
> | *S*                  | 每月天数后面的英文后缀，2 个字符                             | *st*，*nd*，*rd* 或者 *th*。可以和 *j* 一起用                |
> | *w*                  | 星期中的第几天，数字表示                                     | *0*（表示星期天）到 *6*（表示星期六）                        |
> | *z*                  | 年份中的第几天                                               | *0* 到 *365*                                                 |
> | *星期*               | ---                                                          | ---                                                          |
> | *W*                  | ISO-8601 格式年份中的第几周，每周从星期一开始（PHP 4.1.0 新加的） | 例如：*42*（当年的第 42 周）                                 |
> | *月*                 | ---                                                          | ---                                                          |
> | *F*                  | 月份，完整的文本格式，例如 January 或者 March                | *January* 到 *December*                                      |
> | *m*                  | 数字表示的月份，有前导零                                     | *01* 到 *12*                                                 |
> | *M*                  | 三个字母缩写表示的月份                                       | *Jan* 到 *Dec*                                               |
> | *n*                  | 数字表示的月份，没有前导零                                   | *1* 到 *12*                                                  |
> | *t*                  | 给定月份所应有的天数                                         | *28* 到 *31*                                                 |
> | *年*                 | ---                                                          | ---                                                          |
> | *L*                  | 是否为闰年                                                   | 如果是闰年为 *1*，否则为 *0*                                 |
> | *o*                  | ISO-8601 格式年份数字。这和 *Y* 的值相同，只除了如果 ISO 的星期数（*W*）属于前一年或下一年，则用那一年。（PHP 5.1.0 新加） | Examples: *1999* or *2003*                                   |
> | *Y*                  | 4 位数字完整表示的年份                                       | 例如：*1999* 或 *2003*                                       |
> | *y*                  | 2 位数字表示的年份                                           | 例如：*99* 或 *03*                                           |
> | *时间*               | ---                                                          | ---                                                          |
> | *a*                  | 小写的上午和下午值                                           | *am* 或 *pm*                                                 |
> | *A*                  | 大写的上午和下午值                                           | *AM* 或 *PM*                                                 |
> | *B*                  | Swatch Internet 标准时                                       | *000* 到 *999*                                               |
> | *g*                  | 小时，12 小时格式，没有前导零                                | *1* 到 *12*                                                  |
> | *G*                  | 小时，24 小时格式，没有前导零                                | *0* 到 *23*                                                  |
> | *h*                  | 小时，12 小时格式，有前导零                                  | *01* 到 *12*                                                 |
> | *H*                  | 小时，24 小时格式，有前导零                                  | *00* 到 *23*                                                 |
> | *i*                  | 有前导零的分钟数                                             | *00* 到 *59*>                                                |
> | *s*                  | 秒数，有前导零                                               | *00* 到 *59*>                                                |
> | *u*                  | 毫秒 （PHP 5.2.2 新加）。需要注意的是 **date()** 函数总是返回 *000000* 因为它只接受 integer 参数， 而 DateTime::format() 才支持毫秒。 | 示例: *654321*                                               |
> | *时区*               | ---                                                          | ---                                                          |
> | *e*                  | 时区标识（PHP 5.1.0 新加）                                   | 例如：*UTC*，*GMT*，*Atlantic/Azores*                        |
> | *I*                  | 是否为夏令时                                                 | 如果是夏令时为 *1*，否则为 *0*                               |
> | *O*                  | 与格林威治时间相差的小时数                                   | 例如：*+0200*                                                |
> | *P*                  | 与格林威治时间（GMT）的差别，小时和分钟之间有冒号分隔（PHP 5.1.3 新加） | 例如：*+02:00*                                               |
> | *T*                  | 本机所在的时区                                               | 例如：*EST*，*MDT*（【译者注】在 Windows 下为完整文本格式，例如"Eastern Standard Time"，中文版会显示"中国标准时间"）。 |
> | *Z*                  | 时差偏移量的秒数。UTC 西边的时区偏移量总是负的，UTC 东边的时区偏移量总是正的。 | *-43200* 到 *43200*                                          |
> | *完整的日期／时间*   | ---                                                          | ---                                                          |
> | *c*                  | ISO 8601 格式的日期（PHP 5 新加）                            | 2004-02-12T15:19:21+00:00                                    |
> | *r*                  | RFC 822 格式的日期                                           | 例如：*Thu, 21 Dec 2000 16:01:07 +0200*                      |
> | *U*                  | 从 Unix 纪元（January 1 1970 00:00:00 GMT）开始至今的秒数    | 参见 time()                                                  |



##### JSON

###### json_encode

对传入变量进行JSON编码。成功返回数据，否则false。

> 有可选参数：由以下常量组成的二进制掩码 JSON_HEX_QUOT, JSON_HEX_TAG, JSON_HEX_AMP, JSON_HEX_APOS, JSON_NUMERIC_CHECK, JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES, JSON_FORCE_OBJECT, JSON_PRESERVE_ZERO_FRACTION, JSON_UNESCAPED_UNICODE, JSON_PARTIAL_OUTPUT_ON_ERROR。
>
>  JSON_UNESCAPED_UNICODE 选项跳过中文编码

如：

```php
<?php
   $arr = array('a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5);
   echo json_encode($arr);
?>
```



###### json_decode

解码并转化为php变量。

`mixed json_decode ($json_string [,$assoc = false [, $depth = 512 [, $options = 0 ]]])`

- **json_string**: 待解码的 JSON 字符串，必须是 UTF-8 编码数据
- **assoc**: 当该参数为 TRUE 时，将返回数组，FALSE 时返回对象。
- **depth**: 整数类型的参数，它指定递归深度
- **options**: 二进制掩码，目前只支持 JSON_BIGINT_AS_STRING 。



##### 流程控制

###### exit

`exit($msg)`。`die`的别名。输出一条消息并结束执行当前脚本`.php`文件。

###### exec

执行本地指令，如 `exec('python test.py')`。

也可以用 `shell_exec`



##### 文件操作

###### file_exists

文件或目录是否存在

###### move_uploaded_file

将上传的文件(参数1)移动到新位置(参数2)。若成功，则返回 true，否则返回 false。参数1一般是`$_FILES[表单控件name属性]["tmp_name"]`

> 如果目标文件已经存在，将会被覆盖



##### 配置控制

###### ini_set

修改配置文件，如显示报错：

```php
ini_set('display_errors',1);
```



##### cookie

```php
setcookie($key, $value);
echo $_COOKIE[$key];
```



##### session

```php
session_start();
$_SESSION['views']=1;
echo "浏览量：". $_SESSION['views'];
if(isset($_SESSION['views']))
{
    unset($_SESSION['views']);
}
session_destroy(); //重置 session，失去所有已存储的 session 数据
```





### 输入输出

#### 标准输出

##### echo

一次输出一个或多个字符串，多个用逗号隔开，输出时等效于echo多次，不会有分割符，无返回值

可以用echo或echo()，即关键字语法或函数语法

输出效果同js的document.write，所以可以用标签，甚至可以直接在字符串里输出变量：

```php
<?php
echo "<h1>这是","一个标题</h1>";
echo 1e9+7,PHP_EOL,"1"+'234'; //注意字符输出235
echo(1/3); //很多位
//注意加了括号就只能有一个参数了
// echo "s"+"y"; 没有字符串+运算符
?>
```

```php
<?php $x="lr580";echo "I am $x";?> //注意php和$x之间有空格
```

一般而言用`'<br/>'`代表换行。

实现特定秒后自动跳转：[参考](https://blog.csdn.net/qq_36527174/article/details/111574534) (下文例子3秒)

```php
echo "<meta http-equiv='refresh' content ='3;url=index.html'>";
```





##### print

一次输出一个字符串，返回值为1，比echo慢。用法语法完全同echo。



##### print_r

打印变量，以更容易理解的形式展示。常用于输出一个数组。



##### var_dump



##### var_export

`var_export` 可以将一个数组转为一个字符串不同于`var_dump` , `var_export` 并不会输出数据的类型以及字符大小等,只会简单把数组的key跟value拼接成一个字符串



##### 常量

PHP_EOL 换行符



#### 表单I/O

##### POST

默认情况下，POST 方法的发送信息的量最大值为 8 MB（可通过设置 php.ini 文件中的 post_max_size 进行更改）。

在前端，提交的`post`表单，提交后跳转到其`action`指向的网页，并传入提交信息。用`$_POST[键]`即可得到这些信息，如：

```html
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>
 
<form action="welcome.php" method="post">
名字: <input type="text" name="fname">
年龄: <input type="text" name="age">
<input type="submit" value="提交">
</form>
 
</body>
</html>
```

```php
欢迎<?php echo $_POST["fname"]; ?>!<br>
你的年龄是 <?php echo $_POST["age"]; ?>  岁。
```

对自己搭的服务器，可能需要配置：

```php
header("Access-Control-Allow-Origin:*");
header("Access-Control-Allow-Methods:GET,POST");
```



##### GET

HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的

如：

```HTML
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>

<form action="welcome.php" method="get">
名字: <input type="text" name="fname">
年龄: <input type="text" name="age">
<input type="submit" value="提交">
</form>

</body>
</html>
```

```php+HTML
欢迎 <?php echo $_GET["fname"]; ?>!<br>
你的年龄是 <?php echo $_GET["age"]; ?>  岁。
```



##### 表单控件

###### 下拉菜单

可以通过后端`.php`代码创建下拉菜单。单选举例：表单使用 GET 方式获取数据，action 属性值为空表示提交到当前脚本，我们可以通过 select 的 name 属性获取下拉菜单的值。

```php+HTML
<?php //按下提交后 if $q部分显示
$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';
if($q) {
        if($q =='RUNOOB') {
                echo '菜鸟教程<br>http://www.runoob.com';
        } else if($q =='GOOGLE') {
                echo 'Google 搜索<br>http://www.google.com';
        } else if($q =='TAOBAO') {
                echo '淘宝<br>http://www.taobao.com';
        }
} else { //按下提交前下面部分显示
?>
<form action="" method="get"> 
    <select name="q">
    <option value="">选择一个站点:</option>
    <option value="RUNOOB">Runoob</option>
    <option value="GOOGLE">Google</option>
    <option value="TAOBAO">Taobao</option>
    </select>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```

多选举例：

```php+HTML
<?php
$q = isset($_POST['q'])? $_POST['q'] : '';
if(is_array($q)) {
    $sites = array(
            'RUNOOB' => '菜鸟教程: http://www.runoob.com',
            'GOOGLE' => 'Google 搜索: http://www.google.com',
            'TAOBAO' => '淘宝: http://www.taobao.com',
    );
    foreach($q as $val) {
        // PHP_EOL 为常量，用于换行
        echo $sites[$val] . PHP_EOL;
    }
      
} else {
?>
<form action="" method="post"> 
    <select multiple="multiple" name="q[]">
    <option value="">选择一个站点:</option>
    <option value="RUNOOB">Runoob</option>
    <option value="GOOGLE">Google</option>
    <option value="TAOBAO">Taobao</option>
    </select>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



###### 单选按钮

```php+HTML
<?php
$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';
if($q) {
        if($q =='RUNOOB') {
                echo '菜鸟教程<br>http://www.runoob.com';
        } else if($q =='GOOGLE') {
                echo 'Google 搜索<br>http://www.google.com';
        } else if($q =='TAOBAO') {
                echo '淘宝<br>http://www.taobao.com';
        }
} else {
?><form action="" method="get"> 
    <input type="radio" name="q" value="RUNOOB" />Runoob
    <input type="radio" name="q" value="GOOGLE" />Google
    <input type="radio" name="q" value="TAOBAO" />Taobao
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



###### 复选框

```php+HTML
<?php
$q = isset($_POST['q'])? $_POST['q'] : '';
if(is_array($q)) {
    $sites = array(
            'RUNOOB' => '菜鸟教程: http://www.runoob.com',
            'GOOGLE' => 'Google 搜索: http://www.google.com',
            'TAOBAO' => '淘宝: http://www.taobao.com',
    );
    foreach($q as $val) {
        // PHP_EOL 为常量，用于换行
        echo $sites[$val] . PHP_EOL;
    }
      
} else {
?><form action="" method="post"> 
    <input type="checkbox" name="q[]" value="RUNOOB"> Runoob<br> 
    <input type="checkbox" name="q[]" value="GOOGLE"> Google<br> 
    <input type="checkbox" name="q[]" value="TAOBAO"> Taobao<br>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



##### 表单检验

> 当黑客使用跨网站脚本的HTTP链接来攻击时，$_SERVER["PHP_SELF"]服务器变量也会被植入脚本，所以下面两段代码中不安全：
>
> ```php+HTML
> <form method="post" action="<?php echo $_SERVER["PHP_SELF"];?>">
> ```
>
> ```php+HTML
> <form method="post" action="test_form.php">
> ```
>
> 对于下面的代码，网址为`http://www.runoob.com/test_form.php/%22%3E%3Cscript%3Ealert('hacked')%3C/script%3E`时，解析为：
>
> ```html
> <form method="post" action="test_form.php/"><script>alert('hacked')</script>
> ```
>
> 因此，用`htmlspecialchars()`来避免攻击：
>
> ```php+HTML
> <form method="post" action="<?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?>">
> ```
>
> 此外可以用`trim()`函数去除空白字符。

一般而言，综上所述，使用三件套自定义函数：

```php
function test_input($data) {
  $data = trim($data);
  $data = stripslashes($data);
  $data = htmlspecialchars($data);
  return $data;
}
```

检验空的代码示例：

```php+HTML
<form method="post" action="<?php echo htmlspecialchars($_SERVER['PHP_SELF']);?>"> 
   名字: <input type="text" name="name">
   <span class="error">* <?php echo $nameErr;?></span>
   <input type="submit" name="submit" value="Submit"> 
</form>
```

```php
<?php
// 定义变量并默认设为空值
$nameErr = "";
$name = "";

if ($_SERVER["REQUEST_METHOD"] == "POST") {
  if (empty($_POST["name"])) {
    $nameErr = "名字是必需的。";
  } else {
    $name = test_input($_POST["name"]);
  }
}
?>
```



#### 文件I/O

##### 读写

使用`fopen(路径,模式)`。打开失败返回$0$(false)，否则返回文件流。

记得关闭`fclose($文件流)`。

模式有：

| 模式 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| r    | 只读。在文件的开头开始。                                     |
| r+   | 读/写。在文件的开头开始。                                    |
| w    | 只写。打开并清空文件的内容；如果文件不存在，则创建新文件。   |
| w+   | 读/写。打开并清空文件的内容；如果文件不存在，则创建新文件。  |
| a    | 追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。 |
| a+   | 读/追加。通过向文件末尾写内容，来保持文件内容。              |
| x    | 只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。  |
| x+   | 读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 |

如：

```php
<?php
$file=fopen("welcome.txt","r") or exit("Unable to open file!");
?>
```

有`feof($file)`。

逐行读取用`fgets($file)`。

逐字符用`fgetc`

> [更多请参考这里](https://www.runoob.com/php/php-ref-filesystem.html)



##### 上传

用户上传文件到服务器，前端脚本示例：

```html
<form action="upload_file.php" method="post" enctype="multipart/form-data">
    <label for="file">文件名：</label>
    <input type="file" name="file" id="file"><br>
    <input type="submit" name="submit" value="提交">
</form>
```

上传后，全局变量`$_FILES`可以看到文件。一维键是表单的`input`的`name`，二维键可以是：

- `$_FILES["file"]["name"]` - 上传文件的名称

- `$_FILES["file"]["type"] `- 上传文件的类型

  如：`"image/gif"`

- `$_FILES["file"]["size"]` - 上传文件的大小，以字节计

- `$_FILES["file"]["tmp_name"]` - 存储在服务器的文件的临时副本的名称

- `$_FILES["file"]["error"]` - 由文件上传导致的错误代码

要保存上传的文件，需要拷贝到另外的位置。不然脚本结束就会消失。



如：

```php
<?php
// 允许上传的图片后缀
$allowedExts = array("gif", "jpeg", "jpg", "png");
$temp = explode(".", $_FILES["file"]["name"]);
echo $_FILES["file"]["size"];
$extension = end($temp);     // 获取文件后缀名
if ((($_FILES["file"]["type"] == "image/gif")
|| ($_FILES["file"]["type"] == "image/jpeg")
|| ($_FILES["file"]["type"] == "image/jpg")
|| ($_FILES["file"]["type"] == "image/pjpeg")
|| ($_FILES["file"]["type"] == "image/x-png")
|| ($_FILES["file"]["type"] == "image/png"))
&& ($_FILES["file"]["size"] < 204800)   // 小于 200 kb
&& in_array($extension, $allowedExts))
{
    if ($_FILES["file"]["error"] > 0)
    {
        echo "错误：: " . $_FILES["file"]["error"] . "<br>";
    }
    else
    {
        echo "上传文件名: " . $_FILES["file"]["name"] . "<br>";
        echo "文件类型: " . $_FILES["file"]["type"] . "<br>";
        echo "文件大小: " . ($_FILES["file"]["size"] / 1024) . " kB<br>";
        echo "文件临时存储的位置: " . $_FILES["file"]["tmp_name"] . "<br>";
        
        // 判断当前目录下的 upload 目录是否存在该文件
        // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777
        if (file_exists("upload/" . $_FILES["file"]["name"]))
        {
            echo $_FILES["file"]["name"] . " 文件已经存在。 ";
        }
        else
        {
            // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下
            move_uploaded_file($_FILES["file"]["tmp_name"], "upload/" . $_FILES["file"]["name"]);
            echo "文件存储在: " . "upload/" . $_FILES["file"]["name"];
        }
    }
}
else
{
    echo "非法的文件格式";
}
?>
```



#### 邮件

mail() 函数用于从脚本中发送电子邮件。数需要一个已安装且正在运行的邮件系统(如：sendmail、postfix、qmail等)。所用的程序通过在 php.ini 文件中的配置设置进行定义。

> [请参见这里](https://www.runoob.com/php/php-mail.html) 下一节还有防止`E-mail`注入的例子



## 功能

### MySQL

#### mysqli

##### 链接

链接到数据库：

`mysqli_connect(host, username, password, dbname,port, socket);`

| 参数       | 描述                                        |
| :--------- | :------------------------------------------ |
| *host*     | 可选。规定主机名或 IP 地址。                |
| *username* | 可选。规定 MySQL 用户名。                   |
| *password* | 可选。规定 MySQL 密码。                     |
| *dbname*   | 可选。规定默认使用的数据库。                |
| *port*     | 可选。规定尝试连接到 MySQL 服务器的端口号。 |
| *socket*   | 可选。规定 socket 或要使用的已命名 pipe。   |

成功链接到 MySQL 后返回连接标识，失败返回 FALSE 。

断开链接：

`bool mysqli_close ( mysqli $link )`

关闭指定的连接标识所关联的到 MySQL 服务器的非持久连接。如果没有指定 link_identifier，则关闭上一个打开的连接。

通常不需要使用 `mysqli_close()`，因为已打开的非持久连接会在脚本执行完毕后自动关闭。

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
    die('Could not connect: ' . mysqli_error());
}
echo '数据库连接成功！';
mysqli_close($conn);
?>
```



##### 报错输出

`mysqli_error(connection)`，返回字符串



##### 语句执行

mysqli_query 函数来创建或者删除 MySQL 数据库。

该函数有两个参数，在执行成功时返回 TRUE，否则返回 FALSE。

`mysqli_query(connection,query,resultmode);`

| 参数         | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| *connection* | 必需。规定要使用的 MySQL 连接。                              |
| *query*      | 必需，规定查询字符串。                                       |
| *resultmode* | 可选。一个常量。可以是下列值中的任意一个：MYSQLI_USE_RESULT（如果需要检索大量数据，请使用这个）MYSQLI_STORE_RESULT（默认） |

可以执行的指令有：

- 数据库创建、删除
- 数据表创建、删除、查询
- 数据插入

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die('连接错误: ' . mysqli_error($conn));
}
echo '连接成功<br />';
$sql = 'CREATE DATABASE RUNOOB';
$retval = mysqli_query($conn,$sql );
if(! $retval )
{
    die('创建数据库失败: ' . mysqli_error($conn));
}
echo "数据库 RUNOOB 创建成功\n";
mysqli_close($conn);
?>
```

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die('连接失败: ' . mysqli_error($conn));
}
echo '连接成功<br />';
// 设置编码，防止中文乱码
mysqli_query($conn , "set names utf8");
 
$runoob_title = '学习 Python';
$runoob_author = 'RUNOOB.COM';
$submission_date = '2016-03-06';
 
$sql = "INSERT INTO runoob_tbl ".
        "(runoob_title,runoob_author, submission_date) ".
        "VALUES ".
        "('$runoob_title','$runoob_author','$submission_date')";
 
 
mysqli_select_db( $conn, 'RUNOOB' );
$retval = mysqli_query( $conn, $sql );
if(! $retval )
{
  die('无法插入数据: ' . mysqli_error($conn));
}
echo "数据插入成功\n";
mysqli_close($conn);
?>
```





##### 数据库选择

`mysqli_select_db(connection,dbname);`

即等效于`use`。

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
    die('连接失败: ' . mysqli_error($conn));
}
echo '连接成功';
mysqli_select_db($conn, 'RUNOOB' );
mysqli_close($conn);
?>
```



##### 数据查询

首先用`mysqli_query`取`mysql`查询语句的返回值，然后用：

`mysqli_fetch_array(connection, 返回值)`获得所有查询的数据。

从结果集中取得一行作为关联数组，或数字数组，或二者兼有 返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。

可以设置第二个参数为`MYSQLI_ASSOC`，将返回列名作为数组索引。



#### 对象式mysqli

#### 例子

##### 注册登录1

###### conn.php

```php
<?php //conn.php
header("Access-Control-Allow-Origin:*");
header("Access-Control-Allow-Methods:GET,POST");
function salt($str){
    return md5($str.'QwQ'.$str);
}
function getCode($id,$secret){
    return salt($id.$secret);
}
$dbname='cv';
$dbuser='l';
$dbpsw='1';
// if(!$conn) {
//     return;
// }
$conn = new mysqli('localhost', $dbuser, $dbpsw, $dbname);
if($conn->connect_error) {
    die('Could not connect: ' . $conn->connect_error);
}
```

###### register.php

```php
<?php //register.php
include "conn.php";
// $name = json_encode($_POST['name']);
// $password = json_encode($_POST['password']);
$name = $_POST['name'];
$password = $_POST['password'];
if (!strlen($name)){
    echo json_encode(array('state'=>'用户名为空'));
    return;
}
if (!strlen($password)){
    echo json_encode(array('state'=>'密码为空'));
    return;
}
$password=salt($password);
// $result = $conn->query("select * from `user` where id="); #不防SQL注入
$stmt = $conn->prepare("select * from `user` where name=?");
$stmt->bind_param('s',$name);
$stmt->execute();
$result = $stmt->get_result();
// if(!$result){
//     echo json_encode(array('state'=>'用户已存在'));
//     return;
// }
if($row=$result->fetch_assoc()){
    echo json_encode(array('state'=>'用户已存在'));
    return;
}
$stmt->close();

$stmt2 = $conn->prepare('insert into `user` (name, secret) values (?,?)');
$stmt2->bind_param('ss',$name,$password);
$stmt2->execute();
$stmt2->close();

$stmt3 = $conn->prepare('select id from `user` where name=?');
$stmt3->bind_param('s',$name);
$stmt3->execute();
$result = $stmt3->get_result();
$row=$result->fetch_assoc();
$id=$row['id'];
$stmt3->close();

echo json_encode(array('state'=>'ok','code'=>getCode($id,$password)));

// echo json_encode(array('state'=>'ok'));
// echo array('state'=>'ok');
```

###### login.php

```php
<?php
include "conn.php";
$name = $_POST['name'];
$password = $_POST['password'];
if (!strlen($name)){
    echo json_encode(array('state'=>'用户名为空'));
    return;
}
if (!strlen($password)){
    echo json_encode(array('state'=>'密码为空'));
    return;
}
$password=salt($password);

$stmt4 = $conn->prepare("select * from `user` where name=? and secret=?");
ini_set('display_errors',1);
$stmt4->bind_param('ss',$name,$password);
$stmt4->execute();
$result = $stmt4->get_result();
$row=$result->fetch_assoc();

if(!$row){
    echo json_encode(array('state'=>'用户或密码不正确'));
    return;
}
$stmt4->close();

$id=$row['id'];
echo json_encode(array('state'=>'ok','code'=>getCode($id,$password)));

/*
error_reporting(E_ALL);
function f(){
    $_error = error_get_last();
    if ($_error && in_array($_error['type'], array(1, 4, 16, 64, 256, 4096, E_ALL))) {
              header("Content-Type: text/html; charset=utf-8");
              echo '<font color=red>代码出错：</font></br>';
              echo '致命错误:' . $_error['message'] . '</br>';
              echo '文件:' . $_error['file'] . '</br>';
              echo '在第' . $_error['line'] . '行</br>';
    }
}
register_shutdown_function(f);
*/
```

###### index.php

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="jqueryc.js"></script>
  <script>
    function register(){
      let name = $('[name="name"]').val();
      let password = $('[name="password"]').val();
      $.post("register.php",{
        name:name,
        password:password,
      },function(res){
        let obj = JSON.parse(res);
        $('#board').html(obj.state + " " + obj.code);
      });
    }
    function login(){
      let name = $('[name="name"]').val();
      let password = $('[name="password"]').val();
      $.post("login.php",{
        name:name,
        password:password,
      },function(res){
        alert(res);
        let obj = JSON.parse(res);
        $('#board').html(obj.state + " " + obj.code);
      });
    }
  </script>
</head>
<body>
  <h1 align="center">这是一个服务器主页</h1>
  <h4 align="right">--powered by lr580</h4>
  <form>
    用户名：<input type="text" name="name">
    密码：<input type="text" name="password">
    <input type="button" value="注册" onclick="register();">
    <input type="button" value="登录" onclick="login();">
  </form>
  <div id="board"></div>
</body>
</html>
```





## 框架

### ThinkPHP

#### 安装和配置

##### 初始化

环境要求

- PHP 版本在 5.4.0 或以上

- 配置里开启(有 `;` 开头注释的删掉注释符号 `;` ，没有就加)

  ```ini
  extension=php_pdo_mysql.dll
  extension=php_mbstring.dll
  extension=php_curl.dll
  
  [mbstring]
  mbstring.language = Chinese
  mbstring.internal_encoding = UTF-8
  mbstring.encoding_translation = On
  mbstring.http_input = UTF-8
  mbstring.http_output = UTF-8
  mbstring.detect_order = UTF-8
  mbstring.substitute_character = none
  ```

免安装， [官网](http://www.thinkphp.cn/down.html) 下载 ，如 `thinkphp_5.0.24_full` 

将 `tp5` 文件夹复制到 `AppServ/www` ，调试输入：`http://localhost:88/tp5/public/` ，预期能访问到一个主页



##### 配置

显然当前根目录是 `AppServ/www/` 代表 `/`

5.0 版本自带入口文件在 `public/index.php` 

该文件定义了应用目录 APP_PATH 和加载 ThinkPHP 框架的入口文件

显然根据内含代码可以发现该 `index.php` 的源代码位于 `application/index/controller/index.php`



开启调试模式：在 `application/config.php` ，改 `app_debug` 。调试模式在异常的时候可以显示尽可能多的信息，所以对性能有一定的影响



##### 项目新建

将 `tp5` 文件夹复制到自己的项目里，作为基础

可以根目录新建一个 `index.php` 并输入：

```c++
<?php
define('APP_PATH',    __DIR__ . '/application/');
require     __DIR__ . '/thinkphp/start.php';
?>
```



> 可以在根目录下 cmd 输入命令新建样例模块：
>
> ```shell
> php think build --module 模块名
> ```



##### 数据库配置

在 `application/database.php` ，按照提示设置数据库连接即可。

取消 `Db::table` 警告，在 vscode 设置输入 `intelephense languageConstraints` ，取消勾选即可。

如果使用了多个模块且每个模块都用不同的数据库连接，那么每个模块下面单独配置，如： `application/模块名/database.php` ，可以自己新建，如：

```php
return [ 
 	// 服务器地址
	'hostname'  => '192.168.190.129',
 	// 数据库名
    'database'  => 'testdb',
 ];
```





#### 基本概念

##### 目录结构

![image-20220424155126332](img/image-20220424155126332.png)

![image-20220424155136373](img/image-20220424155136373.png)

![image-20220424155142376](img/image-20220424155142376.png)

在根目录下用命令行输出指令，生成展示模块 `demo` ：

```shell
php think build --module demo
```



##### 模块



##### 控制器

关系：一个模块有多个控制器，一个控制器有多个方法

命名规范：驼峰命名法(首字母大写)，调用时每个单词转化为 `_` 间隔

新建一个名为 `Index` 的控制器(命名不能出现大小写 `controller`)，放在 `application/模块名/controller/控制器名.php` ，格式：

```php
<?php
namespace app\index\controller;
class Index
{
    public function index()
    {
        return 'Hello World!';
    }
}
```

控制器可以继承。方法可以定义参数。参数相当于URL参数，如：

```php
<?php
namespace app\index\controller;
class Index
{
    public function index($name='World!'){
        	return	'Hello ' . $name;
    }
}
```

然后根据 `index.php?name=输入的东西` 不同，就等于传入不同的 `$name` 

只有 public 类型的方法才是可以通过URL访问的。要调用哪个方法，就直接 HTML 里打这个方法名，如：

>  `index.php/index/index/hello`  (假设在上述代码定义了这个函数)
> 表示 `Index` 模块的 `index` 控制类的 `hello` 方法
>
> `http://localhost:88/tp5/?name=baicha`



##### 视图

在 `application/模块名` 创建目录 `view` ，尝试添加一个与控制类名字相同的目录名，然后在目录里添加一个 `html` 文件，随便写点内容，如果有变量，用 `{$变量名}` 表示占位。如在 `application/index/hello.html` ：

```html
<div>Ohh, it's {$visitor}</div>
```

使用控制器渲染变量，需要继承 `Controller` 类，如：

```php
<?php
namespace app\index\controller;
use think\Controller;
class Index extends Controller{
    public function hello($name = 'lr580')    {
        $this->assign('visitor', $name);
        return $this->fetch();
    }
}

```

然后打开网页，如：`http://localhost:88/tp5/index.php/index/index/hello?name=QwQ`



如果写成 `return view();` 也行，同理地只需要保证确实有这一个视图即可，区别在于没有参数。



#### 基本语法

##### 控制器

###### 报错输出

```php
$this->error(错误信息str);
```

遇到后弹窗(URL后面的html变成了当前方法名.html)，有自带样式，默认3秒后回到原页面。可以用全称 url ，以导向其他网站，如 oi-wiki 。

```php
if(empty(session('email'))){
       $this->error('请先登录!','index/login/login');
}
```

###### 成功回显

```php
$this->success('注册成功, 跳转到主页', url('index/index'));
```

没有第二个参数就本来在哪回到哪里

###### 重定向

是助手函数，不需要引入就能用。 

```php
$this->redirect(url('index/index'));
```

```php
$this->redirect('index/index');
```

默认使用 302 跳转，可以传第二个参数输入 301 。



##### 视图

###### Controller类

> 可以通过继承Controller类的方式来创建视图类，在新版本中，控制器类可以无需继承Controller类，此时需要自己实例化视图类

对 Contoller 类，可以调用方法：

- `fetch` 渲染html模板输出。如果带参数，参数名就是放在 `view` 文件夹里的 html 名(不带后缀)，不带参数就以当前函数名作为参数。

- `display` 直接输出 HTML 文本，等效于直接 return 。即如：

  ```php+HTML
  return "<h1>QwQ $name</h1>";
  return $this->display("<h1>QwQ $name</h1>");
  ```

- `assign` ，第一个参数是 key ，第二个是 value ，渲染一个变量





助手函数： `view([模板文件],[模板变量],[模板替换])` ，不管继承不继承都可以用。如：`view();view("hello");view("userview/hello")` ，最后一个是同一模块下另一个文件夹内的模板。不带参数就是以自己为参数。

对模板变量，用 `[key=>val]` 形式。

对模板替换，把模板文件内任意(可不在`{}`)key字符串替换为value。



###### PHP语法

在视图代码里，语法用 `{}` 括起来，有：

- PHP变量的常规调用 (直接嵌HTML里进行文本乃至URL拼接都行)

- `foreach $数组变量 as $迭代变量` 开头和 `/foreach` 结尾，如：

  ```php+HTML
  {foreach $result as $flower}
  <table><tr><td>{$flower.fname}</td></tr></table>
  {/foreach}
  ```

- `if condition=""` ， `else`  ， `/if` ，运算符可以是 `eq` 等，如：

  ```php+HTML
  {if condition="$Think.session.email eq ''"}
  <a href="{:url('login/login')}" style="font-size:x-small;text-decoration:none;">登录</a>&nbsp;&nbsp; 
  {else}
  <a href="{:url('login/logOut')}" style="font-size:x-small;text-decoration:none;">退出</a>&nbsp;&nbsp; 
  {/if}
  ```

- `:url('控制器名/方法名')` 超链接(也可以再加一个前缀 `模块名/` ) ，(不区分大小写)，如：

  ```html
  <a href="{:url('order/showorder')}" > QwQ </a>
  ```

- `include file="路径"/` 导入一个HTML (import功能)，如：

  ```php
  {include file="./public/common/top.html"/}
  ```
  
- `volist name="数组名" id="迭代变量名"` `/volist` ，像 Python 的 for，如：

   ```php+HTML
   {volist name="result" id="cart"}
   	<td>{$cart.flowerID}</td>
   {/volist}
   ```

  

其他，如 `__ROOT__` 全局变量。更多系统变量参见 [这里](https://www.kancloud.cn/manual/thinkphp5/125004)

支持输出 `$_SERVER`、`$_ENV`、 `$_POST`、 `$_GET`、 `$_REQUEST`、`$_SESSION`和 `$_COOKIE`变量。

![image-20220517160535460](img/image-20220517160535460.png)

![image-20220517160549072](img/image-20220517160549072.png)



###### 内置标签

普通标签用 `{}` 括起来，中间有空格或者换行则被视为**非模板标签**直接输出。还有可以是 `{ /}` 或 `{}  {/   }` 。

可以在配置参数修改定界符，默认就是上文的 `{}` 。如：

```php
'template'  => [
    // 模板引擎
    'type'   => 'think',
    // 普通标签开始标记 
    'tpl_begin' =>    '{',
    // 普通标签结束标记
    'tpl_end'   =>    '}'        
],
```

标签里可以直接塞一个变量，或它的属性，如 `{$x}, {$x.name}` 



###### 数组遍历

可以用 volist 标签实现循环输出数组。该标签的属性 name 接变量名， id 接遍历时作为遍历变量名， offset 是起始下标， length 是遍历次数， empty 是为空输出。如：

```html
{volist name="result" id="flower" offset="5" length="10" empty="无数据"}
	{$flower.flowerID}:{$flower.fname}
{/volist}
```

可以套子标签 eq ，属性 name 是操作名，对下标运算， value 是比较值。比如换行：

```html
{volist name="result" id="vo" mod="5" }
{$vo.name}
{eq name="mod" value="4"}<br/>{/eq}
{/volist}
```

注意 id 是一个变量，即可以 `{$id名}` 。缺省为 `i` 。



foreach 类似，但是只有 name, item, key(默认为 key) 。也是普通遍历。如

```html
{foreach name="result" item="flower" key="k"}
{$k}|{$flower.id}:{$flower.name}
{/foreach}
```



for：

```html
{for start="开始值" end="结束值" comparison="" step="步进值" name="循环变量名"}{/for}
```

name 默认是 i ，步进默认是 1。会写解析为 for PHP语句。



###### 选择判断

switch 标签，可以接属性 name 代表选择值。内置标签 case 有属性 value ，有 default 标签。

```php+HTML
{switch name="$admin.level"}
    {case value="1"}admin{/case}
    {case value="2"}user{/case}
    {default /}default
{/switch}
```

case 可以设置 break 属性为 0，使得逻辑跟 C++ 的 switch 一样：

```php+HTML
{foreach $result as $admin}
{switch name="$admin.level"}
    {case value="1" break="0"}admin{/case}
    {case value="2"}user{/case}
    {default /}default
{/switch}
{/foreach}
```

name 可以使用函数、系统变量、参数，如 get 的一个属性： `Think.get.userId` ，传入靠 `?userId=xxx` 

value 属性可以用 `|` 分割，如：

```php+HTML
{switch name="Think.get.type"}
    {case value="gif|png|jpg"}图像格式{/case}
    {default /}其他格式
{/switch}
```



可以用 if ，有属性名 condition 接表达式。有内嵌配套的 elseif 和  else 如：

```php+HTML
{foreach $result as $admin}
{if condition="$admin.level eq 1"}
    <h2>admin</h2>
{elseif condition="($admin.level == 2) or ($admin.level>10)"/}
    <h2>user</h2>
{else/}
	<h2>default</h2>   
{/if}
{/foreach}
```

可以用 php 代码在 condition 里：

```php+HTML
{if condition="strtoupper($user['name']) eq 'THINKPHP5'"}
<h2>ThinkPHP5</h2>
{else /} 
<h2>other Framework</h2>
{/if}
```

三者等效：

```php+HTML
{if condition="表达式"}
{if (表达式)}
{if 表达式}
```



###### 比较标签

标签名可以是 `eq` , `equal` , `neq` , `notequal` , `gt` , `egt` ( $\ge$ ) , `lt` , `elt` , `heq` (恒等于) , `nheq` 。用法参数跟 eq 基本一样，如：

```php+HTML
{eq name="name" value="value"}value{/eq}
```

也可以用内嵌 else ，如：

```php+HTML
{eq name="name" value="value"}
相等
{else/}
不相等
{/eq}
```

用函数：

```php+HTML
{eq name="$user['name']|strlen" value='9'}
    <h2>长度=9</h2>
{/eq}
```

用变量：

```php+HTML
{eq name="$user.name" value="$a"}{$user.name}{/eq}
```

用统一标签，用 type 指明类型：

```php+HTML
{compare name="name" value="5" type="eq"}value{/compare}
```



范围判断用标签： `in` , `notin` , `between` , `notbetween` ，如：

```php+HTML
{in name="id" value="1,2,3"}
id在范围内
{/in}
```

对 between ，可以是整数、字符等。

```php+HTML
{between name="id" value="A,Z"} <!--或如 "1,5"-->
输出内容1
{/between}
```

可以用 range 标签统一，如：

```php+HTML
{range name="id" value="1,2,3" type="in"}
输出内容1
{/range}
```



present , `notpresent` 接属性 name ，判定某个变量是否已经定义。

empty, `notepmty` 判断是否为空。

```php+HTML
{empty name="Think.get.name"}
$_GET['name']为空值
{/empty}
```



##### Session

[参考](https://blog.csdn.net/qq_37675827/article/details/77978396)

```php
use think\Session;
```

如：

```php
$rs = Session::get('email')
```



当然也可以暴力用原生的，即 `session('email')`



##### 表单

> 貌似是基本语法，而不是ThinkPHP语法

###### 数据获取

在控制器方法里使用，如：

```php
input('post.email') //对应post的form表单，name=email的表单项
```

###### 数据存储

如：

```php
session('email', $rs['email']);
```



##### 数据库

###### 动态连接

可以不事先配置，而是动态定义，，使用 `Db::connect` 然后一个数组参数(跟配置一样)，如：

```php
Db::connect([
    // 数据库类型
    'type'        => 'mysql',
    // 数据库连接DSN配置
    'dsn'         => '',
    // 服务器地址
    'hostname'    => '127.0.0.1',
    // 数据库名
    'database'    => 'thinkphp',
    // 数据库用户名
    'username'    => 'root',
    // 数据库密码
    'password'    => '',
    // 数据库连接端口
    'hostport'    => '',
    // 数据库连接参数
    'params'      => [],
    // 数据库编码默认采用utf8
    'charset'     => 'utf8',
    // 数据库表前缀
    'prefix'      => 'think_',
]);
```

也可以使用字符串，URL形式，`数据库类型://用户名:密码@数据库地址:数据库端口/数据库名#字符集`，  如：

```php
Db::connect('mysql://root:123456@localhost:3306/flower#utf8');
```

返回一个变量，用这个变量不断调用数据库函数即可实现数据库功能 



###### 基础

在配置好数据库的基础上，在控制器方法，进行读取，例如：

```php
use think\Db;
//...
Db::name(名字str)->find(); //返回读取单行数据
Db::table(名字str)->select(); //读取多行数据
->order(关键字str,'desc') //排序，在table后接
```

name 与 table 的区别在于，若配置项有 `prefix` ， name ， db() 会加上前缀， table 不会

find 找单行，不存在返回 null ； select 找数据集，不存在返回空数组。

value 只返回某一列(属性)，找单次，找不到 null ； column 返回某一列值，找不到返回空数组

可以加 distinct(true) 来去重

可以加 order 来排序

> 综合示例：`->distinct(true)->field('value')->select()`

> ```php
> $data=Db::table('think_user')->where('id',1)->value('name');
> // 返回数组
> $data=Db::table('think_user')->where('name','like','%thinkphp')->column('name');
> // 指定索引
> $data=Db::table('think_user')->where('name','like','%thinkphp')->column('name','id');
> ```

> ```php
> public function index()
> {
>     $fclass = Db::table('flower')->distinct('true')->field('fclass')->select();
>     $this->assign('fclasses', $fclass);
>     $fname = input('post.fname');
>     $fcls = input('post.fclass');
>     $minprice = input('post.minprice');
>     $maxprice = input('post.maxprice');
>     if (empty($maxprice)) {
>         $maxprice = 114514;
>     }
>     if (empty($minprice)) {
>         $minprice = 0;
>     }
>     $searchstr = "yourprice between $minprice and $maxprice";
>     if (!empty($fcls)) {
>         $searchstr .= " and fclass='$fcls'";
>     }
>     if (!empty($fname)) {
>         $searchstr .= " and fname like '%$fname%'";
>     }
>     $data = Db::table('flower')->where($searchstr)->order('SelledNum desc')->select();
>     $this->assign('flowers', $data);
>     return $this->fetch();
> }
> ```



在 HTML 进行php语句操作，如：

```html
{foreach $result as $mem}
<tr><td>{$mem.email}</td>
	<td>{$mem.mname}</td>
	<td>{$mem.mobile}</td>
</tr>
{/foreach}
```

> 例如：
>
> ```php
> <?php
> 
> namespace app\index\controller;
> 
> use think\Controller;
> use think\Db;
> 
> class Index extends Controller
> {
>     public function hellodb()
>     {
>         $data = Db::table('myorder')->select();
>         $this->assign('res', $data);
>         return $this->fetch();
>     }
> }
> ```
>
> ```html
> <table>
>     <tr>
>         <th>orderID</th>
>         <th>custID</th>
>     </tr>
>     {foreach $res as $it}
>     <tr>
>         <td>{$it.orderID}</td>
>         <td>{$it.custID}</td>
>     </tr>
>     {/foreach}
> </table>
> ```



###### 分页

先使用分页查询，如：

```php
$list = Db::name('user')->where('status',1)->paginate(10);
$data = Db::table('flower')->order('SelledNum','desc')->paginate(5);
```

使用 paginate 函数：

![image-20220424161841250](img/image-20220424161841250.png)

例如：

```php
public function showflower(){
    $data = Db::table('flower')->order('SelledNum','desc')->paginate(5);
    $this->assign('result',$data);
    $page=$data->render();
    $this->assign('page',$page);
    return $this->fetch();
}
```

导航使用一次标志即可：

```html
<div class="page">{$page}</div>
```

为了修改分页的样式，可以更改 `thinkphp/library/think/paginator/driver/` 的 `Bootstrap.php` ，如改为：

> ```php
> <?php
> // +----------------------------------------------------------------------
> // | ThinkPHP [ WE CAN DO IT JUST THINK ]
> // +----------------------------------------------------------------------
> // | Copyright (c) 2006~2018 http://thinkphp.cn All rights reserved.
> // +----------------------------------------------------------------------
> // | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )
> // +----------------------------------------------------------------------
> // | Author: zhangyajun <448901948@qq.com>
> // +----------------------------------------------------------------------
> 
> namespace think\paginator\driver;
> 
> use think\Paginator;
> 
> class Bootstrap extends Paginator
> {
>     /*
>      * 上一页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getPreviousButton($text = "上一页")
>     {
>     
>         if ($this->currentPage() <= 1) {
>             return $this->getDisabledTextWrapper($text);
>         }
>     
>         $url = $this->url(
>             $this->currentPage() - 1
>             );
>     
>         return $this->getPageLinkWrapper($url, $text);
>     }
>     
>     /**
>      * 下一页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getNextButton($text = '下一页')
>     {
>         if (!$this->hasMore) {
>             return $this->getDisabledTextWrapper($text);
>         }
>     
>         $url = $this->url($this->currentPage() + 1);
>     
>         return $this->getPageLinkWrapper($url, $text);
>     }
>     
>     /**
>      * 首页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getFirstButton($text = '首页')
>     {
>         $nowPage = $this->rollPage;//计算分页临时变量
>         //当  总页数大于定义的页数时  且  当前页数大于前几页时  显示首页
>         if ($this->lastPage > $this->showPage && $this->currentPage > $nowPage) {
>     
>             $url = $this->url(1);
>     
>             return $this->getPageLinkWrapper($url, $text);
>         }
>     }
>     
>     /**
>      * 末页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getLastButton($text = '末页')
>     {
>         $nowPage = $this->rollPage;//计算分页临时变量
>     
>         //当  总页数大于定义的页数时  且  当前页数小于最后的几页时  显示末页
>         if ($this->lastPage > $this->showPage && $this->currentPage < ($this->lastPage - $nowPage)) {
>     
>             $url = $this->url($this->lastPage);
>     
>             return $this->getPageLinkWrapper($url, $text);
>         }
>     }
>     
>     /**
>      * 页码按钮
>      * @return string
>      */
>     protected function getLinks()
>     {
>         if ($this->simple)
>             return '';
>     
>             $block = [
>                 'first'  => null,
>                 'slider' => null,
>                 'last'   => null
>             ];
>     
>             $side   = 3;
>             $window = $side * 2;
>     
>             if ($this->lastPage < $window + 6) {
>                 $block['first'] = $this->getUrlRange(1, $this->lastPage);
>             } elseif ($this->currentPage <= $window) {
>                 $block['first'] = $this->getUrlRange(1, $window + 2);
>                 $block['last']  = $this->getUrlRange($this->lastPage - 1, $this->lastPage);
>             } elseif ($this->currentPage > ($this->lastPage - $window)) {
>                 $block['first'] = $this->getUrlRange(1, 2);
>                 $block['last']  = $this->getUrlRange($this->lastPage - ($window + 2), $this->lastPage);
>             } else {
>                 $block['first']  = $this->getUrlRange(1, 2);
>                 $block['slider'] = $this->getUrlRange($this->currentPage - $side, $this->currentPage + $side);
>                 $block['last']   = $this->getUrlRange($this->lastPage - 1, $this->lastPage);
>             }
>     
>             $html = '';
>     
>             if (is_array($block['first'])) {
>                 $html .= $this->getUrlLinks($block['first']);
>             }
>     
>             if (is_array($block['slider'])) {
>                 $html .= $this->getDots();
>                 $html .= $this->getUrlLinks($block['slider']);
>             }
>     
>             if (is_array($block['last'])) {
>                 $html .= $this->getDots();
>                 $html .= $this->getUrlLinks($block['last']);
>             }
>     
>             return $html;
>     }
>     
>     /**
>      * 渲染分页html
>      * @return mixed
>      */
>     public function render()
>     {
>         if ($this->hasPages()) {
>             if ($this->simple) {
>                 return sprintf(
>                     '%s %s',
>                     $this->getPreviousButton(),
>                     $this->getNextButton()
>                     );
>             } else {
>                 return sprintf(
>                     '%s %s %s',
>                     $this->getPreviousButton(),
>                     $this->getLinks(),
>                     $this->getNextButton()
>                     );
>             }
>         }
>     }
>     
>     /**
>      * 生成一个可点击的按钮
>      *
>      * @param  string $url
>      * @param  int    $page
>      * @return string
>      */
>     protected function getAvailablePageWrapper($url, $page)
>     {
>         return '&nbsp;&nbsp;<a href="' . htmlentities($url) . '">' . $page . '</a>&nbsp;&nbsp;';
>     }
>     
>     /**
>      * 生成一个禁用的按钮
>      *
>      * @param  string $text
>      * @return string
>      */
>     protected function getDisabledTextWrapper($text)
>     {
>         return '<span>&nbsp;&nbsp;' . $text . '&nbsp;&nbsp;</span>';
>     }
>     
>     /**
>      * 生成一个激活的按钮
>      *
>      * @param  string $text
>      * @return string
>      */
>     protected function getActivePageWrapper($text)
>     {
>         return '<span>&nbsp;&nbsp;' . $text . '&nbsp;&nbsp;</span>';
>     }
>     
>     /**
>      * 生成省略号按钮
>      *
>      * @return string
>      */
>     protected function getDots()
>     {
>         return $this->getDisabledTextWrapper('...');
>     }
>     
>     /**
>      * 批量生成页码按钮.
>      *
>      * @param  array $urls
>      * @return string
>      */
>     protected function getUrlLinks(array $urls)
>     {
>         $html = '';
>     
>         foreach ($urls as $page => $url) {
>             $html .= $this->getPageLinkWrapper($url, $page);
>         }
>     
>         return $html;
>     }
>     
>     /**
>      * 生成普通页码按钮
>      *
>      * @param  string $url
>      * @param  int    $page
>      * @return string
>      */
>     protected function getPageLinkWrapper($url, $page)
>     {
>         if ($page == $this->currentPage()) {
>             return $this->getActivePageWrapper($page);
>         }
>     
>         return $this->getAvailablePageWrapper($url, $page);
>     }
>     }
> 
> ```



###### 复杂查询

`->view(表名str,列名str(, 条件))` ，列名str里内部逗号分隔表示多个列

`->where(列名str, 运算符str, 运算数)`  (可以叠多个where，显然)

最后 `->select()` 或 `->find()` 

如：

```php
public function view1()
{
    $conn=Db::connect('mysql://root:123456@localhost:3306/student#utf8');
    dump('OK');
    $data = $conn->view('S', 'SNO,SNAME')->view('SC', 'GRADE', 'SC.SNO=S.SNO')
        ->view('C', 'CNO,CNAME', 'SC.CNO=C.CNO')
        ->where('GRADE', '>', 80)
        ->select();
    $this->assign("results", $data);
    return $this->fetch();
}
```

多个条件 and 为：

```php
Db::table('think_user')->where('name&uname','like','%thinkphp')->find(); // % 是 SQL通配符
```

多个 or 用 whereOr ：

```php
Db::table('think_user')->where('name','like','%thinkphp')->whereOr('email','tp@163.com')->find();
```

也可以用 `|` ：

```php
Db::table('think_user')->where('name|title','like','%thinkphp')->find();
```

混合且，或，用括号搞顺序。

![image-20220429160653178](img/image-20220429160653178.png)



###### 查询语法

```php
where('字段名','表达式','查询条件');
whereOr('字段名','表达式','查询条件');
```

表达式语法：(都是字符串)(查询条件就可以不是字符串) 

```
EQ、=	等于（=）  //如果只写两个参数，where('字段名','查询条件') 也是 EQ
NEQ、<>	不等于（<>）
GT、>	大于（>）
EGT、>=	大于等于（>=）
LT、<	小于（<）
ELT、<=	小于等于（<=）
LIKE	模糊查询
[NOT] BETWEEN	（不在）区间查询
[NOT] IN	（不在）IN 查询
[NOT] NULL	查询字段是否（不）是NULL  //这时没有查询条件
[NOT] EXISTS	EXISTS查询
EXP	表达式查询，支持SQL语法，后接函数使用
> time	时间比较
< time	时间比较
between time	时间比较
not between time	时间比较
```

5.0.4  支持对同一个字段多次调用查询方法  

EXP 举例：

```php
where('id','exp',' IN (1,3,8) ');
```

综合举例：

```php
Db::table('think_user')->where('name|title','like','thinkphp%')->where('create_time&update_time','>',0)->find();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' OR `title` LIKE 'thinkphp%' ) AND ( `create_time` > 0 AND `update_time` > 0 ) LIMIT 1
> ```



区间查询是一种同一字段多个查询条件的简化写法：

区间查询的查询条件必须使用数组定义方式，支持所有的查询表达式。

```php
Db::table('think_user')->where('name',['like','thinkphp%'],['like','%thinkphp'])->where('id',['>',0],['<>',10],'or')->find();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' AND `name` LIKE '%thinkphp' ) AND ( `id` > 0 OR `id` <> 10 ) LIMIT 1
> ```



批量查询

```php
Db::table('think_user')
    ->where([
        'name'  =>  ['like','thinkphp%'],
        'title' =>  ['like','%thinkphp'],
        'id'    =>  ['>',0],
        'status'=>  1
    ])
    ->select();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE `name` LIKE 'thinkphp%' AND `title` LIKE '%thinkphp' AND `id` > 0 AND `status` = '1'
> ```



可以用箭头混合叠起来用上述的全部东西，如：

> ```php
> Db::table('think_user')
>     ->where('name',['like','thinkphp%'],['like','%thinkphp'])
>     ->where(function($query){
>         $query->where('id',['<',10],['>',100],'or');
>     })
>     ->select();
> ```
>
> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' AND `name` LIKE '%thinkphp' ) AND ( `id` < 10 or `id` > 100 )
> ```



可以套原生：

```php
Db::table('think_user')->where('id > 0 AND name LIKE "thinkphp%"')->select();
```



可以占位符：

```php
Db::table('think_user')
    ->where('id > :id AND name LIKE :name ',['id'=>0, 'name'=>'thinkphp%'])
    ->select();
```



> V5.0.4+开始，ThinkPHP支持对同一个字段多次调用查询条件
>
> ```php
> Db::table('think_user')
>     ->where('name','like','%think%')
>     ->where('name','like','%php%')
>     ->where('id','in',[1,5,80,50])
>     ->where('id','>',10)
>     ->find();
> ```



可以定义别名：

```php
$data = $conn->view(['S'=>'Stu'], ['SNO'=>'Stu_No','SNAME'=>'Stu_Name'])
    ->view('SC', ['GRADE'=>'score'], 'SC.SNO=Stu.SNO')
    ->view('C', 'CNO,CNAME', 'SC.CNO=C.CNO')
    ->where('GRADE', '>', 80)
    ->select();
```

> 对应：
>
> ```sql
> Select  Stu.SNO  as Stu_No,Stu.SNAME as Stu_Nname,SC.GRADE as score 
> From  S Stu inner join SC on SC.SNO=Stu.SNO inner join C on SC.CNO=C.CNO
> Where grade>80;
> ```



###### 模型类

如果在某个模型类里面定义了connection属性的话，则该模型操作的时候会自动连接给定的数据库连接，而不是配置文件中设置的默认连接信息，通常用于某些数据表位于当前数据库连接之外的其它数据库。格式同配置里的数据即这是一个数组或字符串格式。如：

```php
//在模型里单独设置数据库连接信息
namespace app\index\model;
use think\Model;
class User extends Model
{
    protected $connection = [
        // 数据库类型
        'type'        => 'mysql',
        // 数据库连接DSN配置
        'dsn'         => '',
        // 服务器地址
        'hostname'    => '127.0.0.1',
        // 数据库名
        'database'     => 'flower',
        // 数据库用户名
        'username'    => 'root',
        // 数据库密码
        'password'    => '12345678',
        // 数据库连接端口
        'hostport'    => '',
        // 数据库连接参数
        'params'     =>[],
        // 数据库编码默认采用utf8
        'charset'     => 'utf8',
        // 数据库表前缀
        'prefix'      => 'think_',
    ];
}

```

```php
protected $connection = 'mysql://root:12345678@localhost:3306/flower#utf8';
```

需要注意的是，ThinkPHP的数据库连接是**惰性**的，所以并不是在实例化的时候就连接数据库，而是在有实际的数据操作的时候才会去连接数据库。



###### 原生操作

query 和 execute 两个方法，分别用于查询和写入，直接使用 SQL 语句

除了查询都用 execute (如更新)。查询返回 array ，下标从 0 开始，值是对象型数组，其key和value对应查询。execute方法的返回值是影响的行数

支持 `?` 参数绑定和命名占位符 `:名字` 绑定，如：

```php
Db::query('select * from think_user where id=?',[8]);    // id=8
Db::execute('insert into think_user (name, email) values (?, ?)',['thinkphp','tp5@163.com']);
```

```php
Db::query('select * from think_user where id=:id',['id'=>8]);
Db::execute('insert into think_user (name, email) 
values (:name, :email)',['name'=>'thinkphp','email'=>'tp5@163.com']);
```

```php
$result=Db::execute('insert into think_user(id,name,email)	values(null,"thinkphp","tp@163.com")');
dump($result);
```

如：

```html
<form action="{:url('index/create')}" name="f" method="post">
<table border="1">
<tr><td>name:</td><td><input type="text" name="name" value="a1"></td></tr>
<tr><td>email:</td><td><input type="text" name="email" value="a1@163com"></td></tr>
<tr><td>score:</td><td><input type="text" name="score" value="91"></td></tr>
<tr><td colspan="2"><input type="submit" value="添加"></td></tr>
</table>
</form>
```

```php
public function create(){
        $name = input('post.name');
        $email=input('post.email');
        $score=input('post.score');
        Db::execute("insert into think_user(id,name,email,score) 
            values(null,'".$name."','".$email."','".$score."')");
        $this->success('添加成功',url('index/index')); 
    }
}
```



```html
<br/>
<a href="{:url('index/add')}">添加</a>
<br/><br/>
<table border="1">
<tr><th>name</th><th>email</th><th>score</th><th>修改</th><th>删除</th></tr>
{volist name="$result" id="row"}
<tr>
	<td>{$row.name}</td>
	<td>{$row.email}</td>
	<td>{$row.score}</td>
	<td><a href="{:url('index/update')}?id={$row.id}">修改</a></td>
	<td><a href="{:url('index/delete')}?id={$row.id}">删除</a></td>
</tr>	
{/volist}
</table>
```

```html
<form action="{:url('index/doUpdate')}" name="f" method="post">
{foreach $result as $user}
<table border="1">
<input type="hidden" name="id" value="{$user.id}">
<tr><td>name:</td><td><input type="text" name="name" value="{$user.name}"></td></tr>
<tr><td>email:</td><td><input type="text" name="email" value="{$user.email}"></td></tr>
<tr><td>score:</td><td><input type="text" name="score" value="{$user.score}"></td></tr>
<tr><td colspan="2"><input type="submit" value="修改"></td></tr>
</table>
{/foreach}
</form>
```

```php
public function update(){
    $id=input('get.id');
    $user=Db::query("select * from think_user where id=$id");
    dump($user);
    $this->assign('result',$user);
    return $this->fetch();
}
public function doUpdate(){
    $id = input('post.id');
    $name = input('post.name');
    $email=input('post.email');
    $score=input('post.score');
    Db::execute("update think_user 
            set name='$name',
            email='$email',
            score='$score' 
            where id=$id");       
    $this->success('修改成功',url('index/index'));
}

```



###### 表格信息

使用getTableInfo可以获取表信息，信息类型 包括 fields,type,bind,pk，以数组的形式展示，可以指定某个信息进行获取

```php
// 获取`think_user`表所有信息
Db::getTableInfo('think_user');
// 获取`think_user`表所有字段
Db::getTableInfo('think_user', 'fields');
// 获取`think_user`表所有字段的类型
Db::getTableInfo('think_user', 'type');
// 获取`think_user`表的主键
Db::getTableInfo('think_user', 'pk');
```



###### 助手函数

`db(数据表名)` = 前缀 + 数据表名选择。可选参数：第二个参数为数据库的连接参数，留空数组(默认)表示采用数据库配置文件的配置；第三个参数是一个布尔值，默认值是false，如果设置为true表示每次都会重新连接数据库。db函数如果采用相同的链接，可以设置第三个参数false.

> 一个MySQL好似只能同时有至多150个连接



###### 其他查询

使用**查询对象**进行查询，例如：

```php
$query = new \think\db\Query();
$query->table('think_user')->where('name','like','%thinkphp');
// $data=Db::find($query);
$data=Db::select($query);
dump($data);
```

或者直接使用闭包函数查询，例如：

```php
$data=Db::select(function($query){
    $query->table('think_user')->where('name','like','%thinkphp');
});
dump($data);
```



###### 聚合查询

内置方法，可以填参数(也可以不填)代表要统计的字段名：count, max, min, avg, sum

如：

```php
Db::table('think_user')->count();
Db::table('think_user')->where('score>0')->min('score');
```



###### 子查询

使用 select 方法且填参数 false ，表示不进行查询只是返回构建SQL (dump 输出得到语句)

那么使用字符串连接符，如 `'(' . $变量 . ') 子表名'` 为 table 参数，就可以子查询了

```php
$subQuery = $conn->table('SC')
    ->field('SNO,GRADE')
    ->where('CNO','=','k5')
    ->select(false);

$data = $conn->table('('.$subQuery.') a')
    ->view('S','SNO,SNAME','a.SNO=S.SNO')
    ->where('a.GRADE','>',80)
    ->select();
```

也可以用 fetchSql 方法，表示不进行查询而只是返回构建的SQL语句，并且不仅仅支持select，而是支持所有的CURD查询。用法： `->fetchSql(true)->select()` ，得到的还是一样的，后面套子表用法跟上面一样。

调用buildSql方法后不会进行实际的查询操作，而只是生成该次查询的SQL语句（为了避免混淆，结果上会在SQL两边加上括号），我们在后续的查询中直接调用。(字符串连接时可以不用括号了，直接子表名)。调用就查询时把 select 换成 buildSql

如果需要 IN/EXISTS 查询，需要用函数闭包，如：

```php
$data = $conn->table('S')
    ->where('SNO','IN',function($query){
        $query->table('SC')->where('CNO','k5')->field('SNO');
    })
    ->select();
```

```php
$data = $conn->table('S')
    ->where(function($query){
        $query->table('SC')
            ->where('CNO','k5')
            ->where('S.SNO=SC.SNO');
    },'exists')
    ->select(); 
```



###### 管理数据

插入：

```php
$data = ['name' => 'zhangsan', 'email' => 'zs@163.com'];
Db::table('think_user')->insert($data);
```

insert 方法添加数据成功返回添加成功的条数，insert 正常情况返回 1

返回新增数据的自增主键，可以使用：

```php
$userId = Db::name('user')->getLastInsID();
```

或直接合并，插入并返回 (成功返回添加数据的自增主键)：

```php
Db::name('user')->insertGetId($data);
```

多条就二维数组， insertAll ，返回添加数据成功返回添加成功的条数



更新：

返回影响数据的条数，没修改任何数据返回 0

```php
Db::table('think_user')->where('id', 1)->update(['name' => 'tp5_1']);
```

若更新的数据包含主键，不需要 where ：

```php
Db::table('think_user')->update(['name' => 'thinkphp','id'=>1]);
```

只更新一个字段，返回影响数据的条数：

```php
Db::table('think_user')->where('id',1)->setField('name', 'thinkphp');
```

setInc/setDec 如不加第二个参数，默认值为1：

```php
Db::table('think_user')->where('id', 1)->setInc('score');
```

支持延时更新，如果需要延时更新则传入第三个参数，单位为秒



删除：

根据主键删除直接传主键值（多个就数组），返回影响数据的条数，无则 0 ：

```php
Db::table('think_user')->delete(1);
Db::table('think_user')->delete([1,2,3]);
```

也可以 where ：

```php
Db::table('think_user')->where('name','bb')->delete();
Db::table('think_user')->where('id','<',10)->delete();
```



##### 模型类

模型类和 Db 类的区别主要在于对象的封装， Db 类的查询默认返回的是数组（或者集合），而模型类返回的是当前的模型对象实例（或者集合），模型是比 Db 类更高级的数据封装，支持模型关联、模型事件。

###### 定义

要放在 `application/模块/model/模型类名.php` ，如：

```php
namespace app\index\model;
use	think\Model;
class 模型类名 extends Model
{
}
```

大多情况下无需为模型定义任何的属性和方法即可完成基础的操作。

模型会自动对应一个数据表，规范是：

```php
数据表前缀+当前的模型类名（不含命名空间）
```

如果你的模型命名不符合这一数据表对应规范，可以给当前模型定义单独的数据表，包括两种方式。

如：

```php
namespace app\index\model;
use think\Model;
class User extends Model{
// 设置完整的数据表（包含前缀）
	protected $table = 'think_user';
}
```

```php
namespace app\index\model;
use think\Model;
class User extends Model
{
// 设置数据表（不含前缀）
	protected $name ='member';
}
```

果当前模型类需要使用不同的数据库连接，可以定义模型的 connection 属性。即

```php
protected $connection = 按照数据库链接的数组/DSN格式来就行;
```

有一种方式可以让你省去别名定义，系统支持统一对控制器类添加 Controller 后缀，修改配置参数**：**

```php
//是否启用控制器类后缀
'controller_suffix'      =>  true,
```



###### 方法

成员属性就是数据库读出来的每个属性。还有方法如下(含静态方法)：



增加数据：

执行 save 操作都是执行的数据库 insert 操作，如果你需要实例化执行save 执行数据库的 update 操作，请确保在save方法之前调用 isUpdate 方法，如：

```php
$user->isUpdate()->save(); //isUpdate填false
```

静态 create 方法可以传入数组或者标准对象，可以在外部统一赋值后传入，当然也可以直接传入表单数据

可以搞成一个数组，然后用 saveAll 传数组

可以用 return getError 方法的返回值得到报错内容



查询数据：

静态 get 方法，传主键值，返回当前的模型对象实例。如果没有传入任何值的话，则表示获取第一条数据。

模型的 get 方法和 Db 类的 find 方法返回结果的区别在于， Db 类默认返回的只是数组（注意这里说的默认，其实仍然可以设置为对象），而模型的 get 方法查询返回的一定是当前的模型对象实例。但是系统为模型实现了 ArrayAccess 接口，因此仍然可以通过数组的方式访问对象实例。

静态 getBy属性名 方法，传值返回实例。注意命名法。每个单词大写，get除外。或者传一个数组，key => value 形式。

查询构建器：静态方法 where ，第一个参数属性，第二个值(或第二个运算符，第三个值，就跟之前的 where 方法用法一样的)，然后再套无参数的 find 。

全部读取用 all ，然后 for 一下就好了。这个也可以传一个数组，key => value 形式作为查询条件。



更新数据：

先查询得到对象，然后直接暴力改，然后用一下 save 即可。

默认情况下，查询模型数据后返回的模型实例执行 save 操作都是执行的数据库 update 操作，如果你需要实例化模型类后执行 save 执行数据库的 insert 操作，请确保在save方法之前调用 isUpdate 方法。

ActiveRecord 模式的更新数据方式需要首先读取对应的数据，如果需要更高效的方法可以搞一个对象，然后静态方法 update 传进去就行。



删除数据：

先查询得到对象，然后跑一下 delete 方法就行。查到的对象是数组就 for 进去一个一个的 delete 。

也可以用静态方法 destroy(主键)



###### 增数据

> 在当前文件中给 app\index\model\User 模型定义了一个别名 UserModel 是为了避免和当前的app\index\controller\User 产生冲突，如果你当前的控制器类不是 User 的话可以不需要定义UserModel 别名

直接操作对应的控制器类就行，不需要对模型类搞别的东西了。如：

```php
<?php
namespace app\index\controller;
use think\Controller;
use app\index\model\User as UserModel;
class User extends Controller
{//	新增用户数据
	public function add(){
		$user=new UserModel();
		$user->name	= '流年';
		$user->email='thinkphp@qq.com';
		$user->birthday ='1977-03-05';
		if($user->save()){
			return '用户['.$user->name.':'.$user->id.']新增成功';
		}else	{
			return	$user->getError();
		}
	}
}
```

> 如果加了控制器类后缀，那么：
>
> ```php
> <?php
> namespace app\index\controller;
> use think\Controller;
> use app\index\model\User;
> class UserController extends Controller
> {//	新增用户数据
> 	public function add(){
> 		$user=new User();
> 		$user->name= '方圆圆';
> 		$user->email='thinkphp@qq.com';
> 		$user->birthday ='1999-05-20';
> 		if($user->save()){
> 			return '用户['.$user->name.':'.$user->id.']新增成功';
> 		}else	{
> 			return	$user->getError();
> 		}
> 	}
> }
> ```

> 关于 isUpdate：
>
> ```php
> //添加数据
> public function addu()
> {
>     $user=new UserModel();
>     $user->id=15;
>     $user->name='刘晨';
>     $user->email='liuchen@gmail.com';
>     if(false!==$user->isUpdate(false)->save()){
>         return '添加用户成功';
>     }else{
>         return $user->getError();
>     }
> }
> ```
>
> 使用 create 方法：
>
> ```php
> <?php
> namespace app\index\controller;
> use think\Controller;
> use app\index\model\User as UserModel;
> class User extends Controller
> {
>  // 新增用户数据
>     public function add()
>     {
>         $user['name'] = '李丽';
>         $user['email'] = 'lili@qq.com';
>         $user['birthday'] = '2015-04-02';
>         if ($result=UserModel::create($user)) {
>             return '用户['.$result->name.':'.$result->id.']新增成功';
>         } else {
>             return '新增出错';
>         }
>     }
> }
> 
> ```

调用如 `http://localhost:89/MyModel/index.php/index/user/add`



###### 查数据

```php
//	读取用户数据
public function read($id='')
{
    $user=UserModel::get($id);
    echo $user->name.'<br/>';
    echo $user->email.'<br/>';
    echo $user->birthday.'<br/>';
}
public function read3()
{
    $user = UserModel::getByEmail('thinkphp@qq.com');
    echo $user->name.'<br/>';
    echo $user->email.'<br/>';
    echo $user->birthday.'<br/>';
}
public function read4()
{
    $user = UserModel::get(['name'=>'李丽']);
    echo $user->name . '<br/>';
    echo $user->email . '<br/>';
    echo $user->birthday . '<br/>';
}
public function read5()
{
    $user =	UserModel::where('name','李丽')->find();
    echo $user->name.'<br/>';
    echo $user->email.'<br/>';
    echo $user->birthday.'<br/>';
}
public function readall()
{
    $list=UserModel::all();
    foreach	($list as $user)	{
        echo $user->id.'<br/>';
        echo $user->name.'<br/>';
        echo $user->email.'<br/>';
        echo $user->birthday.'<br/>';
        echo '----------------------------------<br/>';
    }
}

```

如： `http://localhost:89/MyModel/index/user/read/?id=1`



###### 改数据

```php
public function update($id)
{
    $user=UserModel::get($id);
    $user->name='刘晨';
    $user->email='liuchen@gmail.com';
    if(false!==$user->save()){
        return '更新用户成功';
    }else{
        return $user->getError();
    }
}
```

如： `http://localhost:89/MyModel/index/user/update?id=3`



###### 删数据

```php
public function delete($id)
{
    $user=UserModel::get($id);
    if($user){
        $user->delete();
        return '删除用户成功';
    }else{
        return '删除的用户不存在';
    }
}
public function delete3()
{
    $users= UserModel::where('id','>',6)->select();
    foreach($users as $user){
        if($user){
            $user->delete();
            echo $user->id.'删除成功</br>';
        }else{
            echo '删除的用户不存在';
        }
    }
}
public function delete2($id)
{
    $result	= UserModel::destroy($id);
    if($result){
        return '删除用户成功';
    }else{
        return '删除的用户不存在';
    }
}

```



###### 关联模型

一对一关系：

对 Model 类，其自带方法(可以 `$this->` 调用)有 `hasOne` ，参数是表名、外键名、被关联表属性名。

自带方法 belongsTo ，参数是数据表名。

```php
<?php
namespace app\index\model;
use think\Model;
class User extends Model
{
    public function user_address(){
        return $this->hasOne('user_address','user_id','id');
    }  
}// user_id是外键名，user_address表中的user_id，关联user表的id，
// 而id是user_address表中的主键
```

```php
public function user(){
    return $this->belongsTo('user');
}
```



一对多关系：

hasMany。belongsTo也行。

```php
return $this->hasMany('Sc','sno','id');
//sno是外键，成绩表sc中的sno，关联student表的sno，id是sc表中的主键
return $this->belongsTo('student');
```



多对多关系：

belongsToMany，参数是：关联模型名、中间表名(不用写前缀)、外键名、当前模型关联外键

```php
return $this->belongsToMany('course','sc','cno','sno');
```



创建关联模型就直接如上 return 即可



这个被返回的玩意可以用 save 等增删改查玩意，可以用 attach(模型实例)，也可以 detach(实例) 。

```php
namespace app\index\model;
use think\Model;
class Student extends Model{ 
    public function sc(){
        return $this->hasMany('Sc','sno','id');
    }
    
    public function Course(){
        return $this->belongsToMany('course','Sc','cno','sno');
    }
}
```

```php
namespace app\index\model;
use think\Model;
class Course extends Model{       
    public function Student(){
        return $this->belongsToManay('student','Sc','sno','cno');
    }
}
```

```php
namespace app\index\model;
use think\Model;
class Sc extends Model{
    public function student(){
        return $this->belongsTo('student');
    }
}
```

```php
<?php
namespace app\index\controller;
use think\Controller;
use app\index\model\Student;
class Index extends Controller
{
    public function addRelate($sname='李强'){
        $student=Student::getBySname($sname);
        $res=$student->Course()->save(['cname'=>'计算机组成原理','teacher'=>'吴昊']);
        if($res){
            echo "新增成功";
        }
    }
```

```php
namespace app\index\controller;
use think\Controller;
use app\index\model\Student;
use app\index\model\Course;
class Index extends Controller
{
  public function addRelate1($sname='李强',$cname='编译原理') {
        $student=Student::getBySname($sname);
        $course = Course::getByCname($cname);
        $res=$student->Course()->attach($course);
        if($res){
            echo "关联成功";
        }
    }
```

```php
<?php
namespace app\index\controller;
use think\Controller;
use app\index\model\Student;
use app\index\model\Course;
class Index extends Controller
{
    public function detach(){
        $student=Student::getBySname('李强');
        $course = Course::getByCname('计算机组成原理');
        $res=$student->Course()->detach($course);
        if(!$res){
            echo "取消成功";
        }
    }

```

```php
public function show1(){
    $students = Student::all();
    foreach ($students as $student) {       
        echo "=================1对多显示==============<br/>";   
        echo '姓名：'.$student->sname.'，学号：'.$student->sno.'，所选课程成绩:<br/>';
        foreach ($student->sc as $sc) {
            if ($student->sno == $sc->sno){
                echo '课程ID：' . $sc->cno . '<br/>';
                echo 'GRADE：' . $sc->grade . '<br/>';
                echo '-----------------------<br/>';
            }
        }
    }
}

```

```php
public function show2(){
    $students = Student::all();
    foreach ($students as $student) { //多对多显示 
        echo '===================多对多显示================<br/>';
        echo '姓名：'.$student->sname.'，学号：'.$student->sno.'，所选修课程:<br/>';
        foreach ($student->Course as $course) {
            echo '课程编号：'. $course->cno.'<br/>';
            echo '课程名称：'. $course->cname . '<br/>';
            echo '任课老师：' . $course->teacher . '<br/>';
            echo '-----------------------<br/>';            
        }
    }
}

```

不知道有什么用。



##### URL

###### pageinfo

ThinkPHP 采用单一入口模式访问应用，对应用的所有请求都定向到应用的入口文件。

页面跳转需要进入 `\traits\controller\Jump` ，而继承 `Controller` 有这个，不需要额外引入。

301和302都是HTTP状态的编码，都代表着某个URL发生了转移。

1) 301跳转，也叫“永久性转移”，301会把原网页权重转移到重定向目标的网站上面,搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。二次请求。

2) 302跳转也称为，“临时性跳转”。搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。一次请求。

可以用 success, error 和 redirect 。

标准 URL 格式：(pathinfo格式)

```shell
http://serverName:端口号/index.php/模块/控制器/操作
```

模块是 application 下子目录，官方的规范是目录名小写，因此模块全部采用小写命名，无论URL是否开启大小写转换，模块名都会强制小写。URL地址中的控制器和操作名是不区分大小写的。

驼峰命名的控制器如 `HelloWorld` ，在 url 输入 `hello_world` 。

如果希望严格区分大小写访问（或者要支持驼峰法进行控制器访问），可以在应用配置文件中”application/config.php”中设置：

```php
// 关闭URL自动转换（支持驼峰访问控制器）
'url_convert' => false,
```

关闭URL自动转换之后，必须使用下面的URL地址访问（控制器名称必须严格使用控制器类的名称，不包含控制器后缀）：

```plain
http://localhost:89/TestTP/index.php/index/HelloWorld/index
```

操作方法的访问本身不会受URL自动转换的影响，但会影响默认的模板渲染输出。



如果我们直接访问入口文件的话，由于URL中没有模块、控制器和操作，因此系统会访问默认模块（index）下面的默认控制器（Index）的默认操作（index），如下面等效：

```plain
http://localhost:89/TestTP/index.php
http://localhost:89/TestTP/index.php/index/index/index
```

传入参数：

```text
http://localhost:89/TestTP/index.php/index/index/hello/name/thinkphp
http://localhost:89/TestTP/index.php/index/index/hello/?name=thinkphp
```



不支持 pathinfo 的话可以用兼容方式：

```html
http://localhost:89/TestTP/index.php?s=/index/Index/hello
```

其中变量 s 的名称如果改为u，则访问的是默认的控制器和index方法。s可以配置的。

TP5.0不再支持普通的URL访问方式，所以下面的访问是无效的：

```
http://localhost:89/TestTP/index.php?m=index&c=index&a=hello
```



###### 参数

pageinfo 方法来写，顺序任意；或 ?：

```phpw
http://localhost:89/TestTP/index.php/index/index/hello/name/tp5
http://localhost:89/TestTP/index.php/index/index/hello1/name/tp5/city/guangzhou 
http://localhost:89/TestTP/index.php/index/index/hello1?name=tp5&city=guangzhou
```

 还可以进一步对URL地址做简化，前提就是我们必须明确参数的顺序代表的变量，我们更改下URL参数的获取方式，把应用配置文件中的 url_param_type 参数的值修改如下：

```php
// 按照参数顺序获取
'url_param_type' => 1,
```

省略后：

```php1
http://localhost:89/TestTP/index.php/index/index/hello1/tp5/shanghai
```

按顺序绑定参数的话，操作方法的参数只能使用URL pathinfo变量，而不能使用get或者post变量。(即?格式)



###### index.php

可以去掉URL地址里面的入口文件 index.php ，但是需要额外配置WEB服务器的重写规则。

以 Apache 为例，需要在入口文件的同级（index.php所在文件夹）添加 .htaccess 文件（官方默认自带了该文件），内容如下：

```htaccess
<IfModule mod_rewrite.c>
Options +FollowSymlinks -Multiviews
RewriteEngine on
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]
</IfModule>
```

用 phpstudy 则：

```htaccess
<IfModule mod_rewrite.c>
Options +FollowSymlinks -Multiviews
RewriteEngine on
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1]
</IfModule>
```

用 nginx 在 `nginx.conf` ：

```js
location / { // …..省略部分代码
    if (!-e $request_filename) {
    	rewrite ^(.*)$ /index.php?s=/$1 last;
    	break;
    }
}

```

去掉后，如：

```php1
http://localhost:89/TestTP/index/index/index
http://localhost:89/TestTP/index/index/hello
```

隐藏后可以用去掉和不去掉两种写法来写。



###### 路由

我们在路由定义文件（ application/route.php ）里面添加一些路由规则，如下：

```php
return [
    // 添加路由规则 路由到 index控制器的hello操作方法
    'hello/[:name]' => 'index/index/hello',
];
```

该路由规则表示所有 hello 开头的并且带参数的访问都会路由到 index 控制器的 hello 操作方法。中括号表示可选。

可以恒简化：

```php1
http://localhost:89/TestTP/index/index/hello/name/tp5
http://localhost:89/TestTP/hello/tp5
```

定义路由规则后，原来的URL地址将会失效，变成非法请求。



动态，在路由配置文件开头添加：

```php
use think\Route;
Route::rule('hello/[:name]', 'index/hello');
```

完成的效果和使用配置方式定义是一样的。

无论是配置方式还是通过Route类的方法定义路由，都统一放到路由配置文件 application/route.php文件中。

提示：注意路由配置不支持在模块配置文件中设置。



若需要完整匹配：

```php
return [
    // 路由参数name为可选
    'hello/[:name]$' => 'index/hello',
];
```

那么：

```abc
http://localhost:89/TestTP/hello   // 正确匹配
http://localhost:89/TestTP/hello/tp5    // 正确匹配
http://localhost:88/TestTP/hello/val/value // 不会匹配
```



闭包：

```php
return [
    // 定义闭包
    'hello/[:name]' => function ($name) {
    	return 'Hello,' . $name . '!';
    },
];
```

或：

```php
use think\Route;
    Route::rule('hello/[:name]', function ($name) {
    	return 'Hello,' . $name . '!';
});
```

闭包函数的参数就是路由规则中定义的变量。



###### 分割符

如果需要改变URL地址中的 pathinfo 参数分隔符，只需要在应用配置文件（application/config.php ）中设置：

```php
// 设置pathinfo分隔符
'pathinfo_depr' => '-',
```

路由规则定义无需做任何改变，我们就可以访问下面的地址：

```a
http://localhost:88/TestTP/hello-tp5
```



###### 路由参数

我们还可以约束路由规则的请求类型或者URL后缀之类的条件，例如：

```php
return [
    // 定义路由的请求类型和后缀
    'hello/[:name]' => ['index/hello', ['method' => 'get', 'ext' => 'html']],
];
```

上面定义的路由规则限制了必须是 get 请求，而且后缀必须是 html 的，所以下面的访问地址：

```ab
http://localhost:89/TestTP/hello    // 无效
http://localhost:89/TestTP/hello.html // 有效
```



###### 变量规则

如：

```php
<?php
namespace app\index\controller;

class Blog
{
    public function get($id){
        return '查看id=' . $id . '的内容';
    }
    public function read($name){
        return '查看name=' . $name . '的内容';
    }
    public function archive($year, $month){
        return '查看' . $year . '/' . $month . '的归档内容';
    }    
}
```

规则：

```php
return [
    'blog/:year/:month' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}', 'month' => '\d{2}']],
    'blog/:id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
    'blog/:name' => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
];
```

如：

```phpa
http://localhost:89/TestTP/blog/5
http://localhost:89/TestTP/blog/thinkphp
http://localhost:89/TestTP/blog/2015/05
```

简化：

```php
return [
'[blog]' => [
    ':year/:month' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}', 'month' => '\d{2}']],
    ':id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
    ':name' => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
],
];

```

对 `blog-<year>-<month>` 这样的非正常规范，我们需要使用 <变量名> 这样的变量定义方式，而不是

:变量名 方式。如：

```php
return [
'blog/:id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
'blog/:name' => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
'blog-<year>-<month>' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}',
'month' => '\d{2}']],
];

```

简单起见，我们还可以把变量规则统一定义，例如：

```php
return [
// 全局变量规则定义
'__pattern__' => [
'name' => '\w+',
'id' => '\d+',
'year' => '\d{4}',
'month' => '\d{2}',
],
// 路由规则定义
'blog/:id' => 'blog/get',
'blog/:name' => 'blog/read',
'blog-<year>-<month>' => 'blog/archive',
];

```

在 \_\_pattern\_\_ 中定义的变量规则我们称之为全局变量规则，在路由规则里面定义的变量规则我们称之为局部变量规则，如果一个变量同时定义了全局规则和局部规则的话，当前的局部规则会覆盖全局规则的。



###### Url类

定义路由规则之后，我们可以通过Url类来方便的生成实际的URL地址（路由地址）

```php
// 输出 blog/thinkphp
Url::build('blog/read', 'name=thinkphp');
Url::build('blog/read', ['name' => 'thinkphp']);

Url::build('blog/archive', 'year=2015&month=05');
Url::build('blog/archive', ['year' => '2015', 'month' => '05']);
```

url助手函数简化：

```php
url('blog/read', 'name=thinkphp');
```

```html
<a href="{:url('blog/read','name=thinkphp')}">跳转</a>
```



##### 请求响应

###### input

助手函数。

```php
input('提交类型.变量名/修饰符');
```

s 字符串，d 整型，b布尔值，a数组，f浮点

如：

```php
$num = input('post.num/d');
manage = input('post.manage/a');
$str = implode(',', $manage);
```



###### Request

> ThinkPHP5 的架构设计和之前版本的主要区别之一就在于增加了 Request 请求对象和 Response 响应对象的概念

请求对象。Request 对象的作用是与客户端交互，收集客户端的Form、Cookies、超链接，或者收集服务器端的环境变量。

Request对象是从客户端向服务器发出请求，包括用户提交的信息以及客户端的一些信息。客户端可通过HTML表单或在网页地址后面提供参数的方法提交数据，然后通过Request对象的相关方法来获取这些数据。

Request的各种方法主要用来处理客户端浏览器提交的请求中的各项参数和选项。

ThinkPHP5 的 Request 对象由 think\Request 类完成。

Request 对象的一个主要职责是统一和更安全地获取当前的请求信息，最好是需要避免直接操作 \$_GET 、\$\_POST 、 \$\_REQUEST 、 \$\_SESSION 、 \$\_COOKIE ，甚至 \$\_FILES 等全局变量，而是统一使用Request 对象提供的方法来获取请求变量。

一种少用的方法：

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello($name = 'World') {
        $request = Request::instance();
		// 获取当前URL地址 不含域名
		echo 'url: ' . $request->url() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```

返回值距离：

```sdsd
/TestTP/index.php/index/index/hello?name='abc'
```

当继承 think\\Controller 时，可以改为 `$this->request->url()` ，也不用 use 和 instance 。

如果没有继承 think\Controller ，则可以使用 Request 对象注入的方式来简化调用：

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request, $name = 'World')    {
		echo 'url: ' . $request->url() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```

hello方法的request参数是系统自动注入的，而不需要通过URL请求传入。



可以给Request请求对象绑定属性，方便全局调用，例如我们可以在公共控制器中绑定当前登录的用户模型到请求对象：

```php
<?php
namespace app\index\controller;
use app\index\model\User;
use think\Controller;
use think\Request;
use think\Session;
class Base extends Controller{
	public function  _initialize(){
        $user = User::get(Session::get('user_id'));
        Request::instance()->bind('user', $user);
    }
}
```

```php
<?php
namespace app\index\controller;
use app\index\controller\Base;
use think\Request;
class Index extends Base{
	public function index(Request $request)    {
		echo $request->user->id;
		echo $request->user->name;
    }
}
```



###### request助手

```php
<?php
namespace app\index\controller;
class Index{
	public function hello($name = 'World')    {
		// 获取当前URL地址 不含域名
		echo 'url: ' . request()->url() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```



###### param

系统推荐使用 param 方法统一获取当前请求变量，该方法最大的优势是让你不需要区分当前请求类型而使用不同的全局变量或者方法

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
    public function hello(Request $request)    {
        echo '请求参数：';
        dump($request->param());
        echo 'name:' . $request->param('name');
    }
}
```

dump 那一行还可以简化为： `dump(input());`

param 方法获取的参数会自动判断当前的请求，以 POST 请求为例的话，参数的优先级别为：路由变量 > 当前请求变量（\$\_POST变量） \> \$\_GET变量

注意：这里的路由变量指的是路由规则里面定义的变量或者 PATH\_INFO 地址中的变量。路由变量无法使用get 方法或者 \$\_GET 变量获取。

param 方法支持变量的过滤和默认值：

```php
echo 'name:' . $request->param('name', 'World', 'strtolower');
echo '<br/>test:' . $request->param('test', 'thinkphp', 'strtoupper');
```

防止代码注入，在 `application/config.php` ：

```php
'default_filter' => 'htmlspecialchars ',
```



###### 其他输入

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request) {
		echo 'GET参数：';
       dump($request->get());
		echo 'GET参数：name';
       dump($request->get('name'));
		echo 'POST参数：name';
        dump($request->post('name'));
		echo 'cookie参数：name';
        dump($request->cookie('name'));
		echo '上传文件信息：image';
        dump($request->file('image'));
    }
}
```

写法二：

```php
<?php
namespace app\index\controller;
class Index{
	public function hello()    {
		echo 'GET参数：';
        dump(input('get.'));
		echo 'GET参数：name';
        dump(input('get.name'));
		echo 'POST参数：name';
        dump(input('post.name'));
		echo 'cookie参数：name';
        dump(input('cookie.name'));
		echo '上传文件信息：image';
        dump(input('file.image'));
    }
}
```

![image-20220524164459786](img/image-20220524164459786.png)

除了 file 都支持默认值和过滤方式。



###### 请求参数

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request) {
		echo '请求方法：' . $request->method() . '<br/>';
		echo '资源类型：' . $request->type() . '<br/>';
		echo '访问IP：' . $request->ip() . '<br/>';
		echo '是否AJax请求：' . var_export($request->isAjax(), true) . '<br/>';
		echo '请求参数：';
        dump($request->param());
		echo '请求参数：仅包含name';
        dump($request->only(['name']));
		echo '请求参数：排除name';
        dump($request->except(['name']));
    }
}
```

`var_export` 可以将一个数组转为一个字符串不同于`var_dump` , `var_export` 并不会输出数据的类型以及字符大小等,只会简单把数组的key跟value拼接成一个字符串



###### URL信息

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request, $name = 'World'){
		// 获取当前域名
		echo 'domain: ' . $request->domain() . '<br/>';
		// 获取当前入口文件
		echo 'file: ' . $request->baseFile() . '<br/>';
		// 获取当前URL地址 不含域名
		echo 'url: ' . $request->url() . '<br/>';
		// 获取包含域名的完整URL地址
		echo 'url with domain: ' . $request->url(true) . '<br/>';
		// 获取当前URL地址 不含QUERY_STRING
		echo 'url without query: ' . $request->baseUrl() . '<br/>';
		// 获取URL访问的ROOT地址
		echo 'root:' . $request->root() . '<br/>';
		// 获取URL访问的ROOT地址
		echo 'root with domain: ' . $request->root(true) . '<br/>';
		// 获取URL地址中的PATH_INFO信息
		echo 'pathinfo: ' . $request->pathinfo() . '<br/>';
		// 获取URL地址中的PATH_INFO信息 不含后缀
		echo 'pathinfo: ' . $request->path() . '<br/>';
		// 获取URL地址中的后缀信息
		echo 'ext: ' . $request->ext() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```

![image-20220524164802059](img/image-20220524164802059.png)

url、baseUrl、baseFile、root方法如果传入true，表示获取包含域名的地址。



###### MCV信息

```php
public function hello(Request $request, $name = 'World') {
		echo '模块：' . $request->module();
		echo '<br/>控制器：' . $request->controller();
		echo '<br/>操作：' . $request->action();
    }
```

controller方法获取的是驼峰命名的实际的控制器名，其它都是小写返回。



###### Response

Response 对象用于动态响应客户端请示,通常用于输出数据给客户端或者浏览器。

ThinkPHP5 的 Response 响应对象由 think\\Response 类或者子类完成

大多数情况，我们不需要关注 Response 对象本身，只需要在控制器的操作方法中返回数据即可，系统会根据 default_return_type 和 default_ajax_return 配置决定响应输出的类型。

默认的自动响应输出会自动判断是否 AJAX 请求，如果是的话会自动输出 default_ajax_return 配置的输出类型。

```php
<?php
namespace app\index\controller;
class Index{
	public function test(){
		$data = ['name' => 'thinkphp', 'status' => '1'];
		return $data;
	}
}
```

若修改配置文件：

```php
// 默认输出类型
'default_return_type' => 'json',
```

那么上文访问会保存一个 json 。改为 xml 就保存一个 xml 。

手动输出控制：

```php
<?php
namespace app\index\controller;
use think\Controller;
class Index{
    public function test(){
        $data = ['name' => 'thinkphp', 'status' => '1'];
        return json($data);
    }  
}
```

![image-20220524165137668](img/image-20220524165137668.png)



##### 事务

`mysql` 的 `myisam` 不支持， `unnodb` 支持。

###### transaction

发生异常自动回滚。

自动控制事务处理：

```php
Db::transaction(function(){
    //执行语句
    //Db::table('think_user')->find(1);
    //Db::table('think_user')->delete(1);
});
```

手动，如：

```php
Db::startTrans();
try{
    Db::table('think_user')->find(1);
    Db::table('think_user')->delete(1);
    // 提交事务
    Db::commit();    
} catch (\Exception $e) {
    // 回滚事务
    Db::rollback();
}
```

注意在事务操作的时候，确保你的数据库连接是相同的。



##### 文件

###### 定义

使用 `think\File`。创建一个控制器：

```php
<?php
namespace app\index\controller;
use think\controller;
use think\Request;
class Upload extends Controller{ 
    // 文件上传表单
    public function index()    {
        return $this->fetch();
    }
    // 文件上传提交
    public function up(Request $request)    {
        // 获取表单上传文件
        $file = $request->file('file');
        if (empty($file)) {
            $this->error('请选择上传文件');
        }
        // 移动到框架应用根目录/public/uploads/ 目录下
        $info = $file->move(ROOT_PATH . 'public' . DS . 'uploads');
        if ($info) {
            $this->success('文件上传成功：' . $info->getRealPath());
        } else {
            // 上传失败获取错误信息
            $this->error($file->getError());
        }
    }
}
```

HTML：

```html
<!doctype html>
<html><head>
<meta charset="UTF-8">
<title>文件上传示例</title>
</head><body>
	<h2>文件上传示例</h2>
	<FORM method="post" enctype="multipart/form-data" action="{:url('up')}">
		选择文件：<INPUT type="file"  name="file"><br/> 
		<INPUT type="submit" value="提交">
	</FORM>
</body>
</html>
```

默认的上传文件会按照当前的日期自动保存



###### 验证

可以嵌套使用。如：

```php
$info=$file->validate(['ext'=>'jpg,png'])->move(ROOT_PATH	.'public'.DS.'uploads');
```

![image-20220607160002845](img/image-20220607160002845.png)

不只是检验后缀，强行改后缀也会说是错的。文件上传验证用到了 **exif 扩展**，如果没有开启请自行开启。



###### 验证类

统一使用验证类 think\Validate 对表单进行验证，也可以直接使用控制器类 think\Controller 的 validate 方法进行上传文件验证

```php
// 文件上传提交
    public function up(Request $request){
 		$file = $request->file('file');
        // 上传文件验证
        $result = $this->validate(['file' => $file],
            ['file' => 'require|image'], 
            ['file.require' => '请选择上传文件','file.image' => '非法图像文件']);
        if (true !== $result) {
            $this->error($result);
        }
        // 移动到框架应用根目录/public/uploads/ 目录下
        $info = $file->move(ROOT_PATH.'public'.DS .'uploads');
        if ($info) {
            $this->success('文件上传成功：'. $info->getRealPath());
        } else {
            // 上传失败获取错误信息
            $this->error($file->getError());
        }
    }

```

由于设置了 require 验证规则（表示必须上传文件），所以如果没有选择任何文件直接提交的话，页面会提示报错。

![image-20220607160214083](img/image-20220607160214083.png)



###### 保存规则

rule 方法设置。

![image-20220607160312054](img/image-20220607160312054.png)

其中md5和sha1规则会自动以散列值的前两个字符作为子目录，后面的散列值作为文件名。

```php
$info = $file->rule('md5')->move(ROOT_PATH . 'public' . DS . 'uploads');
$info=$file->rule('uniqid')->move(ROOT_PATH	.'public'.DS.'uploads');
```

这里使用了 uniqid 函数来生成唯一的ID命名上传文件，如果必要，还可以支持使用闭包定义规则，例如：

```php
// 移动到框架应用根目录/public/uploads/ 目录下
	$info = $file->rule(function ($file) {
    // 使用自定义的文件保存规则
    return $file->getInfo('type').uniqid();
})->move(ROOT_PATH . 'public' . DS . 'uploads');
```

如果希望指定某个文件的保存文件名，还可以直接使用：

```php
// 移动到框架应用根目录/public/uploads/test.后缀 目录下
$info = $file->move(ROOT_PATH . 'public' . DS . 'uploads', 'test');
```

如果希望保持上传文件的原文件名保存，则可以使用：

```php
$info = $file->move(ROOT_PATH . 'public' . DS . 'uploads', '');
```

默认同名覆盖，不想覆盖就：

```php
$file->move(ROOT_PATH . 'public' . DS . 'uploads', true, false);
```

要获取上传的保存文件名(不含路径)，可以调用返回对象的 getSaveName 方法：

```php
$info = $file->rule('md5')->move(ROOT_PATH . 'public' . DS . 'uploads','');
if ($info) {
    echo $info->getSaveName();
} else {
    $this->error($file->getError());
}
```



###### 多文件

如表单。

```html
<h2>多文件上传示例</h2>
<FORM	method="post" enctype="multipart/form-data" action="{:url('up1')}">
<input	type="file"	name="image[]"	/>	<br>	
<input	type="file"	name="image[]"	/>	<br>	
<input	type="file"	name="image[]"	/>	<br>	
<INPUT	type="submit"	class="btn"	value="	提交">
</FORM>
```

```php
public function up1(Request $request)    {
    // 获取表单上传文件
    $files = $request->file('image');
    $item = [];
    foreach ($files as $file) {
        // 移动到框架应用根目录/public/uploads/ 目录下
        $info = $file->move(ROOT_PATH . 'public' . DS . 'uploads');
        if ($info) {
            $item[] = $info->getRealPath();
        } else {
            // 上传失败获取错误信息
            $this->error($file->getError());
        }
    }
    $this->success('文件上传成功' . implode('<br/>', $item));
}
```



###### 文件操作

上传成功后返回的是 File 对象，除了可以使用 SplFileObject 的属性和方法之外，还可以使用File类自身提供的下列方法，便于进行后续的文件处理（例如对图像文件进行剪裁处理或者移动到远程服务器）。

![image-20220607160712006](img/image-20220607160712006.png)

```php
public function up(Request $request) {
    $file = $request->file('file');
    $info = $file->move(ROOT_PATH . 'public' . DS . 'uploads');
    if ($info) {
        // 移动文件到FTP服务器
        $link = ftp_connect('212.45.5.78');
        ftp_login($link, 'root', 'password');
        /* 移动文件 */
        $path = ftp_pwd($link) . '/uploads/';
        if	(!ftp_put($link,$path.$info->getFilename(),	$info->getRealPath(),FTP_BINARY)){
            $this->error('文件上传保存错误！');
        }
    } else {
        // 上传失败获取错误信息
        $this->error($file->getError());
    }
}
```





##### 库

###### 验证码

修改 `php.ini` 配置，增加(取消注释号`;`)：

```ini
extension_dir="./"
extension_dir="ext"
```

添加一个拓展包：

```ini
extension=php_openssl.dll
```

添加：

```ini
openssl.cafile=
```

下载并放置：`AppServ\php7\verify\cacert.pem` 

thinkphp5.0版本安装验证码类库,必须安装1.* 版本，安装2.0版将会出错。

使用 composer，在应用根目录：

```shell
composer require topthink/think-captcha  1.*
```





# MySQL

## 基本

### 基本概念

RDBMS(Relational Database Management System：关系数据库管理系统)，基本特点：

- 数据以表格的形式出现
- 每行为各种记录名称
- 每列为记录名称所对应的数据域
- 许多的行和列组成一张表单
- 若干的表单组成database

mysql是rdbms。

- **数据库:** 数据库是一些关联表的集合。
- **数据表:** 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。
- **列:** 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。
- **行：**一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。
- **冗余**：存储两倍数据，冗余降低了性能，但提高了数据的安全性。
- **主键**：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。
- **外键：**外键用于关联两个表。
- **复合键**：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。
- **索引：**使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。
- **参照完整性:** 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。

> MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
>
> - MySQL 是开源的，目前隶属于 Oracle 旗下产品。
> - MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。
> - MySQL 使用标准的 SQL 数据语言形式。
> - MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。
> - MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。
> - MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。
> - MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。



### 使用

导入导出等其他指令可见指令-其他指令

#### 使用

> 以下均以linux系统为准

安装略。

验证安装：(mysql admin)

```shell
mysqladmin --version
```

输出了有效信息代表安装成功。

启动：(可能需要管理员`sudo`)(-u是`user`,`-uroot`是`root`用户；`-p`是password，同理可以诸如`-p123456`)

```shell
mysql
```

```shell
mysql -u 用户名 -p
```

然后输入密码。

退出：`exit`或`\q`或`quit`

启动后可以直接交互，类似于`python shell`交互方法。

参数：

- `-h 主机` ，如`localhost, 127.0.0.1, 10.191.65.243`
- `-P 端口`
- `-u 用户名`
- `-p` 密码（随后输入）；或`-p密码` 

示例：

```shell
mysqladmin -h 127.0.0.1 -u root -p123 create test
cmd /c mysql -h 127.0.0.1 -u root -p123 test < tb_thu.sql
```



检查MySQL服务器是否启动：

```shell
ps -ef | grep mysqld
```

启动服务器：

```shell
cd /usr/bin
./mysqld_safe &
```

关闭服务器：

```shell
cd /usr/bin
./mysqladmin -u 用户名 -p shutdown
```

文件配置路径：`/etc/my.cnf`

> 上述文件配置在SCNUOJ服务器不存在



#### sql 脚本

一系列 sql 语句的集合。可以用 shell 执行，重定向输入输出。后缀名是 `.sql `。以 shell 为例：

```shell
sudo mysql < xxx.sql > xxx.out
```



#### 开关服务

##### windows

开关分别是：

```shell
mysqld --console
mysqladmin -uroot shutdown
```



##### linux

查看是否启动：

```shell
ps -ef | grep mysqld
```

启动：

```shell
cd /usr/bin
./mysqld_safe &
```

关闭：

```shell
mysqladmin -u root -p shutdown
```



#### vscode

可以使用插件：`SQL Formatter`



#### my.ini

可以查看数据存放的路径



### 基本格式

指令不区分大小写，以分号结束。如可以输入：

```mysql
SHOW DATABASES;
```

> 列出所有数据表

单行注释用`#`或`--`

> `#`和`--`的区别就是：`#`后面直接加注释内容，而`--`的第 2 个破折号后需要跟一个空格符在加注释内容。

多行注释用`/**/`

```mysql
use mysql; #选定数据库，之后所有语句针对这个数据库
SHOW TABLES; -- 展示所有数据表
SHOW /*多行
注释*/ TABLES;
SHOW COLUMNS FROM user; #查看user数据表的所有属性
SHOW INDEX FROM user; #显示数据表的详细索引信息，包括PRIMARY KEY（主键）
SHOW TABLE STATUS from mysql; # 输出数据库性能和统计信息
SHOW TABLE STATUS from mysql LIKE 'time%';     # 表名以time开头的表的信息
SHOW TABLE STATUS from mysql LIKE 'time%'\G;   # 加上 \G，查询结果按列打印
```

名字(数据库名、数据表名、用户名等)可以不用任何引号，数据库名、数据表名、列名都不区分大小写，也可以用单引号或反勾号(esc下面的键)。两者在linux下和windows下不同，linux下不区分，windows下区分。如果SQL服务器模式包括ANSI_QUOTES模式选项，还可以用双引号将识别符引起来。

一般引号用途是避免关键字冲突，如对`date`为列名时，需要引号。三种引号：

- 飘号 \`\` ，通常用于表示可能会产生歧义的列名
- 单引号 \'\' ，用于字符串，也可以用双引号
- 数值不能用引号；字符串不能不用引号也不能用飘号；列名不能用引号

退出：

```mysql
exit
```

> `use,exit`是不需要分号的语句



算术运算符，除法可以用`/`或`DIV`，整除整是小数，取模用`%`或`MOD` 。零除返回 null 。

关系运算符有`between 值 and 值` ，是 $[x,y]$ 区间，`in` , `is null` 及其 `not` 前缀的。还有 greatest, least, like, regexp 。is null (isnull()) ， is not null 。`least(v1, v2, v3, ...)` 。存在 null 返回 null 。有 `in(v1, v2, ...)` ，找不到、括号里有或本来要判断的左操作数是 null 返回 null 。like 里 `%` 是零到多个， `_` 是任意一个。输入左/右 null(不带引号) 返回 null， regexp 同理。

`=`是是否等于，任一方为`NULL`得`NULL`，否则是`0/1` 。一个字符串一个整数按数值比较。还有安全等与 `<=>` ，唯一区别是都为 null 返回 1 。不等于用 `<>` 或 `!= ` 。null 参与比较运算符返回 null，如 `<=` 。字符串比较字典序。

因为 windows 下不区分大小写，所以字符串比较也不区分。要区分的话在字符串前添加 binary 关键字，即如 `binary 'a' != 'A'` 

逻辑有 `!` 或 `NOT` ，有 `AND, OR , XOR` 。操作数为 null 得 null 。对 not 而言， `''` , `'0'` 都返回 1 。xor 的等效是 `(a and (not b))` 或反之即 `((not a) and b)` 。

可以有位运算符 `&|^!<<>>~`，其中`!`取反。返回64位无符号整数。

如：

```mysql
select 22 div 3;
```

最低优先级为： **:=**。

![img](img/1011652-20170416163043227-1936139924.png)

最高优先级为： **!**、**BINARY**、 **COLLATE**。



### 数据类型

![image-20220505113640805](img/image-20220505113640805.png)

#### 数值

支持所有标准 SQL 数值数据类型。

这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。

关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。

BIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB表。

作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。

| 类型         | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| :----------- | :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- |
| TINYINT      | 1 Bytes                                  | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| SMALLINT     | 2 Bytes                                  | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| MEDIUMINT    | 3 Bytes                                  | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| INT或INTEGER | 4 Bytes                                  | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| BIGINT       | 8 Bytes                                  | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| FLOAT        | 4 Bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| DOUBLE       | 8 Bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |

------

int 可以用 int(数值)，表示显示宽度。实际存储宽度可能会大于显示宽度，也就是说显示不出但后台可以存更高。默认显示宽度分别为 4,6,9,11,20 。可以使用 `unsigned` 修饰符。

decimal 默认是 10,0 。[即 numeric]

 

#### 日期时间

表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。

每个时间类型有一个有效值范围和一个"零"值，当指定不合法的MySQL不能表示的值时使用"零"值。

TIMESTAMP类型有专有的自动更新特性，将在后面描述。

year 的输入可以输入字符串，如直接 insert 时 `'2010'` ，可以输入二位，那么范围 $[1,69]$ 前缀为 `20` ，$[70,99]$ 的前缀为 `19`  。特别地输入 `0` 表示 `0000` 

time 的输入可以 `D HH:MM:SS` , `HH:MM:SS` , `HH:MM` , `D HH:MM` `D HH` , `SS` 字符串，其中 D 为 $[0,34]$ 。转换为小时，即 $24D+HH$ ，因为 $HH$ 可以大于 $24$ 。有含义的 `HHMMSS` 数值也合法，但诸如 `1112` 被解释为 `00:11:12` 。同理 `12` 是 `00:00:12` 。冒号则不一样。注意 `D HH` 的 `HH` 一定是 `02d` 格式的。也可以用函数 `NOW()` 或常数 `CURRENT_TIME` (前者有年月日，后者没有) (可以加括号，下同)。

date 可以用字符串 `YYYY-MM-DD` , `YYYYMMDD` , `YY-MM-DD` ，或数值 `YY-MM-DD` , `YYMMDD` ，或 `NOW()` 或 `CURRENT_DATE`。任何标点符号，如 `-./@` 都可以作为日期部分分割符。

datetime `YYYY-MM-D HH:MM:SS` , `YYYYMMDDHHMMSS` ，范围是 `1000-01-01 00:00:00` 到 `9999-12-3 23:59:59` 。其中 `YYYY` 可简写为 `YY` ，可以有 `00` 。也可以用数字格式。同理分隔符可以不严格。可以用 `now()`

timestamp 范围为 `1970-01-01 00:00:01 UTC` 到 `2038-01-19 03:14:07 UTC` 。 UTC 是 coordinated universal time ，世界标准时间。timestamp 存储时转换，查询时按当前时区输出，所以不同时区对同一数据输出不同。

修改时区例如： `set time_zone='+10:00'`

存储时的实质是存储字符串，而不是十进制数值

| 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                     |
| :-------- | :------------ | :----------------------------------------------------------- | :------------------ | :----------------------- |
| DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |
| TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                   |
| DATETIME  | 8             | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4             | 1970-01-01 00:00:00/2038结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |



#### 字符串

字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。

| 类型       | 大小                  | 用途                            |
| :--------- | :-------------------- | :------------------------------ |
| CHAR       | 0-255 bytes           | 定长字符串                      |
| VARCHAR    | 0-65535 bytes         | 变长字符串                      |
| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                    |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535 bytes        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                    |

char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。

CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。

char 定长； varchar 可变长；前者查询快，后者查询慢。若对 char(n) ，那么多出部分右侧空格填充。

BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。

BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。blob变长。

有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。text变长。

此外还有 enum ，1 或 2 字节(最大65535) 。定义时只能取指定值，即 `字段名 enum('x', 'y', ..)` ，当然可以是字符串，因为实际存的是下标。从 1 开始编号。取时， NULL 对 NULL， 0 对 `"` ，其他照常对。插入时可以输入字符串值或下标。若声明为 null，null值是该列首个有效值，默认值是null。声明not null默认为允许的值列表第一个元素。比较适合诸如性别选择。

有 set ，有多个成员， 1,2,3,4或8字节，取决成员数量(最多64个)。定义和存储原理类似。会自动去重。按定义顺序显示。比如插入 `'a'` ,  `'a,b,c'` 。比较适合诸如爱好选择。

实际存储长度是字符串长度+1，多出一位存长度数值

二进制字符串有 bit , (var)binary , (tiny/medium/long/)blob 。如 bit(二进制位数)，然后插入数值即可。bin函数转数字为二进制，可以用来 select 显示。多余左补 0 ，如 `b'1010'` 。因为二进制，可以存图片、音频等，但不建议这么做。

(var)binary 可以包含二进制字节。前者可右补足 `\0`



### 安装

#### windows

> 废置：官网下载 [这里](https://dev.mysql.com/downloads/windows/installer/8.0.html) ，下载安装包
>
> 选custom，然后点击右边列表的每一项，更改小字点击advance更改安装路径

 [这里](https://dev.mysql.com/downloads/mysql/) 选 No thanks 即可。下完到合适位置直接解压，就是目录了。

接下来配置：在该安装目录(如：`D:\Temps\mysql-8.0.27-winx64`)

新建文件 `my.ini` ，输入：

```ini
[mysql]
default-character-set=utf8

[mysqld]
port = 3306 
basedir=D:\Temps\mysql-8.0.27-winx64
datadir=D:\Temps\mysql-8.0.27-winx64\data
max_connections=200
character-set-server=utf8
default-storage-engine=INNODB 
```

> 对其中路径改成合适的安装路径

以管理员身份运行 cmd (`C:\Windows\System32` 里找到右击) ，进入安装目录，输入：

```shell
mysqld --remove mysql #清除原有
mysqld -install #或install
mysqld --initialize 
net start mysql
```

在安装目录的 `\data` 找到 `.err` 后缀文件，打开看到最后一行，找到初始密码。

登录：

```shell
mysql -uroot -p
```

输入初始密码。

修改密码：

```mysql
ALTER USER 'root'@'localhost' IDENTIFIED BY '新的密码';
exit; -- 退出
```

> 注意: 在 5.7 需要初始化 data 目录：
>
> ```shell
> cd C:\web\mysql-8.0.11\bin 
> mysqld --initialize-insecure 
> ```
>
> 初始化后再运行 net start mysql 即可启动 mysql



#### Linux安装

一系列应用如下：

> - **MySQL** - MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。
> - **MySQL-client** - MySQL 客户端程序，用于连接并操作Mysql服务器。
> - **MySQL-devel** - 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。
> - **MySQL-shared** - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。
> - **MySQL-bench** - MySQL数据库服务器的基准和性能测试工具。
>
> 可以使用 MariaDB 代替，MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。
>
> MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。
>
> ```shell
> yum install mariadb-server mariadb 
> ```
>
> mariadb数据库的相关命令是：
>
> ```shell
> systemctl start mariadb  #启动MariaDB
> systemctl stop mariadb  #停止MariaDB
> systemctl restart mariadb  #重启MariaDB
> systemctl enable mariadb  #设置开机启动
> ```

> rpm下卸载参考：
>
> ```shell
> rpm -e mysql　　// 普通删除模式
> rpm -e --nodeps mysql　　// 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除
> ```





## 指令

### 权限指令

#### 理论

用户分为普通和 `root`。后者可以增删改用户，普通用户一般不行。权限表由 `MYSQL_install_db` 脚本初始化。权限信息表主要有 `user,db,host,tables_priv,columns_priv,procs_priv`。

##### 权限表

在数据库 `mysql`。

###### user

记录允许连接到服务器的账户信息，全局级的权限，即有权限就能操作所有数据库。可以 `desc user;` 看表结构。

用户列包括 `Host`, `User`, `authentication_string` 表示主机名、用户名、密码(显然经过加密)。前两者是该表的联合主键。只有这三个值都匹配，才能连接建立。修改用户密码的本质是修改密码列。

权限列表明了允许的操作，字段值类型是 enum，修改权限可以直接改这个列，也可以用 `grant` 语句。

安全列有 6 个子段，两个是 `ssl` 加密，两个是 `x509` 标准用于识别用户，另外两个是授权插件相关的 (`plugin` 字段)，为空使用内部授权验证机制。通过 `show variables like 'have_openssl';` 检查是否支持 `ssl` 功能。

资源控制列，限制用户使用的资源， `max_questions` 每小时允许执行查询操作数； `max_updates` , `max_connections` (连接操作次数)，`max_user_connections` 同时建立连接数。若超出限制，会被锁定，直到下一个小时才能执行对应操作。



###### db

存储用户对某个数据库的操作权限。主键是 `host,user,db`。其中 `create_routine_priv,aalter_routine_priv` 是创建和修改存储过程的权限。host 可以为空。



###### tables_priv

对表设置操作权限。

![image-20220528180802581](img/image-20220528180802581.png)

![image-20220528180823335](img/image-20220528180823335.png)



###### columns_priv

![image-20220528182931268](img/image-20220528182931268.png)



###### procs_priv

存储过程/函数。

![image-20220528183033295](img/image-20220528183033295.png)



##### 访问控制

两个阶段：

- 连接核实阶段，即对密码
- 请求核实阶段，即查命令是否有权做



#### 登录

SHELL 命令。可以查看帮助： `mysql --help`

`mysql` 登陆命令的参数：

- `-h` 主机名，默认 `localhost`
- `-u` 用户名
- `-p` 指定登录密码或随后输入(无密码直接回车)
- `-P` 端口号
- `数据库名` 
- `-e` 执行该参数后的指令 SQL 语句并退出(输出执行结果)

如：

```shell
mysql -u root -p #或mysql -uroot -p
mysql -u root -p test_db -e "DESC person;"
```



> 使用 `mysqld -initialize` 安装 `mysql` 是安全的，因为自动为 `root` 生成标记过期的随机密码，不创建任何匿名账户和 `test` 数据库。



匿名用户：`user`表里 `user` 子段为空字符串，使得任何用户可以连接到数据库。检查是否存在并删除：

```mysql
select * from user where user='';
delete from user where user='';
```





#### 新建

首先选择一个数据库，用：

```mysql
use 数据库名;
```

> 数据库名不需要加引号；列出所有数据库用指令`SHOW DATABASES;`



命令为 

```sql
CREATE USER 用户名 IDENTIFIED BY '密码';
```

如：

```mysql
create user oj identified by 'scnunoj';
```

> 标准格式：
>
> ```mysql
> create user user_specification[,user_speci..]
> ```
>
> 其中后面的参数可以是：
>
> ```mysql
> user@host
> identified by [password] 'password'
> | identified with auth_plugin [as 'auth_string']
> ```
>
> 若选上 `password` 关键字，表示用哈希值设置密码。插件名字可以单引号或双引号。新添加的账号没有任何权限。不能跟已有账户重复。

也可以直接操作表，就插入数据的格式，即：

```mysql
insert into mysql.user(host, user, authentication_string,[权限名字,...]) values ('host','username',md5('密码'),['Y'/'N',...])
```

如：

```mysql
INSERT INTO user
	(host, user, authentication_string,
    select_priv, insert_priv, update_priv)
VALUES ('IP地址', '用户名', MD5(密码), 'Y', 'Y', 'Y')
```

> password() 加密函数已经在 8.0.11 中移除了，可以使用 MD5() 函数代替
>
> 在`5.7`以下，`authentication_string` 是 `password`

可以设置 `Y/N` 的包括：

- Select_priv
- Insert_priv
- Update_priv
- Delete_priv
- Create_priv
- Drop_priv
- Reload_priv
- Shutdown_priv
- Process_priv
- File_priv
- Grant_priv
- References_priv
- Index_priv
- Alter_priv



#### 删除

```mysql
drop user 用户名,[用户名];
```

如：

```mysql
drop user 'user'@'localhost';
drop user; -- 干掉全部
```

不能自动删掉任何打开的用户对话，删的话要等到该用户对话关闭后才会生效。

也可以：

```mysql
delete from mysql.user where host='' and user=''
```

如：

```mysql
delete from mysql.user where host='localhost' and user='baicha';
```



#### 修改

修改密码，直接改表，如：

```mysql
update mysql.user set authentication_string=md5('新密码') where user='root' and host='localhost';
```

修改后要生效，需要刷新：

```mysql
flush privileges;
```

对非 `root` 用户，修改密码可以：

```mysql
set password for 'user'@'localhost' = '密码';
```

也可以跟上面一样的改法。但无论如何都要刷新。



#### 授权

使用 grant 命令授权，撤回是 revoke。全局权限是 `grant all on *.*` ，撤回同理。数据库层级就 `on 数据库.*`，表就后者改成表名。子程序可以是全局或数据库、子程序级别的。有 grant 权限的可以执行。语法：

```mysql
grant priv_type [(columns)] [,priv_type columns...]
on [object_type] table1,...
to user [with grant option]
```

`object_type` 有 `table,function,procedure`。升级时要用就要升级授权表。若不指定 `columns` 就是全表。旧版本 `mysql` 。可以设置密码。with 后一个或多个参数：

![image-20220528192244500](img/image-20220528192244500.png)

```mysql
GRANT ALL PRIVILEGES ON 数据库名.* to 用户名@'%' IDENTIFIED BY 'scnuoj';
```

```mysql
FLUSH PRIVILEGES; # 重新加载
```

如：

```mysql
grant all privileges on scnuoj.* to oj@'%' identified by 'scnuoj';
flush privileges;
```

```mysql
-- 给指定数据库TUTORIALS添加用户 zara ，密码为 zara123 
GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
ON TUTORIALS.*
TO 'zara'@'localhost'
IDENTIFIED BY 'zara123';
```

```mysql
grant select,insert on *.* to 'grantUser'@'localhost'
identified by 'grantpwd'
with grant option;
```

```mysql
grant select(classNo,className,institute),update(classNo,className,institute) on scoredb.class to user01, user02;
flush privileges;
-- 那么这两个用户可以查和改这几个列(单独或同时)
```





##### 权限列表

![image-20220528192630499](img/image-20220528192630499.png)

可以使用的权限：

![image-20220528191315792](img/image-20220528191315792.png)

![image-20220528191322149](img/image-20220528191322149.png)

![image-20220528191533380](img/image-20220528191533380.png)

其它权限是管理性操作，用 `mysqladmin` 或 `sql` 语句：

![image-20220528191646834](img/image-20220528191646834.png)

![image-20220528191658497](img/image-20220528191658497.png)



#### 收回

revoke。从 `db,host,table_priv,columns_priv` 删除。语法：

```mysql
revoke all privileges, grant option
from 'user'@'host' [,'user'@'host'...]
```

```mysql
revoke priv_type [(columns)] [,...]
on table1, ...
from 'user'@'host' ,...
```

有全局 `create user,update` 之一的可以使用该权限。

如：

```mysql
revoke update on *.* from 'user'@'localhost';
```



#### 查询

```mysql
show grants for 'user'@'host';
```

或者查表的字段，如：

```mysql
select privileges_list from user where user='' ,  host=''
```

`privileges_list` 如 `select_priv` 等。



#### 自动换密码

8.0

设置账户密码过期时间，过期用户要连接需要更改密码。查看：

```mysql
select user,host,password_last_changed,password_lifeftime,password_expired from mysql.user \G;
```

时间为 `null` 永不过期。设置永不过期，如：

```sql
alter user root@localhost password expire default;
alter user root@localhost password expire interval 260 day; -- 260天过期
```



#### 角色

用户组。

```sql
create role role_name;
```

```mysql
grant select on db.* to role_name;
revoke select on db.* from role_name;
```

```mysql
grant role_name to user@host;
```

```mysql
select * from mysql.default_roles;
select * from mysql_role_edges; -- 用户属于什么角色
```

```mysql
drop role role_name;
```





### 数据库指令

#### 查询

显示所有数据库。

```mysql
SHOW DATABASES;
```

显示编码：

```mysql
SHOW VARIABLES LIKE 'character_set_database';
```





#### 创建

```mysql
CREATE DATABASE 数据库名;
```

可以用管理员权限在shell时创建：

```shell
mysqladmin -u 管理员帐号名 -p create 数据库名
```

已存在同名时不能创建。



变体：不存在则创建

```mysql
CREATE DATABASE IF NOT EXISTS 数据库名
```

设定编码：

```mysql
CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;
```

`utf8_general_ci` 数据库的校验规则,ci是case insensitive的缩写,意思是大小写不敏感;相对的是cs,即case sensitive,大小写敏感;

MYSQL8.0前默认字符集是 `latin1` ，`utf8` 是 `utf8mb3` ； 8.0 开始，默认编码是 `utf8mb4` 。



#### 删除

```mysql
DROP DATABASE 数据库名;
```

或shell：

```shell
mysqladmin -u 管理员帐号名 -p drop 数据库名
```

执行后会出现提示，确认是否删除。而PHP脚本删除，不会出现提示消息。

> 删除数据库对象（表、库、索引、视图等）都用 drop ，删除数据都用 delete



#### 选择

```mysql
USE 数据库名;
```

选择后，mysql指令会针对这个数据库。



### 数据表指令

#### 枚举

```mysql
SHOW TABLES;
```



#### 查看概况

```mysql
DESC 数据表名;
```

或全称：

```mysql
DESCRIBE 数据表名;
```

查看列名。

查看建表语句(跟真实输入的建表语句不一样，经过转换的)：

```mysql
SHOW CREATE TABLE 数据表名;
```

查看数据库默认编码直接查看建表语句。



可以看当前全部数据表类型：

```mysql
SHOW TABLE STATUS ;
```

查看特定库：

```mysql
show table status from 数据库;
```





其他更多指令：

```mysql
SHOW COLUMNS FROM user; #查看user数据表的所有属性
SHOW INDEX FROM user; #显示数据表的详细索引信息，包括PRIMARY KEY（主键）
SHOW TABLE STATUS from mysql; # 输出数据库性能和统计信息
SHOW TABLE STATUS from mysql LIKE 'time%';     # 表名以time开头的表的信息
SHOW TABLE STATUS from mysql LIKE 'time%'\G;   # 加上 \G，查询结果按列打印
```



#### 创建

```mysql
CREATE TABLE table_name (column_name column_type);
```

```mysql
CREATE TABLE 数据表名(`列名` 列类型, `列名` 列类型, ..., PRIMARY KEY(`主键列名`) ) ENGINE=存储引擎 CHARSET=编码 DEFAULT
```

当数据库有规定 `ENGINE, CHARSET` 时，数据表大概可以不规定

如：

```mysql
CREATE TABLE IF NOT EXISTS runoob_tbl(
   runoob_id INT UNSIGNED AUTO_INCREMENT,
   runoob_title VARCHAR(100) NOT NULL,
   runoob_author VARCHAR(40) NOT NULL,
   submission_date DATE,
   PRIMARY KEY ( runoob_id )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

- 如果不想字段为 **NULL** 可以设置字段的属性为 **NOT NULL**， 在操作数据库时如果输入该字段的数据为**NULL** ，就会报错。

- PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。单个主键可以直接在定义属性时定义(`属性 类型 PRIMARY KEY [默认值]`)，多个必须用 `PRIMARY KEY(属性,属性, ...)` (也可以加前缀 `CONSTRAINT 约束名`)

  主键的特性：非空，唯一，非必须

- AUTO_INCREMENT定义列为自增的属性，只能用于主键，数值会自动加1。

  MYSQL 5.7 自增起始值重启后会以当前 `MAX` 初始化；而 `8.0` 不会

- ENGINE 设置存储引擎，CHARSET 设置编码

- 外键约束：(约束名字不能重复)

  ```mysql
  CONSTRAINT 约束名字 FOREIGN KEY(属性1) REFERENCES 数据表名(该表属性名)
  ```

  (也可以一行属性1，属性2 一一对应)，数据类型、数据表引擎必须匹配，否则报错

  有外键约束的，不可删除被外键指向的一列；数据表也是

  也可以做表达式判定，用 `check(逻辑表达式)` ，如：

  ```mysql
  check(classNum > 0 and classNum < 50)
  constraint checkClassNum check(classNum > 0 and classNum < 50)
  ```

  如果使用了如 `sysdate()` ，那么是动态的，不是以建表时日期为准

- 唯一性约束：`UNIQUE` ，可以单独定义，也可以定义属性时定义，允许为空但只允许一次

- 默认值：`DEFAULT 值 `，定义属性时定义



#### 删除

```mysql
DROP TABLE 数据表名;
```

> 只清空数据不删掉表可以用 truncate (见数据指令-删除)



#### 查询

读取所有数据：

```mysql
SELECT * FROM 数据表名;
```

通用：

```mysql
SELECT 列名, 列名, ...
FROM 数据表名
[WHERE 从句判断] /*可选：包含任何条件*/
[LIMIT 数目] /*可选：返回记录数*/
[OFFSET 数目] /*可选：开始查询的数据偏移量，默认0*/
```

```mysql
SELECT 字段列表 FROM 数据表名
[WHERE xx] [GROUP BY 字段名] [HAVING 分组条件]
[ORDER BY ASC|DESC]
```

> **having：**用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作
>
> 顺序是这样的
>
> 1. FROM, including JOINs
> 2. WHERE
> 3. GROUP BY
> 4. HAVING
> 5. WINDOW functions
> 6. SELECT
> 7. DISTINCT
> 8. UNION
> 9. ORDER BY
> 10. LIMIT and OFFSET

如：

```mysql
select * from student;
select * from student where id=1;
select * from student where id in (1,2,3) and grade >= 10;
select name,age from tb_emp where sex="female" order by age;
```



补充：

- offset 必须在 limit 下才能用，作用为先偏移后获取不超过 limit 个

- order by 也可以用列名，之后可以加升序降序(默认升序)，可以有多个排序依据。8.0后对 group by 不再隐式排序

  按拼音排序(utf8)为例：`order by convert(列名 using gbk)`

  一个 desc 只对当前关键字起作用

- distinct 关键字取不重复值

- between and 关键字可以取区间(字符串也行)

- `%`代表任意零到多个字符，`_`是任一个字符，可以用\\转义

  需要用 like 关键字才能用(不含`%`时等效于`=`)

  需要转移时，用 `escape` ，如 `like '%16\_%' escape '\'` 。

- 可以使用能用的正则表达式，用`REGEXP`代替`=`位置即可(^$分别是开头和结尾)，也可以用 `RLIKE`

- 不等于可以用 `!=` 或 `<>`

- 使用 binary 关键字设定区分大小写；默认不区分

- 运算符`IS NULL` 当列值是`NULL`返回true；同理有`IS NOT NULL`，有`<=>`运算符，当相等或都为`NULL`返回真

  (不可以使用`=NULL`,`!=NULL`作为比较条件，恒假)

  可以用函数`ifnull(值,成真值)`将`NULL`转掉
  
- `limit [offset,] length` (或 `limit length offset of`)，第一条偏移 0 

- 比较运算符，若比较者是集合(大于一个元组)，需要用 all 或 any(some) 修饰，如 `=any, >all, !=any`。聚合函数不可以直接使用在WHERE子句中所以不能用 max,min取代。(=any 是 in, !=all 是not in)

如：

```mysql
select * from student order by grade;
select * from student order by grade desc;
select * from student_1 order by convert(major using gbk), student_number;
select distinct grade from student;
select * from student where id between 2 and 7;
select * from student where id between '2' and '7';
select * from student_1 where name like '张%' and id>5;
select * from student where binary student_name='abc';
select * from student_1 where student_number regexp "^20202005\\d{3}"; #可以再加一个$
```

> 子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。
>
> 实际可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式



#### UNION

将两个`select`结果组合到一起输出，并去重，如：

```mysql
select id from student union select id from score order by id;
```

所联合的东西必须具有一致列数。如果使用`union all` ，那么不会去重。

可以联合多个表，如：

```mysql
select * from student_2 union select * from student_3 union select * from student_4;
```

同样可以使用 `all` ，使用一次对一次生效(从左到右)

![image-20220519114408219](img/image-20220519114408219.png)



#### GROUP BY

语法：

```mysql
SELECT column_name, function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;
```

可以加上关键字`with rollup` 统计总结果(均值是总均值，累积就累积)在最后一行输出。可以设置分组列名为`coalesce(a,b,c)`，顺次判断，a空选b，b空选c

所用函数通常有：`count, sum, avg, max, min` 。聚合函数不能进行运算，如 `>80` 。聚合函数使用 `f(distinct 列名)` 先去重再计算。不去重就不填或填 all。除 `count(*)` 外所有的函数皆跳过空值，只处理非空值。

例如，统计每个人有多少条记录：

```mysql
select student_id, count(*) from score_1 group by student_id;
select student_id, avg(value) from score_1 group by student_id;
```

统计分数均值、总值和计次：

```mysql
select student_id, avg(value), sum(value), count(*) from score_1 group by student_id with rollup;
```

使得求和列名有意义（非NULL）：

```mysql
select coalesce(student_id, '统计量'), avg(value), sum(value), count(*) from score_1 group by student_id with rollup;
```

```mysql
select sum(distinct value) from infos;
```



#### JOIN

联合多表查询；可以在`SELECT,UPDATE,DELETE` 中使用，分为：

- `INNER JOIN` 内连接(等值连接)(简写为`JOIN`)，得到两表交集
- `LEFT JOIN` 左连接(获取左表所有记录，即使右表没有对应匹配的记录)(得到左表和两表)，区别在于即使右匹配不到，也会强行得到一个NULL作为结果
- `RIGHT JOIN` 右连接
- `full outer join` 全外连接，左+右

要配合联合列名的约束条件，用`on`关键字；为了区分开，通常把表名定义，然后用`a.列名` 这样的方法指出 `a` 表的列(若歧义)，如：

```mysql
SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
```

可以多表查询，如：(?处随便填点什么，#同理写个数字)

```mysql
select a.name, a.major, b.name, b.semester, c.value from 
`student_#` a join
`subject_#` b join
`score_#` c on
a.id = c.student_id and
b.id = c.subject_id and
c.value>=? and 
c.value <=? and
a.name like ? and 
a.major like ? and 
b.name like ? and 
b.semester like ?;
```



#### with

8.0

通用表表达式 CTE (Common Table Expressions) ，命名临时结果集

```mysql
with [recursive]
	cte_name [cols] as (subquery)
	[,cte_name [cols] as (subquery) ...]
select / update / delete 
-- 或诸如 insert ... with ... select
-- 或诸如 select ... where in (with ... select ...) ...
```





#### 更改

`ALTER`

增删改字段：

```mysql
ALTER TABLE 数据表名 DROP 列名;
ALTER TABLE 数据表名 ADD 列名 数据类型;
ALTER TABLE 数据表名 MODIFY 列名 数据类型;
ALTER TABLE 数据表名 CHANGE 列名 新列名 数据类型;
ALTER TABLE 数据表名 SET DEFAULT 值;
ALTER TABLE 数据表名 DROP DEFAULT;
ALTER TABLE 数据表名 DROP FOREIGN KEY 约束名;
ALTER TABLE 数据表名 ENGINE = 新数据表类型;
ALTER TABLE 数据表名 RENAME TO 数据表名; -- TO 可以不写
```

增加时可以设置位置，用`first`或`after 列名`；增加后会得到全空值。不设置就默认在最后添加。可以设置默认值，`default` 加值。(删掉就默认`NULL`)，修改时也可以用，作为调整位置。设置数据类型时可以附加约束。修改时原列名可以和新列名一样。如果本来`not null`修改时不能漏，不然会默认改成`null`允许的。`modify` 可以实现重排序。

引擎默认为 `InnoDB` ，还支持 `FEDERATED, MRG_MYISAM, MyISAM, BLACKHOLE, CSV, MEMORY, ARCHIVE, PERFORMANCE_SCHEMA` 。

如：

```mysql
alter table student add haha int first;
alter table student drop haha;
alter table student add haha int after id;
alter table student drop haha;
alter table student add haha int;
alter table student drop haha;
alter table student add haha int not null default 580;
alter table student modify haha bigint not null;
alter table student change haha xixi bigint not null;
```

```mysql
ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;
ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;
ALTER TABLE testalter_tbl ENGINE = MYISAM;
ALTER TABLE testalter_tbl RENAME TO alter_tbl;
```

> `show table status;`可以看数据表类型



#### 复制

先复制表结构：

```mysql
CREATE TABLE 新表名 LIKE 旧表名;
```

或：

```mysql
CREATE TABLE 新表名 SELECT * FROM 旧表;
```



再覆盖数据：

```mysql
INSERT INTO 新表名 SELECT * FROM 旧表名; 
```

可以部分复制并同时复制数据：

```mysql
CREATE TABLE 新表名 AS
(
    SELECT 列名, 列名 FROM 旧表名
)
```

可以改列名并同时复制数据：

```mysql
CREATE TABLE 新表名 AS
(
    SELECT 列名 AS 新名字 FROM 旧表名
)
```

如：

```mysql
create table hhh as (select id,student_name as `name` from student);
```

可以用新规则覆盖旧列名，如：

```mysql
create table hhh (id int) as (select * from student);
```



#### 计算列

通过别的列计算得到的列。定义：

```sql
col_name data_type [generated always] as (expression) [virtual | stored] [unique [key]] [comment comm] [not null|null] [[primary] key]
```

可以通过 `create table` 或 `alter table` 来搞，例如：

```sql
c int(9) generated always as ((a+b)) virtual
```





#### 检查

查看数据库的类似哈希值(long)

```mysql
checksum table 表名;
```

得到 `Checksum` 属性是 `long` ，跟其他表的作对比可以检查两表是否数据一致



#### explain

后接一条命令。如：

```mysql
explain select * from cart;
```

可以查看性能(如filtered列)。

![image-20220519182923635](img/image-20220519182923635.png)

> extra 里若有 using filesort 表明是外部排序，证明效率较低



#### 直方图

8.0

近似获得一列数据分布情况。支持等宽 singleton 和等高 equi-height 。

创建语法：

```sql
analyze table table_name [update histogram on col_name with n buckets | drop histogram on col_name]
```

buckets 默认值 100 ，合法范围是 $[1,100]$ ，取决：这列不同值数目，数据分布情况和准确性要求。存储在数据字典表 `column_statistics` 中，可以通过查询视图 `information_schema.COLUMN_STATISTICS` 访问。以 json 格式存储。`analyze` 会基于表大小自动判断是否取样，和建立什么图。可以多列。如：

```mysql
analyze table flower update histogram on yourprice with 60 buckets;
```

删除：

```mysql
analyze table flower drop histogram on yourprice；
```

直方图创建后永不更新。建立时数据读到内存，然后进行操作。为了避免 MLE ，会根据 `histogram_generation_max_mem_size` 计算读多少行数据到内存，可以用 `set` 语句设置它的值。



### 索引指令

> 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。
>
> 创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。
>
> 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。
>
> 所有引擎支持每个表至少 16 个索引，总长度至少 256 byte 。类型有 btree 和 hash 。myisam 和 innodb 只支持 btree , memory / heap 可以同时支持。
>
> 普通索引可以重复和null。唯一索引可以null但不可以重复。组合索引那么组合值必须唯一。主键索引不能null。全文索引是 fulltext 类型，在定义的列上全文查找，允许重复和空，可以在 char, varchar, text 里，只有 myisam 支持。空间索引有  geomerty, point, linestring, polygon ，使用 spatial 关键字拓展，使得能用个创建正则索引类似的语法创建空间索引；必须是 not null 和 myisam 。
>
> 经验原则：不要太多以影响磁盘 IO ，避免在常更新的表设很多，数据小的不要设，条件表达式经常用的且取值范围大的可以设，频繁排序和分组的可以设，唯一性可以设。

#### 普通索引

##### 创建

```mysql
CREATE INDEX indexName ON table_name (column_name);
```

> 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。

建表时添加的详细为：

```mysql
create table name [col_name data_type] 
[unique|fulltext|spatial] [index|key] [index_name] (con_name [length]) [asc|desc]
```

> index 和 key 是同义词。索引长度只对字符串类型能用。默认 col_name 为索引值。 8.0 支持降序排序(5.7实际创建还是升序的)

添加索引：

```mysql
ALTER table tableName ADD INDEX indexName(columnName)
```

创建时指定：

```mysql
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
INDEX [indexName] (username(length))  
 
);  
```

> 升序索引比降序索引效率高

如：  

```mysql
index(bookNo)
unique index uniqIdx(bookNo)
index(bookNo, readerNo)
fulltext index idx2(info)
```



##### 删除

```mysql
DROP INDEX [indexName] ON mytable; 
```

或

```mysql
ALTER TABLE testalter_tbl DROP INDEX c;
```



#### 唯一指引

索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。指令如下：

```mysql
CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
```

```mysql
ALTER table mytable ADD UNIQUE [indexName] (username(length))
```

```mysql
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
UNIQUE [indexName] (username(length))  
 
);  
```



#### 修改

有四种方式来添加数据表的索引：

- **ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):**

  该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。

- **ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):** 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。

- **ALTER TABLE tbl_name ADD INDEX index_name (column_list):** 添加普通索引，索引值可出现多次。

- **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。

如：

```mysql
ALTER TABLE testalter_tbl ADD INDEX (c);
ALTER TABLE testalter_tbl DROP INDEX c;
```

主键作用于列上（可以一个列或多个列联合主键），添加主键索引时，你需要确保该主键默认不为空（NOT NULL）

```mysql
ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;
ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
ALTER TABLE testalter_tbl DROP PRIMARY KEY;
```



#### 显示

```mysql
SHOW INDEX FROM 数据表名
```

> 可以加\G以列表而不是表格来显示结果

也可以查看建表来看 `show create table 表名 \G`

![image-20220519183246250](img/image-20220519183246250.png)



### 数据指令

#### 插入

```mysql
INSERT INTO 数据表名 (列名1, ...) VALUES (值1, ...);
```

如：

```mysql
INSERT INTO runoob_tbl
(runoob_title, runoob_author, submission_date)
VALUES
("学习 MySQL", "菜鸟教程", NOW());
```

```mysql
insert into tb_emb values(2,'lr580','啊','啊啊');
```

对有自增主键的，列里可以不包含这个列；没定义 `not null` 的也可以缺省

为了防止中文乱码，可以事先设置：

```mysql
set names utf8;
```

可以一次插入多个行，逗号隔开，多条记录一个语句插效率更高，如：

```mysql
insert into student (student_name, grade) values ('abc',3),('aBC',4);
```

其实可以插入值`NULL`

如果列按顺序来且都有赋值，第一个括号可以不要，如：

```mysql
insert into student values (14,'aaa',55);
```

可以用 `ignore` 关键字，无则插有则忽略(但warning)。可以用 `replace into` ，无则插有则换。如：

```mysql
replace into student values (7,'qwq',666);
insert ignore into student values (7,'qwq',666);
```

如果插入多个时，其中一个出错(比如重复主键(跟已有或输入的多个重复))，整个语句打断，一条插入也不执行。

可以将查询结果批量插入，如：(见数据表指令-复制)

```mysql
insert into test2 select * from test;
```





#### 更新

```mysql
UPDATE 数据表名 SET 字段名 = 新字段值 WHERE 条件表达式
```

可以逗号分隔，更改多列

可以自增自减

如：

```mysql
update tb_emp set age = 24 where id = 2;
update student set student_name='www',grade=123 where id=7;
update student set grade=grade-1 where id=7;
```

可以多表查然后更改：

> ```mysql
> update t1,t2 set t1.v=t2.v where t1.id=t2.id;
> ```



#### 删除

```mysql
DELETE FROM 数据表名 WHERE 条件表达式
```

如：

```mysql
delete from tb_emp where id = 1024;
```

> 如果没有`where` 子句就是删掉整个表。
>
> delete，drop，truncate 都有删除表的作用，区别在于：
>
> -  1、delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除
> -  2、delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚(不记日志)
> -  3、执行的速度上，**drop>truncate>delete**
>
> truncate 约等于 drop + create ，变为初始大小。delete 删了之后数据表大小不变。



### 视图指令

视图：虚表，不存数据，只存定义。建视图不会随着关闭 CLI 而删除。

#### 创建

不执行查询指令，创建跟查询相同定义的视图

```mysql
create view 视图名 as 查询指令;
```

通用格式：

```mysql
create view 视图名 [(列名[,列名……])] as 子查询 [with check option]
```

详细：

```sql
create [on replace] [algorithm = {undefined | merge | temptable}] view view_name [cols] as select_statement [with [cascade | local] check option]
```

如果 `with check option` ，那么增删改必须满足创建时的条件。如果增改了不符合条件的元素，那么查询时查不出来。

列名不定义就跟查询得到的一样。但若目标列是聚集函数或表达式、多表连接同列名时必须写列名。(select 处定义也行)

> replace 表示替换已存在的，需要有 drop 权限。算法分别表示自动选择、试图语句与试图定义合并(定义的某一部分取代语句对应部分)、存入临时表然后用临时表执行语句。cascade 默认，更新时满足相关条件，local满足视图条件即可。
>
> 跨选择的数据库建视图要作用域，如 `db_name.view_name` 

视图的常用功能之一是计算一些由数据库基本信息计算得出的信息，如出生日期计算年龄

> 基于保留主码基本表的视图是行列子集视图；视图可建立在多个基本表，或视图上

> 如：
>
> ```mysql
> CREATE VIEW ScoreView
> AS
>       SELECT a.studentNo, studentName, courseName, creditHour, score
>       FROM Student a, Course b, Score c
>       WHERE a.studentNo=c.studentNo AND b.courseNo=c.courseNo
>              AND score>=60     -- 成绩必须大于等于60分才能获得学分
> ```
>
> ```mysql
> CREATE VIEW SourceView(courseNo, courseName, courseCount, courseAvg)
> AS
>       SELECT a.courseNo, courseName, count(*), avg(score)
>       FROM Course a, Score b
>       WHERE a.courseNo=b.courseNo
>       GROUP BY a.courseNo, courseName
> ```
>
> 上例也可以在 select 取名，不在一开始取，即：
>
> ```mysql
> SELECT a.courseNo, courseName, count(*) courseCount, avg(score) courseAvg
> ```
>
> ```mysql
> CREATE VIEW SourceView2
> AS SELECT * FROM SourceView WHERE courseCount>=5
> ```



#### 查询

等价于把查询条件和视图条件融合起来再查基本表。 (视图消解)

对聚合函数的运算，会被消解为 having 。如：

> ```mysql
> SELECT * FROM SourceView WHERE courseAvg>=80
> ```



#### 更新

通过视图来直接增删改及本表数据。如果创建视图的语句中包含了表达式，或聚合运算，或消除重复值运算，则不能对视图进行更新操作(一般行列子集视图可以更新，其他类型的一般不更新)。不建议对视图更新。语法同数据指令。

更新字段可以 `create or relpace view` 或 `alter` 。如：

```mysql
create or replace view view_t as select * from flower;
```

或 alter ：

```mysql
alter view view_t as select * from flower;
```



#### 删除

```mysql
drop view 数据表名 [cascade]
```

cascade 是级联删除，选中时，若该视图导出了其他视图，一并删除。

删除基本表时，由该基本表导出的所有视图都必须显式地使用DROP VIEW语句删除。



#### 查看

可以 `describe` / `desc`。也可以 `show table statuc like 'view_name' \G` 。也可以 `show create view view_name \G` 。也可以看系统表：

```mysql
select * from infomation_schema.views;
```





### 事务指令

#### 事务理论

> - 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
> - 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
> - 事务用来管理 insert,update,delete 语句
>
> 一般来说，事务是必须满足4个条件（ACID）：：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）
>
> - **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
> - **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
> - **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
> - **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失
>
> 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交
>
> 8.0 InnoDB 支持 DDL 事务完整性， DDL 操作要么成功要么回滚，后者写入日志到 `data dictionary` 数据字典隐藏表 `mysql.innodb_ddl_log` 。通过设置参数可以将 DDL 操作日志打印输出到错误日志中。意思是执行到一半发现报错的指令，会全部撤销掉，而不是一半执行一半不执行。 

查看支持事务操作的引擎：

```mysql
show engines;
```

查看一个表的引擎：

#### 事务控制

- BEGIN 或 START TRANSACTION 显式地开启一个事务；
- COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；
- ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
- SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；
- RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；(但是不会回滚)
- ROLLBACK TO identifier 把事务回滚到标记点；
- SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

处理事务的两种方法：

1、用 BEGIN, ROLLBACK, COMMIT来实现

- **BEGIN** 开始一个事务
- **ROLLBACK** 事务回滚
- **COMMIT** 事务确认

2、直接用 SET 来改变 MySQL 的自动提交模式:

- **SET AUTOCOMMIT=0** 禁止自动提交
- **SET AUTOCOMMIT=1** 开启自动提交

> 使用`savepoint`必须关

例如：

```mysql
begin;
insert into score values(5);
# 当前生效，但不永久生效；
insert into score values(6);
commit;
select * from score;
begin;
insert into score values(7);
rollback;
select * from score;
```

```mysql
set autocommit=0;
begin;
insert into score values(5);
savepoint svp;
select * from score;
insert into score values(6);
rollback to svp;
select * from score;
insert into score values(7);
release savepoint svp;
commit;
```



### 操作指令

暂时不会分类的东西

#### 临时表

> 临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表
>
> 临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间；使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁

创建数据表时，增加关键字 `TEMPORARY` 即可，其他操作基本是一样的；特别的，`show tables;` 不会看到临时表；可以用 `drop table` 手动删除，不过退出时会自动删除的

如：

```mysql
CREATE TEMPORARY TABLE SalesSummary (
    product_name VARCHAR(50) NOT NULL,
    total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00,
    avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00
    ,total_units_sold INT UNSIGNED NOT NULL DEFAULT 0
);
```

可以查询时创建：

```mysql
CREATE TEMPORARY TABLE 临时表名 AS
(
    SELECT *  FROM 旧的表名
    LIMIT 0,10000
);
```



#### 元数据

以下命令语句可以在 MySQL 的命令提示符使用，也可以在脚本中 使用，如PHP脚本。

| 命令               | 描述                      |
| :----------------- | :------------------------ |
| SELECT VERSION( )  | 服务器版本信息            |
| SELECT DATABASE( ) | 当前数据库名 (或者返回空) |
| SELECT USER( )     | 当前用户名                |
| SHOW STATUS        | 服务器状态                |
| SHOW VARIABLES     | 服务器配置变量            |

后两个很长；user是`名@IP`，如：`root@localhost`



#### 序列

即自增 `auto_increment` 。

使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。

要重置这个值需要删掉该列再加入，但是需要谨防数据混乱。

默认值起始为1，修改的话建表的时候`auto_increment=起始值`即可，或：

```mysql
ALTER TABLE t AUTO_INCREMENT = 100;
```



#### 重复处理

在 MySQL 数据表中设置指定的字段为 **PRIMARY KEY（主键）** 或者 **UNIQUE（唯一）** 索引来保证数据的唯一性

可以尝试双主键：

```mysql
CREATE TABLE person_tbl
(
   first_name CHAR(20) NOT NULL,
   last_name CHAR(20) NOT NULL,
   sex CHAR(10),
   PRIMARY KEY (last_name, first_name)
);
```

或 UNIQUE 索引：

```mysql
CREATE TABLE person_tbl
(
   first_name CHAR(20) NOT NULL,
   last_name CHAR(20) NOT NULL,
   sex CHAR(10),
   UNIQUE (last_name, first_name)
);
```



如果我们设置了唯一索引，那么在插入重复数据时，SQL 语句将无法执行成功,并抛出错。

INSERT IGNORE INTO 与 INSERT INTO 的区别就是 INSERT IGNORE INTO 会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。如：

```mysql
INSERT IGNORE INTO person_tbl (last_name, first_name)
VALUES( 'Jay', 'Thomas'), ( 'Jay', 'Thomas');
```

插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而 REPLACE INTO 如果存在 primary 或 unique 相同的记录，则先删除掉。再插入新记录。



统计重复：

```mysql
SELECT COUNT(*) as repetitions, last_name, first_name
FROM person_tbl
GROUP BY last_name, first_name
HAVING repetitions > 1;
```



选择时读取不重复数据，加入`distinct`，如：

```mysql
SELECT DISTINCT last_name, first_name FROM person_tbl;
```

或用`group by`列，如：

```mysql
SELECT DISTINCT last_name, first_name FROM 
GROUP BY (last_name, first_name);
```

数据表去重，先建一个表，插入选中的所有去重后元素，然后删掉原表，然后这个表改名为原表名，或单纯增加一下主键，如：

```mysql
ALTER IGNORE TABLE person_tbl
ADD PRIMARY KEY (last_name, first_name);
```



#### 手动报错

如：

```mysql
signal sqlstate 'HY000' set message_text = '不允许插入';
```



#### 注入

1. 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双"-"进行转换等。
2. 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。
3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
4. 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。
5. 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装
6. sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。







### 其他指令

看不到的可以看基本-使用章节或基本

#### 导出

##### SQL格式

```shell
mysqldump -uroot -p 数据库名 数据表名 > 输出文件名.sql
mysqldump -uroot -p 数据库名 数据表名,表名2,... > 输出文件名.sql
mysqldump -uroot -p 数据库名 > 输出文件名.sql
mysqldump -uroot -p --databases 库名,库名.. > 输出文件名.sql
mysqldump -uroot -p --all-databases > 输出文件名.sql #含系统数据库
```

> 或 `-p密码` ，这种方法通常用于非输入式。注意文件名所在的目录要存在。

如：

```shell
mysqldump -uroot -p javase > test.sql
mysqldump -uroot -p javase score > test.sql
mysqldump -uroot -p javase s1, s2 > test.sql
```

可以 `-P端口 -hIP` , `-u用户名 -p密码` 的方式导出非本地数据库如：

```shell
mysqldump -uroot -p -P3306 -h127.0.0.1 went > abcc.sql
```

> 可以用 `--tab=路径`，如：
>
> ```shell
> mysqldump -u root -p --no-create-info
> --tab=/tmp RUNOOB runoob_tbl
> ```

输出的文件 `.sql` 实质是指令集，执行后能够得到与之一样的数据库格式和数据，会在注释里表明工具版本号、备份账号名称、主机信息、数据库名、服务器版本号。会看到格式为诸如 `/*!40101 set @a=1*/;` 的语句，这些语句会被 `mysql` 执行，其他DBMS当成注释。意思是当且仅当版本号不小于那个数字时执行。`@@` 是系统变量，不能够自己新建。



##### 文本格式

也可以上指令：在`select`时`into outfile '路径'`

在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。(具体见下)

```mysql
SELECT a,b,a+b INTO OUTFILE '/tmp/result.text'
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
LINES TERMINATED BY '\n'
FROM test_table;
```

- LOAD DATA INFILE是SELECT ... INTO OUTFILE的逆操作，SELECT句法。为了将一个数据库的数据写入一个文件，使用SELECT ... INTO OUTFILE，为了将文件读回数据库，使用LOAD DATA INFILE。
- SELECT...INTO OUTFILE 'file_name'形式的SELECT可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。
- 输出不能是一个已存在的文件。防止文件数据被篡改。
- 你需要有一个登陆服务器的账号来检索文件。否则 SELECT ... INTO OUTFILE 不会起任何作用。
- 在UNIX中，该文件被创建后是可读的，权限由MySQL服务器所拥有。这意味着，虽然你就可以读取该文件，但可能无法将其删除

> 在写出的时候会出现The MySQL server is running with the --secure-file-priv option so it cannot execute this statement的错误解决方法：
>
> 出现这个错误是因为没有给数据库指定写出文件的路径或者写出的路径有问题。
>
> 首先使用下面的命令 **show variables like '%secure%';** 查看数据库的存储路径。如果查出的 secure_file_priv 是 null 的时候就证明在 my.ini 文件里面没有配置写出路径。
>
> 这时候就可以在 mysql.ini 文件的 [mysqld] 代码下增加 secure_file_priv=E:/TEST 再重启 mysql 就可以了。然后在导出的地址下面写上刚才配置的这个地址 eg: **select \* from tb_test into outfile "E:/TEST/test.txt"；**就可以了。



> 若在服务器上备份且表都是 `myisam`，应该考虑使用 `MYSQLhotcopy`。
>
> ```shell
> mysqlhotcopy db_name_1, .... /path/new_directory
> ```
>
> 如：
>
> ```shell
> pysqlhotcupy -u root -p test /usr/backup
> ```
>
> 需要有 `select,reload(即flush tables),lock table` 权限。本质是将表所在目录复制到另一个位置，只适用于 `myisam,archive`，也不能跨操作系统。

> 也可以暴力复制备份，如对 windows，在 `C:\Documents and Settings\All Users\Application Data\MYSQL\MYSQL Server 8.0\data` 或用户自定义，对 linux 在 `/var/lib/MYSQL/` 具体情况具体分析，直接复制。需要版本相同。主版本号(第一个数字)相同的话，数据库文件格式相同。
>
> 保持备份一致性，要备份前执行：
>
> ```mysql
> lock tables;
> flush tables;
> -- 或者：
> flush tables with read lock;
> ```
>
> 这样复制时允许用户查询；flush 作用是确保备份前所有激活的索引页写入硬盘。



单表

```mysql
select ... into outfile 'filename' [option];
```

将一个查询语句结果导出到外部文件。默认`\t`分割，`\n`换行，`NULL`得`\N`。选项有：

![image-20220529160802020](img/image-20220529160802020.png)

`files` 和 `lines` 都有时，前者必须在前面。一般是在服务器用的，客户端只能用这样的形式调用：

```shell
mysql -e "select ... > file_name"
```

导出的可以用 `load data infile` 导入。

导出的目录有权限限制，可以查看：

```mysql
show global variables like '%secure%';
```

要自定义导出路径需要修改 `my.ini` ，如注释掉 `secure-file-priv` 行，添加 `secure-file-priv="D:/"` 来修改。

如：

```mysql
select * from db1.tb1 into outfile 'D:/abc.txt';
select * from d.t into outfile 'D:/abc2.txt'
fields terminated by ',' enclosed by '\"' escaped by '\''
lines terminated by '\r\n';
```

 

也可以用 `MYSQLdump`，指定 `-T` 参数和选项，那么多导出一个 `txt`：

![image-20220529161857041](img/image-20220529161857041.png)

如：

```shell
mysqldump -T D:\ test_db person -u root -p
mysqldump -T D:\ test_db person -u root -p --fields-terminated-by=, --fields-optionally-enclosed-by\" --files-escaped-by? --lines-terminated-by=\r\n
```

也可以用 `mysql -e 语句`，如：

```shell
mysql -u root -p --execute="select * from abc;" dbname > filename.txt
```

 输入 `--vertical` 输出显示结果。输入 `--html` 导出为 `html` 格式文件，得到一张表格。也可以用 `--xml` ，得到 `resultset,row,field`等子段。



#### 导入

##### 创建数据库

`mysqladmin -h 端口号 -u 用户名 -p密码 create 数据库名`

也可以输入密码的方式，下同

如：

```shell
mysqladmin -h 127.0.0.1 -u root -p1437580 create test
```



##### 导入数据表

`cmd /c mysql -h 端口号 -u 用户名 -p密码 < 文件名.sql`

> cmd /k在执行命令后不关掉命令行窗口 cmd /c在执行完命令行后关掉命令行窗口 

如：

```shell
mysql -h 127.0.0.1 -u root -p1437580 test < tb_thu.sql
```

数据库主版本号相同可以直接迁移，如：

```shell
mysqldump -h www.bac.cm -uroot -ppassword dbname |
mysql -h www.bcd.com -uroot -ppasword
```

> 旧升新好升，新降旧比较麻烦。
>
> windows 下可以用 `MyODBC` 实现 `MySQL` 和 `SQL Server` 迁移。官方工具 `MYSQL Migration Toolkit` 也可以做迁移。



##### source

source 命令导入数据库需要先登录到数库终端：

```mysql
create database abc;      # 创建数据库
use abc;                  # 使用已创建的数据库 
set names utf8;           # 设置编码
source /home/abc/abc.sql  # 导入备份数据库
```



##### load data

MySQL 中提供了LOAD DATA INFILE语句来插入数据。通用格式：

```mysql
load data infile 'filename.txt' into table tablename [option] [ignore number lines]
```

ignore 是忽略头多少行。

以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。

```shell
mysql> LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl;
```

如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。

你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。

两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。

如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。

```mysql
LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl
FIELDS TERMINATED BY ':'
LINES TERMINATED BY '\r\n';
```

LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。

如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下：

```mysql
LOAD DATA LOCAL INFILE 'dump.txt' 
INTO TABLE mytbl (b, c, a);
```



##### mysqlimport

mysqlimport 客户端提供了 LOAD DATA INFILEQL 语句的一个命令行接口。不需要登录 mysql 客户端。mysqlimport 的大多数选项直接对应 LOAD DATA INFILE 子句。 

从文件 dump.txt 中将数据导入到 mytbl 数据表中, 可以使用以下命令：

```shell
mysqlimport -u root -p --local mytbl dump.txt
```

mysqlimport 命令可以指定选项来设置指定格式,命令语句格式如下：

```shell
mysqlimport -u root -p --local --fields-terminated-by=":" --lines-terminated-by="\r\n"  mytbl dump.txt
```

mysqlimport 语句中使用 --columns 选项来设置列的顺序：

```shell
mysqlimport -u root -p --local --columns=b,c,a mytbl dump.txt
```

------

mysqlimport的常用选项介绍

| 选项                         | 功能                                                         |
| :--------------------------- | :----------------------------------------------------------- |
| -d or --delete               | 新数据导入数据表中之前删除数据数据表中的所有信息             |
| -f or --force                | 不管是否遇到错误，mysqlimport将强制继续插入数据              |
| -i or --ignore               | mysqlimport跳过或者忽略那些有相同唯一 关键字的行， 导入文件中的数据将被忽略。 |
| -l or -lock-tables           | 数据被插入之前锁住表，这样就防止了， 你在更新数据库时，用户的查询和更新受到影响。 |
| -r or -replace               | 这个选项与－i选项的作用相反；此选项将替代 表中有相同唯一关键字的记录。 |
| --fields-enclosed- by= char  | 指定文本文件中数据的记录时以什么括起的， 很多情况下 数据以双引号括起。 默认的情况下数据是没有被字符括起的。 |
| --fields-terminated- by=char | 指定各个数据的值之间的分隔符，在句号分隔的文件中， 分隔符是句号。您可以用此选项指定数据之间的分隔符。 默认的分隔符是跳格符（Tab） |
| --lines-terminated- by=str   | 此选项指定文本文件中行与行之间数据的分隔字符串 或者字符。 默认的情况下mysqlimport以newline为行分隔符。 您可以选择用一个字符串来替代一个单个的字符： 一个新行或者一个回车。 |

mysqlimport 命令常用的选项还有 -v 显示版本（version）， -p 提示输入密码（password）等

![image-20220529163124940](img/image-20220529163124940.png)



##### hotcopy

用 `MYSQLhotcopy` 备份后的恢复，在服务器停止运行时，直接复制、给权限和重启即可，如：

```shell
chown -R abc.sql /var/lib/mysql/dbname
cp -R /usr/backup/abc usr/local/mysql/data
```

若数据库已存在，先删掉。注意版本必须兼容。



#### 查询

##### 引擎

系统表类型：

```mysql
select distinct(engine) from information_schema.tables;
```



##### 警告

```mysql
show warnings;
```



#### 配置

##### 全局设置

###### 时区

例如： `set time_zone='+10:00'`  设置为东十区



###### 编码

在 `my.ini` ，找到 `default-character-set` , `character-set-server` ，改为想要的，如 `gbk, gb2312, latin1` ，然后重启。

查询： `show variables like 'character_set_%'` 

临时修改，如： `set names utf8;`



##### 严格模式

非严格模式不会理字符串越界。



### 函数指令

#### 内置

> 可以见 [列表](https://www.runoob.com/mysql/mysql-functions.html)
>



常用：数学函数、字符串函数、日期和时间函数、聚合函数和系统函数等

##### 数学

有 `abs, pi, sign` 。

有 `sqrt` ，负数返回 null 。`mod(x,y)` 返回 $x\bmod y$ ，可以是小数

有 `ceil` / `ceiling` ，不小于目标的最小整数 (bigint) 和 `floor` 。

有 `rand(种子)` 取随机数 $[0,1]$ 

`round(x,y)` 返回最接近 $x$ 的保留小数点后 $y$ (若负则前) $y$ 位。四舍五入。truncate 参数同理，截断小数部分。

有 `pow` / `power` ，有 `exp` ，输出常数则 `exp(1)` 。有 `log` (以 $e$ 为底)，有 `log10` 。负数返回 null 。

有 `radians` ， `degrees` 。用弧度制有六种三角函数。超出值返回 null 。

`conv(n, base1, base2)` 进制转换，从 base1 到 base2 。英文用大写。基数范围 $[2,36]$

`inet_aton(expr)` 将 4 或 8 位地址转换为十进制数。如 `inet_aton('192.168.1.1')` 。反函数是 `inet_ntoa` 。

窗口函数(传入集合，返回多行结果)，8.0 新增，如 rank 。按升序排序，使用举例：

```mysql
select *,rank() over w1 from infos window w1 as (order by value);
select *,(value/sum(value) over()) from infos; -- 求百分比
```



##### 字符串

求长度 `char_length` ，中文算 1 。而用 `length` 的话，中文算 3 。

合并 `concat(s1, s2, ...)` 。存在 null 就 null。存在二进制就变二进制。用 `concat_ws(sep, s1, s2, ...)` ，在两两之间添加分割符 (with separator)

替换 `insert(s1, x, len, s2)` 将 s1 从 x 开始的长为 len 被取代。若 x 超过越界返回原始，下标从 1 开始，若大于从 x 开始。如 `insert('quest',2,4,'what)='qwhat'` , `insert('quest',-1,4,'what)='quest'` , `insert('quest',3,100,'what)='quwhat'` , `insert('jinle',4,1,'sangze')='jinsangzee` 

大小写转换， `lower` 或 `lcase` ； `upper` 或 `ucase` 。希腊字母也行。

取长为 n 的前/后缀 `left(s,n)` , `right(s,n)` 

填充 `lpad(s1, len ,s2)` , 将 s1 长度变为 len ，不足部分用 s2 填充。如 `lpad('xingyue',10,'xo')='xoxxingyue'`  , `rpad('xingyue',5,'qwq')=lpad('xingyue',5,'qwq')='xingy'` 

删除空白字符 `ltrim, rtrim, trim` 。可以 `trim(s1 from s)` ，把 s 里的首尾 s1 全部干掉。

字符串乘法 `repeat(s,n)` 。用 `space(n)` 等于 `repeat(' ',n)` 。

字符串替换 `replace(s,s1,s2)` , 用 s2 替换 s 里所有 s1 子串。不会递归下去。

字典序比较 `strcmp` ，返回 $\pm1$ 或 $0$ 

获得子串 `substring(s,n,len)` ，从 n 开始(负的语法同 python),len越界就本来长度有多长算多长。同名函数是 `mid` 。若 len 小于 1 得到空串。

匹配子串开始的位置 `locate(substr, str), position(subs in str), instr(str, substr)` 。找不到返回 0 。

转置 `reverse` 。

`elt(n, s1, s2, s3, ...)` 返回 `sn` 。越界返回 null 。

`fleld(s, s1, s2, ..., sn)` 返回 s 第一次出现的位置 i 。找不到得 0 。

`find_in_set(s1, s2)` 等效于上面，其中 `s2=concat_ws(',',s1,s2,...,sn)` 。所以 `s1` 不要有逗号。

`make_set(x,s1,s2,...,sn)` ，按二进制枚举用 `,` 拼接选出来的字符串，可以是空串。其中最小位代表 s1

转换编码 `convert(str using 编码集)` 如 `convert('abc' using latin1)`

格式化 `format(x,n)` 将数字 x 四舍五入保留 n 位返回字符串。若 n 为 0 不含小数部分。注意每个三位输出一个逗号。如 `format(1e9,2)`

查询分组拼接：`group_concat(key)` ，如：

```mysql
select value,group_concat(`key`) from infos group by value;
```





##### 时间

now 是当时的年月日时分秒

current\_time 或 curtime 是当时的时分秒。同理年月日替换为字 date

还有 `current_timestamp, localtime, sysdate` 。

`unix_timestamp(date)` ，无参数返回 now 与 `1970-01-01 00:00:00 GMT` 的秒数差。GMT是 green wich mean time 格林尼治标准时间。跟这个时间作差。`from_unixtime(date)` 就是时间戳转时间，可以传入字符串/数值。其实这两个就是两种格式互转。

`utc_date()` 返回 UTC (世界标准时间)格式日期值，返回当前时区日期值。

用 `month, monthname` 截取 date 。值域是 $[1,12]$ 或英文全名(首字母大写)；用 `dayname,dayofweek,weekday` 取 $[1,7]$ 或全名，或周索引 $[0,6]$ ；用 `week,weekofyear` 获取一年中的第几周， week 第二个参数：

![image-20220518202055242](img/image-20220518202055242.png)

默认为 0 ；天数用 `dayofyear, dayofmonth` ，一年中的第几天。

year 获取年份，值域 $[1970,2069]$ 。 quarter 返回 $[1,4]$ ， minute(time) 返回 $[0,59]$ ， second 同理。

`extract(type from date)` 用类型获取日期的某个值，如 `extract(year from '2018-07-02')` 。参数有 `year, year_month, day_minute` (时分秒)

`time_to_sec` 返回时间的秒数。反函数 `sec_to_time` 。

日起运算 `date_add, adddate, date_sub, subdate, addtime, subtime, date_diff`  。对 `date_add(date, interval expr type)` ，date 是起始值，expr 表达式，type 关键字。

![image-20220518202657628](img/image-20220518202657628.png)

![image-20220518202704401](img/image-20220518202704401.png)

例如：`date_add('2010-12-31 23:59:59', interval 1 second)` , `date_add('2010-12-31 23:59:59', interval 1:1 minute_second)` 。 add 放负数也可以。或者粗暴一点， `addtime(date, expr)` ，如 `addtime('02:02:02', '02:00:00')` 。而 `datediff` 计算日期的间隔天数。

格式化：`date_format(date, format)` 

![image-20220518204702276](img/image-20220518204702276.png)

同理有 `time_format` 。可以用 `get_format(type, area)` 表示某个地区显示的格式，即根据表的第一项(不用引号)和第二项(要)查第三项：

![image-20220518205341135](img/image-20220518205341135.png)

![image-20220518205348783](img/image-20220518205348783.png)



##### 条件判断

`if(expr, v1, v2)` ，为真返回 `v1` ，否则 `v2` 。`ifnull(v1,v2)` 。

`case expr when v1 then r1 [when v2 then r2] ... [else rn] end` ，具体返回字符串还是数值看需要用到处的运算。



##### 系统

`version()` ，如 `8.0.27` 。

`connection_id()` 当前连接 id 整数。

`processlist` 连接数和所有链接状态，前 100 条(`full processlist` 可以全部)。只有 root 能看到全部，一般用户看到自己。如果不行，用 `select * from information_schema.processlist;` 

![image-20220518210337407](img/image-20220518210337407.png)

`database()` 当前数据库名。可能是 null 。 `schema()`  同。

`user(),current_user,current_user(),system_user(),session_user()` 获取用户名。格式是 `主机名字@IP` 如 `root@localhost`

`charset(str)` 获得当前字符串所用字符集。`collation(str)` 返回排列方式。

`last_insert_id()` 最后生成的 `auto_increment` 。一个语句插入多条时，以第一条为准。与表无关。

`get_lock(str, timeout)` 给字符串 str 名字加 timeout 秒的锁，成功得到 1 ，超时得到 0 ，错误得到 null 。 `release_lock(str)` 或连接断开断开这个锁，前者锁被解开返回 1，没有创建锁返回0，不存在这个所返回null。提前解开或未get过就是不存在。`is_free_lock(str)` 检查名为 str 的锁是否可用(未被封锁)，可用返回 1，被占用返回 0，其他返回 null 。`is_used_lock(str)` 同理，但被封锁返回用锁客户端的connection ID，否则返回 null

`benchmark(count, expr)` 执行 count 次 expr 。返回值是运行时间(客户端时间，而不是服务端CPU时间)，通常是 0 。

`cast(x as type)` 或 `convert(x, type)` 进行类型转换。type 有 `binary, char(n), date, time, datetime, decimal, signed ,unsigned` 。如 `cast(100 as char(2))`



##### 加密

在 8.0 新增 

一般都传入 null 得 null

`md5(str)` 进行 MD5 128比特校验和，以32位十六进制二进制字符串返回

`sha(str)` 返回格式一样

`sha2(str, hash_length)` ，第二个参数支持 `224,256,384,512,0` ，其中 0=256

`aes_encrypt(src,pwd), aes_decrypt`，正常查看加密后的显示是一段乱码或十六进制数字。解码得到十六进制数字。





#### 存储过程

是一条或多条 SQL 语句集合，类似批处理。

```sql
create procedure sp_name ([proc_parameter]) [characteristics ...] routine_body ;
```

参数列表形式如下：

```mysql
[in | out | inout] param_name type
```

存储过程特性 characteristics 取值如下：

- `language sql` 由 SQL 语句组成
- `[not] deterministic` 存储过程执行结果是否是确定的(同一输入得到同一输出)，默认 not 
- `[contains sql | no sql | reads sql data | modifies sql data]` 子程序限制。依次是：
  - 包含 SQL 但不包含读写数据。默认
  - 不包含 SQL
  - 包含读数据
  - 包含写数据
- `sql security {definer | invoker}` 有权限执行者，定义者或有权调用者。默认前者。
- `comment 'string'` 注释

routine body 用 `begin` , `end` 开始和结束。

使用 `delimiter` 符号修改结束符，避免存储过程 `;` 与语义 `;` 冲突，将其换为别的。一般不用 `\` ，其他随便用。

不支持修改代码，想修改只能删掉重写。函数同。可以调用其他存储过程，但不能 drop  其他存储过程。中文阐述建议规定字符集，如：

```mysql
create procedure userinfo(in u_name varchar(50) character set gbk, out u_age int)
```

如：

```mysql
delimiter $
create procedure AvgPrice ()
begin
select avg(`yourprice`) as `AvgPrice` from `flower`;
end$
delimiter ;
call AvgPrice(); -- 调用
drop procedure AvgPrice; -- 删除
```

调用通式是 `call dbmane.procname` ，即可能跨库调用。IO 示例如下：

```mysql
delimiter //
create procedure countgt (in pr int, out num int)
begin
select count(*) into num from flower where yourprice >= pr;
end //
delimiter ;
call countgt(100, @tmp);
select @tmp;
```



#### 自定义函数

本质上都是存储程序。区别在于 return 与否，以及限制的多寡。例如函数不能用临时表，只能用表变量，一些函数不可用，但是可以嵌入到 sql 语句内使用。

```sql
create function func_name ([func_parameter])
returns type [characteristics ...] routine_body
```

默认参数总是 in 。函数体必须包含 `return value` 语句。

可以显示当前是否允许不指定特性：

```mysql
show variables like 'log_bin_trust_function_creators';
```

设置为允许，防止下面例子报错：

```mysql
set global log_bin_trust_function_creators=1;
```

> 这样设置显然是临时的，可以在 `my.cnf` 添加  `log_bin_trust_function_creators=1`

如：

```mysql
delimiter //
create function hello()
returns char(20)
return (select fName from flower limit 1); //
delimiter ;
select hello(); -- 函数调用
drop function if exists hello; -- 函数删除
```

```mysql
delimiter lr580
create function countpr2 (pr int) returns int begin
return (select count(*) from flower where yourprice>pr);
end; lr580
delimiter ;
select countpr2(200);
```





#### 变量

不区分大小写。

##### 常规

定义：

```mysql
declare var_name[,var_name, ...] data_type [default value]
```

如：

```sql
declare myparam int default 100;
```

赋值：

```mysql
set var_name = expr [,var_name = expr ...];
```

如：

```mysql
set myparam = myparam * 2;
```

也可以用下面方法为一个或多个变量赋值：

```mysql
select col_name[, ...] into var_name[, ...] table_expr;
```

如：

```mysql
select fName, flowerId into name, id from flower where flowerId = 1;
```

##### 用户变量

`@var_name` 是用户变量，用 set 赋值，与连接有关，一个客户定义的不能被其他用户看到，连接释放自动释放。如：

```sql
select @x; -- NULL
set @x=1;
select @x;
```



##### 全局变量

加 global 关键字。数据库重启后从配置项重新读取。

如：

```mysql
set global MAX_EXECUTION_TIME = 2000;
```

而用 `persist` 则保存到 `mysqld-auto.cnt` 下次启动会读取，覆盖默认配置，如：

```mysql
set persist max_connections = 1000;
```

可以查询：

```mysql
show variables like '%max_connections%';
```





#### 条件处理

类似于 try...catch 。

定义处理的条件：

```sql
declare condition_name condition for [condition_type]
[condition_type]:
sqlstate [value] sqlstate_value | mysql_error_code
```

`sqlstate_value` 是长度为 $5$ 是字符串错误类型代码，`mysql_error_code` 是数值错误代码。如：

```mysql
declare cmd_not_allow condition for sqlstate '42000';
declare cmd_not_allow condition for sqlstate 1148;
```

定义处理条件的程序：

```sql
declare handler_type handler for condition_value[,...] sp_statement
handler_type: continue | exit | undo
condition_value: sqlstate [value] sqlstate_value | condition_name | sqlwarning | not found | sqlexception | mysql_error_code
```

`handler_type` 为错误处理方式，分别为不处理、马上退出和撤回之前的操作(不支持 undo )。`sqlwarning` 匹配所有 `01` 开头的 `sqlstate` 错误代码，`not found` 则以 `02` 开头， `sqlexception` 则是没有被上述两种捕获的全部错误代码

如：

```sql
declare continue handler for sqlstate '42S02' set @info='NO_SUCH_TABLE';
declare no_such_table condition for 1146;
declare continue handler for no_such_table set @info='NO_SUCH_TABLE';
declare exit handler for sqlwarning set @info='ERROR';
```

综合使用：

```sql
delimiter //
create procedure fdemo ()
begin
declare continue handler for sqlstate '23000' set @x2 = 1;
-- 主键冲突忽略
set @x = 1;
insert into test_db.t values (1);
insert into test_db.t values (1); -- 主键冲突
set @x = 2; -- 理论上调用后得到 @x=2
end;//
delimiter ;
```



#### 光标

声明：

```sql
declare cursor_name cursor for select_statement;
```

如：

```mysql
declare cursor_flower cursor for select fName, flowerID from flower;
```



打开：

```mysql
open cursor_name;
```

使用：

```mysql
fetch cursor_name into var_name [, var_name ...]
```

表示将光标中 select 查出来的信息存入到这个 `var_name` 里

关闭：

```mysql
close cursor_name;
```

只能在存储过程 / 函数使用。



#### 流程控制

if:

```sql
if expr_condition then statement_list
[elseif expr_condition then statment_list ...]
[else statement_list]
end if;
```

如：

```mysql
if val is null then select 'empty val'; -- 输出
else select 'ok';
end if;
```



case:

```mysql
case case_expr when when_value then statement_list 
[,when ...]
[else statement_list]
end case;
```

或：

```sql
case
[when expr_condition then statement_list] ...
[else statement_list]
end case;
```

> 存储程序与函数里略有不同。



loop:

```mysql
[loop_label:] loop
	statement_list
end loop [loop_label]
```

使用 `leave loop_label`  break ；使用 `iterate loop_label` continue;

如：

```mysql
delimiter $
create procedure fordemo()
begin
declare id int default 0;
add_loop: loop
	set `id` = `id` + 1;
	if `id` >= 10 then leave add_loop;
	elseif `id` = 5 then iterate add_loop; -- else if 暴毙 
	end if;
	select `id`;
end loop add_loop;
end$
delimiter ;
```



repeat:

```sql
[repeat_label:] repeat
	statement_list
until expr_condition
end repeat [repeat_label];
```



while:

```mysql
[while_label] while expr_condition do
	statement_list
end while [while_label];
```



#### 查询状态

可以直接从系统的 `information_schema` 数据库查询。也可以：

```mysql
show {procedure | function} status [like 'pattern']
```

返回子程序的特征，如数据库、名字、类型、创建者、创建日期、修改日期。一定要 like ，不然会输出一大堆乱七八糟的内容。如：

```mysql
show procedure status like 'fordemo%'\G;
```

也可以：

```sql
show create {procedure | function} sp_name;
```

如：

```mysql
show create procedure fordemo\G;
```

也可以查系统表：

```mysql
select * from information_schema.Routines where ROUTINE_NAME='sp_name' \G;
```

还可以只差函数或过程，限定： `and ROUTINE_TYPE = 'FUNCTION'` 。



#### 修改

```mysql
alter {procedure | function} sp_name [characteristic ...]
```

![image-20220520122056379](img/image-20220520122056379.png)

例如：

```mysql
alter procedure mypro modifies sql data sql security invoker;
alter procedure mypro comment 'QwQ';
```



#### 触发器

trigger ，特殊的存储过程。预定义事件（增删改）发生时，被 mysql 自动调用。通常而言很不推荐使用触发器，除非对需求有显著好处。

单行语句触发器语法：

```mysql
create trigger trigger_name trigger_time trigger_event
on tbl_name for each row trigger_stmt
```

`trigger_time` 为 `before` 或 `after` ，`trigger_event` 为触发事件，包括 `insert,update,delete` 。插入时临时新列是 new ，删除临时旧表示 old 。通过对这两张表操作可以实现 rollback 。

如：

```mysql
create trigger ins_sum before insert on account
for each row set @sum = @sum + NEW.value;
```

多行语句：

```mysql
create trigger trigger_name trigger_time trigger_event
on tbl_name for each row begin
...
end
```

查看： `show triggers` , 查看特定从 `information_schema` 数据库找 `trigger` 表，条件属性名 `TRIGGER_NAME` 。删除也是 `drop` 。

相同表相同事件只能有一个触发器。

如：

```mysql
create table if not exists ts (v int);
delimiter lr580
create trigger tst before insert on ts for each row begin
if new.v <= 0 then
signal sqlstate 'HY000' set message_text = '不允许插入';
end if;
end lr580
delimiter ;
insert into ts values (0); -- 输出报错
insert into ts values (10);
```



### 日志指令

分为：

- 错误日志：记录 MYSQL 服务启动、运行或停止 MYSQL 服务时出现的问题
- 查询日志：记录建立的客户端连接和执行的语句
- 二进制日志：记录所有更改数据的语句，可以用于数据复制
- 慢查询日志：记录所有执行时间超过 `long_query_time` 的所有查询或不使用索引的查询

日志创建在 MYSQL 数据目录。刷新日志可以强制 MYSQL 关闭。用指令 `flush logs`,或 cmd 语句 `mysqladmin flush-logs`, `mysqladmin refresh`。

复制功能，在复制服务器上维护更多日志文件，称为接替日志

查询和慢查询日志可能会降低性能和占用大量空间

日志跟数据库文件不建议放在同一个磁盘，若磁盘故障可能会一锅端

8.0 新版本添加了每条记录的错误信息编号如`[my-010311]`和错误所属子系统如`[server]`。

#### 二进制日志

事务安全。包含所有更新了数据或已经潜在更新了数据的语句，以事件形式保存，描述数据更改。包含每个更新数据库语句的执行时间信息。目的：最大可能地恢复数据库

修改配置 `my.ini`，来启动：

```ini
log-bin [=path/ [filename]]
```

定义路径和日志文件名称。会生成 `filename.000001` 等和 `filename.index`。`expire_logs_days` 定义了清除过期日志的时间，即自动删除的天数。默认为 0 即不删除。启动或刷新时可能删除。`max_binlog_size` 定义单个文件大小限制，不能大于 1GB 或小于 4096B，默认 1GB。但是大的事务会使得实际值超过该限制。

如：

```ini
[mysqld]
log-bin
expire_logs_days = 10
max_binlog_size = 100M
```

查询：

```mysql
show variables like 'log_%';
show binary logs;
```

也可以 cmd：

```shell
mysqlbinlog 文件路径
```

如：

```shell
mysqlbinlog D:/mysql/log/binlog.000001
```

删除全部：

```sql
reset master
```

删除指定文件名(比指定的编号小的所有(不包括这个指定的))或日期(该日期之前的所有(不包括当天))：

```mysql
purge {master | binary} logs to 'log_name';
purge {master | binary} logs before 'date';
```

如：

```mysql
purge master logs before '20190130';
purge master logs to "abc.000003";
```

使用日志恢复数据库：

```shell
mysqlbinlog [option] filename | mysql -uuser -ppass
```

选项有 `--start-date, --stop-date` 和 `--start-position, --stop-position`，指定时间和位置。时间如 `--stop-date="2019-01-30 15:27:48"`，其中 `|` 是管道运算符, windows 也可以管道

暂停/启动：

```mysql
set sql_log_bin = {0|1}
```



#### 错误日志

当启动和停止或运行时的严重错误相关信息。默认在数据库数据目录下，为 `hostname.err`。执行 `flush logs` 会重新加载。

配置：(修改后重启生效, `my.ini` 或 `my.cnf`)

```ini
[mysqld]
log-error=[path / [file_name]]
```

查看：

```mysql
show variables like 'log_error';
```

删除：直接找到文件删掉即可。5.5.7 以前版本 flush logs 可以重命名为 `filename.err_old` 并创建新的，之后只重新打开，不存在创建。运行时删除不会自动创建，需要的话：

```shell
mysqladmin -u root -p flush-logs
```

或：

```mysql
flush logs;
```



#### 通用查询日志

所有用户操作，含启动关闭服务、执行查询和更新。

默认不开启。查询：

```mysql
show variables like '%general%';
```

开启：(关闭设0)(调其他变量同理)

```mysql
set @@global.general_log=1;
```

查看可以直接到路径下翻。删除可以直接删，重建的话用：

```shell
mysqladmin [-u root -p] -flush logs
```



#### 慢查询日志

配置：

```ini
[mysqld]
log-slow-queries[=pat / [filename]]
long_query_time=n
```

n 是超过阈值，不填默认 10 秒。单位是秒。默认在数据目录，文件名 `hostname-slow.log`。查看直接打开。可以借助 mysql dump slow, mysql sla, mysql log ffilter, myprofi 等工具分析。删除同查询日志。



## 其他

### 性能优化

#### 性能查询

```mysql
show status like 'value';
```

value 如：

- `Connections` 连接服务器次数
- `uptime` 服务器上线时间
- `slow_queries` 慢查询次数
- `com_select` 查询次数
- `com_insert` 插入次数
- `com_update` 更新次数
- `com_delete` 删除次数



#### 查询分析

三者其一

```mysql
explain [extended] select select_option
describe select select_option
desc select select_option
```

输出里 `id` 是查询序列号。

`select_type` 有不含连接查询和子查询的简单查询 `simple`，主查询(最外层查询) `primary`，`union` 连接查询的非首个查询语句。`dependent union` 是连接查询非首个的 select；`union result` 是连接查询结果。`subquery` 是子查询第一个语句。同理 `dependent subquery`。`derived` 导出表的 select(from 子句的子查询)。

`table` 是要查询的表。

`type` 是连接类型。从最优到最差分别是 `system`, `const`(最多一个匹配行)，`eq_ref`(从前两者的组合里读取一行；当一个索引所有部分都在查询中使用且是 union/primary key索引时可以使用)；`ref` (前面的表读取所有匹配行)；`ref_or_null`；`index_merge` (索引合并优化)；`index_subquery`；`index_subquery`；`range`；`index`；`all`。

`rows` 遍历次数。

`extended` 会产生附加信息。

查询语句条件中只有 or 且前后两条件的列都是索引时才会使用索引，否则不使用。

子查询灵活但效率不高。会有临时表的创建和撤销。使用 join 代替子查询从而不需要建立临时表。连接效率更高只因为不需要再内存中创建临时表。

8.0 索引可以被隐藏，此时不被查询优化器使用。

```mysql
create table test1(a int, b int, index idx_a_b(a,b desc) invisible);
alter table test1 alter index idx_a_b visible;
show index from test1 \G
```



#### 数据库结构

字段多的表，对使用频率低的子段可以分离形成新表。

经常联合查询的表，可以建立中间表。

降低范式，添加冗余字段，减少连接操作。但是可能代价是空间和修改。

8.0 增加资源组用于调控线程优先级和绑定 CPU。mysql 用户权限为 resource\_group\_admin。进程要有 cap\_sys\_nice 权限如：

```shell
sudo setcap cap_sys_nice+ep /usr/local/mysql8.0/bin/mysqld
getcap /usr/local/mysql8.0/bin/mysqld # 输出
```

```mysql
create resource group my_re type=user vcpu=0,1 thread_priority=5;
set resource group my_re;
select * from performance_schema.threads where resource_group='my_re';
drop resource group my_re;
alter resource group my_re vcpu=2,3 thread_priority=8;
set resource group usr_default for 48;
set resource group my_re for thead_id;
select thread_id from performance_schema.threads;
set resource group my_reso for 20;
```





#### 数据插入

影响插入的主要因素是索引、唯一性校验、插入的数目。myisam可以插入前禁用索引，插入后再开启，如：

```mysql
alter table table_name disable keys;
alter table table_name enable keys;
```

同理禁用唯一性校验：

```mysql
set unique_checks=0;
set unique_checks=1;
```

用一条插入语句代替多条插入语句。

用 `load data infile` 代替 insert，更快。

对 innodb，可以：同理禁用唯一性，还可以禁用外键检查：

```mysql
set foreign_key_checks=0;
```

禁用自动提交：

```mysql
set autocommit=0;
```



#### 分析表

分析关键字的分布。

```mysql
analyze [local | no_write_to_binlog] table tbl_name [,tbl_name]...
```

local 与后者互为别名，都表示执行过程不写入二进制日志。

分析时加只读锁。能分析 innodb, bdb, myisam。

table 是表名。on 是执行的操作。msg\_type 是 status/info/note/warning/error, msg\_text 是显示信息



#### 检查表

检查 innodb, myisam 是否存在错误。后者还会更新关键字统计数据。也可以检查视图(如被引用的表不存在)

```mysql
check table tbl_name [,tbl_name] ... [option] ...
```

option 有 quick(不扫描行，不检查错误连接)；fast(只检查未被正确关闭的表)；changed(只检查上次检查后被更改和未正确关闭的)；medium(扫描行，验证删除的连接是有效的，计算各行关键字校验和)；extended(每行关键字做全面关键字查找，确保表 100% 一致)

option 只能 myisam。check 时加只读锁。



#### 优化表

对 innodb, myisam 有效，优化 varchar, blob, text。

```mysql
optimize [local | no_write_to_binlog] table tbl_name [,tbl_name] ...
```

可以消除删除和更新造成的文件碎片。加只读锁。一般只需要一周或一个月一次，只需要对特定的表运行。



#### 服务器

硬件：较大的内存。内存速度比磁盘 I/O 快。增加缓冲区容量使得在内存停留更久。高速磁盘。合理分布磁盘 I/O，分散到多个设备减少资源竞争，提高并行操作。配置多处理器，多线程。

参数：

- `key_buffer_size` 索引缓冲区大小。所有线程共享。值太大会操作系统频繁换页，降低系统性能
- `table_cache` 同时打开的表个数，太多影响系统性能
- `query_cache_size` 查询缓冲区大小。与 `query_cache_type` 配合，为 0 时都不使用，但不会导致释放所配置的内存；为 1 时都使用，除非查询语句指定 `select sql_no_cache * from` 这样的语法。而为 2 时，只有语句有 `sql_cache` 关键字才用。用缓冲区可以提高查询速度，只使用修改操作少和经常执行相同查询操作
- `sort_buffer_size` 排序缓冲区大小，越大排序速度越快。提高 order by 或 group by，默认约 2MB(2097144 byte)
- `read_buffer_size` 每个线程连续扫描时为扫描的每个表分配的缓冲区大小(字节)，从表连续读取记录时用到。可以 `set session read_buffer_size=n` 临时设置
- `read_rnd_buffer_size` 每个线程保留的缓冲区大小。主要用于存储按特定顺序读取出来的记录。也可以 set。频繁多次连续扫描可以增加。
- `innodb_buffer_pool_size` 该类型表和索引最大缓存。越大查询越快，太大影响操作系统性能
- `max_connections`。连接会浪费内存资源，过多会僵死
- `innodb_flush_log_at_fix_commit` 何时将缓冲区写入日志。0 是每隔一秒写入磁盘，1 是每次提交事务，2 是每次提交事务写日志，每隔 1 秒日志存盘。默认 1。0 更快但安全性差。
- `back_log` 暂时停止回答新请求的时间内，多少请求可以存在栈里。即对到来的 tcp/ip 连接侦听队列大小。高于操作系统无效。
- `interactive_timeout` 关闭连接前等待行动秒数
- `thread_cache_size` 复用线程数
- `wait_timeout` 关闭连接前等待秒数，默认 28800
- `innodb_log_buffer_size`
- `innodb_log_file_size`



#### 临时表

8.0 

可以把数据库和表归组到逻辑和物理表空间，提高资源利用率

去掉了临时表不必要持久化。增加 undo 日志额外的类型。临时表设置特别类型。

临时表元数据在 innodb\_temp\_table\_info 系统表

用 `create tablespace` 创建通用表空间。

```mysql
create tablespace dxy add datefile 'dxy.ibd' file_block_size=16k;
alter table t1 tablespace dxy;
drop table t1;
drop tablespace dxy;
```





#### 超时处理

限制语句时间。

```mysql
set global max_execution_time=2000; -- 毫秒,0无限
```

会话超时时间：

```mysql
set session max_execution_time=2000;
```



### 主从

Replication

数据库复制。从一个主服务器(master)将数据复制到另外若干台从服务器(slaves)的过程。将主数据库的 DDL 和 DML 操作通过二进制日志传到从服务器上然后执行，使得同步。复制异步进行。

从服务器一般用于处理查询，减少主服务器压力。

#### windows

查看数据路径：

```mysql
show variables like '%datadir%';
```

修改 `my.ini` 添加：

```ini
[mysqld]
log_bin="D:/MySQLlog/binlog"
expire_logs_days=10
max_binlog_size=100M
```

创建对应的文件。参数：删除的天数和最大的大小。

测试是否成功开启：

```mysql
show variables like '%log_bin%';
```

`log_bin=ON` 则开启。

配置一个复制用的账号 `repl`：

```mysql
grant replication slave on *.* to repl@'%' identified by '123';
flush privileges;
```

继续配置 ini：

```ini
server-id=1
binlog-do-db=test
binlog-ignore-db=mysql
```

放服务器标识 id，与 slave 不一样。要复制的数据库名和不需要复制的数据库名。

重启，查询信息：

```mysql
show master status \G;
```

导出数据，导入到从服务器：

```shell
mysqldump -u root -p -h localhost test > c:\a.txt
```

复制 txt 到从服务器，导入：

```shell
mysqldump -u root -p -h localhost test < c:\a.txt
```

继续配置从服务器：

```ini
[mysql]
default-character-set=utf8
log_bin="D:/MySQLlog/binlog"
expire_logs_days=10
max_binlog_size=100M

[mysqld]
server-id=2
```

可以注释掉 log\_bin 在 mysqld 的

重启从服务器，执行：

```mysql
stop slave;
change master to
master_host='192.168.0.208',
master_user='repl',
master_password='123',
master_log_file='binlog.000003',
master_log_pos=120;
start slave;
show slave status \G;
```

后两个表示要复制的日志文件和偏移量。

解决 fatal error 1236:

重启主机，执行：

```mysql
show master status \G;
```

记录 file 和 position 值。

重新设置从机，并把后两个参数调成这个值。

可以发现，主机每执行一次更改，就会同步到从机。



#### linux

安装 mysql

停止服务器：

```shell
service mysql stop
```

若 netstat 查询 330 无结果，则已经关闭

下略



#### 维护

查看从服务器：

```mysql
show slave status \G;
```

大文本复制出错：

```mysql
show variables like 'max_allowed_packet';
set @@global.max_allowed_packet=16777216;
```

或 `my.cnf` 设置。（16MB）

自增长冲突：主服务器设置 `auto_increment_increment=1,auto_increment_offfset=1`，从后者 0 前者 1。

切换服务器：

```mysql
stop slave IO_THREAD;
show processlist \G;
```

从：

```mysql
stop slave;
reset master;//从变f主
```



#### Proxy

mysql proxy 使得一个客户端的读写命令，写命令放到主数据库，读放到从数据库。只有一个 proxy 机器可能会出现单点失效，可以用多个 proxy 作为冗余。

```shell
mysql-proxy --help-all
```

[下载](downloads.mysql.com/archives/proxy)



### 锁

三种锁：行级、页级、表级。

#### 行级锁定

innodb 支持(row-level locking)和表级锁。默认前者。myisam memory两者表级。BDB 是页面和表。

颗粒度小，发生争用概率小。获取和释放消耗大，容易死锁。

如果一个事物请求的锁模式与当前模式兼容，就可以做，否则要等待。(考虑并发，多个会话)显然同一个会话自己不会冲突，加锁时其他会话可能会冲突。

共享锁 S，排他锁 X，意向共享锁 IX，意向排他锁 IX。

|      | S    | X    | IS   | IX   |
| ---- | ---- | ---- | ---- | ---- |
| S    | √    |      | √    |      |
| X    |      |      |      |      |
| IS   | √    |      | √    | √    |
| IX   |      |      | √    | √    |

意向锁自动添加。普通 select innodb 不加任何锁。增删改 innodb 自动加排他锁。

添加共享锁 S：

```mysql
select * from ... lock in share mode;
```

添加排他锁 X：

```c++
select * from ... for update;
```



#### 表级锁定

颗粒度大。系统开销小。较好避免死锁。冲突率高，并发度低。

包含读锁定和写锁定。

类型包括：

- ignore, unlock, read, write, `read_with_shared_locks`, `read_high_priority`, `read_no_insert`, `write_allow_write`, `write_allow_read`, `write_concurrent_insert`, `write_delayed`, `write_low_priority`, `write_only`

```mysql
lock table table_name read;
unlock tables;
```



#### 页级锁定

介于两者之间的颗粒度。因此性质也是介于两者之间。



#### myisam

有共享读锁 table read lock 和表独占写锁 table write lock

|      | None | 读锁 | 写锁 |
| ---- | ---- | ---- | ---- |
| 读锁 | √    | √    |      |
| 写锁 | √    |      |      |

如：

```mysql
lock table read_lock write;
unlock tables;
```

争用查看：

```mysql
show status like 'table%';
```

`table_locks_immediate` 产生表级锁定的次数

`table_locks_waited` 出现比较锁定争用而发生的等待次数

后者高争用明显。大量读写并发效率大大降低。读增加可能严重读写锁问题，实际上采用主从分离。

建议：将 `concurrent_insert` 设 2，文件碎片定期 `optimize table`；设置 `max_write_lock_count=1`；给读更高优先级 `low-priority-updates=1`

锁表语法：

```mysql
lock table tbl_name [as alias] {read[local] | [low_priority] write} [,tbl_name ...] ...
unlock tables;
```

用别名引用表就要用一样的别名锁定表，如：

```mysql
lock table cc as c read;
select * from cc as c; -- OK,直接select不OK
select * from cc; -- BAD
unlock tables;
lock table cc read;
select * from cc as c; -- BAD
select * from cc; -- OK
```

read local 允许锁定时执行非冲突性 insert 语句同时插入；若 low priority write，则等待特定的锁定，直到没有申请 read 锁定的线程为止，已经获得 write 时，其他线程会等待

系统变量 `concurrent_insert` 为 0 不允许并发插入，1 表没有被删除的行允许在一个进程读表时另一个进程表尾插入；2 无论如何都允许表尾并发插入

查询：

```mysql
show variables like '%concurrent%';
```



#### innodb

支持事务处理。但可能发生：

- 更新丢失：两个数据更新同一行数据，第二个进程中途退出，两个修改都失效
- 脏读：读了之后另一个事务马上更改了，使得所有操作被回滚可能
- 不可重复读：重复读两次，两次结果不一致
- 幻读：两次查询，第二次出现了第一次没有出现的数据

![image-20220829193406316](img/image-20220829193406316.png)

添加共享锁：

```mysql
select id,data from s_table where id=120 lock in share mode;
```

查询争用情况：

```mysql
show status like '%innodb_row_lock%'
```

`innodb_row_lock_current_waits` 当前等待锁定的数量，`innodb_row_lock_time` 从系统启动到现在锁定总时间长度，`innodb_row_lock_time_avg` 每次等待平均时间，`innodb_row_lock_time_max` 系统启动到现在最长的一次等待，`innodb_row_lock_waits` 启动后到现在一共等待了多少次

```mysql
show innodb status;
```



间隙锁

net-key 锁。存储一个区间数据时，会锁定这个区间的全部记录。即使某条记录不存在也会被锁定。

查看隔离级别：

```mysql
select @@tx_isolation;
```

```mysql
set session transaction isolation level repeatable read;
set session transaction isolation level serializable;
```



建议：控制事务大小；尽可能所有数据检索通过索引，避免表级锁定；减少基于范围的数据检索搜索条件；尽量用较低级别的事务隔离；尽可能按相同顺序访问；尽可能以此锁定所需所有资源；容易死锁可以放弃innodb行级使用表级；不要申请超过需求的锁级别。



#### 跳过锁等待

5.7 `select ... for update` 执行时若获取不到锁，会一直等待直到 `innodb_lock_wait_timeout` 超时

8.0 对其他会话，想要获取锁时，添加 nowait 和 skip locked 立即返回。若查询的加锁，前者返回报错，后者返回不包含锁定的行。

```mysql
select * from bbs1 where id=102 for update nowait;
select * from bbs1 where id=102 for update skip locked;
```





### 其他8.0特性

#### innodb

##### 在线

旧版本添加主键需要复制数据表。8.0 可以直接添加：

```mysql
create table tt(id int);
alter table tt add primary key(id);
```

8.0 在线更改 varchar：(增大到 255 内，且不支持在线介绍)

```mysql
alter table tm modify name varchar(255);
```

8.0 在线重命名索引：

```mysql
alter table bb rename index bs to newbs;
```



##### 缓冲池

可以动态修改大小

大小是 128mb 的倍数，否则会适当调大。

查看大小和个数：

```mysql
show variables like '%innodb_buffer_pool_size%';
show variables like '%innodb_buffer_pool_instances%';
```

设置：

```mysql
set global innodb_buffer_pool_size=1048576000;
```

查看设置进度：

```mysql
show global status like 'innodb_buffer_pool_resize_status';
```



##### 表空间数据加密

支持对独享表空间的 innodb 数据加密，使用 keyring plugin 管理，启动参数：

```ini
[mysqld]
early-plugin-load=keyring_file.so
```

检查是否支持加密：

```mysql
select plugin_name, plugin_status from information_schema.plugins where plugin_name like 'keyring%';
```

创建：

```mysql
create table t(id int, name varchar(10)) engine=innodb default charset utf8mb4 encryption='y';
```



#### json

传统存储为字符串，需要用户保证正确性，且在用户代码处理，只提取json一个字段也需要读取整个字符串，且无法建索引。

8.0 实现 json 支持。

```mysql
create table tb(data json)engine=innodb; -- or myisam
insert into tb values('{"key":"val"}');
```

实际存储是 blob。key 的长度用 2 字节(65535)保存，超过会错。内部会 key 排序。

```mysql
insert into tb values(json_object('key','val'));
```



#### 全文索引加强

支持外部分析器。实现标记优化器。实现支持 CJK(中日韩)全文检索。

检索(旧版本全部匹配到就算匹配到，新版本匹配到子串就行了)：

```mysql
select * from tft where match (name) against ('中文文本');
```



### 存储引擎

比较：

![image-20220830230200957](img/image-20220830230200957.png)

![image-20220830230205825](img/image-20220830230205825.png)

提供提交、回滚和崩溃恢复能力，事务安全，并发控制，innodb。

数据表主要用来插入和查询，效率 myisam 较高。

临时存放，数据量不大，不需要较高安全性，可以 memory。

只有 insert, select 可以 archive，高并发插入，但不事务安全。非常适合归档数据，如日志信息。

查看默认引擎：

```mysql
show variables like 'storage_engine';
```





### SQL注入

#### 登录

用户名设置为 `1' or '1='1` ，密码同理。使得通过 `where` 时， or 后边的判断总是成立，从而使得用户和密码总是正确，如：

```mysql
select * from _userlist where name = '?' and psw = '?';
```

在 java 里用 `mysql` ，statement 难以防御注入，建议使用 `preparestatement` ，可以防止注入，把特殊符号转义。





# Yii

[教程](https://dev.mysql.com/downloads/windows/installer/8.0.html)



# Docker

## 理论

[教程](https://yeasy.gitbook.io/docker_practice/basic_concept/image)

### 基本概念

docker类似于轻量虚拟机，可以用于将一台机子部署的东西快速迁移到别的机子



**镜像** Image 类似于 root 文件系统。是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 **不包含** 任何动态数据，其内容在构建之后也不会被改变。

镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。

> 因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。



**容器** Container 。容器是镜像的实例。镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 `root` 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样

> 容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更

一个 **Docker Registry** 中可以包含多个 **仓库**（`Repository`）；每个仓库可以包含多个 **标签**（`Tag`）；每个标签对应一个镜像。通过 `<仓库名>:<标签>` 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 `latest` 作为默认标签

> 仓库名经常以 *两段式路径* 形式出现，比如 `jwilder/nginx-proxy`，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名



## 使用

### 安装

#### windows 10

##### docker安装

建议先下载高速下载工具， winget [下载链接](https://www.microsoft.com/zh-cn/p/app-installer/9nblggh4nns1?rtc=1#activetab=pivot:overviewtab) 或者可以用我自己的备份[下载docker](https://cloud.socoding.cn/s/KZ1Tb)

然后在 cmd 键入指令：

```bash
winget install Docker.DockerDesktop
```

> 也可以 `-i` 指定交互界面安装，可以 `-l 路径` 指定安装目录，但是 docker 不支持
>
> 下载路径根据输出内容发现为： `C:\Users\lr580\AppData\Local\Temp\WinGet` ，装完好会自己删包

可能需要输入一次 `y` 

之后建议重启电脑一次



##### hyper-v安装

> 这一步可能是不需要的

然后安装 hyper-v，在管理员下执行该脚本：

```bat
pushd "%~dp0"

dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum >hyper-v.txt

for /f %%i in ('findstr /i . hyper-v.txt 2^>nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i"

del hyper-v.txt

Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL
```

然后重启电脑



##### 迁移到D盘

[教程对标](https://www.cnblogs.com/renguanyu/p/15201827.html) [备用对标教程](https://blog.csdn.net/jxl15680701016/article/details/106925002/)

因为默认安装在 C 盘，所以接下来考虑迁移走 C 盘：

首先在任务管理器关闭所有 Docker 前缀的进程

然后控制面板里搜索管理工具，点击Hyper-v管理器，点击仅有的一台，点停止服务，点 Hyper-v 设置



在管理员下，逐个剪切路径到另一个路径，然后执行下述命令：(后者路径仅供参考)

```bat
mklink /j "C:\ProgramData\Docker" "D:\Temps\docker\DockerData"
mklink /j "C:\ProgramData\DockerDesktop" "D:\Temps\docker\DockerDesktop"
mklink /j "C:\Program Files\Docker" "D:\Temps\docker\Docker"
mklink /j "C:\Users\lr580\AppData\Local\Docker" "D:\Users\lr580\AppData\Local\Docker"
```

当且仅当在 C 盘对应位置能看到快捷图标然后点进去可以时，证明迁移成功，此时可以打开dockerdesktop。

验收标准：打开Docker Desktop正常，不会闪退(可能会要求安装WSL2)



##### WSL安装升级

安装 WSL(Windows Subsystem for Linux)：

win+r 运行 `winver` 查看版本号，确保内部版本号大于等于19041

打开 powershell ，列举可安装版本：

```bash
wsl -l -o
```

可以安装一个 Linux，如：

```bash
wsl --install -d Ubuntu-20.04
```

设置管理员密码：

```bash
sudo passwd root
```

关闭：

```bash
wsl --shutdown
```

然后迁移到D盘，使用类似的方法：

```bat
mklink /j  "C:\Users\lr580\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc" "D:\Temps\wsl\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc"
```

然后右击设置权限为完全控制。 [参考教程](https://www.cnblogs.com/itkingyw/p/12736358.html)

要卸载的话可以在菜单搜索 Ubuntu，直接右击卸载

检查安装的版本是 WSL 1还是2，输入：

```bash
wsl -l -v
```

关闭特定，如：

```bash
wsl -t Ubuntu-20.04
```

要启动的话，直接菜单搜索点击即可

管理员下 powershell 输入指令：[参考文献](https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package)

```bat
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
```

下载文献里的安装包 `.msi` ，大约16MB，安装，重启

对 WSL 1更新到 WSL 2： [参考文献](https://docs.microsoft.com/zh-cn/windows/wsl/install)

```bash
wsl --set-version Ubuntu-20.04 2
```

如果提示`转换完成。` 就成功了

设置默认版本：

```bash
wsl --set-default-version 2
```



验收标准：打开docker desktop，显示大约为：`Get started with Docker in a few easy steps!`



> 注意 docker 使用过程中疑似要一直开着那个虚拟机，所以不要关掉；此外 docker 还会创多两个虚拟机



### 配置

#### 镜像加速器

##### windows 10

菜单选择 `Settings`，打开配置窗口后在左侧导航菜单选择 `Docker Engine`，在右侧像下边一样编辑追加 json 文件，之后点击 `Apply & Restart` 保存后 Docker 就会重启并应用配置的镜像地址了。

```json
{
  "registry-mirrors": [
    "https://hub-mirror.c.163.com",
    "https://mirror.baidubce.com"
  ]
}
```

若输入指令：

```bash
docker info
```

后，能够查找到 `Registry Mirrors`有内容，即证明配置成功



#### 实验特性

一些 docker 命令或功能仅当 **实验特性** 开启时才能使用，在类似 `镜像加速器` 的方法里编辑 json：

```json
"expermental": true
```



### 使用

#### 官方hello-world

下载一个项目：

```bash
git clone git@github.com:docker/getting-started.git
```

cd 进入这个项目，在 docker 窗里跑：

```bash
docker run --name repo alpine
```

验收标准：不能再跑这个命令，输出`docker:Error response from daemon: Conflict.`

跑这个指令：

```bash
docker build -t docker101tutorial
```

等待完毕后，跑：

```bash
docker run -d -p 80:80 --name docker-tutorial docker101tutorial
```

注册一个账号，然后执行指令例如，上传分享：

```bash
docker tag docker101tutorial lr580/docker101tutorial
docker push lr580/docker101tutorial
```

可以点击查看 [自己上传的内容](https://hub.docker.com/repositories)

验收：发现端口是 80 ，猜测是 httpd ，所以直接在浏览器跑一下 [localhost](https://localhost) ，能看到网页就胜利了



#### 杂项

可以在任意 cmd 窗口，如 powershell 使用 docker，也可以用 Desktop

由于许多输出颜色跟 Powershell 背景颜色相似，建议右击标题栏修改 powershell 背景颜色



## 指令

### 镜像

#### 列举

```bash
docker image ls
```

列表包含了 `仓库名`、`标签`、`镜像 ID`、`创建时间` 以及 `所占用的空间`。

> 在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 `docker image ls` 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小
>
> 镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多

通过 `docker system df` 命令来便捷的查看镜像、容器、数据卷所占用的空间



> 列举出摘要 (即 SHA256)
>
> ```bash
> docker image ls --digests
> ```
>
> 按名字精准查询，如：
>
> ```bash
> docker image ls -q docker101tutorial
> ```
>
> 某版本之前的，如：
>
> ```bash
> docker image ls -q -f before=mongo:3.2
> ```



#### 获取

```bash
docker pull --help
```

命令格式：

```bash
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]
```

例如：

```bash
docker pull ubuntu:18.04
```



#### 删除

```bash
docker image rm [选项] <镜像1> [<镜像2> ...]
```

其中，`<镜像>` 可以是 `镜像短 ID`、`镜像长 ID`、`镜像名` 或者 `镜像摘要`。短 ID 一般取长为 3 的前缀，足以区分即可

如：

```bash
docker image rm centos
```

更精确的是使用镜像摘要来删除，先列出摘要：

```bash
docker image ls --digests
```

然后删除用 `名字@摘要全文` ，如：

```bash
docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
```

> 镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。

> 删除的过程先把满足我们要求的所有镜像标签都取消，当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。直到没有任何层依赖当前层时，才会真实的删除当前层。

> 除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。



可以使用组合技 `docker image rm $(一条指令)` ，如：

```bash
docker image rm $(docker image ls -q -f before=mongo:3.2)
```



#### 对比

```bash
docker diff 镜像
```



#### 保存

**慎用该指令** ,因为这种方法所有对镜像的操作都是黑箱操作，生成的镜像也被称为 **黑箱镜像**

```bash
docker commit --author "作者" --message "更改内容" 名字 镜像:版本
```



#### 历史

```bash
docker history 镜像
```



#### mainfest

不懂，大概是跨平台用的



#### import

格式：`docker import [选项] <文件>|<URL>|- [<仓库名>[:<标签>]]`

压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 `/` 目录展开，并直接作为镜像第一层提交，如：

```bash
docker import http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz openvz/ubuntu:16.04
docker image ls openvz/ubuntu
```



#### save

> Docker 还提供了 `docker save` 和 `docker load` 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以

使用 `docker save` 命令可以将镜像保存为归档文件

```bash
docker save alpine -o filename
file filename
```

这里的 filename 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件

注意：如果同名则会覆盖（没有警告）

如：

```bash
docker save alpine | gzip > alpine-latest.tar.gz
```

在另一台机子加载：

```bash
docker load -i alpine-latest.tar.gz
```

```bash
docker save <镜像名> | bzip2 | pv | ssh <用户名>@<主机名> 'cat | docker load'
```





### Dockerfile

镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。

Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。

在一个空白目录中，建立一个文本文件，并命名为 `Dockerfile` 

#### 概述

在该文件里输入：

```dockerfile
FROM nginx
RUN echo '<h1>Nya haha, I am lr580~</h1>' > /usr/share/nginx/html/index.html
```

##### FROM

FROM 是必备指令和第一条指令；除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 `scratch`。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像

##### RUN

RUN 执行命令行，格式为：`RUN <命令>` 或 `RUN ["可执行文件", "参数1", "参数2"]`

> Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层

为了压缩层数，将多个 RUN 使用 `&&` 串联；为了美观，使用 `\` 换行，使用 `#` 行首注释；通常安装完环境后还需要删除掉安装包



##### 构建

接下来在有 `Dockerfile` 的目录下构建：

```bash
docker build -t nginx:v3 .
```

通用格式为：

```bash
docker build [选项] <上下文路径/URL/->
```

`docker build` 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的；指定构建镜像上下文的路径，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件



##### 上下文

context

> `COPY` 这类指令中的源文件的路径都是*相对路径* ， `COPY ../package.json /app` 或者 `COPY /opt/xxxx /app` 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去，一种复制如：
>
> ```dockerfile
> COPY ./package.json /app/
> ```

一般来说，应该会将 `Dockerfile` 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 `.gitignore` 一样的语法写一个 `.dockerignore`，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的

> 这只是默认行为，实际上 `Dockerfile` 的文件名并不要求必须为 `Dockerfile`，而且并不要求必须位于上下文目录中，比如可以用 `-f ../Dockerfile.php` 参数指定某个文件作为 `Dockerfile`



##### 远程

可以用 `-t` 参数从 URL 构建，如：

```bash
docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world
```

也可以是 tar 压缩包，那么会自动解包：

```bash
docker build http://server/context.tar.gz
```



##### 输入构建

```bash
docker build - < Dockerfile
```

或

```bash
cat Dockerfile | docker build -
```

如果标准输入传入的是文本文件，则将其视为 `Dockerfile`，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 `COPY` 进镜像之类的事情。

可以读取上下文压缩包：

```bash
docker build - < context.tar.gz
```



##### 运行

在窗口化里点击运行，输入参数端口，然后直接访问 [localhost](https://localhost) 即可



##### 阶段

另一种方式，就是我们事先在一个 `Dockerfile` 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 `Dockerfile` 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂

如：

```dockerfile
FROM golang:alpine as builder

RUN apk --no-cache add git

WORKDIR /go/src/github.com/go/helloworld/

RUN go get -d -v github.com/go-sql-driver/mysql

COPY app.go .

RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest as prod

RUN apk --no-cache add ca-certificates

WORKDIR /root/

COPY --from=0 /go/src/github.com/go/helloworld/app .

CMD ["./app"]
```

使用 as 后，若只想构建某一阶段的镜像，就可以`--target=as名字`，如：

```dockerfile
FROM golang:alpine as builder
```

```bash
docker build --target builder -t username/imagename:tag .
```

使用 `COPY --from=0 /go/src/github.com/go/helloworld/app .` 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件

```dockerfile
$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf
```





#### 指令

##### COPY

格式：

`COPY [--chown=<user>:<group>] <源路径>... <目标路径>`

`COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]`

`COPY` 指令将从构建上下文目录中 `<源路径>` 的文件/目录复制到新的一层的镜像内的 `<目标路径>` 位置。比如：

```dockerfile
COPY package.json /usr/src/app/
```

`<源路径>` 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 [`filepath.Match`](https://golang.org/pkg/path/filepath/#Match) 规则：

```
pattern:
	{ term }
term:
	'*'         matches any sequence of non-Separator characters
	'?'         matches any single non-Separator character
	'[' [ '^' ] { character-range } ']'
	            character class (must be non-empty)
	c           matches character c (c != '*', '?', '\\', '[')
	'\\' c      matches character c

character-range:
	c           matches character c (c != '\\', '-', ']')
	'\\' c      matches character c
	lo '-' hi   matches character c for lo <= c <= hi
```

目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录

使用 `COPY` 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等

在使用该指令的时候还可以加上 `--chown=<user>:<group>` 选项来改变文件的所属用户及所属组，如：

```dockerfile
COPY --chown=55:mygroup files* /mydir/
COPY --chown=bin files* /mydir/
COPY --chown=1 files* /mydir/
COPY --chown=10:11 files* /mydir/
```

如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径



##### ADD

是 COPY 的超集

 `<源路径>` 可以是一个 `URL`，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 `<目标路径>` 去。下载后的文件权限自动设置为 `600`，如果这并不是想要的权限，那么还需要增加额外的一层 `RUN` 进行权限调整

> 另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 `RUN` 指令进行解压缩。所以不如直接使用 `RUN` 指令，然后使用 `wget` 或者 `curl` 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用
>
> 真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 `ADD` 命令了
>
> `ADD` 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢

可以遵循这样的原则，所有的文件复制均使用 `COPY` 指令，仅在需要自动解压缩的场合使用 `ADD`



##### CMD

`shell` 格式：`CMD <命令>`

`exec` 格式：`CMD ["可执行文件", "参数1", "参数2"...]`

参数列表格式：`CMD ["参数1", "参数2"...]`。在指定了 `ENTRYPOINT` 指令后，用 `CMD` 指定具体的参数

在指令格式上，一般推荐使用 `exec` 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 `"`，而不要使用单引号



Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。`CMD` 指令就是用于指定默认的容器主进程的启动命令的

如果使用 `shell` 格式的话，实际的命令会被包装为 `sh -c` 的参数的形式进行执行。比如

```dockerfile
CMD echo $HOME
```

会变为：

```dockerfile
CMD [ "sh", "-c", "echo $HOME" ]
```

容器内没有后台服务的概念，例如 `service nginx start` 会挂掉

对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西

正确的做法是直接执行 `nginx` 可执行文件，并且要求以前台形式运行。比如：

```bash
CMD ["nginx", "-g", "daemon off;"]
```



只可以出现一次，如果写了多个，只有最后一个生效

运行时可以替换掉这个默认指令



##### ENTERPOINT

格式同 RUN

`ENTRYPOINT` 在运行时也可以替代，不过比 `CMD` 要略显繁琐，需要通过 `docker run` 的参数 `--entrypoint` 来指定。

当指定了 `ENTRYPOINT` 后，`CMD` 的含义就发生了改变，不再是直接的运行其命令，而是将 `CMD` 的内容作为参数传给 `ENTRYPOINT` 指令



场景一：让镜像像命令一样使用，如：

```dockerfile
FROM ubuntu:18.04
RUN apt-get update \
    && apt-get install -y curl \
    && rm -rf /var/lib/apt/lists/*
ENTRYPOINT [ "curl", "-s", "http://myip.ipip.net" ]
```

构建：

```bash
docker build -t myip
```

那么可以同时支持：

```bash
docker run myip
docker run myip -i
```

而不是后者需要：

```bash
docker run myip curl -s http://myip.ipip.net -i
```

> 若 `dockerfile` 的最后一行是 CMD 就要这么做



只可以出现一次，如果写了多个，只有最后一个生效



场景二：应用前的准备

通常用于一些初始化(特别是可能需要 root 的)

```dockerfile
FROM alpine:3.4
...
RUN addgroup -S redis && adduser -S -G redis redis
...
ENTRYPOINT ["docker-entrypoint.sh"]

EXPOSE 6379
CMD [ "redis-server" ]
```

其 `docker-entrypoint.sh` 为：

```bash
#!/bin/sh
...
# allow the container to be started with `--user`
if [ "$1" = 'redis-server' -a "$(id -u)" = '0' ]; then
    find . \! -user redis -exec chown redis '{}' +
    exec gosu redis "$0" "$@"
fi

exec "$@"
```

该脚本的内容就是根据 `CMD` 的内容来判断，如果是 `redis-server` 的话，则切换到 `redis` 用户身份启动服务器，否则依旧使用 `root` 身份执行，如：

```bash
docker run -it redis id
```



##### ENV

设置环境变量

```
ENV <key> <value>
```

```
ENV <key1>=<value1> <key2>=<value2>...
```

换行，以及对含有空格的值用双引号括起来的办法，如：

```dockerfile
ENV VERSION=1.0 DEBUG=on \
    NAME="Happy Feet"
```

环境变量可以被后文使用，如：

```dockerfile
ENV NODE_VERSION 7.2.0

RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz"
```

> 下列指令可以支持环境变量展开： `ADD`、`COPY`、`ENV`、`EXPOSE`、`FROM`、`LABEL`、`USER`、`WORKDIR`、`VOLUME`、`STOPSIGNAL`、`ONBUILD`、`RUN`。



##### ARG

构建参数和 `ENV` 的效果一样，都是设置环境变量。所不同的是，`ARG` 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的

`docker history` 还是可以看到所有值的(所以不可以存敏感信息)

该默认值可以在构建命令 `docker build` 中用 `--build-arg <参数名>=<值>` 来覆盖。

ARG 指令有生效范围，如果在 `FROM` 指令之前指定，那么只能用于 `FROM` 指令中



##### VOLUME

定义匿名卷

容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中

可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据，如：

```dockerfile
VOLUME /data
```

任何向 `/data` 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：

```bash
docker run -d -v mydata:/data xxxx
```



##### EXPOSE

格式为 `EXPOSE <端口1> [<端口2>...]`

声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 `docker run -P` 时，会自动随机映射 `EXPOSE` 的端口

要将 `EXPOSE` 和在运行时使用 `-p <宿主端口>:<容器端口>` 区分开来。`-p`，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 `EXPOSE` 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射



##### WORKDIR

使用 `WORKDIR` 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，`WORKDIR` 会帮你建立目录，如：

```dockerfile
WORKDIR /app

RUN echo "hello" > world.txt
```

```dockerfile
WORKDIR /a
WORKDIR b
WORKDIR c

RUN pwd
```

> pwd在 `/a/b/c`



##### USER

`USER <用户名>[:<用户组>]`

注意，`USER` 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换

如果以 `root` 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 `su` 或者 `sudo`，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 [`gosu`](https://github.com/tianon/gosu)

```dockerfile
# 建立 redis 用户，并使用 gosu 换另一个用户执行命令
RUN groupadd -r redis && useradd -r -g redis redis
# 下载 gosu
RUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64" \
    && chmod +x /usr/local/bin/gosu \
    && gosu nobody true
# 设置 CMD，并以另外的用户执行
CMD [ "exec", "gosu", "redis", "redis-server" ]
```



##### HEALTHCHECK

`HEALTHCHECK [选项] CMD <命令>`：设置检查容器健康状况的命令

`HEALTHCHECK NONE`：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令

当在一个镜像指定了 `HEALTHCHECK` 指令后，用其启动容器，初始状态会为 `starting`，在 `HEALTHCHECK` 指令检查成功后变为 `healthy`，如果连续一定次数失败，则会变为 `unhealthy`。

`HEALTHCHECK` 支持下列选项：

- `--interval=<间隔>`：两次健康检查的间隔，默认为 30 秒；
- `--timeout=<时长>`：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；
- `--retries=<次数>`：当连续失败指定次数后，则将容器状态视为 `unhealthy`，默认 3 次

和 `CMD`, `ENTRYPOINT` 一样，`HEALTHCHECK` 只可以出现一次，如果写了多个，只有最后一个生效。

如：

```dockerfile
FROM nginx
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
HEALTHCHECK --interval=5s --timeout=3s \
  CMD curl -fs http://localhost/ || exit 1
```

构建和启动、检查：

```bash
docker build -t myweb:v1 .
docker run -d --name web -p 80:80 myweb:v1
docker container ls
```

检查：

```bash
docker inspect --format '{{json .State.Health}}' web | python -m json.tool
```



##### ONBUILD

`ONBUILD` 是一个特殊的指令，它后面跟的是其它指令，比如 `RUN`, `COPY` 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行



##### LABEL

`LABEL` 指令用来给镜像以键值对的形式添加一些元数据（metadata）

```dockerfile
LABEL <key>=<value> <key>=<value> <key>=<value> ...
```

如：

```dockerfile
LABEL org.opencontainers.image.authors="yeasy"

LABEL org.opencontainers.image.documentation="https://yeasy.gitbooks.io"
```



##### SHELL

格式：`SHELL ["executable", "parameters"]`

`SHELL` 指令可以指定 `RUN` `ENTRYPOINT` `CMD` 指令的 shell，Linux 中默认为 `["/bin/sh", "-c"]`

```dockerfile
SHELL ["/bin/sh", "-c"]

RUN lll ; ls

SHELL ["/bin/sh", "-cex"]

RUN lll ; ls
```

两个 `RUN` 运行同一命令，第二个 `RUN` 运行的命令会打印出每条命令并当遇到错误时退出。



### 容器

容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用



#### 启动

`docker run 镜像`

`-t` 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， `-i` 则让容器的标准输入保持打开，如：

```bash
docker run -t -i ubuntu:18.04 /bin/bash
```

当利用 `docker run` 来创建容器时，Docker 在后台运行的标准操作包括：

- 检查本地是否存在指定的镜像，不存在就从 registry 下载
- 利用镜像创建并启动一个容器
- 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层
- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
- 从地址池配置一个 ip 地址给容器
- 执行用户指定的应用程序
- 执行完毕后容器被终止



可以利用 `docker container start` 命令，直接将一个已经终止（`exited`）的容器启动运行。

可以在伪终端中利用 `ps` 或 `top` 来查看进程信息



#### 守护态运行

更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 `-d` 参数来实现

如果不使用 `-d` 参数运行容器，容器会把输出的结果 (STDOUT) 打印到宿主机上面

如果使用了 `-d` 参数运行容器，输出结果可以用 `docker logs` 查看

容器是否会长久运行，是和 `docker run` 指定的命令有关，和 `-d` 参数无关

使用 `-d` 参数启动后会返回一个唯一的 id，也可以通过 `docker container ls` 命令来查看容器信息



#### 终止

可以使用 `docker container stop` 来终止一个运行中的容器。

此外，当 Docker 容器中指定的应用终结时，容器也自动终止

中只启动了一个终端的容器，用户通过 `exit` 命令或 `Ctrl+d` 来退出终端时，所创建的容器立刻终止

终止状态的容器可以用 `docker container ls -a` 命令看到

处于终止状态的容器，可以通过 `docker container start` 命令来重新启动。

此外，`docker container restart` 命令会将一个运行态的容器终止，然后再重新启动它



#### 进入

在使用 `-d` 参数时，容器启动后会进入后台。

某些时候需要进入容器进行操作，包括使用 `docker attach` 命令或 `docker exec` 命令，如：

```bash
docker run -dit ubuntu
docker container ls
docker attach 243c  #CONTAINER ID的前缀
```

*注意：* 如果从这个 stdin 中 exit，会导致容器的停止



`docker exec` 后边可以跟多个参数，这里主要说明 `-i` `-t` 参数。

只用 `-i` 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。

当 `-i` `-t` 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符，如：

```bash
docker run -dit ubuntu
docker container ls
docker exec -i 69d1 bash
docker exec -it 69d1 bash
```

如果从这个 stdin 中 exit，不会导致容器的停止



```bash
docker exec --help
```



#### 导出导入

导出：`docker export CONTAINER_ID > 文件名.tar`

导入：

- `cat 文件名.tar | docker import 镜像名/镜像:版本`
- `docker import URL 镜像`

如：

```bash
docker export 7691a814370e > ubuntu.tar
cat ubuntu.tar | docker import - test/ubuntu:v1.0
docker import http://example.com/exampleimage.tgz example/imagerepo
```

*注：用户既可以使用* *`docker load`* *来导入镜像存储文件到本地镜像库，也可以使用* *`docker import`* *来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。*



#### 删除

`docker container rm` ，如：

```bash
docker container rm trusting_newton
```

如果要删除一个运行中的容器，可以添加 `-f` 参数。Docker 会发送 `SIGKILL` 信号给容器。

用下面的命令可以清理掉所有处于终止状态的容器：

```bash
docker container prune
```



### 仓库

仓库（`Repository`）是集中存放镜像的地方。

一个容易混淆的概念是注册服务器（`Registry`）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 `docker.io/ubuntu` 来说，`docker.io` 是注册服务器地址，`ubuntu` 是仓库名

docker hub 是官方公共仓库

基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字

比如 `ansible/centos7-ansible` 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 `username/` 来指定使用某个用户提供的镜像，比如 `ansible` 用户

私有仓库、Nexus3.x 略，有需要再看



#### 登录

可以通过执行 `docker login` 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。

你可以通过 `docker logout` 退出登录。



#### 搜索

通过 `docker search` 命令来查找官方仓库中的镜像，如：

```bash
docker search centos
```

描述包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（`OFFICIAL`）、是否自动构建 （`AUTOMATED`）

查找的时候通过 `--filter=stars=N` 参数可以指定仅显示收藏数量为 `N` 以上的镜像



#### 拉取

```bash
docker pull
```



#### 推送

```bash
docker tag 镜像:版本 用户名/镜像:版本
docker push 用户名/镜像:版本
```

验证：

```bash
docker search username
```



### 数据

![image-20220207124300680](img/image-20220207124300680.png)

在容器中管理数据主要有两种方式：

- 数据卷（Volumes）
- 挂载主机目录 (Bind mounts)

`数据卷` 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：

- `数据卷` 可以在容器之间共享和重用
- 对 `数据卷` 的修改会立马生效
- 对 `数据卷` 的更新，不会影响镜像
- `数据卷` 默认会一直存在，即使容器被删除

`数据卷` 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）



#### 数据卷

##### 创建

```bash
docker volume create my-vol
```



##### 查看

列出全部：

```bash
docker volume ls
```

查看某个卷：

```bash
docker volume inspect my-vol
```

或(可能其实是两个不同的指令)

```bash
docker inspect my-vol
```



##### 启动

在用 `docker run` 命令的时候，使用 `--mount` 标记来将 `数据卷` 挂载到容器里。在一次 `docker run` 中可以挂载多个 `数据卷` ，如：

```bash
docker run -d -P \
    --name web \
    # -v my-vol:/usr/share/nginx/html \
    --mount source=my-vol,target=/usr/share/nginx/html \
    nginx:alpine
```



##### 删除

```bash
docker volume rm my-vol
```

`数据卷` 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 `数据卷`，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 `数据卷`。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 `docker rm -v` 这个命令。

无主的数据卷可能会占据很多空间，要清理请使用以下命令

```bash
docker volume prune
```



#### 主机目录

本地目录的路径必须是绝对路径，以前使用 `-v` 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 `--mount` 参数时如果本地目录不存在，Docker 会报错。如：

```bash
docker run -d -P \
    --name web \
    # -v /src/webapp:/usr/share/nginx/html \
    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \
    nginx:alpine
```

Docker 挂载主机目录的默认权限是 `读写`，用户也可以通过增加 `readonly` 指定为 `只读`，如：

```bash
docker run -d -P \
    --name web \
    # -v /src/webapp:/usr/share/nginx/html:ro \
    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \
    nginx:alpine
```

`--mount` 标记也可以从主机挂载单个文件到容器中，如：

```bash
docker run --rm -it \
   # -v $HOME/.bash_history:/root/.bash_history \
   --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \
   ubuntu:18.04 \
   bash
```

这样就可以记录在容器输入过的命令了。



### 网络

#### 端口

容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 `-P` 或 `-p` 参数来指定端口映射

当使用 `-P` 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口

如：

```bash
docker run -d -P nginx:alpine
docker container ls -l #port处看端口
```

同样的，可以通过 `docker logs` 命令来查看访问记录，如：

```bash
docker logs sth
```

`-p` 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 `ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort`。

使用 `hostPort:containerPort` 格式本地的 80 端口映射到容器的 80 端口，可以执行，如：

```bash
docker run -d -p 80:80 nginx:alpine
```

可以使用 `ip:hostPort:containerPort` 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1，可以：

```bash
docker run -d -p 127.0.0.1:80:80 nginx:alpine
```

使用 `ip::containerPort` 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口

```bash
docker run -d -p 127.0.0.1::80 nginx:alpine
```

还可以使用 `udp` 标记来指定 `udp` 端口

```bash
docker run -d -p 127.0.0.1:80:80/udp nginx:alpine
```



使用 `docker port` 来查看当前映射的端口配置，也可以查看到绑定的地址，如：

```bash
docker port sth 80
```

容器有自己的内部网络和 ip 地址（使用 `docker inspect` 查看，Docker 还可以有一个可变的网络配置。）

`-p` 标记可以多次使用来绑定多个端口，如：

```bash
docker run -d \
    -p 80:80 \
    -p 443:443 \
    nginx:alpine
```



#### 互联

> 建议将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 `--link` 参数

创建网络：

```bash
docker network create -d bridge my-net
```

运行一个容器并连接到新建的 `my-net` 网络

```bash
docker run -it --rm --name busybox1 --network my-net busybox sh
```

打开新的终端，再运行一个容器并加入到 `my-net` 网络

```bash
docker run -it --rm --name busybox2 --network my-net busybox sh
```

再在第三个终端查看容器信息：

```bash
docker container ls
```

此时两个容器可以互相 ping 通，如：

```bash
ping busybox2
```



#### DNS

 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。

在容器中使用 `mount` 命令可以看到挂载信息：

这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 `/etc/resolv.conf` 文件立刻得到更新。

配置全部容器的 DNS ，也可以在 `/etc/docker/daemon.json` 文件中增加以下内容来设置。

```bash
{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}
```

检验生效：

```bash
docker run -it --rm ubuntu:18.04 cat etc/resolv.conf
```

如果用户想要手动指定容器的配置，可以在使用 `docker run` 命令启动容器时加入如下参数：

`-h HOSTNAME` 或者 `--hostname=HOSTNAME` 设定容器的主机名，它会被写到容器内的 `/etc/hostname` 和 `/etc/hosts`。但它在容器外部看不到，既不会在 `docker container ls` 中显示，也不会在其他的容器的 `/etc/hosts` 看到。

`--dns=IP_ADDRESS` 添加 DNS 服务器到容器的 `/etc/resolv.conf` 中，让容器用这个服务器来解析所有不在 `/etc/hosts` 中的主机名。

`--dns-search=DOMAIN` 设定容器的搜索域，当设定搜索域为 `.example.com` 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 `host.example.com`。

> 注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 `/etc/resolv.conf` 来配置容器。



## Compose

`Compose` 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 `OpenStack` 中的 `Heat` 十分类似

定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」

它允许用户通过一个单独的 `docker-compose.yml` 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）

`Compose` 中有两个重要的概念：

- 服务 (`service`)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。
- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元，在 `docker-compose.yml` 文件中定义。

> 原版本是 Python 写的，目前 Docker 官方用 GO 语言 [重写](https://github.com/docker/compose-cli) 了 Docker Compose，并将其作为了 docker cli 的子命令，称为 `Compose V2`。你可以参照官方文档安装，然后将熟悉的 `docker-compose` 命令替换为 `docker compose`，即可使用 Docker Compose。

`Docker Desktop for Mac/Windows` 自带 `docker-compose` 二进制文件，安装 Docker 之后可以直接使用(默认为v2)

使用如下命令查看是否装了：

```bash
docker-compose --version
```

Linux 有多种方法安装



### 使用

#### Hello world

在新的目录编写 `app.py` ：

```python
from flask import Flask
from redis import Redis

app = Flask(__name__)
redis = Redis(host='redis', port=6379)

@app.route('/')
def hello():
    count = redis.incr('hits')
    return 'Nya! lr580\'s here ovo <br/> 该页面已被访问 {} 次。\n'.format(count)

if __name__ == "__main__":
    app.run(host="0.0.0.0", debug=True)
```

> 每次重启 count 会被清零

编写 `Dockerfile` ，内容：

```dockerfile
FROM python:3.6-alpine
ADD . /code
WORKDIR /code
RUN pip install redis flask
CMD ["python", "app.py"]
```

编写 `docker-compose.yml` ，内容：

```yml
version: '3'
services:

  web:
    build: .
    ports:
     - "5000:5000"

  redis:
    image: "redis:alpine"
```

运行：

```bash
docker-compose up
```

在同一目录下执行以下指令结束：

```bash
docker-compose down
```



### 指令

通用格式：

```bash
docker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]
```

`-f, --file FILE` 指定使用的 Compose 模板文件，默认为 `docker-compose.yml`，可以多次指定。

`-p, --project-name NAME` 指定项目名称，默认将使用所在目录名称作为项目名。

`--verbose` 输出更多调试信息。

`-v, --version` 打印版本并退出。



#### help

```bash
docker-compose help
docker-compose 指令 --help
```



#### build

格式为 `docker-compose build [options] [SERVICE...]`。

构建（重新构建）项目中的服务容器。

服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。

可以随时在项目目录下运行 `docker-compose build` 来重新构建服务。

选项包括：

- `--force-rm` 删除构建过程中的临时容器。
- `--no-cache` 构建镜像过程中不使用 cache（这将加长构建过程）。
- `--pull` 始终尝试通过 pull 来获取更新版本的镜像。



#### config

验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。



#### down

此命令将会停止 `up` 命令所启动的容器，并移除网络



#### exec

进入指定的容器



#### images

列出 Compose 文件中包含的镜像。

`up` 时才能看到，如果全部关闭是看不到的



#### kill

格式为 `docker-compose kill [options] [SERVICE...]`。

通过发送 `SIGKILL` 信号来强制停止服务容器。

支持通过 `-s` 参数来指定发送的信号，例如通过如下指令发送 `SIGINT` 信号。

```bash
docker-compose kill -s SIGINT
```



#### logs

格式为 `docker-compose logs [options] [SERVICE...]`。

查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 `--no-color` 来关闭颜色。

该命令在调试问题的时候十分有用。



#### pause

格式为 `docker-compose pause [SERVICE...]`。

暂停一个服务容器。



#### port

格式为 `docker-compose port [options] SERVICE PRIVATE_PORT`。

打印某个容器端口所映射的公共端口。

选项：

- `--protocol=proto` 指定端口协议，tcp（默认值）或者 udp。
- `--index=index` 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。



#### ps

格式为 `docker-compose ps [options] [SERVICE...]`。

列出项目中目前的所有容器。

选项：

- `-q` 只打印容器的 ID 信息。



#### pull

格式为 `docker-compose pull [options] [SERVICE...]`。

拉取服务依赖的镜像。

选项：

- `--ignore-pull-failures` 忽略拉取镜像过程中的错误。



#### push

推送服务依赖的镜像到 Docker 镜像仓库。



#### restart

格式为 `docker-compose restart [options] [SERVICE...]`。

重启项目中的服务。

选项：

- `-t, --timeout TIMEOUT` 指定重启前停止容器的超时（默认为 10 秒）。



#### rm

格式为 `docker-compose rm [options] [SERVICE...]`。

删除所有（停止状态的）服务容器。推荐先执行 `docker-compose stop` 命令来停止容器。

选项：

- `-f, --force` 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。
- `-v` 删除容器所挂载的数据卷。



#### run

格式为 `docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]`。

在指定服务上执行一个命令。例如：

```bash
docker-compose run ubuntu ping docker.com
```

将会启动一个 ubuntu 服务容器，并执行 `ping docker.com` 命令。

默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。

该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。

两个不同点：

- 给定命令将会覆盖原有的自动运行命令；
- 不会自动创建端口，以避免冲突。

如果不希望自动启动关联的容器，可以使用 `--no-deps` 选项，例如

```bash
docker-compose run --no-deps web python manage.py shell
```

将不会启动 web 容器所关联的其它容器。

选项：

- `-d` 后台运行容器。
- `--name NAME` 为容器指定一个名字。
- `--entrypoint CMD` 覆盖默认的容器启动指令。
- `-e KEY=VAL` 设置环境变量值，可多次使用选项来设置多个环境变量。
- `-u, --user=""` 指定运行容器的用户名或者 uid。
- `--no-deps` 不自动启动关联的服务容器。
- `--rm` 运行命令后自动删除容器，`d` 模式下将忽略。
- `-p, --publish=[]` 映射容器端口到本地主机。
- `--service-ports` 配置服务端口并映射到本地主机。
- `-T` 不分配伪 tty，意味着依赖 tty 的指令将无法运行。



#### scale

格式为 `docker-compose scale [options] [SERVICE=NUM...]`。

设置指定服务运行的容器个数。

通过 `service=num` 的参数来设置数量。例如：

```bash
docker-compose scale web=3 db=2
```

一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器

选项：

- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）



#### start

格式为 `docker-compose start [SERVICE...]`。

启动已经存在的服务容器。



#### stop

格式为 `docker-compose stop [options] [SERVICE...]`。

停止已经处于运行状态的容器，但不删除它。通过 `docker-compose start` 可以再次启动这些容器。

选项：

- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。



#### top

查看各个服务容器内运行的进程。



#### unpause

格式为 `docker-compose unpause [SERVICE...]`。

恢复处于暂停状态中的服务。



#### up

格式为 `docker-compose up [options] [SERVICE...]`。

该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。

链接的服务都将会被自动启动，除非已经处于运行状态。

可以说，大部分时候都可以直接通过该命令来启动一个项目。

默认情况，`docker-compose up` 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。

当通过 `Ctrl-C` 停止命令时，所有容器将会停止。

如果使用 `docker-compose up -d`，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。

默认情况，如果服务容器已经存在，`docker-compose up` 将会尝试停止容器，然后重新创建（保持使用 `volumes-from` 挂载的卷），以保证新启动的服务匹配 `docker-compose.yml` 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 `docker-compose up --no-recreate`。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 `docker-compose up --no-deps -d <SERVICE_NAME>` 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。

选项：

- `-d` 在后台运行服务容器。
- `--no-color` 不使用颜色来区分不同的服务的控制台输出。
- `--no-deps` 不启动服务所链接的容器。
- `--force-recreate` 强制重新创建容器，不能与 `--no-recreate` 同时使用。
- `--no-recreate` 如果容器已经存在了，则不重新创建，不能与 `--force-recreate` 同时使用。
- `--no-build` 不自动构建缺失的服务镜像。
- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。



### compose文件

默认的模板文件名称为 `docker-compose.yml`，格式为 YAML 格式。

注意每个服务都必须通过 `image` 指令指定镜像或 `build` 指令（需要 Dockerfile）等来自动构建生成镜像。

如果使用 `build` 指令，在 `Dockerfile` 中设置的选项(例如：`CMD`, `EXPOSE`, `VOLUME`, `ENV` 等) 将会自动被获取，无需在 `docker-compose.yml` 中重复设置。



#### build

指定 `Dockerfile` 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 `Compose` 将会利用它自动构建这个镜像，然后使用这个镜像。如：

```yml
version: '3'
services:

  webapp:
    build: ./dir
```

你也可以使用 `context` 指令指定 `Dockerfile` 所在文件夹的路径。

使用 `dockerfile` 指令指定 `Dockerfile` 文件名。

使用 `arg` 指令指定构建镜像时的变量。

```yml
version: '3'
services:

  webapp:
    build:
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1
```

使用 `cache_from` 指定构建镜像的缓存

```yml
build:
  context: .
  cache_from:
    - alpine:latest
    - corp/web_app:3.14
```



#### cap_add,cap_drop

指定容器的内核能力（capacity）分配。

例如，让容器拥有所有能力可以指定为：

```yml
cap_add:
  - ALL
```

去掉 NET_ADMIN 能力可以指定为：

```yml
cap_drop:
  - NET_ADMIN
```



#### command

覆盖容器启动后默认执行的命令。

```yml
command: echo "hello world"
```



#### container_name

指定容器名称。默认将会使用 `项目名称_服务名称_序号` 这样的格式。

```yml
container_name: docker-web-container
```

> 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。



#### dns

自定义 `DNS` 服务器。可以是一个值，也可以是一个列表。

```yml
dns: 8.8.8.8

dns:
  - 8.8.8.8
  - 114.114.114.114
```

配置 `DNS` 搜索域。可以是一个值，也可以是一个列表。

```yml
dns_search: example.com

dns_search:
  - domain1.example.com
  - domain2.example.com
```



#### env_file

从文件中获取环境变量，可以为单独的文件路径或列表。

如果通过 `docker-compose -f FILE` 方式来指定 Compose 模板文件，则 `env_file` 中变量的路径会基于模板文件路径。

如果有变量名称与 `environment` 指令冲突，则按照惯例，以后者为准。

```yml
env_file: .env

env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env
```

环境变量文件中每一行必须符合格式，支持 `#` 开头的注释行。

设置环境变量。你可以使用数组或字典两种格式。

只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。

```yml
environment:
  RACK_ENV: development
  SESSION_SECRET:

environment:
  - RACK_ENV=development
  - SESSION_SECRET
```

如果变量名称或者值中用到 `true|false，yes|no` 等表达 [布尔](https://yaml.org/type/bool.html) 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括

```yml
y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF
```



Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 `.env` 文件中的变量。

例如，下面的 Compose 文件将从运行它的环境中读取变量 `${MONGO_VERSION}` 的值，并写入执行的指令中。

```yml
version: "3"
services:

db:
  image: "mongo:${MONGO_VERSION}"
```





#### image

指定为镜像名称或镜像 ID。如果镜像在本地不存在，`Compose` 将会尝试拉取这个镜像。

```yml
image: ubuntu
image: orchardup/postgresql
image: a4bc65fd
```



> 网络看文档吧，我不知道有什么用



#### secrets

存储敏感数据，例如 `mysql` 服务密码。

```yml
version: "3.1"
services:

mysql:
  image: mysql
  environment:
    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password
  secrets:
    - db_root_password
    - my_other_secret

secrets:
  my_secret:
    file: ./my_secret.txt
  my_other_secret:
    external: true
```



#### volumes

数据卷所挂载路径设置。可以设置为宿主机路径(`HOST:CONTAINER`)或者数据卷名称(`VOLUME:CONTAINER`)，并且可以设置访问模式 （`HOST:CONTAINER:ro`）。

该指令中路径支持相对路径。

```yml
volumes:
 - /var/lib/mysql
 - cache/:/tmp/cache
 - ~/configs:/etc/configs/:ro
```

如果路径为数据卷名称，必须在文件中配置数据卷。

```yml
version: "3"

services:
  my_src:
    image: mysql:8.0
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:
```



## swarm

咕咕咕