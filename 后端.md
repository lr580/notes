<p align="right" style="font-size:18px;font-weight:900;color:chocolate"> --by 蒟蒻lr580 </p>

> 阅读前的前置知识：`(C/C++),(PYTHON),(JAVA),HTML,CSS,JS`

# PHP

## 使用

### 安装

#### windows

照着课件来

Zend 安装遇到 `已安装此产品的另一版本` 提示时，直接找缓存目录 `C:\ProgramData\Package Cache` ，按时间找最近的一个，点开看到安装包继续安装 [参考资料](https://blog.csdn.net/chb_1_2/article/details/88932088)

改windows-preferences-php-code style-code templates-code-simple php file-edit 修改为模板：

```php+HTML
<!DOCTYPE html>
<html>

<head>
    <meta charset='UTF-8'>
    <title></title>
</head>

<body>
    <?php
    echo "Hello World!"
    ?>
</body>

</html>
```

修改zend默认服务器配置：windows-preferences-php-servers-进行更改即可

vsc 格式化插件：PHP Intelephense

配置 php.ini ，开启拓展：

```ini
extesion_dir = "目录/php7/ext"
extension=php_pdo_mysql.dll
extension=php_mysqli.dll
```

若 mysql 为 8.0 ，对要登录的账号设置，如：

```mysql
use mysql;
alter user root@localhost identified with mysql_native_password by '123456';
flush privileges;
```





## 基本语法

### 基本格式

代码文件是`.php`。上面允许出现HTML语法。

php脚本的长标志是`<?php ?>`，注释同C语言格式。

单行代码可以不用分号，多行一定要。缩进格式同C语言。

> 在php的配置文件（php.ini）中有一个short_open_tag的值，开启以后可以使用PHP的短标签：`<? ?>`

开启短标签后，可以用`<?=`代替`<?echo`。

如：

```php
<?php echo "123"?>
<?= "123" ?>  //这两行代码等效
```

> [php7新特性参见这里](https://www.runoob.com/php/php7-new-features.html)

### 变量

#### 命名规则

变量以`$`开头。命名规则与C类似。创建和使用与PYTHON类似(弱类型)。如：

```php
<?php
$lr=580;
echo $lr*2;
?>
```

#### 作用域

##### local

即函数的局部变量

##### global

函数外定义的变量都有全局作用域。可以跨段使用，如：

```php
<?php$x=3;?>
<?=$x?>//$x写成x暴毙
```

函数内使用全局变量需要global关键字。如：

```php
<?php
$x=5; /*运行环境：SCNUOJ */
function f()
{
    global $x; //没有这一行，即使没有下一行也会报错(但是可以$x=1)
    ++$x;
    echo $x; //1
    echo " ";
}
f();
echo $x; //5
?>
```

事实上全局变量是存在字典`$GLOBALS`里的，即全局`$x`等效`于$GLOBALS['x']`。

```php
<?php
$x=5;
$y=10;
function myTest()
{
    $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];
} 
myTest();
echo $y;
?>
```

> 注：在SCNUOJ上跑不动这个代码，原因未知。



##### static

同C语言static。如：

```php
<?php
function myTest()
{
    static $x=0;
    echo $x;
    $x++;
    echo PHP_EOL; // 换行符，同HTML一样，输出等于一个空格
}
 
myTest();
myTest();
myTest();
?>
```



##### parameter

参数作用域。



#### 数据类型

有String,Integer,Float,Boolean,Array,Object,NULL

`var_dump()`函数输出变量数据类型和值。如：

```php
<?php
$x=1;
var_dump($x);//int(1)
?>
```



##### 字符串

###### 定义

可以单双引号。区别：

1. 双引号可以自带变量占位
2. 双引号内`\`转义，单引号代表普通字符
3. 单引号内可以不转移地用双引号，反之相反
4. 单引号处理速度略快于双引号

举例：

```php
<?php
$a = '\n12\n34';
$b = "\\n12\\n34";
echo $a,'<br/>',$b, '<br/>';
echo "$a, $b",'<br/>','$a, $b';
?>
```

可以定义多行字符，以`<<<EOF`开始，以`EOF;`结束。然后中间任意文本，如：

```php
<?php
$name="lr580"; 
$a= <<<EOF
        abc$name
            "1 23
EOF;
// 结束需要独立一行且前后不能空格
//里面的引号就是输出可显示的引号，换行和tab没用，空格有用
echo $a;
?>
```



###### 运算

不支持`+`运算符。(能`+`运算的都是数值).但支持并置运算符进行字符串连接。

```php
<?php
$t1="nice";
echo $t1.' lad!';
?>
```

支持`strlen`函数。返回长度。

```php
<?php
echo strlen("lr580");
echo strlen("你好"); //中文字符3个长度
?>
```

支持`strpos`函数，返回子串出现位置。查无返回FALSE。



> [更多运算函数](https://www.runoob.com/php/php-ref-string.html)



##### 整数

三种赋值方法，十进制，十六进制`0x`，八进制前导`0`。

支持四则运算，除法不是整除，零除报错，取模(浮点数会强转整数，右操作数是负数等同于正数)，位运算。

数据范围是C的signed long long。

##### 浮点数

同一般程序语言的赋值方法和运算方法。

##### 布尔值

TRUE或FALSE，不区分大小写。echo输出true为1，false啥也不输出

```php
<?php
$x=TRue;
echo $x;
?>
```

##### NULL

不区分大小写。

```php
<?php
$x=null;
$y;
var_dump($x);
echo $x; //nothing
// echo $y; //$y不仅不可以输出，也不可以vardump，不然都会报错
?>
```



#### 常量

##### 普通常量

使用`define()`定义常量，第一个参数字符串，名字；第二个参数值，第三个参数若true，大小写不敏感。默认敏感。

常量是全局的。如：

```php
<?php
function f()
{
    define("lr",580);
}
f();
echo lr;
?>
```

也可以用const。调用输出常量名或`constant('常量名')`如：

```php
<?php
const x=3;
echo x;
echo constant('x');//二者等效
?>
```



##### 魔术常量

值随着它们在代码中的位置改变而改变。不区分大小写。

`__LINE__`是当前在脚本.php文件中的行数

`__FILE__`是当前文件绝对路径

`__DIR__`是当前文件所在目录的绝对路径(不含后缀`/`)，等价于`dirname(__FILE__)`

`__FUNCTION__`是当前函数的名字(不在函数内调用是输出空)。PHP5起得到的值区分大小写，PHP4中总是小写的。(PHP4.3.0新增)

`__CLASS__`返回类的名字。同PHP5起区分大小写。PHP5.4起对trait也起作用(调用 trait 方法的类的名字)。同理类外无输出。

`__METHOD__`方法名。对函数也可用。

`__NAMESPACE__`命名空间名称。PHP5.3.0。未定义(`namespace 空间名;`)时为空。

`__TRAIT__`



#### 运算

##### 逻辑

###### 比较相等

有`==`,`===`

> 细则：
>
> ![image-20211007194417871](img/image-20211007194417871.png)
>
> ![image-20211007194437384](img/image-20211007194437384.png)
>
> ![image-20211007194450604](img/image-20211007194450604.png)
>
> ![image-20211007194458827](img/image-20211007194458827.png)



###### 不等号

不等于是`<>`或`!=`，其他同C。绝对不等于是`!==`。



###### 逻辑运算

`and`,`or`,`xor`,`&&`,`||`,`!`



###### 三元运算

PHP5.3起，可以省略中间部分而写成`expr1?:expr2`

PHP7+版本有运算符`expr1??expe2`，当且仅当`expr1`为NULL返回`expr2`，否则返回`expr1`。



###### 组合比较

`$a<=>$b`，若`$a>$b`，返回$1$，若`$a<$b`，返回$-1$，否则返回$0$



##### 优先级

| 结合方向 | 运算符                                                   | 附加信息                 |
| :------- | :------------------------------------------------------- | :----------------------- |
| 无       | clone new                                                | clone 和 new             |
| 左       | [                                                        | array()                  |
| 右       | ++ -- ~ (int) (float) (string) (array) (object) (bool) @ | 类型和递增／递减         |
| 无       | instanceof                                               | 类型                     |
| 右       | !                                                        | 逻辑运算符               |
| 左       | * / %                                                    | 算术运算符               |
| 左       | + – .                                                    | 算术运算符和字符串运算符 |
| 左       | << >>                                                    | 位运算符                 |
| 无       | `== != === !== <>`                                       | 比较运算符               |
| 左       | &                                                        | 位运算符和引用           |
| 左       | ^                                                        | 位运算符                 |
| 左       | \|                                                       | 位运算符                 |
| 左       | &&                                                       | 逻辑运算符               |
| 左       | \|\|                                                     | 逻辑运算符               |
| 左       | ? :                                                      | 三元运算符               |
| 右       | = += -= *= /= .= %= &= \|= ^= <<= >>= =>                 | 赋值运算符               |
| 左       | and                                                      | 逻辑运算符               |
| 左       | xor                                                      | 逻辑运算符               |
| 左       | or                                                       | 逻辑运算符               |
| 左       | ,                                                        | 多处用到                 |

注意：or,and和||&&优先级不一样，虽然效果相同。如：

```php
<?php
// 优先级： &&  >  =  >  and
// 优先级： ||  >  =  >  or
 
$a = 3;
$b = false;
$c = $a or $b;
var_dump($c);          // 这里的 $c 为 int 值3，而不是 boolean 值 true
$d = $a || $b;
var_dump($d);          //这里的 $d 就是 boolean 值 true 
?>
```



#### 数组

有数值数组，关联数组(类似PYTHON字典)和多维数组。

> [完整参考手册](https://www.runoob.com/php/php-ref-array.html)

##### 创建

构造数值函数`array(值, ...)`，自动分配，下标从0递增。

也可以手动分配，如PYTHON。即`$数组变量[下标]=值`

构造关联数组：`array(键=>值, ...)`，`$数组变量[键]=值`

数值和关联可以混用。

如：

```php
<?php
$x=array(1,3,5);
echo $x[0]+($x[1]*$x[2]);
$x[6]=7;
echo $x[6]+count($x);//11
?>
```

```php
<?php
$x=array('lr'=>580,'bc'=>998);
$x['awa']=13;
echo count($x),' ',$x['awa']+$x['bc'];
?>
```

```php
<?php
$cars = array
(
    array("Volvo",100,96),
    array("BMW",60,59),
    array("Toyota",110,100)
);
?>
```



##### 遍历

用`foreach($数组 as $键变量=>$值变量)`或`foreach($数组 as $值变量)`，如：

```php
<?php
$x=array(1,-1);
foreach($x as $key=>$v)
{
    echo $key,' ', $v, '<br/>';
}
$y=array('lr'=>580,'bc'=>998);
foreach($y as $key=>$v)
{
    echo $key,' ', $v, '<br/>';
}
?>
```

直接输出整个数组用`var_dump`或`print_r`，不用`echo`。



##### 运算

`+`运算符取交集，如果都有某个下标，取左操作数的，如：

```php
<?php
$x=array(1,2);
$y=array(3,2=>4);
var_dump($x);
echo '<br/>';
print_r($y);
echo '<br/>';
print_r($x+$y);//1,2,4
?>
```

`==`当且仅当有相同的键值对。

`===`在上述前提下还要求顺序相同。

类推定义`!=,<>,!==`。如：

```php
<?php
$x=array(1,2);
$y=array(1=>2,0=>1);
echo $x==$y?'yes':'no','<br/>',$x===$y?'yes':'no';
?>
```





##### 函数

`is_array($数组)`判定是否是数组

`count($数组)`长度取元素数量。

`sort($数组)`升序排序，`rsort`降序。

​	`asort`根据关联数组值升序，`ksort`根据关联数组键。

​	同理有：`arsort,krsort`。

`end`将内部指针指向数组中的最后一个元素，并输出

> - [current()](https://www.runoob.com/php/func-array-current.html) - 返回数组中的当前元素的值。
> - [next()](https://www.runoob.com/php/func-array-next.html) - 将内部指针指向数组中的下一个元素，并输出。
> - [prev()](https://www.runoob.com/php/func-array-prev.html) - 将内部指针指向数组中的上一个元素，并输出。
> - [reset()](https://www.runoob.com/php/func-array-reset.html) - 将内部指针指向数组中的第一个元素，并输出。
> - [each()](https://www.runoob.com/php/func-array-each.html) - 返回当前元素的键名和键值，并将内部指针向前移动。

`in_array(一些值,$数组)`，可以有第三个参数表示是否区分大小写

如：

```php
<?php
$arr=array('a','B','A'); //ASCII顺序
sort($arr);
print_r($arr);
?>
```



#### 超级全局变量

- $GLOBALS

- $_SERVER

  包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。如有属性`PHP_SELF,SERVER_NAME,HTTP_HOST,HTTP_REFERER,HTTP_USER_AGENT,SCRIPT_NAME`

- $_REQUEST

  收集HTML表单提交的数据。

- $_POST

  收集HTML表单提交的数据。

- $_GET

  收集HTML表单提交的数据。

- $_FILES

- $_ENV

- $_COOKIE

- $_SESSION



> [表单相关参见](https://www.runoob.com/php/php-forms.html)



##### _SERVER

详细：

| 元素/代码                       | 描述                                                         |
| :------------------------------ | :----------------------------------------------------------- |
| $_SERVER['PHP_SELF']            | 当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $_SERVER['PHP_SELF'] 将得到 /test.php/foo.bar。__FILE__ 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 |
| $_SERVER['GATEWAY_INTERFACE']   | 服务器使用的 CGI 规范的版本；例如，"CGI/1.1"。               |
| $_SERVER['SERVER_ADDR']         | 当前运行脚本所在的服务器的 IP 地址。                         |
| $_SERVER['SERVER_NAME']         | 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: www.runoob.com) |
| $_SERVER['SERVER_SOFTWARE']     | 服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache/2.2.24) |
| $_SERVER['SERVER_PROTOCOL']     | 请求页面时通信协议的名称和版本。例如，"HTTP/1.0"。           |
| $_SERVER['REQUEST_METHOD']      | 访问页面使用的请求方法；例如，"GET", "HEAD"，"POST"，"PUT"。 |
| $_SERVER['REQUEST_TIME']        | 请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496)   |
| $_SERVER['QUERY_STRING']        | query string（查询字符串），如果有的话，通过它进行页面访问。 |
| $_SERVER['HTTP_ACCEPT']         | 当前请求头中 Accept: 项的内容，如果存在的话。                |
| $_SERVER['HTTP_ACCEPT_CHARSET'] | 当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如："iso-8859-1,*,utf-8"。 |
| $_SERVER['HTTP_HOST']           | 当前请求头中 Host: 项的内容，如果存在的话。                  |
| $_SERVER['HTTP_REFERER']        | 引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。) |
| $_SERVER['HTTPS']               | 如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。      |
| $_SERVER['REMOTE_ADDR']         | 浏览当前页面的用户的 IP 地址。                               |
| $_SERVER['REMOTE_HOST']         | 浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。 |
| $_SERVER['REMOTE_PORT']         | 用户机器上连接到 Web 服务器所使用的端口号。                  |
| $_SERVER['SCRIPT_FILENAME']     | 当前执行脚本的绝对路径。                                     |
| $_SERVER['SERVER_ADMIN']        | 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：someone@runoob.com) |
| $_SERVER['SERVER_PORT']         | Web 服务器使用的端口。默认值为 "80"。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。 |
| $_SERVER['SERVER_SIGNATURE']    | 包含了服务器版本和虚拟主机名的字符串。                       |
| $_SERVER['PATH_TRANSLATED']     | 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 |
| $_SERVER['SCRIPT_NAME']         | 包含当前脚本的路径。这在页面需要指向自己时非常有用。__FILE__ 常量包含当前脚本(例如包含文件)的完整路径和文件名。 |
| $_SERVER['SCRIPT_URI']          | URI 用来指定要访问的页面。例如 "/index.html"。               |



##### \_REQUEST

预定义的 \$_REQUEST 变量包含了 ​\$\_GET、\$\_POST 和 \$\_COOKIE 的内容。

\$\_REQUEST 变量可用来收集通过 GET 和 POST 方法发送的表单数据。

举例：

```php
<!DOCTYPE html>
<html>
<body>

<form method="post" action="<?php echo $_SERVER['PHP_SELF'];?>">
Name: <input type="text" name="fname">
<input type="submit">
</form>

<?php 
$name = htmlspecialchars($_REQUEST['fname']); 
echo $name; 
?>

</body>
</html>
```



##### _POST

举例：

```php+HTML
<!DOCTYPE html>
<html>
<body>

<form method="post" action="<?php echo $_SERVER['PHP_SELF'];?>">
Name: <input type="text" name="fname">
<input type="submit">
</form>

<?php 
$name = htmlspecialchars($_POST['fname']); 
echo $name; 
?>

</body>
</html>
```



##### _GET

举例：

```html
<html>
<body>
<a href="test_get.php?subject=PHP&web=runoob.com">Test $GET</a>
</body>
</html>
```

```php+HTML
<!DOCTYPE html>
<html>
<body>

<a href="test_get.php?subject=PHP&web=runoob.com">测试 $_GET</a>

</body>
</html>
```



##### _COOKIE

是关联数组。通常用`isset`函数查找某个键值是否存在。

操作函数：`setcookie(键,值,过期时间)`

删除即更改过期时间为当前之前的时间即可，如：

```php
<?php
// 设置 cookie 过期时间为过去 1 小时
setcookie("user", "", time()-3600);
?>
```



##### _SESSION

PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。

> （未核实）该信息是临时的，在用户离开网站后将被删除。

删除某些 session 数据，可以使用 unset() 或 session_destroy() 函数。后者彻底删除全部session数据。



#### 对象

##### 概述

定义用`class`关键字(语法类似java)。成员属性用`var`关键字，可以声明初始值。

新建变量用`new 类名`，如果没有构造函数可以不写括号。访问变量的成员都用`->`操作符。

`$this`表示self指针，用`$this->`运算符访问成员属性。

构造函数是`__construct`，析构函数是`__destruct`。子类构造方法不能自动调用父类的构造方法。

继承用`extends`，不支持多继承。`parent`关键字加`::`访问父类。

访问控制关键字同C：

> - **public（公有）：**公有的类成员可以在任何地方被访问。
> - **protected（受保护）：**受保护的类成员则可以被其自身以及其子类和父类访问。
> - **private（私有）：**私有的类成员则只能被其定义所在的类访问。

(有关键字时可以不声明`var`，`var`认为是共有)。成员函数不设置控制关键字默认为公有。子类不能重定义私有成员，其他可以。

接口的语法同JAVA。显然类中必须实现接口中定义的所有方法。

常成员(常量)用`const`定义，调用为`类名::常量名`或`$实例名::常量名`，或字符串值为类名的：`$字符串::常量名`。常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。

抽象类语法同JAVA。

> 继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。
>
> 此外，子类方法可以包含父类抽象方法中不存在的可选参数。
>
> 例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则也是可以正常运行的。

静态成员语法同java。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。调用为`类名::静态成员`

> 自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static。

final语法同JAVA。类为final不可继承。

如：

```php
<?php
/**
 * Define MyClass
 */
class MyClass
{
    public $public = 'Public';
    protected $protected = 'Protected';
    private $private = 'Private';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj = new MyClass();
echo $obj->public; // 这行能被正常执行
echo $obj->protected; // 这行会产生一个致命错误
echo $obj->private; // 这行也会产生一个致命错误
$obj->printHello(); // 输出 Public、Protected 和 Private


/**
 * Define MyClass2
 */
class MyClass2 extends MyClass
{
    // 可以对 public 和 protected 进行重定义，但 private 而不能
    protected $protected = 'Protected2';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj2 = new MyClass2();
echo $obj2->public; // 这行能被正常执行
echo $obj2->private; // 未定义 private
echo $obj2->protected; // 这行会产生一个致命错误
$obj2->printHello(); // 输出 Public、Protected2 和 Undefined

?>
```

```php
<?php
abstract class AbstractClass
{
    // 我们的抽象方法仅需要定义需要的参数
    abstract protected function prefixName($name);

}

class ConcreteClass extends AbstractClass
{

    // 我们的子类可以定义父类签名中不存在的可选参数
    public function prefixName($name, $separator = ".") {
        if ($name == "Pacman") {
            $prefix = "Mr";
        } elseif ($name == "Pacwoman") {
            $prefix = "Mrs";
        } else {
            $prefix = "";
        }
        return "{$prefix}{$separator} {$name}";
    }
}

$class = new ConcreteClass;
echo $class->prefixName("Pacman"), "\n";
echo $class->prefixName("Pacwoman"), "\n";
?>
```



##### trait

一种代码复用的方法。

声明：`trait 名字{}`，调用：`use 名字;`

如：

```php
<?php
class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}
 
trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}
 
class MyHelloWorld extends Base {
    use SayWorld;
}
 
$o = new MyHelloWorld();
$o->sayHello();
?>
```





### 流程控制

#### 条件判断

##### if

使用`if(),elseif(),else()`，大括号括起来语句(或不括起来单行)，语法大同C。`elseif`写成`else if`也行。

##### switch

语法同C。case可以是字符串或浮点数。如：

```php
<?php
$x=3.1;
switch($x)
{
    case 3.1:
        echo 'awa';
}
?>
```



#### 循环

`for`,`while`和`do...while`格式同C。

有`foreach($数组 as $下标变量 => $值变量)`。



#### 函数

以字母或下划线开头（不能以数字开头）。

创建语法：

```php
function 函数名(参数)
{
    
}
```

可以有默认参数。如：

```php
<?php
function f($x=1)
{
    echo $x;
}
f();
f(2);
?>
```

可以传引用，如`function foo(&$bar){...`



#### 命名空间

##### 定义

未定义命名空间时，所有常量、类和函数放在全局空间。

文件包含命名空间时，必须在所有其他代码之前声明：`namespace 空间名;`或`namespace 名{代码块}`。第二种解法常用于一个代码文件有多个空间时。

全局代码用无名的`namespace{}`。声明了之后整个文件部分都必须在任何一个命名空间或全局代码大括号内，不能在别的地方。

调用命名空间：`空间名\空间内的内容名`

如：

```php
<?php
namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace { // 全局代码
session_start();
$a = MyProject\connect();
echo MyProject\Connection::start();
}
?>
```

有命名空间后，声明空间前唯一合法的代码是`declare`，如：

```php
<?php
declare(encoding='UTF-8'); //定义多个命名空间和不包含在命名空间中的代码
namespace {...
?>
```

可以定义子空间，如`namespace MyProject\Sub\Level`。

全局变量可以使用完全限定名称调用，如全局函数`f`可写作调用`\f()`，常量、类等同理。



##### 引用

`use 命名空间`

`use 命名空间 as 别名`

可以用关键字`namespace`显式访问当前命名空间及其子空间的元素，等价类的`self`操作符。

如：

```php
<?php
namespace MyProject;

use blah\blah as mine; // 引入了 blah\blah 命名空间，并定义了个别名mine

mine\mine(); // 调用函数 blah\blah\mine()
namespace\blah\mine(); // 调用函数 MyProject\blah\mine()

namespace\func(); // 调用函数 MyProject\func()
namespace\sub\func(); // 调用函数 MyProject\sub\func()
namespace\cname::method(); // 调用 MyProject\cname 类的静态方法
$a = new namespace\sub\cname(); // 实例化 MyProject\sub\cname 类的对象
$b = namespace\CONSTANT; // 将常量 MyProject\CONSTANT 的值赋给 $b
?>
```

```php
<?php
namespace\func(); // calls function func()
namespace\sub\func(); // calls function sub\func()
namespace\cname::method(); // calls static method "method" of class cname
$a = new namespace\sub\cname(); // instantiates object of class sub\cname
$b = namespace\CONSTANT; // assigns value of constant CONSTANT to $b
?>
```

```php
<?php
namespace foo;
use My\Full\Classname as Another;

// 下面的例子与 use My\Full\NSname as NSname 相同
use My\Full\NSname;

// 导入一个全局类
use \ArrayObject;

$obj = new namespace\Another; // 实例化 foo\Another 对象
$obj = new Another; // 实例化 My\Full\Classname　对象
NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func
$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象
// 如果不使用 "use \ArrayObject" ，则实例化一个 foo\ArrayObject 对象
?>
```

```php
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // 实例化 My\Full\Classname 对象
NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func
?>
```

甚至可以用字符串动态生成命名空间对象：

```php
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // 实例化一个 My\Full\Classname 对象
$a = 'Another';
$obj = new $a;      // 实际化一个 Another 对象
?>
```

> 名称解析遵循下列规则：
>
> 1. 对完全限定名称的函数，类和常量的调用在编译时解析。例如 *new \A\B* 解析为类 *A\B*。
>
> 2. 所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 *A\B\C* 被导入为 *C*，那么对 *C\D\e()* 的调用就会被转换为 *A\B\C\D\e()*。
>
> 3. 在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 *A\B* 内部调用 *C\D\e()*，则 *C\D\e()* 会被转换为 *A\B\C\D\e()* 。
>
> 4. 非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 *A\B\C* 导入为C，则 *new C()* 被转换为 *new A\B\C()* 。
>
> 5. 在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数
>
>     
>
>    foo()
>
>     
>
>    的调用是这样解析的：
>
>    1. 在当前命名空间中查找名为 *A\B\foo()* 的函数
>    2. 尝试查找并调用 *全局(global)* 空间中的函数 *foo()*。
>
> 6. 在命名空间（例如
>
>    A\B
>
>    ）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用
>
>     
>
>    new C()
>
>     
>
>    及
>
>     
>
>    new D\E()
>
>     
>
>    的解析过程：
>
>     
>
>    new C()
>
>    的解析:
>
>    1. 在当前命名空间中查找*A\B\C*类。
>    2. 尝试自动装载类*A\B\C*。
>
>    new D\E()
>
>    的解析:
>
>    1. 在类名称前面加上当前命名空间名称变成：*A\B\D\E*，然后查找该类。
>    2. 尝试自动装载类 *A\B\D\E*。
>
>    为了引用全局命名空间中的全局类，必须使用完全限定名称
>
>     
>
>    new \C()



#### 包含文件

使用`include`或`require`操作符加上字符串文件名，表示在此处插入别的文件的代码。

> 这两个操作符的区别在于
>
> ①错误处理方式：
>
> - require 生成`E_COMPILE_ERROR`，错误发生后脚本停止执行
> - include 生成`E_WARNING`，错误发生后脚本继续执行
>
> ②位置：
>
> - require 一般放在文件最前面，程序执行前先导入要引用的文件
> - include 一般放在程序的流程控制中，程序执行时碰到才会引用
>
> [更多区别](https://www.runoob.com/w3cnote/php-different-include-and-require.html)

如：

```php
<?php
$color='red'; //vars.php
$car='BMW';
?>
```

```php+HTML
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>
<h1>欢迎来到我的主页!</h1>
<?php 
include 'vars.php';
echo "I have a $color $car"; // I have a red BMW
?>
</body>
</html>
```



#### 错误处理

##### 错误处理函数

`set_error_handler(处理函数名字符串)`，设置自定义错误处理程序，当触发了报错时执行。可选参数是规定显示何种错误报告级别的用户定义错误。默认是 `"E_ALL"`。

错误处理函数格式：

```php
error_function(error_level,error_message,
error_file,error_line,error_context)
```

| 参数          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| error_level   | 必需。为用户定义的错误规定错误报告级别。必须是一个数字。参见下面的表格：错误报告级别。 |
| error_message | 必需。为用户定义的错误规定错误消息。                         |
| error_file    | 可选。规定错误发生的文件名。                                 |
| error_line    | 可选。规定错误发生的行号。                                   |
| error_context | 可选。规定一个数组，包含了当错误发生时在用的每个变量以及它们的值。 |

`trigger_error($msg,[$level])`函数触发一个报错，调用设置的错误处理函数，传入对应参数。触发能执行的前提是设置了自定义错误处理函数。

如：

```php
<?php
 // 用户定义的错误处理函数
 function myErrorHandler($errno, $errstr, $errfile, $errline) {
     echo "<b>Custom error:</b> [$errno] $errstr<br>";
     echo " Error on line $errline in $errfile<br>";
 }

 // 设置用户定义的错误处理函数
 set_error_handler("myErrorHandler");

 $test=2;

 // 触发错误
 if ($test>1) {
     trigger_error("A custom error has been triggered");
 }
 ?> 
```

```php
<?php
// 错误处理函数
function customError($errno, $errstr)
{
    echo "<b>Error:</b> [$errno] $errstr<br>";
    echo "已通知网站管理员";
    error_log("Error: [$errno] $errstr",1,
    "someone@example.com","From: webmaster@example.com");
}

// 设置错误处理函数
set_error_handler("customError",E_USER_WARNING);

// 触发错误
$test=2;
if ($test>1)
{
    trigger_error("变量值必须小于等于 1",E_USER_WARNING);
}
?>
```

```php
<?php
function myException($exception)
{
    echo "<b>Exception:</b> " , $exception->getMessage();
}
 
set_exception_handler('myException');
 
throw new Exception('Uncaught Exception occurred');
?>
```



> [详见](https://www.w3school.com.cn/php/php_ref_error.asp)



##### 异常

> 异常处理用于在指定的错误（异常）情况发生时改变脚本的正常流程。这种情况称为异常。
>
> 当异常被触发时，通常会发生：
>
> - 当前代码状态被保存
> - 代码执行被切换到预定义（自定义）的异常处理器函数
> - 根据情况，处理器也许会从保存的代码状态重新开始执行代码，终止脚本执行，或从代码中另外的位置继续执行脚本

当异常被抛出时，其后的代码不会继续执行，PHP 会尝试查找匹配的 "catch" 代码块。

如果异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么将发生一个严重的错误（致命错误），并且输出 "Uncaught Exception" （未捕获异常）的错误消息/直接服务器内部错误(SCNUOJ环境)。

如：

```php
<?php
throw new Exception("Value must be 1 or below");
?>
```

格式：

```php
try
{
    ...
}
catch(错误类 $变量) //若干个catch
{
    
}
```

`set_exception_handler()` 函数可设置处理所有未捕获异常的用户定义函数。函数参数是一个错误处理函数名，该函数需要处理一个参数，该参数为异常实例。

异常具有的方法有：`getLine`,`getFile`,`getMessage`。

抛出异常的语句为`throw new 异常类(构造函数参数)`

如：

```php
<?php
// 创建一个有异常处理的函数
function checkNum($number)
{
    if($number>1)
    {
        throw new Exception("变量值必须小于等于 1");
    }
        return true;
}
    
// 在 try 块 触发异常
try
{
    checkNum(2);
    // 如果抛出异常，以下文本不会输出
    echo '如果输出该内容，说明 $number 变量';
}
// 捕获异常
catch(Exception $e)
{
    echo 'Message: ' .$e->getMessage();
}
?>
```

可以定义自定义异常类如：

```php
<?php
class customException extends Exception
{
    public function errorMessage()
    {
        // 错误信息
        $errorMsg = '错误行号 '.$this->getLine().' in '.$this->getFile()
        .': <b>'.$this->getMessage().'</b> 不是一个合法的 E-Mail 地址';
        return $errorMsg;
    }
}
?>
```





### 内建函数

##### 变量操作

###### isset

检测变量是否设置，并且不是 `null`

如果一次传入多个参数，那么 isset() 只有在全部参数都以被设置时返回 `true` 计算过程从左至右，中途遇到没有设置的变量时就会立即停止。

###### unset

销毁若干个变量(可变参数)。

如果是全局变量，在函数中销毁，只在函数生效。但对`$_GLOBALS`则全局生效。

如果是引用参数变量，只在函数内销毁。

如果是函数静态变量，只在此次生效，下次调用还在。

如：

```php
<?php
$x=1;
unset($x);
echo empty($x);
?>
```



###### filter_var

检测变量是否符合过滤器要求。如果成功，则返回已过滤的数据，如果失败，则返回 false。

第一个参数是待检验变量，第二个是过滤器ID。

如：

```php
<?php
if(!filter_var("someone@example....com", FILTER_VALIDATE_EMAIL))
 {
 echo("E-mail is not valid");
 }
else
 {
 echo("E-mail is valid");
 }
?>
```

```php
<?php
$int = 123;
 
if(!filter_var($int, FILTER_VALIDATE_INT))
{
    echo("不是一个合法的整数");
}
else
{
    echo("是个合法的整数");
}
?>
```

```php
<?php
$var=300;
 
$int_options = array(
    "options"=>array
    (
        "min_range"=>0,
        "max_range"=>256
    )
);
 
if(!filter_var($var, FILTER_VALIDATE_INT, $int_options))
{
    echo("不是一个合法的整数");
}
else
{
    echo("是个合法的整数");
}
?>
```

```php
<?php
$filters = array
(
    "name" => array
    (
        "filter"=>FILTER_SANITIZE_STRING
    ),
    "age" => array
    (
        "filter"=>FILTER_VALIDATE_INT,
        "options"=>array
        (
            "min_range"=>1,
            "max_range"=>120
        )
    ),
    "email"=> FILTER_VALIDATE_EMAIL
);
 
$result = filter_input_array(INPUT_GET, $filters);
 
if (!$result["age"])
{
    echo("年龄必须在 1 到 120 之间。<br>");
}
elseif(!$result["email"])
{
    echo("E-Mail 不合法<br>");
}
else
{
    echo("输入正确");
}
?>
```



过滤器分类：

Validating 过滤器：

- 用于验证用户输入
- 严格的格式规则（比如 URL 或 E-Mail 验证）
- 如果成功则返回预期的类型，如果失败则返回 FALSE

Sanitizing 过滤器：

- 用于允许或禁止字符串中指定的字符
- 无数据格式规则
- 始终返回字符串



通过使用 FILTER_CALLBACK 过滤器，可以调用自定义的函数，把它作为一个过滤器来使用。

```php
<?php
function convertSpace($string)
{
    return str_replace("_", ".", $string);
}
 
$string = "www_runoob_com!";
 
echo filter_var($string, FILTER_CALLBACK,
array("options"=>"convertSpace"));
?>
```



> [过滤器参见这里](https://www.w3school.com.cn/php/php_ref_filter.asp)
>
> - filter_var() - 通过一个指定的过滤器来过滤单一的变量
> - filter_var_array() - 通过相同的或不同的过滤器来过滤多个变量
> - filter_input - 获取一个输入变量，并对它进行过滤
> - filter_input_array - 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤
>
> [过滤器使用](https://www.runoob.com/php/php-filter.html)
>
> [更多举例](https://www.runoob.com/php/php-filter-advanced.html)



##### 字符处理

###### htmlspecialchars

将HTML标签失效。例如字符串里有`<b></b>`，将会直接输出，而不是渲染加粗。

失效字符包括：`&,",',<,>`，转化为`&amp,&qpot,&#039,&lt,&gt`



###### trim

去除手尾空白字符。



###### stripslashes

去除所有`\`，如：

```php
<?php
echo stripslashes('1\2\n3'); //12n3
// echo stripslashes("1\2\n3"); //nope
?>
```



###### empty

是否为空。变量为$0$、空字符、不存在或NULL时为真。如：

```php
<?php
echo empty($t);
echo empty('');
echo empty(NULL); //都是true
echo empty(0);
echo empty(1);
echo empty(0.0);
?>
```



###### preg_match

正则表达式匹配。参数为`$pattern,$subject,[$matches(array),[$flags]]`。`$matches[0]`包含于整个模式匹配的文本，`$matches[1]`包含第一个括号的子模式匹配文本。相当于返回的数组。

正则表达式文本格式同json。

如：

```php
if (!preg_match("/^[a-zA-Z ]*$/",$name)) {
  $nameErr = "只允许字母和空格"; 
}
```

常用正则：

- 邮箱 `/([\w\-]+\@[\w\-]+\.[\w\-]+)/`

  `/^\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/`
- URL `/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&@#\/%?=~_|!:,.;]*[-a-z0-9+&@#\/%=~_|]/`



###### explode

字符串分割，第一个参数是分割符，第二个参数是字符串变量。可选第三个参数表示结果数组元素限制最大数。



###### strpos

即find，第一个参数是被查找串，第二个参数是要查找的子串。大小写敏感。失败返回false。

大小写不敏感用`stripos`，倒找用`strrpos,strripos`。



##### 日期时间

###### date

> [时间日期参考手册](https://www.runoob.com/php/func-date-date.html)

第一个参数是字符串输出格式，`Y,m,d`代表年(四位)月($[01,12]$)日($01,31$)，其他字符代表本身的含义。返回字符串。第二个参数是整数时间戳，可缺省。如：

```php
<?php
echo date('Y/m/d H:i:s');
?>
```



> 具体格式有：
>
> | `format` 字符        | 说明                                                         | 返回值例子                                                   |
> | :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
> | *日*                 | ---                                                          | ---                                                          |
> | *d*                  | 月份中的第几天，有前导零的 2 位数字                          | *01* 到 *31*                                                 |
> | *D*                  | 星期中的第几天，文本表示，3 个字母                           | *Mon* 到 *Sun*                                               |
> | *j*                  | 月份中的第几天，没有前导零                                   | *1* 到 *31*                                                  |
> | *l*（"L"的小写字母） | 星期几，完整的文本格式                                       | *Sunday* 到 *Saturday*                                       |
> | *N*                  | ISO-8601 格式数字表示的星期中的第几天（PHP 5.1.0 新加）      | *1*（表示星期一）到 *7*（表示星期天）                        |
> | *S*                  | 每月天数后面的英文后缀，2 个字符                             | *st*，*nd*，*rd* 或者 *th*。可以和 *j* 一起用                |
> | *w*                  | 星期中的第几天，数字表示                                     | *0*（表示星期天）到 *6*（表示星期六）                        |
> | *z*                  | 年份中的第几天                                               | *0* 到 *365*                                                 |
> | *星期*               | ---                                                          | ---                                                          |
> | *W*                  | ISO-8601 格式年份中的第几周，每周从星期一开始（PHP 4.1.0 新加的） | 例如：*42*（当年的第 42 周）                                 |
> | *月*                 | ---                                                          | ---                                                          |
> | *F*                  | 月份，完整的文本格式，例如 January 或者 March                | *January* 到 *December*                                      |
> | *m*                  | 数字表示的月份，有前导零                                     | *01* 到 *12*                                                 |
> | *M*                  | 三个字母缩写表示的月份                                       | *Jan* 到 *Dec*                                               |
> | *n*                  | 数字表示的月份，没有前导零                                   | *1* 到 *12*                                                  |
> | *t*                  | 给定月份所应有的天数                                         | *28* 到 *31*                                                 |
> | *年*                 | ---                                                          | ---                                                          |
> | *L*                  | 是否为闰年                                                   | 如果是闰年为 *1*，否则为 *0*                                 |
> | *o*                  | ISO-8601 格式年份数字。这和 *Y* 的值相同，只除了如果 ISO 的星期数（*W*）属于前一年或下一年，则用那一年。（PHP 5.1.0 新加） | Examples: *1999* or *2003*                                   |
> | *Y*                  | 4 位数字完整表示的年份                                       | 例如：*1999* 或 *2003*                                       |
> | *y*                  | 2 位数字表示的年份                                           | 例如：*99* 或 *03*                                           |
> | *时间*               | ---                                                          | ---                                                          |
> | *a*                  | 小写的上午和下午值                                           | *am* 或 *pm*                                                 |
> | *A*                  | 大写的上午和下午值                                           | *AM* 或 *PM*                                                 |
> | *B*                  | Swatch Internet 标准时                                       | *000* 到 *999*                                               |
> | *g*                  | 小时，12 小时格式，没有前导零                                | *1* 到 *12*                                                  |
> | *G*                  | 小时，24 小时格式，没有前导零                                | *0* 到 *23*                                                  |
> | *h*                  | 小时，12 小时格式，有前导零                                  | *01* 到 *12*                                                 |
> | *H*                  | 小时，24 小时格式，有前导零                                  | *00* 到 *23*                                                 |
> | *i*                  | 有前导零的分钟数                                             | *00* 到 *59*>                                                |
> | *s*                  | 秒数，有前导零                                               | *00* 到 *59*>                                                |
> | *u*                  | 毫秒 （PHP 5.2.2 新加）。需要注意的是 **date()** 函数总是返回 *000000* 因为它只接受 integer 参数， 而 DateTime::format() 才支持毫秒。 | 示例: *654321*                                               |
> | *时区*               | ---                                                          | ---                                                          |
> | *e*                  | 时区标识（PHP 5.1.0 新加）                                   | 例如：*UTC*，*GMT*，*Atlantic/Azores*                        |
> | *I*                  | 是否为夏令时                                                 | 如果是夏令时为 *1*，否则为 *0*                               |
> | *O*                  | 与格林威治时间相差的小时数                                   | 例如：*+0200*                                                |
> | *P*                  | 与格林威治时间（GMT）的差别，小时和分钟之间有冒号分隔（PHP 5.1.3 新加） | 例如：*+02:00*                                               |
> | *T*                  | 本机所在的时区                                               | 例如：*EST*，*MDT*（【译者注】在 Windows 下为完整文本格式，例如"Eastern Standard Time"，中文版会显示"中国标准时间"）。 |
> | *Z*                  | 时差偏移量的秒数。UTC 西边的时区偏移量总是负的，UTC 东边的时区偏移量总是正的。 | *-43200* 到 *43200*                                          |
> | *完整的日期／时间*   | ---                                                          | ---                                                          |
> | *c*                  | ISO 8601 格式的日期（PHP 5 新加）                            | 2004-02-12T15:19:21+00:00                                    |
> | *r*                  | RFC 822 格式的日期                                           | 例如：*Thu, 21 Dec 2000 16:01:07 +0200*                      |
> | *U*                  | 从 Unix 纪元（January 1 1970 00:00:00 GMT）开始至今的秒数    | 参见 time()                                                  |



##### JSON

###### json_encode

对传入变量进行JSON编码。成功返回数据，否则false。

> 有可选参数：由以下常量组成的二进制掩码 JSON_HEX_QUOT, JSON_HEX_TAG, JSON_HEX_AMP, JSON_HEX_APOS, JSON_NUMERIC_CHECK, JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES, JSON_FORCE_OBJECT, JSON_PRESERVE_ZERO_FRACTION, JSON_UNESCAPED_UNICODE, JSON_PARTIAL_OUTPUT_ON_ERROR。
>
>  JSON_UNESCAPED_UNICODE 选项跳过中文编码

如：

```php
<?php
   $arr = array('a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5);
   echo json_encode($arr);
?>
```



###### json_decode

解码并转化为php变量。

`mixed json_decode ($json_string [,$assoc = false [, $depth = 512 [, $options = 0 ]]])`

- **json_string**: 待解码的 JSON 字符串，必须是 UTF-8 编码数据
- **assoc**: 当该参数为 TRUE 时，将返回数组，FALSE 时返回对象。
- **depth**: 整数类型的参数，它指定递归深度
- **options**: 二进制掩码，目前只支持 JSON_BIGINT_AS_STRING 。



##### 流程控制

###### exit

`exit($msg)`。`die`的别名。输出一条消息并结束执行当前脚本`.php`文件。



##### 文件操作

###### file_exists

文件或目录是否存在

###### move_uploaded_file

将上传的文件(参数1)移动到新位置(参数2)。若成功，则返回 true，否则返回 false。参数1一般是`$_FILES[表单控件name属性]["tmp_name"]`

> 如果目标文件已经存在，将会被覆盖



### 输入输出

#### 标准输出

##### echo

一次输出一个或多个字符串，无返回值

可以用echo或echo()，即关键字语法或函数语法

输出效果同js的document.write，所以可以用标签，甚至可以直接在字符串里输出变量：

```php
<?php
echo "<h1>这是","一个标题</h1>";
echo 1e9+7,PHP_EOL,"1"+'234'; //注意字符输出235
echo(1/3); //很多位
//注意加了括号就只能有一个参数了
// echo "s"+"y"; 没有字符串+运算符
?>
```

```php
<?php $x="lr580";echo "I am $x";?> //注意php和$x之间有空格
```

一般而言用`'<br/>'`代表换行。



##### print

一次输出一个字符串，返回值为1，比echo慢。用法语法完全同echo。



##### print_r

打印变量，以更容易理解的形式展示。常用于输出一个数组。



##### 常量

PHP_EOL 换行符



#### 表单I/O

##### POST

默认情况下，POST 方法的发送信息的量最大值为 8 MB（可通过设置 php.ini 文件中的 post_max_size 进行更改）。

在前端，提交的`post`表单，提交后跳转到其`action`指向的网页，并传入提交信息。用`$_POST[键]`即可得到这些信息，如：

```html
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>
 
<form action="welcome.php" method="post">
名字: <input type="text" name="fname">
年龄: <input type="text" name="age">
<input type="submit" value="提交">
</form>
 
</body>
</html>
```

```php
欢迎<?php echo $_POST["fname"]; ?>!<br>
你的年龄是 <?php echo $_POST["age"]; ?>  岁。
```



##### GET

HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的

如：

```HTML
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>

<form action="welcome.php" method="get">
名字: <input type="text" name="fname">
年龄: <input type="text" name="age">
<input type="submit" value="提交">
</form>

</body>
</html>
```

```php+HTML
欢迎 <?php echo $_GET["fname"]; ?>!<br>
你的年龄是 <?php echo $_GET["age"]; ?>  岁。
```



##### 表单控件

###### 下拉菜单

可以通过后端`.php`代码创建下拉菜单。单选举例：表单使用 GET 方式获取数据，action 属性值为空表示提交到当前脚本，我们可以通过 select 的 name 属性获取下拉菜单的值。

```php+HTML
<?php //按下提交后 if $q部分显示
$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';
if($q) {
        if($q =='RUNOOB') {
                echo '菜鸟教程<br>http://www.runoob.com';
        } else if($q =='GOOGLE') {
                echo 'Google 搜索<br>http://www.google.com';
        } else if($q =='TAOBAO') {
                echo '淘宝<br>http://www.taobao.com';
        }
} else { //按下提交前下面部分显示
?>
<form action="" method="get"> 
    <select name="q">
    <option value="">选择一个站点:</option>
    <option value="RUNOOB">Runoob</option>
    <option value="GOOGLE">Google</option>
    <option value="TAOBAO">Taobao</option>
    </select>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```

多选举例：

```php+HTML
<?php
$q = isset($_POST['q'])? $_POST['q'] : '';
if(is_array($q)) {
    $sites = array(
            'RUNOOB' => '菜鸟教程: http://www.runoob.com',
            'GOOGLE' => 'Google 搜索: http://www.google.com',
            'TAOBAO' => '淘宝: http://www.taobao.com',
    );
    foreach($q as $val) {
        // PHP_EOL 为常量，用于换行
        echo $sites[$val] . PHP_EOL;
    }
      
} else {
?>
<form action="" method="post"> 
    <select multiple="multiple" name="q[]">
    <option value="">选择一个站点:</option>
    <option value="RUNOOB">Runoob</option>
    <option value="GOOGLE">Google</option>
    <option value="TAOBAO">Taobao</option>
    </select>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



###### 单选按钮

```php+HTML
<?php
$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';
if($q) {
        if($q =='RUNOOB') {
                echo '菜鸟教程<br>http://www.runoob.com';
        } else if($q =='GOOGLE') {
                echo 'Google 搜索<br>http://www.google.com';
        } else if($q =='TAOBAO') {
                echo '淘宝<br>http://www.taobao.com';
        }
} else {
?><form action="" method="get"> 
    <input type="radio" name="q" value="RUNOOB" />Runoob
    <input type="radio" name="q" value="GOOGLE" />Google
    <input type="radio" name="q" value="TAOBAO" />Taobao
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



###### 复选框

```php+HTML
<?php
$q = isset($_POST['q'])? $_POST['q'] : '';
if(is_array($q)) {
    $sites = array(
            'RUNOOB' => '菜鸟教程: http://www.runoob.com',
            'GOOGLE' => 'Google 搜索: http://www.google.com',
            'TAOBAO' => '淘宝: http://www.taobao.com',
    );
    foreach($q as $val) {
        // PHP_EOL 为常量，用于换行
        echo $sites[$val] . PHP_EOL;
    }
      
} else {
?><form action="" method="post"> 
    <input type="checkbox" name="q[]" value="RUNOOB"> Runoob<br> 
    <input type="checkbox" name="q[]" value="GOOGLE"> Google<br> 
    <input type="checkbox" name="q[]" value="TAOBAO"> Taobao<br>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



##### 表单检验

> 当黑客使用跨网站脚本的HTTP链接来攻击时，$_SERVER["PHP_SELF"]服务器变量也会被植入脚本，所以下面两段代码中不安全：
>
> ```php+HTML
> <form method="post" action="<?php echo $_SERVER["PHP_SELF"];?>">
> ```
>
> ```php+HTML
> <form method="post" action="test_form.php">
> ```
>
> 对于下面的代码，网址为`http://www.runoob.com/test_form.php/%22%3E%3Cscript%3Ealert('hacked')%3C/script%3E`时，解析为：
>
> ```html
> <form method="post" action="test_form.php/"><script>alert('hacked')</script>
> ```
>
> 因此，用`htmlspecialchars()`来避免攻击：
>
> ```php+HTML
> <form method="post" action="<?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?>">
> ```
>
> 此外可以用`trim()`函数去除空白字符。

一般而言，综上所述，使用三件套自定义函数：

```php
function test_input($data) {
  $data = trim($data);
  $data = stripslashes($data);
  $data = htmlspecialchars($data);
  return $data;
}
```

检验空的代码示例：

```php+HTML
<form method="post" action="<?php echo htmlspecialchars($_SERVER['PHP_SELF']);?>"> 
   名字: <input type="text" name="name">
   <span class="error">* <?php echo $nameErr;?></span>
   <input type="submit" name="submit" value="Submit"> 
</form>
```

```php
<?php
// 定义变量并默认设为空值
$nameErr = "";
$name = "";

if ($_SERVER["REQUEST_METHOD"] == "POST") {
  if (empty($_POST["name"])) {
    $nameErr = "名字是必需的。";
  } else {
    $name = test_input($_POST["name"]);
  }
}
?>
```



#### 文件I/O

##### 读写

使用`fopen(路径,模式)`。打开失败返回$0$(false)，否则返回文件流。

记得关闭`fclose($文件流)`。

模式有：

| 模式 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| r    | 只读。在文件的开头开始。                                     |
| r+   | 读/写。在文件的开头开始。                                    |
| w    | 只写。打开并清空文件的内容；如果文件不存在，则创建新文件。   |
| w+   | 读/写。打开并清空文件的内容；如果文件不存在，则创建新文件。  |
| a    | 追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。 |
| a+   | 读/追加。通过向文件末尾写内容，来保持文件内容。              |
| x    | 只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。  |
| x+   | 读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 |

如：

```php
<?php
$file=fopen("welcome.txt","r") or exit("Unable to open file!");
?>
```

有`feof($file)`。

逐行读取用`fgets($file)`。

逐字符用`fgetc`

> [更多请参考这里](https://www.runoob.com/php/php-ref-filesystem.html)



##### 上传

用户上传文件到服务器，前端脚本示例：

```html
<form action="upload_file.php" method="post" enctype="multipart/form-data">
    <label for="file">文件名：</label>
    <input type="file" name="file" id="file"><br>
    <input type="submit" name="submit" value="提交">
</form>
```

上传后，全局变量`$_FILES`可以看到文件。一维键是表单的`input`的`name`，二维键可以是：

- `$_FILES["file"]["name"]` - 上传文件的名称

- `$_FILES["file"]["type"] `- 上传文件的类型

  如：`"image/gif"`

- `$_FILES["file"]["size"]` - 上传文件的大小，以字节计

- `$_FILES["file"]["tmp_name"]` - 存储在服务器的文件的临时副本的名称

- `$_FILES["file"]["error"]` - 由文件上传导致的错误代码

要保存上传的文件，需要拷贝到另外的位置。不然脚本结束就会消失。



如：

```php
<?php
// 允许上传的图片后缀
$allowedExts = array("gif", "jpeg", "jpg", "png");
$temp = explode(".", $_FILES["file"]["name"]);
echo $_FILES["file"]["size"];
$extension = end($temp);     // 获取文件后缀名
if ((($_FILES["file"]["type"] == "image/gif")
|| ($_FILES["file"]["type"] == "image/jpeg")
|| ($_FILES["file"]["type"] == "image/jpg")
|| ($_FILES["file"]["type"] == "image/pjpeg")
|| ($_FILES["file"]["type"] == "image/x-png")
|| ($_FILES["file"]["type"] == "image/png"))
&& ($_FILES["file"]["size"] < 204800)   // 小于 200 kb
&& in_array($extension, $allowedExts))
{
    if ($_FILES["file"]["error"] > 0)
    {
        echo "错误：: " . $_FILES["file"]["error"] . "<br>";
    }
    else
    {
        echo "上传文件名: " . $_FILES["file"]["name"] . "<br>";
        echo "文件类型: " . $_FILES["file"]["type"] . "<br>";
        echo "文件大小: " . ($_FILES["file"]["size"] / 1024) . " kB<br>";
        echo "文件临时存储的位置: " . $_FILES["file"]["tmp_name"] . "<br>";
        
        // 判断当前目录下的 upload 目录是否存在该文件
        // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777
        if (file_exists("upload/" . $_FILES["file"]["name"]))
        {
            echo $_FILES["file"]["name"] . " 文件已经存在。 ";
        }
        else
        {
            // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下
            move_uploaded_file($_FILES["file"]["tmp_name"], "upload/" . $_FILES["file"]["name"]);
            echo "文件存储在: " . "upload/" . $_FILES["file"]["name"];
        }
    }
}
else
{
    echo "非法的文件格式";
}
?>
```



#### 邮件

mail() 函数用于从脚本中发送电子邮件。数需要一个已安装且正在运行的邮件系统(如：sendmail、postfix、qmail等)。所用的程序通过在 php.ini 文件中的配置设置进行定义。

> [请参见这里](https://www.runoob.com/php/php-mail.html) 下一节还有防止`E-mail`注入的例子



## 功能

### MySQL

#### mysqli

##### 链接

链接到数据库：

`mysqli_connect(host, username, password, dbname,port, socket);`

| 参数       | 描述                                        |
| :--------- | :------------------------------------------ |
| *host*     | 可选。规定主机名或 IP 地址。                |
| *username* | 可选。规定 MySQL 用户名。                   |
| *password* | 可选。规定 MySQL 密码。                     |
| *dbname*   | 可选。规定默认使用的数据库。                |
| *port*     | 可选。规定尝试连接到 MySQL 服务器的端口号。 |
| *socket*   | 可选。规定 socket 或要使用的已命名 pipe。   |

成功链接到 MySQL 后返回连接标识，失败返回 FALSE 。

断开链接：

`bool mysqli_close ( mysqli $link )`

关闭指定的连接标识所关联的到 MySQL 服务器的非持久连接。如果没有指定 link_identifier，则关闭上一个打开的连接。

通常不需要使用 `mysqli_close()`，因为已打开的非持久连接会在脚本执行完毕后自动关闭。

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
    die('Could not connect: ' . mysqli_error());
}
echo '数据库连接成功！';
mysqli_close($conn);
?>
```



##### 报错输出

`mysqli_error(connection)`，返回字符串



##### 语句执行

mysqli_query 函数来创建或者删除 MySQL 数据库。

该函数有两个参数，在执行成功时返回 TRUE，否则返回 FALSE。

`mysqli_query(connection,query,resultmode);`

| 参数         | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| *connection* | 必需。规定要使用的 MySQL 连接。                              |
| *query*      | 必需，规定查询字符串。                                       |
| *resultmode* | 可选。一个常量。可以是下列值中的任意一个：MYSQLI_USE_RESULT（如果需要检索大量数据，请使用这个）MYSQLI_STORE_RESULT（默认） |

可以执行的指令有：

- 数据库创建、删除
- 数据表创建、删除、查询
- 数据插入

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die('连接错误: ' . mysqli_error($conn));
}
echo '连接成功<br />';
$sql = 'CREATE DATABASE RUNOOB';
$retval = mysqli_query($conn,$sql );
if(! $retval )
{
    die('创建数据库失败: ' . mysqli_error($conn));
}
echo "数据库 RUNOOB 创建成功\n";
mysqli_close($conn);
?>
```

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die('连接失败: ' . mysqli_error($conn));
}
echo '连接成功<br />';
// 设置编码，防止中文乱码
mysqli_query($conn , "set names utf8");
 
$runoob_title = '学习 Python';
$runoob_author = 'RUNOOB.COM';
$submission_date = '2016-03-06';
 
$sql = "INSERT INTO runoob_tbl ".
        "(runoob_title,runoob_author, submission_date) ".
        "VALUES ".
        "('$runoob_title','$runoob_author','$submission_date')";
 
 
mysqli_select_db( $conn, 'RUNOOB' );
$retval = mysqli_query( $conn, $sql );
if(! $retval )
{
  die('无法插入数据: ' . mysqli_error($conn));
}
echo "数据插入成功\n";
mysqli_close($conn);
?>
```





##### 数据库选择

`mysqli_select_db(connection,dbname);`

即等效于`use`。

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
    die('连接失败: ' . mysqli_error($conn));
}
echo '连接成功';
mysqli_select_db($conn, 'RUNOOB' );
mysqli_close($conn);
?>
```



##### 数据查询

首先用`mysqli_query`取`mysql`查询语句的返回值，然后用：

`mysqli_fetch_array(connection, 返回值)`获得所有查询的数据。

从结果集中取得一行作为关联数组，或数字数组，或二者兼有 返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。

可以设置第二个参数为`MYSQLI_ASSOC`，将返回列名作为数组索引。



## 框架

### ThinkPHP

#### 安装和配置

##### 初始化

环境要求

- PHP 版本在 5.4.0 或以上

- 配置里开启(有 `;` 开头注释的删掉注释符号 `;` ，没有就加)

  ```ini
  extension=php_pdo_mysql.dll
  extension=php_mbstring.dll
  extension=php_curl.dll
  
  [mbstring]
  mbstring.language = Chinese
  mbstring.internal_encoding = UTF-8
  mbstring.encoding_translation = On
  mbstring.http_input = UTF-8
  mbstring.http_output = UTF-8
  mbstring.detect_order = UTF-8
  mbstring.substitute_character = none
  ```

免安装， [官网](http://www.thinkphp.cn/down.html) 下载 ，如 `thinkphp_5.0.24_full` 

将 `tp5` 文件夹复制到 `AppServ/www` ，调试输入：`http://localhost:88/tp5/public/` ，预期能访问到一个主页



##### 配置

显然当前根目录是 `AppServ/www/` 代表 `/`

5.0 版本自带入口文件在 `public/index.php` 

该文件定义了应用目录 APP_PATH 和加载 ThinkPHP 框架的入口文件

显然根据内含代码可以发现该 `index.php` 的源代码位于 `application/index/controller/index.php`



开启调试模式：在 `application/config.php` ，改 `app_debug` 。调试模式在异常的时候可以显示尽可能多的信息，所以对性能有一定的影响



##### 项目新建

将 `tp5` 文件夹复制到自己的项目里，作为基础

可以根目录新建一个 `index.php` 并输入：

```c++
<?php
define('APP_PATH',    __DIR__ . '/application/');
require     __DIR__ . '/thinkphp/start.php';
?>
```



> 可以在根目录下 cmd 输入命令新建样例模块：
>
> ```shell
> php think build --module 模块名
> ```



##### 数据库配置

在 `application/database.php` ，按照提示设置数据库连接即可。

取消 `Db::table` 警告，在 vscode 设置输入 `intelephense languageConstraints` ，取消勾选即可。

如果使用了多个模块且每个模块都用不同的数据库连接，那么每个模块下面单独配置，如： `application/模块名/database.php` ，可以自己新建，如：

```php
return [ 
 	// 服务器地址
	'hostname'  => '192.168.190.129',
 	// 数据库名
    'database'  => 'testdb',
 ];
```





#### 基本概念

##### 目录结构

![image-20220424155126332](img/image-20220424155126332.png)

![image-20220424155136373](img/image-20220424155136373.png)

![image-20220424155142376](img/image-20220424155142376.png)

在根目录下用命令行输出指令，生成展示模块 `demo` ：

```shell
php think build --module demo
```



##### 模块



##### 控制器

关系：一个模块有多个控制器，一个控制器有多个方法

命名规范：驼峰命名法(首字母大写)，调用时每个单词转化为 `_` 间隔

新建一个名为 `Index` 的控制器(命名不能出现大小写 `controller`)，放在 `application/模块名/controller/控制器名.php` ，格式：

```php
<?php
namespace app\index\controller;
class Index
{
    public function index()
    {
        return 'Hello World!';
    }
}
```

控制器可以继承。方法可以定义参数。参数相当于URL参数，如：

```php
<?php
namespace app\index\controller;
class Index
{
    public function index($name='World!'){
        	return	'Hello ' . $name;
    }
}
```

然后根据 `index.php?name=输入的东西` 不同，就等于传入不同的 `$name` 

只有 public 类型的方法才是可以通过URL访问的。要调用哪个方法，就直接 HTML 里打这个方法名，如：

>  `index.php/index/index/hello`  (假设在上述代码定义了这个函数)
> 表示 `Index` 模块的 `index` 控制类的 `hello` 方法
>
> `http://localhost:88/tp5/?name=baicha`



##### 视图

在 `application/模块名` 创建目录 `view` ，尝试添加一个与控制类名字相同的目录名，然后在目录里添加一个 `html` 文件，随便写点内容，如果有变量，用 `{$变量名}` 表示占位。如在 `application/index/hello.html` ：

```html
<div>Ohh, it's {$visitor}</div>
```

使用控制器渲染变量，需要继承 `Controller` 类，如：

```php
<?php
namespace app\index\controller;
use think\Controller;
class Index extends Controller{
    public function hello($name = 'lr580')    {
        $this->assign('visitor', $name);
        return $this->fetch();
    }
}

```

然后打开网页，如：`http://localhost:88/tp5/index.php/index/index/hello?name=QwQ`



如果写成 `return view();` 也行，同理地只需要保证确实有这一个视图即可，区别在于没有参数。



#### 基本语法

##### 控制器

###### 报错输出

```php
$this->error(错误信息str);
```

遇到后弹窗(URL后面的html变成了当前方法名.html)，有自带样式，默认3秒后回到原页面

###### 成功回显

```php
$this->success('注册成功, 跳转到主页', url('index/index'));
```

没有第二个参数就本来在哪回到哪里

###### 重定向

```php
$this->redirect(url('index/index'));
```



##### 视图

###### PHP语法

在视图代码里，语法用 `{}` 括起来，有：

- PHP变量的常规调用 (直接嵌HTML里进行文本乃至URL拼接都行)

- `foreach $数组变量 as $迭代变量` 开头和 `/foreach` 结尾，如：

  ```php+HTML
  {foreach $result as $flower}
  <table><tr><td>{$flower.fname}</td></tr></table>
  {/foreach}
  ```

- `if condition=""` ， `else`  ， `/if` ，运算符可以是 `eq` 等，如：

  ```php+HTML
  {if condition="$Think.session.email eq ''"}
  <a href="{:url('login/login')}" style="font-size:x-small;text-decoration:none;">登录</a>&nbsp;&nbsp; 
  {else}
  <a href="{:url('login/logOut')}" style="font-size:x-small;text-decoration:none;">退出</a>&nbsp;&nbsp; 
  {/if}
  ```

- `:url('控制器名/方法名')` 超链接(也可以再加一个前缀 `模块名/` ) ，(不区分大小写)，如：

  ```html
  <a href="{:url('order/showorder')}" > QwQ </a>
  ```

- `include file="路径"/` 导入一个HTML (import功能)，如：

  ```php
  {include file="./public/common/top.html"/}
  ```

其他，如 `__ROOT__` 全局变量



##### 表单

> 貌似是基本语法，而不是ThinkPHP语法

###### 数据获取

在控制器方法里使用，如：

```php
input('post.email') //对应post的form表单，name=email的表单项
```

###### 数据存储

如：

```php
session('email', $rs['email']);
```



##### Session

[参考](https://blog.csdn.net/qq_37675827/article/details/77978396)

```php
use think\Session;
```

如：

```php
$rs = Session::get('email')
```





##### 数据库

###### 动态连接

可以不事先配置，而是动态定义，，使用 `Db::connect` 然后一个数组参数(跟配置一样)，如：

```php
Db::connect([
    // 数据库类型
    'type'        => 'mysql',
    // 数据库连接DSN配置
    'dsn'         => '',
    // 服务器地址
    'hostname'    => '127.0.0.1',
    // 数据库名
    'database'    => 'thinkphp',
    // 数据库用户名
    'username'    => 'root',
    // 数据库密码
    'password'    => '',
    // 数据库连接端口
    'hostport'    => '',
    // 数据库连接参数
    'params'      => [],
    // 数据库编码默认采用utf8
    'charset'     => 'utf8',
    // 数据库表前缀
    'prefix'      => 'think_',
]);
```

也可以使用字符串，URL形式，`数据库类型://用户名:密码@数据库地址:数据库端口/数据库名#字符集`，  如：

```php
Db::connect('mysql://root:123456@localhost:3306/flower#utf8');
```

返回一个变量，用这个变量不断调用数据库函数即可实现数据库功能 



###### 基础

在配置好数据库的基础上，在控制器方法，进行读取，例如：

```php
use think\Db;
//...
Db::name(名字str)->find(); //返回读取单行数据
Db::table(名字str)->select(); //读取多行数据
->order(关键字str,'desc') //排序，在table后接
```

name 与 table 的区别在于，若配置项有 `prefix` ， name ， db() 会加上前缀， table 不会

find 找单行，不存在返回 null ； select 找数据集，不存在返回空数组。

value 只返回某一列(属性)，找单次，找不到 null ； column 返回某一列值，找不到返回空数组

可以加 distinct(true) 来去重

可以加 order 来排序

> 综合示例：`->distinct(true)->field('value')->select()`

> ```php
> $data=Db::table('think_user')->where('id',1)->value('name');
> // 返回数组
> $data=Db::table('think_user')->where('name','like','%thinkphp')->column('name');
> // 指定索引
> $data=Db::table('think_user')->where('name','like','%thinkphp')->column('name','id');
> ```

> ```php
> public function index()
> {
>     $fclass = Db::table('flower')->distinct('true')->field('fclass')->select();
>     $this->assign('fclasses', $fclass);
>     $fname = input('post.fname');
>     $fcls = input('post.fclass');
>     $minprice = input('post.minprice');
>     $maxprice = input('post.maxprice');
>     if (empty($maxprice)) {
>         $maxprice = 114514;
>     }
>     if (empty($minprice)) {
>         $minprice = 0;
>     }
>     $searchstr = "yourprice between $minprice and $maxprice";
>     if (!empty($fcls)) {
>         $searchstr .= " and fclass='$fcls'";
>     }
>     if (!empty($fname)) {
>         $searchstr .= " and fname like '%$fname%'";
>     }
>     $data = Db::table('flower')->where($searchstr)->order('SelledNum desc')->select();
>     $this->assign('flowers', $data);
>     return $this->fetch();
> }
> ```



在 HTML 进行php语句操作，如：

```html
{foreach $result as $mem}
<tr><td>{$mem.email}</td>
	<td>{$mem.mname}</td>
	<td>{$mem.mobile}</td>
</tr>
{/foreach}
```

> 例如：
>
> ```php
> <?php
> 
> namespace app\index\controller;
> 
> use think\Controller;
> use think\Db;
> 
> class Index extends Controller
> {
>     public function hellodb()
>     {
>         $data = Db::table('myorder')->select();
>         $this->assign('res', $data);
>         return $this->fetch();
>     }
> }
> ```
>
> ```html
> <table>
>     <tr>
>         <th>orderID</th>
>         <th>custID</th>
>     </tr>
>     {foreach $res as $it}
>     <tr>
>         <td>{$it.orderID}</td>
>         <td>{$it.custID}</td>
>     </tr>
>     {/foreach}
> </table>
> ```



###### 分页

先使用分页查询，如：

```php
$list = Db::name('user')->where('status',1)->paginate(10);
$data = Db::table('flower')->order('SelledNum','desc')->paginate(5);
```

使用 paginate 函数：

![image-20220424161841250](img/image-20220424161841250.png)

例如：

```php
public function showflower(){
    $data = Db::table('flower')->order('SelledNum','desc')->paginate(5);
    $this->assign('result',$data);
    $page=$data->render();
    $this->assign('page',$page);
    return $this->fetch();
}
```

导航使用一次标志即可：

```html
<div class="page">{$page}</div>
```

为了修改分页的样式，可以更改 `thinkphp/library/think/paginator/driver/` 的 `Bootstrap.php` ，如改为：

> ```php
> <?php
> // +----------------------------------------------------------------------
> // | ThinkPHP [ WE CAN DO IT JUST THINK ]
> // +----------------------------------------------------------------------
> // | Copyright (c) 2006~2018 http://thinkphp.cn All rights reserved.
> // +----------------------------------------------------------------------
> // | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )
> // +----------------------------------------------------------------------
> // | Author: zhangyajun <448901948@qq.com>
> // +----------------------------------------------------------------------
> 
> namespace think\paginator\driver;
> 
> use think\Paginator;
> 
> class Bootstrap extends Paginator
> {
>     /*
>      * 上一页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getPreviousButton($text = "上一页")
>     {
>     
>         if ($this->currentPage() <= 1) {
>             return $this->getDisabledTextWrapper($text);
>         }
>     
>         $url = $this->url(
>             $this->currentPage() - 1
>             );
>     
>         return $this->getPageLinkWrapper($url, $text);
>     }
>     
>     /**
>      * 下一页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getNextButton($text = '下一页')
>     {
>         if (!$this->hasMore) {
>             return $this->getDisabledTextWrapper($text);
>         }
>     
>         $url = $this->url($this->currentPage() + 1);
>     
>         return $this->getPageLinkWrapper($url, $text);
>     }
>     
>     /**
>      * 首页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getFirstButton($text = '首页')
>     {
>         $nowPage = $this->rollPage;//计算分页临时变量
>         //当  总页数大于定义的页数时  且  当前页数大于前几页时  显示首页
>         if ($this->lastPage > $this->showPage && $this->currentPage > $nowPage) {
>     
>             $url = $this->url(1);
>     
>             return $this->getPageLinkWrapper($url, $text);
>         }
>     }
>     
>     /**
>      * 末页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getLastButton($text = '末页')
>     {
>         $nowPage = $this->rollPage;//计算分页临时变量
>     
>         //当  总页数大于定义的页数时  且  当前页数小于最后的几页时  显示末页
>         if ($this->lastPage > $this->showPage && $this->currentPage < ($this->lastPage - $nowPage)) {
>     
>             $url = $this->url($this->lastPage);
>     
>             return $this->getPageLinkWrapper($url, $text);
>         }
>     }
>     
>     /**
>      * 页码按钮
>      * @return string
>      */
>     protected function getLinks()
>     {
>         if ($this->simple)
>             return '';
>     
>             $block = [
>                 'first'  => null,
>                 'slider' => null,
>                 'last'   => null
>             ];
>     
>             $side   = 3;
>             $window = $side * 2;
>     
>             if ($this->lastPage < $window + 6) {
>                 $block['first'] = $this->getUrlRange(1, $this->lastPage);
>             } elseif ($this->currentPage <= $window) {
>                 $block['first'] = $this->getUrlRange(1, $window + 2);
>                 $block['last']  = $this->getUrlRange($this->lastPage - 1, $this->lastPage);
>             } elseif ($this->currentPage > ($this->lastPage - $window)) {
>                 $block['first'] = $this->getUrlRange(1, 2);
>                 $block['last']  = $this->getUrlRange($this->lastPage - ($window + 2), $this->lastPage);
>             } else {
>                 $block['first']  = $this->getUrlRange(1, 2);
>                 $block['slider'] = $this->getUrlRange($this->currentPage - $side, $this->currentPage + $side);
>                 $block['last']   = $this->getUrlRange($this->lastPage - 1, $this->lastPage);
>             }
>     
>             $html = '';
>     
>             if (is_array($block['first'])) {
>                 $html .= $this->getUrlLinks($block['first']);
>             }
>     
>             if (is_array($block['slider'])) {
>                 $html .= $this->getDots();
>                 $html .= $this->getUrlLinks($block['slider']);
>             }
>     
>             if (is_array($block['last'])) {
>                 $html .= $this->getDots();
>                 $html .= $this->getUrlLinks($block['last']);
>             }
>     
>             return $html;
>     }
>     
>     /**
>      * 渲染分页html
>      * @return mixed
>      */
>     public function render()
>     {
>         if ($this->hasPages()) {
>             if ($this->simple) {
>                 return sprintf(
>                     '%s %s',
>                     $this->getPreviousButton(),
>                     $this->getNextButton()
>                     );
>             } else {
>                 return sprintf(
>                     '%s %s %s',
>                     $this->getPreviousButton(),
>                     $this->getLinks(),
>                     $this->getNextButton()
>                     );
>             }
>         }
>     }
>     
>     /**
>      * 生成一个可点击的按钮
>      *
>      * @param  string $url
>      * @param  int    $page
>      * @return string
>      */
>     protected function getAvailablePageWrapper($url, $page)
>     {
>         return '&nbsp;&nbsp;<a href="' . htmlentities($url) . '">' . $page . '</a>&nbsp;&nbsp;';
>     }
>     
>     /**
>      * 生成一个禁用的按钮
>      *
>      * @param  string $text
>      * @return string
>      */
>     protected function getDisabledTextWrapper($text)
>     {
>         return '<span>&nbsp;&nbsp;' . $text . '&nbsp;&nbsp;</span>';
>     }
>     
>     /**
>      * 生成一个激活的按钮
>      *
>      * @param  string $text
>      * @return string
>      */
>     protected function getActivePageWrapper($text)
>     {
>         return '<span>&nbsp;&nbsp;' . $text . '&nbsp;&nbsp;</span>';
>     }
>     
>     /**
>      * 生成省略号按钮
>      *
>      * @return string
>      */
>     protected function getDots()
>     {
>         return $this->getDisabledTextWrapper('...');
>     }
>     
>     /**
>      * 批量生成页码按钮.
>      *
>      * @param  array $urls
>      * @return string
>      */
>     protected function getUrlLinks(array $urls)
>     {
>         $html = '';
>     
>         foreach ($urls as $page => $url) {
>             $html .= $this->getPageLinkWrapper($url, $page);
>         }
>     
>         return $html;
>     }
>     
>     /**
>      * 生成普通页码按钮
>      *
>      * @param  string $url
>      * @param  int    $page
>      * @return string
>      */
>     protected function getPageLinkWrapper($url, $page)
>     {
>         if ($page == $this->currentPage()) {
>             return $this->getActivePageWrapper($page);
>         }
>     
>         return $this->getAvailablePageWrapper($url, $page);
>     }
>     }
> 
> ```



###### 复杂查询

`->view(表名str,列名str(, 条件))` ，列名str里内部逗号分隔表示多个列

`->where(列名str, 运算符str, 运算数)`  (可以叠多个where，显然)

最后 `->select()` 或 `->find()` 

如：

```php
public function view1()
{
    $conn=Db::connect('mysql://root:123456@localhost:3306/student#utf8');
    dump('OK');
    $data = $conn->view('S', 'SNO,SNAME')->view('SC', 'GRADE', 'SC.SNO=S.SNO')
        ->view('C', 'CNO,CNAME', 'SC.CNO=C.CNO')
        ->where('GRADE', '>', 80)
        ->select();
    $this->assign("results", $data);
    return $this->fetch();
}
```

多个条件 and 为：

```php
Db::table('think_user')->where('name&uname','like','%thinkphp')->find(); // % 是 SQL通配符
```

多个 or 用 whereOr ：

```php
Db::table('think_user')->where('name','like','%thinkphp')->whereOr('email','tp@163.com')->find();
```

也可以用 `|` ：

```php
Db::table('think_user')->where('name|title','like','%thinkphp')->find();
```

混合且，或，用括号搞顺序。

![image-20220429160653178](img/image-20220429160653178.png)



###### 查询语法

```php
where('字段名','表达式','查询条件');
whereOr('字段名','表达式','查询条件');
```

表达式语法：(都是字符串)(查询条件就可以不是字符串) 

```
EQ、=	等于（=）  //如果只写两个参数，where('字段名','查询条件') 也是 EQ
NEQ、<>	不等于（<>）
GT、>	大于（>）
EGT、>=	大于等于（>=）
LT、<	小于（<）
ELT、<=	小于等于（<=）
LIKE	模糊查询
[NOT] BETWEEN	（不在）区间查询
[NOT] IN	（不在）IN 查询
[NOT] NULL	查询字段是否（不）是NULL  //这时没有查询条件
[NOT] EXISTS	EXISTS查询
EXP	表达式查询，支持SQL语法，后接函数使用
> time	时间比较
< time	时间比较
between time	时间比较
not between time	时间比较
```

5.0.4  支持对同一个字段多次调用查询方法  

EXP 举例：

```php
where('id','exp',' IN (1,3,8) ');
```

综合举例：

```php
Db::table('think_user')->where('name|title','like','thinkphp%')->where('create_time&update_time','>',0)->find();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' OR `title` LIKE 'thinkphp%' ) AND ( `create_time` > 0 AND `update_time` > 0 ) LIMIT 1
> ```



区间查询是一种同一字段多个查询条件的简化写法：

区间查询的查询条件必须使用数组定义方式，支持所有的查询表达式。

```php
Db::table('think_user')->where('name',['like','thinkphp%'],['like','%thinkphp'])->where('id',['>',0],['<>',10],'or')->find();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' AND `name` LIKE '%thinkphp' ) AND ( `id` > 0 OR `id` <> 10 ) LIMIT 1
> ```



批量查询

```php
Db::table('think_user')
    ->where([
        'name'  =>  ['like','thinkphp%'],
        'title' =>  ['like','%thinkphp'],
        'id'    =>  ['>',0],
        'status'=>  1
    ])
    ->select();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE `name` LIKE 'thinkphp%' AND `title` LIKE '%thinkphp' AND `id` > 0 AND `status` = '1'
> ```



可以用箭头混合叠起来用上述的全部东西，如：

> ```php
> Db::table('think_user')
>     ->where('name',['like','thinkphp%'],['like','%thinkphp'])
>     ->where(function($query){
>         $query->where('id',['<',10],['>',100],'or');
>     })
>     ->select();
> ```
>
> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' AND `name` LIKE '%thinkphp' ) AND ( `id` < 10 or `id` > 100 )
> ```



可以套原生：

```php
Db::table('think_user')->where('id > 0 AND name LIKE "thinkphp%"')->select();
```



可以占位符：

```php
Db::table('think_user')
    ->where('id > :id AND name LIKE :name ',['id'=>0, 'name'=>'thinkphp%'])
    ->select();
```



> V5.0.4+开始，ThinkPHP支持对同一个字段多次调用查询条件
>
> ```php
> Db::table('think_user')
>     ->where('name','like','%think%')
>     ->where('name','like','%php%')
>     ->where('id','in',[1,5,80,50])
>     ->where('id','>',10)
>     ->find();
> ```



可以定义别名：

```php
$data = $conn->view(['S'=>'Stu'], ['SNO'=>'Stu_No','SNAME'=>'Stu_Name'])
    ->view('SC', ['GRADE'=>'score'], 'SC.SNO=Stu.SNO')
    ->view('C', 'CNO,CNAME', 'SC.CNO=C.CNO')
    ->where('GRADE', '>', 80)
    ->select();
```

> 对应：
>
> ```sql
> Select  Stu.SNO  as Stu_No,Stu.SNAME as Stu_Nname,SC.GRADE as score 
> From  S Stu inner join SC on SC.SNO=Stu.SNO inner join C on SC.CNO=C.CNO
> Where grade>80;
> ```



###### 模型类

如果在某个模型类里面定义了connection属性的话，则该模型操作的时候会自动连接给定的数据库连接，而不是配置文件中设置的默认连接信息，通常用于某些数据表位于当前数据库连接之外的其它数据库。格式同配置里的数据即这是一个数组或字符串格式。如：

```php
//在模型里单独设置数据库连接信息
namespace app\index\model;
use think\Model;
class User extends Model
{
    protected $connection = [
        // 数据库类型
        'type'        => 'mysql',
        // 数据库连接DSN配置
        'dsn'         => '',
        // 服务器地址
        'hostname'    => '127.0.0.1',
        // 数据库名
        'database'     => 'flower',
        // 数据库用户名
        'username'    => 'root',
        // 数据库密码
        'password'    => '12345678',
        // 数据库连接端口
        'hostport'    => '',
        // 数据库连接参数
        'params'     =>[],
        // 数据库编码默认采用utf8
        'charset'     => 'utf8',
        // 数据库表前缀
        'prefix'      => 'think_',
    ];
}

```

```php
protected $connection = 'mysql://root:12345678@localhost:3306/flower#utf8';
```

需要注意的是，ThinkPHP的数据库连接是**惰性**的，所以并不是在实例化的时候就连接数据库，而是在有实际的数据操作的时候才会去连接数据库。



###### 原生操作

query 和 execute 两个方法，分别用于查询和写入，直接使用 SQL 语句

除了查询都用 execute (如更新)。查询返回 array ，下标从 0 开始，值是对象型数组，其key和value对应查询。execute方法的返回值是影响的行数

支持 `?` 参数绑定和命名占位符 `:名字` 绑定，如：

```php
Db::query('select * from think_user where id=?',[8]);    // id=8
Db::execute('insert into think_user (name, email) values (?, ?)',['thinkphp','tp5@163.com']);
```

```php
Db::query('select * from think_user where id=:id',['id'=>8]);
Db::execute('insert into think_user (name, email) 
values (:name, :email)',['name'=>'thinkphp','email'=>'tp5@163.com']);
```

```php
$result=Db::execute('insert into think_user(id,name,email)	values(null,"thinkphp","tp@163.com")');
dump($result);
```

如：

```html
<form action="{:url('index/create')}" name="f" method="post">
<table border="1">
<tr><td>name:</td><td><input type="text" name="name" value="a1"></td></tr>
<tr><td>email:</td><td><input type="text" name="email" value="a1@163com"></td></tr>
<tr><td>score:</td><td><input type="text" name="score" value="91"></td></tr>
<tr><td colspan="2"><input type="submit" value="添加"></td></tr>
</table>
</form>
```

```php
public function create(){
        $name = input('post.name');
        $email=input('post.email');
        $score=input('post.score');
        Db::execute("insert into think_user(id,name,email,score) 
            values(null,'".$name."','".$email."','".$score."')");
        $this->success('添加成功',url('index/index')); 
    }
}
```



```html
<br/>
<a href="{:url('index/add')}">添加</a>
<br/><br/>
<table border="1">
<tr><th>name</th><th>email</th><th>score</th><th>修改</th><th>删除</th></tr>
{volist name="$result" id="row"}
<tr>
	<td>{$row.name}</td>
	<td>{$row.email}</td>
	<td>{$row.score}</td>
	<td><a href="{:url('index/update')}?id={$row.id}">修改</a></td>
	<td><a href="{:url('index/delete')}?id={$row.id}">删除</a></td>
</tr>	
{/volist}
</table>
```

```html
<form action="{:url('index/doUpdate')}" name="f" method="post">
{foreach $result as $user}
<table border="1">
<input type="hidden" name="id" value="{$user.id}">
<tr><td>name:</td><td><input type="text" name="name" value="{$user.name}"></td></tr>
<tr><td>email:</td><td><input type="text" name="email" value="{$user.email}"></td></tr>
<tr><td>score:</td><td><input type="text" name="score" value="{$user.score}"></td></tr>
<tr><td colspan="2"><input type="submit" value="修改"></td></tr>
</table>
{/foreach}
</form>
```

```php
public function update(){
    $id=input('get.id');
    $user=Db::query("select * from think_user where id=$id");
    dump($user);
    $this->assign('result',$user);
    return $this->fetch();
}
public function doUpdate(){
    $id = input('post.id');
    $name = input('post.name');
    $email=input('post.email');
    $score=input('post.score');
    Db::execute("update think_user 
            set name='$name',
            email='$email',
            score='$score' 
            where id=$id");       
    $this->success('修改成功',url('index/index'));
}

```



###### 表格信息

使用getTableInfo可以获取表信息，信息类型 包括 fields,type,bind,pk，以数组的形式展示，可以指定某个信息进行获取

```php
// 获取`think_user`表所有信息
Db::getTableInfo('think_user');
// 获取`think_user`表所有字段
Db::getTableInfo('think_user', 'fields');
// 获取`think_user`表所有字段的类型
Db::getTableInfo('think_user', 'type');
// 获取`think_user`表的主键
Db::getTableInfo('think_user', 'pk');
```



###### 助手函数

`db(数据表名)` = 前缀 + 数据表名选择。可选参数：第二个参数为数据库的连接参数，留空数组(默认)表示采用数据库配置文件的配置；第三个参数是一个布尔值，默认值是false，如果设置为true表示每次都会重新连接数据库。db函数如果采用相同的链接，可以设置第三个参数false.

> 一个MySQL好似只能同时有至多150个连接



###### 其他查询

使用**查询对象**进行查询，例如：

```php
$query = new \think\db\Query();
$query->table('think_user')->where('name','like','%thinkphp');
// $data=Db::find($query);
$data=Db::select($query);
dump($data);
```

或者直接使用闭包函数查询，例如：

```php
$data=Db::select(function($query){
    $query->table('think_user')->where('name','like','%thinkphp');
});
dump($data);
```



###### 聚合查询

内置方法，可以填参数(也可以不填)代表要统计的字段名：count, max, min, avg, sum

如：

```php
Db::table('think_user')->count();
Db::table('think_user')->where('score>0')->min('score');
```



###### 子查询

使用 select 方法且填参数 false ，表示不进行查询只是返回构建SQL (dump 输出得到语句)

那么使用字符串连接符，如 `'(' . $变量 . ') 子表名'` 为 table 参数，就可以子查询了

```php
$subQuery = $conn->table('SC')
    ->field('SNO,GRADE')
    ->where('CNO','=','k5')
    ->select(false);

$data = $conn->table('('.$subQuery.') a')
    ->view('S','SNO,SNAME','a.SNO=S.SNO')
    ->where('a.GRADE','>',80)
    ->select();
```

也可以用 fetchSql 方法，表示不进行查询而只是返回构建的SQL语句，并且不仅仅支持select，而是支持所有的CURD查询。用法： `->fetchSql(true)->select()` ，得到的还是一样的，后面套子表用法跟上面一样。

调用buildSql方法后不会进行实际的查询操作，而只是生成该次查询的SQL语句（为了避免混淆，结果上会在SQL两边加上括号），我们在后续的查询中直接调用。(字符串连接时可以不用括号了，直接子表名)。调用就查询时把 select 换成 buildSql

如果需要 IN/EXISTS 查询，需要用函数闭包，如：

```php
$data = $conn->table('S')
    ->where('SNO','IN',function($query){
        $query->table('SC')->where('CNO','k5')->field('SNO');
    })
    ->select();
```

```php
$data = $conn->table('S')
    ->where(function($query){
        $query->table('SC')
            ->where('CNO','k5')
            ->where('S.SNO=SC.SNO');
    },'exists')
    ->select(); 
```



###### 管理数据

插入：

```php
$data = ['name' => 'zhangsan', 'email' => 'zs@163.com'];
Db::table('think_user')->insert($data);
```

insert 方法添加数据成功返回添加成功的条数，insert 正常情况返回 1

返回新增数据的自增主键，可以使用：

```php
$userId = Db::name('user')->getLastInsID();
```

或直接合并，插入并返回 (成功返回添加数据的自增主键)：

```php
Db::name('user')->insertGetId($data);
```

多条就二维数组， insertAll ，返回添加数据成功返回添加成功的条数



更新：

返回影响数据的条数，没修改任何数据返回 0

```php
Db::table('think_user')->where('id', 1)->update(['name' => 'tp5_1']);
```

若更新的数据包含主键，不需要 where ：

```php
Db::table('think_user')->update(['name' => 'thinkphp','id'=>1]);
```

只更新一个字段，返回影响数据的条数：

```php
Db::table('think_user')->where('id',1)->setField('name', 'thinkphp');
```

setInc/setDec 如不加第二个参数，默认值为1：

```php
Db::table('think_user')->where('id', 1)->setInc('score');
```

支持延时更新，如果需要延时更新则传入第三个参数，单位为秒



删除：

根据主键删除直接传主键值（多个就数组），返回影响数据的条数，无则 0 ：

```php
Db::table('think_user')->delete(1);
Db::table('think_user')->delete([1,2,3]);
```

也可以 where ：

```php
Db::table('think_user')->where('name','bb')->delete();
Db::table('think_user')->where('id','<',10)->delete();
```







# MySQL

## 基本

### 基本概念

RDBMS(Relational Database Management System：关系数据库管理系统)，基本特点：

- 数据以表格的形式出现
- 每行为各种记录名称
- 每列为记录名称所对应的数据域
- 许多的行和列组成一张表单
- 若干的表单组成database

mysql是rdbms。

- **数据库:** 数据库是一些关联表的集合。
- **数据表:** 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。
- **列:** 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。
- **行：**一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。
- **冗余**：存储两倍数据，冗余降低了性能，但提高了数据的安全性。
- **主键**：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。
- **外键：**外键用于关联两个表。
- **复合键**：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。
- **索引：**使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。
- **参照完整性:** 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。

> MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
>
> - MySQL 是开源的，目前隶属于 Oracle 旗下产品。
> - MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。
> - MySQL 使用标准的 SQL 数据语言形式。
> - MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。
> - MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。
> - MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。
> - MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。



### 使用

导入导出等其他指令可见指令-其他指令

#### 使用

> 以下均以linux系统为准

安装略。

验证安装：(mysql admin)

```shell
mysqladmin --version
```

输出了有效信息代表安装成功。

启动：(可能需要管理员`sudo`)(-u是`user`,`-uroot`是`root`用户；`-p`是password，同理可以诸如`-p123456`)

```shell
mysql
```

```shell
mysql -u 用户名 -p
```

然后输入密码。

退出：`exit`或`\q`或`quit`

启动后可以直接交互，类似于`python shell`交互方法。

参数：

- `-h 主机` ，如`localhost, 127.0.0.1, 10.191.65.243`
- `-P 端口`
- `-u 用户名`
- `-p` 密码（随后输入）；或`-p密码` 

示例：

```shell
mysqladmin -h 127.0.0.1 -u root -p123 create test
cmd /c mysql -h 127.0.0.1 -u root -p123 test < tb_thu.sql
```



检查MySQL服务器是否启动：

```shell
ps -ef | grep mysqld
```

启动服务器：

```shell
cd /usr/bin
./mysqld_safe &
```

关闭服务器：

```shell
cd /usr/bin
./mysqladmin -u 用户名 -p shutdown
```

文件配置路径：`/etc/my.cnf`

> 上述文件配置在SCNUOJ服务器不存在



#### sql 脚本

一系列 sql 语句的集合。可以用 shell 执行，重定向输入输出。后缀名是 `.sql `。以 shell 为例：

```shell
sudo mysql < xxx.sql > xxx.out
```



#### 开关服务

##### windows

开关分别是：

```shell
mysqld --console
mysqladmin -uroot shutdown
```



##### linux

查看是否启动：

```shell
ps -ef | grep mysqld
```

启动：

```shell
cd /usr/bin
./mysqld_safe &
```

关闭：

```shell
mysqladmin -u root -p shutdown
```



#### vscode

可以使用插件：`SQL Formatter`



#### my.ini

可以查看数据存放的路径



### 基本格式

指令不区分大小写，以分号结束。如可以输入：

```mysql
SHOW DATABASES;
```

> 列出所有数据表

单行注释用`#`或`--`

> `#`和`--`的区别就是：`#`后面直接加注释内容，而`--`的第 2 个破折号后需要跟一个空格符在加注释内容。

多行注释用`/**/`

```mysql
use mysql; #选定数据库，之后所有语句针对这个数据库
SHOW TABLES; -- 展示所有数据表
SHOW /*多行
注释*/ TABLES;
SHOW COLUMNS FROM user; #查看user数据表的所有属性
SHOW INDEX FROM user; #显示数据表的详细索引信息，包括PRIMARY KEY（主键）
SHOW TABLE STATUS from mysql; # 输出数据库性能和统计信息
SHOW TABLE STATUS from mysql LIKE 'time%';     # 表名以time开头的表的信息
SHOW TABLE STATUS from mysql LIKE 'time%'\G;   # 加上 \G，查询结果按列打印
```

名字(数据库名、数据表名、用户名等)可以不用任何引号，也可以用单引号或反勾号(esc下面的键)。两者在linux下和windows下不同，linux下不区分，windows下区分。如果SQL服务器模式包括ANSI_QUOTES模式选项，还可以用双引号将识别符引起来。

一般引号用途是避免关键字冲突，如对`date`为列名时，需要引号。三种引号：

- 飘号 \`\` ，通常用于表示可能会产生歧义的列名
- 单引号 \'\' ，用于字符串，也可以用双引号
- 数值不能用引号；字符串不能不用引号也不能用飘号；列名不能用引号

退出：

```mysql
exit
```

> `use,exit`是不需要分号的语句



算术运算符，除法可以用`/`或`DIV`，整除整是小数，取模用`%`或`MOD`

关系运算符有`between 值 and 值` ，`in` , `is null` 及其 `not` 前缀的

`=`是是否等于，任一方为`NULL`得`NULL`，否则是`0/1`

逻辑有 `!` 或 `NOT` ，有 `AND, OR , XOR`

可以有位运算符 `&|^!<<>>`，其中`!`取反

如：

```mysql
select 22 div 3;
```

最低优先级为： **:=**。

![img](img/1011652-20170416163043227-1936139924.png)

最高优先级为： **!**、**BINARY**、 **COLLATE**。



### 数据类型

#### 数值

支持所有标准 SQL 数值数据类型。

这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。

关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。

BIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB表。

作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。

| 类型         | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| :----------- | :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- |
| TINYINT      | 1 Bytes                                  | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| SMALLINT     | 2 Bytes                                  | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| MEDIUMINT    | 3 Bytes                                  | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| INT或INTEGER | 4 Bytes                                  | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| BIGINT       | 8 Bytes                                  | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| FLOAT        | 4 Bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| DOUBLE       | 8 Bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |

------

int 可以用 int(数值)，表示显示宽度。实际存储宽度可能会大于显示宽度。默认显示宽度分别为 4,6,9,11,20 。可以使用 `unsigned` 修饰符。

decimal 默认是 10,0

 

#### 日期时间

表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。

每个时间类型有一个有效值范围和一个"零"值，当指定不合法的MySQL不能表示的值时使用"零"值。

TIMESTAMP类型有专有的自动更新特性，将在后面描述。

| 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                     |
| :-------- | :------------ | :----------------------------------------------------------- | :------------------ | :----------------------- |
| DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |
| TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                   |
| DATETIME  | 8             | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4             | 1970-01-01 00:00:00/2038结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |



#### 字符串

字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。

| 类型       | 大小                  | 用途                            |
| :--------- | :-------------------- | :------------------------------ |
| CHAR       | 0-255 bytes           | 定长字符串                      |
| VARCHAR    | 0-65535 bytes         | 变长字符串                      |
| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                    |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535 bytes        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                    |

char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。

CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。

char 定长； varchar 可变长；前者查询快，后者查询慢

BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。

BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。

有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。



### 安装

#### windows

> 废置：官网下载 [这里](https://dev.mysql.com/downloads/windows/installer/8.0.html) ，下载安装包
>
> 选custom，然后点击右边列表的每一项，更改小字点击advance更改安装路径

 [这里](https://dev.mysql.com/downloads/mysql/) 选 No thanks 即可。下完到合适位置直接解压，就是目录了。

接下来配置：在该安装目录(如：`D:\Temps\mysql-8.0.27-winx64`)

新建文件 `my.ini` ，输入：

```ini
[mysql]
default-character-set=utf8

[mysqld]
port = 3306 
basedir=D:\Temps\mysql-8.0.27-winx64
datadir=D:\Temps\mysql-8.0.27-winx64\data
max_connections=200
character-set-server=utf8
default-storage-engine=INNODB 
```

> 对其中路径改成合适的安装路径

以管理员身份运行 cmd (`C:\Windows\System32` 里找到右击) ，进入安装目录，输入：

```shell
mysqld --remove mysql #清除原有
mysqld -install #或install
mysqld --initialize 
net start mysql
```

在安装目录的 `\data` 找到 `.err` 后缀文件，打开看到最后一行，找到初始密码。

登录：

```shell
mysql -uroot -p
```

输入初始密码。

修改密码：

```mysql
ALTER USER 'root'@'localhost' IDENTIFIED BY '新的密码';
exit; -- 退出
```

> 注意: 在 5.7 需要初始化 data 目录：
>
> ```shell
> cd C:\web\mysql-8.0.11\bin 
> mysqld --initialize-insecure 
> ```
>
> 初始化后再运行 net start mysql 即可启动 mysql



#### Linux安装

一系列应用如下：

> - **MySQL** - MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。
> - **MySQL-client** - MySQL 客户端程序，用于连接并操作Mysql服务器。
> - **MySQL-devel** - 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。
> - **MySQL-shared** - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。
> - **MySQL-bench** - MySQL数据库服务器的基准和性能测试工具。
>
> 可以使用 MariaDB 代替，MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。
>
> MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。
>
> ```shell
> yum install mariadb-server mariadb 
> ```
>
> mariadb数据库的相关命令是：
>
> ```shell
> systemctl start mariadb  #启动MariaDB
> systemctl stop mariadb  #停止MariaDB
> systemctl restart mariadb  #重启MariaDB
> systemctl enable mariadb  #设置开机启动
> ```

> rpm下卸载参考：
>
> ```shell
> rpm -e mysql　　// 普通删除模式
> rpm -e --nodeps mysql　　// 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除
> ```





## 指令

### 用户指令

#### 新建

首先选择一个数据库，用：

```mysql
use 数据库名;
```

> 数据库名不需要加引号；列出所有数据库用指令`SHOW DATABASES;`



命令为 

```mysql
CREATE USER 用户名 IDENTIFIED BY '密码';
```

如：

```mysql
create user oj identified by 'scnunoj';
```



#### 添加用户

```mysql
INSERT INTO user
	(host, user, authentication_string,
    select_priv, insert_priv, update_priv)
VALUES ('IP地址', '用户名', MD5(密码), 'Y', 'Y', 'Y')
```

> password() 加密函数已经在 8.0.11 中移除了，可以使用 MD5() 函数代替
>
> 在`5.7`以下，`authentication_string` 是 `password`

可以设置 `Y/N` 的包括：

- Select_priv
- Insert_priv
- Update_priv
- Delete_priv
- Create_priv
- Drop_priv
- Reload_priv
- Shutdown_priv
- Process_priv
- File_priv
- Grant_priv
- References_priv
- Index_priv
- Alter_priv



#### 授权

```mysql
GRANT ALL PRIVILEGES ON 数据库名.* to 用户名@'%' IDENTIFIED BY 'scnuoj';
```

```mysql
FLUSH PRIVILEGES; # 重新加载
```

如：

```mysql
grant all privileges on scnuoj.* to oj@'%' identified by 'scnuoj';
flush privileges;
```



```mysql
-- 给指定数据库TUTORIALS添加用户 zara ，密码为 zara123 
GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
ON TUTORIALS.*
TO 'zara'@'localhost'
IDENTIFIED BY 'zara123';
```





### 数据库指令

#### 查询

显示所有数据库。

```mysql
SHOW DATABASES;
```

显示编码：

```mysql
SHOW VARIABLES LIKE 'character_set_database';
```





#### 创建

```mysql
CREATE DATABASE 数据库名;
```

可以用管理员权限在shell时创建：

```shell
mysqladmin -u 管理员帐号名 -p create 数据库名
```

已存在同名时不能创建。



变体：不存在则创建

```mysql
CREATE DATABASE IF NOT EXISTS 数据库名
```

设定编码：

```mysql
CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;
```

`utf8_general_ci` 数据库的校验规则,ci是case insensitive的缩写,意思是大小写不敏感;相对的是cs,即case sensitive,大小写敏感;

MYSQL8.0前默认字符集是 `latin1` ，`utf8` 是 `utf8mb3` ； 8.0 开始，默认编码是 `utf8mb4` 。



#### 删除

```mysql
DROP DATABASE 数据库名;
```

或shell：

```shell
mysqladmin -u 管理员帐号名 -p drop 数据库名
```

执行后会出现提示，确认是否删除。而PHP脚本删除，不会出现提示消息。



#### 选择

```mysql
USE 数据库名;
```

选择后，mysql指令会针对这个数据库。



### 数据表指令

#### 枚举

```mysql
SHOW TABLES;
```



#### 查看概况

```mysql
DESC 数据表名;
```

或全称：

```mysql
DESCRIBE 数据表名;
```

查看列名。

查看建表语句(跟真实输入的建表语句不一样，经过转换的)：

```mysql
SHOW CREATE TABLE 数据表名;
```

查看数据库默认编码直接查看建表语句。



可以看当前全部数据表类型：

```mysql
SHOW TABLE STATUS ;
```



其他更多指令：

```mysql
SHOW COLUMNS FROM user; #查看user数据表的所有属性
SHOW INDEX FROM user; #显示数据表的详细索引信息，包括PRIMARY KEY（主键）
SHOW TABLE STATUS from mysql; # 输出数据库性能和统计信息
SHOW TABLE STATUS from mysql LIKE 'time%';     # 表名以time开头的表的信息
SHOW TABLE STATUS from mysql LIKE 'time%'\G;   # 加上 \G，查询结果按列打印
```



#### 创建

```mysql
CREATE TABLE table_name (column_name column_type);
```

```mysql
CREATE TABLE 数据表名(`列名` 列类型, `列名` 列类型, ..., PRIMARY KEY(`主键列名`) ) ENGINE=存储引擎 CHARSET=编码 DEFAULT
```

当数据库有规定 `ENGINE, CHARSET` 时，数据表大概可以不规定

如：

```mysql
CREATE TABLE IF NOT EXISTS runoob_tbl(
   runoob_id INT UNSIGNED AUTO_INCREMENT,
   runoob_title VARCHAR(100) NOT NULL,
   runoob_author VARCHAR(40) NOT NULL,
   submission_date DATE,
   PRIMARY KEY ( runoob_id )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

- 如果不想字段为 **NULL** 可以设置字段的属性为 **NOT NULL**， 在操作数据库时如果输入该字段的数据为**NULL** ，就会报错。

- PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。单个主键可以直接在定义属性时定义(`属性 类型 PRIMARY KEY [默认值]`)，多个必须用 `PRIMARY KEY(属性,属性, ...)` (也可以加前缀 `CONSTRAINT 约束名`)

  主键的特性：非空，唯一，非必须

- AUTO_INCREMENT定义列为自增的属性，只能用于主键，数值会自动加1。

  MYSQL 5.7 自增起始值重启后会以当前 `MAX` 初始化；而 `8.0` 不会

- ENGINE 设置存储引擎，CHARSET 设置编码

- 外键约束：(约束名字不能重复)

  ```mysql
  CONSTRAINT 约束名字 FOREIGN KEY(属性1) REFERENCES 数据表名(该表属性名)
  ```

  (也可以一行属性1，属性2 一一对应)，数据类型、数据表引擎必须匹配，否则报错

  有外键约束的，不可删除被外键指向的一列；数据表也是

- 唯一性约束：`UNIQUE` ，可以单独定义，也可以定义属性时定义，允许为空但只允许一次

- 默认值：`DEFAULT 值 `，定义属性时定义



#### 删除

```mysql
DROP TABLE 数据表名;
```

> 只清空数据不删掉表可以用 truncate (见数据指令-删除)



#### 查询

读取所有数据：

```mysql
SELECT * FROM 数据表名;
```

通用：

```mysql
SELECT 列名, 列名, ...
FROM 数据表名
[WHERE 从句判断] /*可选：包含任何条件*/
[LIMIT 数目] /*可选：返回记录数*/
[OFFSET 数目] /*可选：开始查询的数据偏移量，默认0*/
```

```mysql
SELECT 字段列表 FROM 数据表名
[WHERE xx] [GROUP BY 字段名] [HAVING 分组条件]
[ORDER BY ASC|DESC]
```

> **having：**用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作
>
> 顺序是这样的
>
> 1. FROM, including JOINs
> 2. WHERE
> 3. GROUP BY
> 4. HAVING
> 5. WINDOW functions
> 6. SELECT
> 7. DISTINCT
> 8. UNION
> 9. ORDER BY
> 10. LIMIT and OFFSET

如：

```mysql
select * from student;
select * from student where id=1;
select * from student where id in (1,2,3) and grade >= 10;
select name,age from tb_emp where sex="female" order by age;
```



补充：

- offset 必须在 limit 下才能用，作用为先偏移后获取不超过 limit 个

- order by 也可以用列名，之后可以加升序降序(默认升序)，可以有多个排序依据

  按拼音排序(utf8)为例：`order by convert(列名 using gbk)`

- distinct 关键字取不重复值

- between and 关键字可以取区间(字符串也行)

- `%`代表任意零到多个字符，`_`是任一个字符，可以用\\转义

  需要用 like 关键字才能用(不含`%`时等效于`=`)

- 可以使用能用的正则表达式，用`REGEXP`代替`=`位置即可(^$分别是开头和结尾)，也可以用 `RLIKE`

- 不等于可以用 `!=` 或 `<>`

- 使用 binary 关键字设定区分大小写；默认不区分

- 运算符`IS NULL` 当列值是`NULL`返回true；同理有`IS NOT NULL`，有`<=>`运算符，当相等或都为`NULL`返回真

  (不可以使用`=NULL`,`!=NULL`作为比较条件，恒假)

  可以用函数`ifnull(值,成真值)`将`NULL`转掉

如：

```mysql
select * from student order by grade;
select * from student order by grade desc;
select * from student_1 order by convert(major using gbk), student_number;
select distinct grade from student;
select * from student where id between 2 and 7;
select * from student where id between '2' and '7';
select * from student_1 where name like '张%' and id>5;
select * from student where binary student_name='abc';
select * from student_1 where student_number regexp "^20202005\\d{3}"; #可以再加一个$
```

> 子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。
>
> 实际可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式



#### UNION

将两个`select`结果组合到一起输出，并去重，如：

```mysql
select id from student union select id from score order by id;
```

所联合的东西必须具有一致列数。如果使用`union all` ，那么不会去重。

可以联合多个表，如：

```mysql
select * from student_2 union select * from student_3 union select * from student_4;
```

同样可以使用 `all` ，使用一次对一次生效(从左到右)



#### GROUP BY

语法：

```mysql
SELECT column_name, function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;
```

可以加上关键字`with rollup` 统计总结果(均值是总均值，累积就累积)在最后一行输出。可以设置分组列名为`coalesce(a,b,c)`，顺次判断，a空选b，b空选c

所用函数通常有：`count, sum, avg` 。

例如，统计每个人有多少条记录：

```mysql
select student_id, count(*) from score_1 group by student_id;
select student_id, avg(value) from score_1 group by student_id;
```

统计分数均值、总值和计次：

```mysql
select student_id, avg(value), sum(value), count(*) from score_1 group by student_id with rollup;
```

使得求和列名有意义（非NULL）：

```mysql
select coalesce(student_id, '统计量'), avg(value), sum(value), count(*) from score_1 group by student_id with rollup;
```



#### JOIN

联合多表查询；可以在`SELECT,UPDATE,DELETE` 中使用，分为：

- `INNER JOIN` 内连接(等值连接)(简写为`JOIN`)，得到两表交集
- `LEFT JOIN` 左连接(获取左表所有记录，即使右表没有对应匹配的记录)(得到左表和两表)，区别在于即使右匹配不到，也会强行得到一个NULL作为结果
- `RIGHT JOIN` 右连接

要配合联合列名的约束条件，用`on`关键字；为了区分开，通常把表名定义，然后用`a.列名` 这样的方法指出 `a` 表的列，如：

```mysql
SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
```

可以多表查询，如：(?处随便填点什么，#同理写个数字)

```mysql
select a.name, a.major, b.name, b.semester, c.value from 
`student_#` a join
`subject_#` b join
`score_#` c on
a.id = c.student_id and
b.id = c.subject_id and
c.value>=? and 
c.value <=? and
a.name like ? and 
a.major like ? and 
b.name like ? and 
b.semester like ?;
```



#### 更改

`ALTER`

增删改字段：

```mysql
ALTER TABLE 数据表名 DROP 列名;
ALTER TABLE 数据表名 ADD 列名 数据类型;
ALTER TABLE 数据表名 MODIFY 列名 数据类型;
ALTER TABLE 数据表名 CHANGE 列名 新列名 数据类型;
ALTER TABLE 数据表名 SET DEFAULT 值;
ALTER TABLE 数据表名 DROP DEFAULT;
ALTER TABLE 数据表名 DROP FOREIGN KEY 约束名;
ALTER TABLE 数据表名 ENGINE = 新数据表类型;
ALTER TABLE 数据表名 RENAME TO 数据表名; -- TO 可以不写
```

增加时可以设置位置，用`first`或`after 列名`；增加后会得到全空值。不设置就默认在最后添加。可以设置默认值，`default` 加值。(删掉就默认`NULL`)，修改时也可以用，作为调整位置。设置数据类型时可以附加约束。修改时原列名可以和新列名一样。如果本来`not null`修改时不能漏，不然会默认改成`null`允许的。`modify` 可以实现重排序。

引擎默认为 `InnoDB` ，还支持 `FEDERATED, MRG_MYISAM, MyISAM, BLACKHOLE, CSV, MEMORY, ARCHIVE, PERFORMANCE_SCHEMA` 。

如：

```mysql
alter table student add haha int first;
alter table student drop haha;
alter table student add haha int after id;
alter table student drop haha;
alter table student add haha int;
alter table student drop haha;
alter table student add haha int not null default 580;
alter table student modify haha bigint not null;
alter table student change haha xixi bigint not null;
```

```mysql
ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;
ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;
ALTER TABLE testalter_tbl ENGINE = MYISAM;
ALTER TABLE testalter_tbl RENAME TO alter_tbl;
```

> `show table status;`可以看数据表类型



#### 复制

先复制表结构：

```mysql
CREATE TABLE 新表名 LIKE 旧表名;
```

或：

```mysql
CREATE TABLE 新表名 SELECT * FROM 旧表;
```



再覆盖数据：

```mysql
INSERT INTO 新表名 SELECT * FROM 旧表名; 
```

可以部分复制并同时复制数据：

```mysql
CREATE TABLE 新表名 AS
(
    SELECT 列名, 列名 FROM 旧表名
)
```

可以改列名并同时复制数据：

```mysql
CREATE TABLE 新表名 AS
(
    SELECT 列名 AS 新名字 FROM 旧表名
)
```

如：

```mysql
create table hhh as (select id,student_name as `name` from student);
```

可以用新规则覆盖旧列名，如：

```mysql
create table hhh (id int) as (select * from student);
```



#### 检查

查看数据库的类似哈希值(long)

```mysql
checksum table 表名;
```

得到 `Checksum` 属性是 `long` ，跟其他表的作对比可以检查两表是否数据一致



### 索引指令

> 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。
>
> 创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。
>
> 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。

#### 普通索引

##### 创建

```mysql
CREATE INDEX indexName ON table_name (column_name);
```

> 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。

添加索引：

```mysql
ALTER table tableName ADD INDEX indexName(columnName)
```

创建时指定：

```mysql
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
INDEX [indexName] (username(length))  
 
);  
```



##### 删除

```mysql
DROP INDEX [indexName] ON mytable; 
```

或

```mysql
ALTER TABLE testalter_tbl DROP INDEX c;
```



#### 唯一指引

索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。指令如下：

```mysql
CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
```

```mysql
ALTER table mytable ADD UNIQUE [indexName] (username(length))
```

```mysql
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
UNIQUE [indexName] (username(length))  
 
);  
```



#### 修改

有四种方式来添加数据表的索引：

- **ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):**

  该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。

- **ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):** 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。

- **ALTER TABLE tbl_name ADD INDEX index_name (column_list):** 添加普通索引，索引值可出现多次。

- **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。

如：

```mysql
ALTER TABLE testalter_tbl ADD INDEX (c);
ALTER TABLE testalter_tbl DROP INDEX c;
```

主键作用于列上（可以一个列或多个列联合主键），添加主键索引时，你需要确保该主键默认不为空（NOT NULL）

```mysql
ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;
ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
ALTER TABLE testalter_tbl DROP PRIMARY KEY;
```



#### 显示

```mysql
SHOW INDEX FROM 数据表名
```

> 可以加\G以列表而不是表格来显示结果



### 数据指令

#### 插入

```mysql
INSERT INTO 数据表名 (列名1, ...) VALUES (值1, ...);
```

如：

```mysql
INSERT INTO runoob_tbl
(runoob_title, runoob_author, submission_date)
VALUES
("学习 MySQL", "菜鸟教程", NOW());
```

```mysql
insert into tb_emb values(2,'lr580','啊','啊啊');
```

对有自增主键的，列里可以不包含这个列；没定义 `not null` 的也可以缺省

为了防止中文乱码，可以事先设置：

```mysql
set names utf8;
```

可以一次插入多个行，逗号隔开，如：

```mysql
insert into student (student_name, grade) values ('abc',3),('aBC',4);
```

其实可以插入值`NULL`

如果列按顺序来且都有赋值，第一个括号可以不要，如：

```mysql
insert into student values (14,'aaa',55);
```

可以用 `ignore` 关键字，无则插有则忽略(但warning)。可以用 `replace into` ，无则插有则换。如：

```mysql
replace into student values (7,'qwq',666);
insert ignore into student values (7,'qwq',666);
```





#### 更新

```mysql
UPDATE 数据表名 SET 字段名 = 新字段值 WHERE 条件表达式
```

可以逗号分隔，更改多列

可以自增自减

如：

```mysql
update tb_emp set age = 24 where id = 2;
update student set student_name='www',grade=123 where id=7;
update student set grade=grade-1 where id=7;
```



#### 删除

```mysql
DELETE FROM 数据表名 WHERE 条件表达式
```

如：

```mysql
delete from tb_emp where id = 1024;
```

> 如果没有`where` 子句就是删掉整个表。
>
> delete，drop，truncate 都有删除表的作用，区别在于：
>
> -  1、delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除
> -  2、delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚
> -  3、执行的速度上，**drop>truncate>delete**



### 事务指令

> - 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
> - 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
> - 事务用来管理 insert,update,delete 语句
>
> 一般来说，事务是必须满足4个条件（ACID）：：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）
>
> - **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
> - **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
> - **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
> - **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失
>
> 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交

#### 事务控制

- BEGIN 或 START TRANSACTION 显式地开启一个事务；
- COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；
- ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
- SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；
- RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；(但是不会回滚)
- ROLLBACK TO identifier 把事务回滚到标记点；
- SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

处理事务的两种方法：

1、用 BEGIN, ROLLBACK, COMMIT来实现

- **BEGIN** 开始一个事务
- **ROLLBACK** 事务回滚
- **COMMIT** 事务确认

2、直接用 SET 来改变 MySQL 的自动提交模式:

- **SET AUTOCOMMIT=0** 禁止自动提交
- **SET AUTOCOMMIT=1** 开启自动提交

> 使用`savepoint`必须关

例如：

```mysql
begin;
insert into score values(5);
# 当前生效，但不永久生效；
insert into score values(6);
commit;
select * from score;
begin;
insert into score values(7);
rollback;
select * from score;
```

```mysql
set autocommit=0;
begin;
insert into score values(5);
savepoint svp;
select * from score;
insert into score values(6);
rollback to svp;
select * from score;
insert into score values(7);
release savepoint svp;
commit;
```



### 操作指令

暂时不会分类的东西

#### 临时表

> 临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表
>
> 临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间；使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁

创建数据表时，增加关键字 `TEMPORARY` 即可，其他操作基本是一样的；特别的，`show tables;` 不会看到临时表；可以用 `drop table` 手动删除，不过退出时会自动删除的

如：

```mysql
CREATE TEMPORARY TABLE SalesSummary (
    product_name VARCHAR(50) NOT NULL,
    total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00,
    avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00
    ,total_units_sold INT UNSIGNED NOT NULL DEFAULT 0
);
```

可以查询时创建：

```mysql
CREATE TEMPORARY TABLE 临时表名 AS
(
    SELECT *  FROM 旧的表名
    LIMIT 0,10000
);
```



#### 元数据

以下命令语句可以在 MySQL 的命令提示符使用，也可以在脚本中 使用，如PHP脚本。

| 命令               | 描述                      |
| :----------------- | :------------------------ |
| SELECT VERSION( )  | 服务器版本信息            |
| SELECT DATABASE( ) | 当前数据库名 (或者返回空) |
| SELECT USER( )     | 当前用户名                |
| SHOW STATUS        | 服务器状态                |
| SHOW VARIABLES     | 服务器配置变量            |

后两个很长；user是`名@IP`，如：`root@localhost`



#### 序列

即自增 `auto_increment` 。

使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。

要重置这个值需要删掉该列再加入，但是需要谨防数据混乱。

默认值起始为1，修改的话建表的时候`auto_increment=起始值`即可，或：

```mysql
ALTER TABLE t AUTO_INCREMENT = 100;
```



#### 重复处理

在 MySQL 数据表中设置指定的字段为 **PRIMARY KEY（主键）** 或者 **UNIQUE（唯一）** 索引来保证数据的唯一性

可以尝试双主键：

```mysql
CREATE TABLE person_tbl
(
   first_name CHAR(20) NOT NULL,
   last_name CHAR(20) NOT NULL,
   sex CHAR(10),
   PRIMARY KEY (last_name, first_name)
);
```

或 UNIQUE 索引：

```mysql
CREATE TABLE person_tbl
(
   first_name CHAR(20) NOT NULL,
   last_name CHAR(20) NOT NULL,
   sex CHAR(10),
   UNIQUE (last_name, first_name)
);
```



如果我们设置了唯一索引，那么在插入重复数据时，SQL 语句将无法执行成功,并抛出错。

INSERT IGNORE INTO 与 INSERT INTO 的区别就是 INSERT IGNORE INTO 会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。如：

```mysql
INSERT IGNORE INTO person_tbl (last_name, first_name)
VALUES( 'Jay', 'Thomas'), ( 'Jay', 'Thomas');
```

插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而 REPLACE INTO 如果存在 primary 或 unique 相同的记录，则先删除掉。再插入新记录。



统计重复：

```mysql
SELECT COUNT(*) as repetitions, last_name, first_name
FROM person_tbl
GROUP BY last_name, first_name
HAVING repetitions > 1;
```



选择时读取不重复数据，加入`distinct`，如：

```mysql
SELECT DISTINCT last_name, first_name FROM person_tbl;
```

或用`group by`列，如：

```mysql
SELECT DISTINCT last_name, first_name FROM 
GROUP BY (last_name, first_name);
```

数据表去重，先建一个表，插入选中的所有去重后元素，然后删掉原表，然后这个表改名为原表名，或单纯增加一下主键，如：

```mysql
ALTER IGNORE TABLE person_tbl
ADD PRIMARY KEY (last_name, first_name);
```



#### 注入

1. 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双"-"进行转换等。
2. 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。
3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
4. 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。
5. 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装
6. sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。





### 其他指令

看不到的可以看基本-使用章节或基本

#### 导出

##### SQL格式

`mysqldump -uroot -p 数据库名 数据表名 > 输出文件名.sql`

`mysqldump -uroot -p 数据库名 > 输出文件名.sql`

> 或 `-p密码` ，这种方法通常用于非输入式。

如：

```shell
mysqldump -uroot -p javase > test.sql
mysqldump -uroot -p javase score > test.sql
```

可以 `-P端口 -hIP` , `-u用户名 -p密码` 的方式导出非本地数据库如：

```shell
mysqldump -uroot -p -P3306 -h127.0.0.1 went > abcc.sql
```

> 可以用 `--tab=路径`，如：
>
> ```shell
> mysqldump -u root -p --no-create-info
> --tab=/tmp RUNOOB runoob_tbl
> ```



##### 文本格式

也可以上指令：在`select`时`into outfile '路径'`

在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。

```mysql
SELECT a,b,a+b INTO OUTFILE '/tmp/result.text'
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
LINES TERMINATED BY '\n'
FROM test_table;
```

- LOAD DATA INFILE是SELECT ... INTO OUTFILE的逆操作，SELECT句法。为了将一个数据库的数据写入一个文件，使用SELECT ... INTO OUTFILE，为了将文件读回数据库，使用LOAD DATA INFILE。
- SELECT...INTO OUTFILE 'file_name'形式的SELECT可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。
- 输出不能是一个已存在的文件。防止文件数据被篡改。
- 你需要有一个登陆服务器的账号来检索文件。否则 SELECT ... INTO OUTFILE 不会起任何作用。
- 在UNIX中，该文件被创建后是可读的，权限由MySQL服务器所拥有。这意味着，虽然你就可以读取该文件，但可能无法将其删除

> 在写出的时候会出现The MySQL server is running with the --secure-file-priv option so it cannot execute this statement的错误解决方法：
>
> 出现这个错误是因为没有给数据库指定写出文件的路径或者写出的路径有问题。
>
> 首先使用下面的命令 **show variables like '%secure%';** 查看数据库的存储路径。如果查出的 secure_file_priv 是 null 的时候就证明在 my.ini 文件里面没有配置写出路径。
>
> 这时候就可以在 mysql.ini 文件的 [mysqld] 代码下增加 secure_file_priv=E:/TEST 再重启 mysql 就可以了。然后在导出的地址下面写上刚才配置的这个地址 eg: **select \* from tb_test into outfile "E:/TEST/test.txt"；**就可以了。



#### 导入

##### 创建数据库

`mysqladmin -h 端口号 -u 用户名 -p密码 create 数据库名`

也可以输入密码的方式，下同

如：

```shell
mysqladmin -h 127.0.0.1 -u root -p1437580 create test
```



##### 导入数据表

`cmd /c mysql -h 端口号 -u 用户名 -p密码 < 文件名.sql`

> cmd /k在执行命令后不关掉命令行窗口 cmd /c在执行完命令行后关掉命令行窗口 

如：

```shell
mysql -h 127.0.0.1 -u root -p1437580 test < tb_thu.sql
```



##### source

source 命令导入数据库需要先登录到数库终端：

```mysql
create database abc;      # 创建数据库
use abc;                  # 使用已创建的数据库 
set names utf8;           # 设置编码
source /home/abc/abc.sql  # 导入备份数据库
```



##### load data

MySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。

```
mysql> LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl;
```

　如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。

你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。

两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。

如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。

```mysql
LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl
FIELDS TERMINATED BY ':'
LINES TERMINATED BY '\r\n';
```

LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。

如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下：

```mysql
LOAD DATA LOCAL INFILE 'dump.txt' 
INTO TABLE mytbl (b, c, a);
```



##### mysqlimport

mysqlimport 客户端提供了 LOAD DATA INFILEQL 语句的一个命令行接口。mysqlimport 的大多数选项直接对应 LOAD DATA INFILE 子句。

从文件 dump.txt 中将数据导入到 mytbl 数据表中, 可以使用以下命令：

```shell
mysqlimport -u root -p --local mytbl dump.txt
```

mysqlimport 命令可以指定选项来设置指定格式,命令语句格式如下：

```shell
mysqlimport -u root -p --local --fields-terminated-by=":" --lines-terminated-by="\r\n"  mytbl dump.txt
```

mysqlimport 语句中使用 --columns 选项来设置列的顺序：

```shell
mysqlimport -u root -p --local --columns=b,c,a mytbl dump.txt
```

------

mysqlimport的常用选项介绍

| 选项                         | 功能                                                         |
| :--------------------------- | :----------------------------------------------------------- |
| -d or --delete               | 新数据导入数据表中之前删除数据数据表中的所有信息             |
| -f or --force                | 不管是否遇到错误，mysqlimport将强制继续插入数据              |
| -i or --ignore               | mysqlimport跳过或者忽略那些有相同唯一 关键字的行， 导入文件中的数据将被忽略。 |
| -l or -lock-tables           | 数据被插入之前锁住表，这样就防止了， 你在更新数据库时，用户的查询和更新受到影响。 |
| -r or -replace               | 这个选项与－i选项的作用相反；此选项将替代 表中有相同唯一关键字的记录。 |
| --fields-enclosed- by= char  | 指定文本文件中数据的记录时以什么括起的， 很多情况下 数据以双引号括起。 默认的情况下数据是没有被字符括起的。 |
| --fields-terminated- by=char | 指定各个数据的值之间的分隔符，在句号分隔的文件中， 分隔符是句号。您可以用此选项指定数据之间的分隔符。 默认的分隔符是跳格符（Tab） |
| --lines-terminated- by=str   | 此选项指定文本文件中行与行之间数据的分隔字符串 或者字符。 默认的情况下mysqlimport以newline为行分隔符。 您可以选择用一个字符串来替代一个单个的字符： 一个新行或者一个回车。 |

mysqlimport 命令常用的选项还有 -v 显示版本（version）， -p 提示输入密码（password）等



#### 查询

##### 引擎

系统表类型：

```mysql
select distinct(engine) from information_schema.tables;
```



##### 警告

```mysql
show warnings;
```





### 函数

#### 内置

太多了枚举出来要死了，直接贴链接[列表](https://www.runoob.com/mysql/mysql-functions.html)



#### 自定义

> 举例：
>
> ```mysql
> DROP TABLE IF EXISTS sequence; 
> CREATE TABLE sequence ( 
> name VARCHAR(50) NOT NULL, 
> current_value INT NOT NULL, 
> increment INT NOT NULL DEFAULT 1, 
> PRIMARY KEY (name) 
> ) ENGINE=InnoDB;
> 
> DROP FUNCTION IF EXISTS currval; 
> DELIMITER $ 
> CREATE FUNCTION currval (seq_name VARCHAR(50)) 
> RETURNS INTEGER
> LANGUAGE SQL 
> DETERMINISTIC 
> CONTAINS SQL 
> SQL SECURITY DEFINER 
> COMMENT ''
> BEGIN
> DECLARE value INTEGER; 
> SET value = 0; 
> SELECT current_value INTO value 
> FROM sequence
> WHERE name = seq_name; 
> RETURN value; 
> END
> $ 
> DELIMITER ;
> 
> DROP FUNCTION IF EXISTS nextval; 
> DELIMITER $ 
> CREATE FUNCTION nextval (seq_name VARCHAR(50)) 
> RETURNS INTEGER
> LANGUAGE SQL 
> DETERMINISTIC 
> CONTAINS SQL 
> SQL SECURITY DEFINER 
> COMMENT ''
> BEGIN
> UPDATE sequence
> SET current_value = current_value + increment 
> WHERE name = seq_name; 
> RETURN currval(seq_name); 
> END
> $ 
> DELIMITER;
> 
> DROP FUNCTION IF EXISTS setval; 
> DELIMITER $ 
> CREATE FUNCTION setval (seq_name VARCHAR(50), value INTEGER) 
> RETURNS INTEGER
> LANGUAGE SQL 
> DETERMINISTIC 
> CONTAINS SQL 
> SQL SECURITY DEFINER 
> COMMENT ''
> BEGIN
> UPDATE sequence
> SET current_value = value 
> WHERE name = seq_name; 
> RETURN currval(seq_name); 
> END
> $ 
> DELIMITER ;
> 
> INSERT INTO sequence VALUES ('TestSeq', 0, 1);
> ----添加一个sequence名称和初始值，以及自增幅度  添加一个名为TestSeq 的自增序列
> 
> SELECT SETVAL('TestSeq', 10);
> ---设置指定sequence的初始值    这里设置TestSeq 的初始值为10
> 
> SELECT CURRVAL('TestSeq');  
> --查询指定sequence的当前值   这里是获取TestSeq当前值
> 
> SELECT NEXTVAL('TestSeq');  
> --查询指定sequence的下一个值  这里是获取TestSeq下一个值
> ```





## 实例

### SQL注入

#### 登录

用户名设置为 `1' or '1='1` ，密码同理。使得通过 `where` 时， or 后边的判断总是成立，从而使得用户和密码总是正确，如：

```mysql
select * from _userlist where name = '?' and psw = '?';
```

在 java 里用 `mysql` ，statement 难以防御注入，建议使用 `preparestatement` ，可以防止注入，把特殊符号转义。





# Yii

[教程](https://dev.mysql.com/downloads/windows/installer/8.0.html)



# Docker

## 理论

[教程](https://yeasy.gitbook.io/docker_practice/basic_concept/image)

### 基本概念

docker类似于轻量虚拟机，可以用于将一台机子部署的东西快速迁移到别的机子



**镜像** Image 类似于 root 文件系统。是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 **不包含** 任何动态数据，其内容在构建之后也不会被改变。

镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。

> 因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。



**容器** Container 。容器是镜像的实例。镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 `root` 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样

> 容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更

一个 **Docker Registry** 中可以包含多个 **仓库**（`Repository`）；每个仓库可以包含多个 **标签**（`Tag`）；每个标签对应一个镜像。通过 `<仓库名>:<标签>` 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 `latest` 作为默认标签

> 仓库名经常以 *两段式路径* 形式出现，比如 `jwilder/nginx-proxy`，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名



## 使用

### 安装

#### windows 10

##### docker安装

建议先下载高速下载工具， winget [下载链接](https://www.microsoft.com/zh-cn/p/app-installer/9nblggh4nns1?rtc=1#activetab=pivot:overviewtab) 或者可以用我自己的备份[下载docker](https://cloud.socoding.cn/s/KZ1Tb)

然后在 cmd 键入指令：

```bash
winget install Docker.DockerDesktop
```

> 也可以 `-i` 指定交互界面安装，可以 `-l 路径` 指定安装目录，但是 docker 不支持
>
> 下载路径根据输出内容发现为： `C:\Users\lr580\AppData\Local\Temp\WinGet` ，装完好会自己删包

可能需要输入一次 `y` 

之后建议重启电脑一次



##### hyper-v安装

> 这一步可能是不需要的

然后安装 hyper-v，在管理员下执行该脚本：

```bat
pushd "%~dp0"

dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum >hyper-v.txt

for /f %%i in ('findstr /i . hyper-v.txt 2^>nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i"

del hyper-v.txt

Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL
```

然后重启电脑



##### 迁移到D盘

[教程对标](https://www.cnblogs.com/renguanyu/p/15201827.html) [备用对标教程](https://blog.csdn.net/jxl15680701016/article/details/106925002/)

因为默认安装在 C 盘，所以接下来考虑迁移走 C 盘：

首先在任务管理器关闭所有 Docker 前缀的进程

然后控制面板里搜索管理工具，点击Hyper-v管理器，点击仅有的一台，点停止服务，点 Hyper-v 设置



在管理员下，逐个剪切路径到另一个路径，然后执行下述命令：(后者路径仅供参考)

```bat
mklink /j "C:\ProgramData\Docker" "D:\Temps\docker\DockerData"
mklink /j "C:\ProgramData\DockerDesktop" "D:\Temps\docker\DockerDesktop"
mklink /j "C:\Program Files\Docker" "D:\Temps\docker\Docker"
mklink /j "C:\Users\lr580\AppData\Local\Docker" "D:\Users\lr580\AppData\Local\Docker"
```

当且仅当在 C 盘对应位置能看到快捷图标然后点进去可以时，证明迁移成功，此时可以打开dockerdesktop。

验收标准：打开Docker Desktop正常，不会闪退(可能会要求安装WSL2)



##### WSL安装升级

安装 WSL(Windows Subsystem for Linux)：

win+r 运行 `winver` 查看版本号，确保内部版本号大于等于19041

打开 powershell ，列举可安装版本：

```bash
wsl -l -o
```

可以安装一个 Linux，如：

```bash
wsl --install -d Ubuntu-20.04
```

设置管理员密码：

```bash
sudo passwd root
```

关闭：

```bash
wsl --shutdown
```

然后迁移到D盘，使用类似的方法：

```bat
mklink /j  "C:\Users\lr580\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc" "D:\Temps\wsl\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc"
```

然后右击设置权限为完全控制。 [参考教程](https://www.cnblogs.com/itkingyw/p/12736358.html)

要卸载的话可以在菜单搜索 Ubuntu，直接右击卸载

检查安装的版本是 WSL 1还是2，输入：

```bash
wsl -l -v
```

关闭特定，如：

```bash
wsl -t Ubuntu-20.04
```

要启动的话，直接菜单搜索点击即可

管理员下 powershell 输入指令：[参考文献](https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package)

```bat
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
```

下载文献里的安装包 `.msi` ，大约16MB，安装，重启

对 WSL 1更新到 WSL 2： [参考文献](https://docs.microsoft.com/zh-cn/windows/wsl/install)

```bash
wsl --set-version Ubuntu-20.04 2
```

如果提示`转换完成。` 就成功了

设置默认版本：

```bash
wsl --set-default-version 2
```



验收标准：打开docker desktop，显示大约为：`Get started with Docker in a few easy steps!`



> 注意 docker 使用过程中疑似要一直开着那个虚拟机，所以不要关掉；此外 docker 还会创多两个虚拟机



### 配置

#### 镜像加速器

##### windows 10

菜单选择 `Settings`，打开配置窗口后在左侧导航菜单选择 `Docker Engine`，在右侧像下边一样编辑追加 json 文件，之后点击 `Apply & Restart` 保存后 Docker 就会重启并应用配置的镜像地址了。

```json
{
  "registry-mirrors": [
    "https://hub-mirror.c.163.com",
    "https://mirror.baidubce.com"
  ]
}
```

若输入指令：

```bash
docker info
```

后，能够查找到 `Registry Mirrors`有内容，即证明配置成功



#### 实验特性

一些 docker 命令或功能仅当 **实验特性** 开启时才能使用，在类似 `镜像加速器` 的方法里编辑 json：

```json
"expermental": true
```



### 使用

#### 官方hello-world

下载一个项目：

```bash
git clone git@github.com:docker/getting-started.git
```

cd 进入这个项目，在 docker 窗里跑：

```bash
docker run --name repo alpine
```

验收标准：不能再跑这个命令，输出`docker:Error response from daemon: Conflict.`

跑这个指令：

```bash
docker build -t docker101tutorial
```

等待完毕后，跑：

```bash
docker run -d -p 80:80 --name docker-tutorial docker101tutorial
```

注册一个账号，然后执行指令例如，上传分享：

```bash
docker tag docker101tutorial lr580/docker101tutorial
docker push lr580/docker101tutorial
```

可以点击查看 [自己上传的内容](https://hub.docker.com/repositories)

验收：发现端口是 80 ，猜测是 httpd ，所以直接在浏览器跑一下 [localhost](https://localhost) ，能看到网页就胜利了



#### 杂项

可以在任意 cmd 窗口，如 powershell 使用 docker，也可以用 Desktop

由于许多输出颜色跟 Powershell 背景颜色相似，建议右击标题栏修改 powershell 背景颜色



## 指令

### 镜像

#### 列举

```bash
docker image ls
```

列表包含了 `仓库名`、`标签`、`镜像 ID`、`创建时间` 以及 `所占用的空间`。

> 在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 `docker image ls` 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小
>
> 镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多

通过 `docker system df` 命令来便捷的查看镜像、容器、数据卷所占用的空间



> 列举出摘要 (即 SHA256)
>
> ```bash
> docker image ls --digests
> ```
>
> 按名字精准查询，如：
>
> ```bash
> docker image ls -q docker101tutorial
> ```
>
> 某版本之前的，如：
>
> ```bash
> docker image ls -q -f before=mongo:3.2
> ```



#### 获取

```bash
docker pull --help
```

命令格式：

```bash
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]
```

例如：

```bash
docker pull ubuntu:18.04
```



#### 删除

```bash
docker image rm [选项] <镜像1> [<镜像2> ...]
```

其中，`<镜像>` 可以是 `镜像短 ID`、`镜像长 ID`、`镜像名` 或者 `镜像摘要`。短 ID 一般取长为 3 的前缀，足以区分即可

如：

```bash
docker image rm centos
```

更精确的是使用镜像摘要来删除，先列出摘要：

```bash
docker image ls --digests
```

然后删除用 `名字@摘要全文` ，如：

```bash
docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
```

> 镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。

> 删除的过程先把满足我们要求的所有镜像标签都取消，当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。直到没有任何层依赖当前层时，才会真实的删除当前层。

> 除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。



可以使用组合技 `docker image rm $(一条指令)` ，如：

```bash
docker image rm $(docker image ls -q -f before=mongo:3.2)
```



#### 对比

```bash
docker diff 镜像
```



#### 保存

**慎用该指令** ,因为这种方法所有对镜像的操作都是黑箱操作，生成的镜像也被称为 **黑箱镜像**

```bash
docker commit --author "作者" --message "更改内容" 名字 镜像:版本
```



#### 历史

```bash
docker history 镜像
```



#### mainfest

不懂，大概是跨平台用的



#### import

格式：`docker import [选项] <文件>|<URL>|- [<仓库名>[:<标签>]]`

压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 `/` 目录展开，并直接作为镜像第一层提交，如：

```bash
docker import http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz openvz/ubuntu:16.04
docker image ls openvz/ubuntu
```



#### save

> Docker 还提供了 `docker save` 和 `docker load` 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以

使用 `docker save` 命令可以将镜像保存为归档文件

```bash
docker save alpine -o filename
file filename
```

这里的 filename 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件

注意：如果同名则会覆盖（没有警告）

如：

```bash
docker save alpine | gzip > alpine-latest.tar.gz
```

在另一台机子加载：

```bash
docker load -i alpine-latest.tar.gz
```

```bash
docker save <镜像名> | bzip2 | pv | ssh <用户名>@<主机名> 'cat | docker load'
```





### Dockerfile

镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。

Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。

在一个空白目录中，建立一个文本文件，并命名为 `Dockerfile` 

#### 概述

在该文件里输入：

```dockerfile
FROM nginx
RUN echo '<h1>Nya haha, I am lr580~</h1>' > /usr/share/nginx/html/index.html
```

##### FROM

FROM 是必备指令和第一条指令；除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 `scratch`。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像

##### RUN

RUN 执行命令行，格式为：`RUN <命令>` 或 `RUN ["可执行文件", "参数1", "参数2"]`

> Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层

为了压缩层数，将多个 RUN 使用 `&&` 串联；为了美观，使用 `\` 换行，使用 `#` 行首注释；通常安装完环境后还需要删除掉安装包



##### 构建

接下来在有 `Dockerfile` 的目录下构建：

```bash
docker build -t nginx:v3 .
```

通用格式为：

```bash
docker build [选项] <上下文路径/URL/->
```

`docker build` 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的；指定构建镜像上下文的路径，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件



##### 上下文

context

> `COPY` 这类指令中的源文件的路径都是*相对路径* ， `COPY ../package.json /app` 或者 `COPY /opt/xxxx /app` 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去，一种复制如：
>
> ```dockerfile
> COPY ./package.json /app/
> ```

一般来说，应该会将 `Dockerfile` 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 `.gitignore` 一样的语法写一个 `.dockerignore`，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的

> 这只是默认行为，实际上 `Dockerfile` 的文件名并不要求必须为 `Dockerfile`，而且并不要求必须位于上下文目录中，比如可以用 `-f ../Dockerfile.php` 参数指定某个文件作为 `Dockerfile`



##### 远程

可以用 `-t` 参数从 URL 构建，如：

```bash
docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world
```

也可以是 tar 压缩包，那么会自动解包：

```bash
docker build http://server/context.tar.gz
```



##### 输入构建

```bash
docker build - < Dockerfile
```

或

```bash
cat Dockerfile | docker build -
```

如果标准输入传入的是文本文件，则将其视为 `Dockerfile`，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 `COPY` 进镜像之类的事情。

可以读取上下文压缩包：

```bash
docker build - < context.tar.gz
```



##### 运行

在窗口化里点击运行，输入参数端口，然后直接访问 [localhost](https://localhost) 即可



##### 阶段

另一种方式，就是我们事先在一个 `Dockerfile` 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 `Dockerfile` 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂

如：

```dockerfile
FROM golang:alpine as builder

RUN apk --no-cache add git

WORKDIR /go/src/github.com/go/helloworld/

RUN go get -d -v github.com/go-sql-driver/mysql

COPY app.go .

RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest as prod

RUN apk --no-cache add ca-certificates

WORKDIR /root/

COPY --from=0 /go/src/github.com/go/helloworld/app .

CMD ["./app"]
```

使用 as 后，若只想构建某一阶段的镜像，就可以`--target=as名字`，如：

```dockerfile
FROM golang:alpine as builder
```

```bash
docker build --target builder -t username/imagename:tag .
```

使用 `COPY --from=0 /go/src/github.com/go/helloworld/app .` 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件

```dockerfile
$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf
```





#### 指令

##### COPY

格式：

`COPY [--chown=<user>:<group>] <源路径>... <目标路径>`

`COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]`

`COPY` 指令将从构建上下文目录中 `<源路径>` 的文件/目录复制到新的一层的镜像内的 `<目标路径>` 位置。比如：

```dockerfile
COPY package.json /usr/src/app/
```

`<源路径>` 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 [`filepath.Match`](https://golang.org/pkg/path/filepath/#Match) 规则：

```
pattern:
	{ term }
term:
	'*'         matches any sequence of non-Separator characters
	'?'         matches any single non-Separator character
	'[' [ '^' ] { character-range } ']'
	            character class (must be non-empty)
	c           matches character c (c != '*', '?', '\\', '[')
	'\\' c      matches character c

character-range:
	c           matches character c (c != '\\', '-', ']')
	'\\' c      matches character c
	lo '-' hi   matches character c for lo <= c <= hi
```

目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录

使用 `COPY` 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等

在使用该指令的时候还可以加上 `--chown=<user>:<group>` 选项来改变文件的所属用户及所属组，如：

```dockerfile
COPY --chown=55:mygroup files* /mydir/
COPY --chown=bin files* /mydir/
COPY --chown=1 files* /mydir/
COPY --chown=10:11 files* /mydir/
```

如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径



##### ADD

是 COPY 的超集

 `<源路径>` 可以是一个 `URL`，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 `<目标路径>` 去。下载后的文件权限自动设置为 `600`，如果这并不是想要的权限，那么还需要增加额外的一层 `RUN` 进行权限调整

> 另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 `RUN` 指令进行解压缩。所以不如直接使用 `RUN` 指令，然后使用 `wget` 或者 `curl` 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用
>
> 真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 `ADD` 命令了
>
> `ADD` 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢

可以遵循这样的原则，所有的文件复制均使用 `COPY` 指令，仅在需要自动解压缩的场合使用 `ADD`



##### CMD

`shell` 格式：`CMD <命令>`

`exec` 格式：`CMD ["可执行文件", "参数1", "参数2"...]`

参数列表格式：`CMD ["参数1", "参数2"...]`。在指定了 `ENTRYPOINT` 指令后，用 `CMD` 指定具体的参数

在指令格式上，一般推荐使用 `exec` 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 `"`，而不要使用单引号



Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。`CMD` 指令就是用于指定默认的容器主进程的启动命令的

如果使用 `shell` 格式的话，实际的命令会被包装为 `sh -c` 的参数的形式进行执行。比如

```dockerfile
CMD echo $HOME
```

会变为：

```dockerfile
CMD [ "sh", "-c", "echo $HOME" ]
```

容器内没有后台服务的概念，例如 `service nginx start` 会挂掉

对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西

正确的做法是直接执行 `nginx` 可执行文件，并且要求以前台形式运行。比如：

```bash
CMD ["nginx", "-g", "daemon off;"]
```



只可以出现一次，如果写了多个，只有最后一个生效

运行时可以替换掉这个默认指令



##### ENTERPOINT

格式同 RUN

`ENTRYPOINT` 在运行时也可以替代，不过比 `CMD` 要略显繁琐，需要通过 `docker run` 的参数 `--entrypoint` 来指定。

当指定了 `ENTRYPOINT` 后，`CMD` 的含义就发生了改变，不再是直接的运行其命令，而是将 `CMD` 的内容作为参数传给 `ENTRYPOINT` 指令



场景一：让镜像像命令一样使用，如：

```dockerfile
FROM ubuntu:18.04
RUN apt-get update \
    && apt-get install -y curl \
    && rm -rf /var/lib/apt/lists/*
ENTRYPOINT [ "curl", "-s", "http://myip.ipip.net" ]
```

构建：

```bash
docker build -t myip
```

那么可以同时支持：

```bash
docker run myip
docker run myip -i
```

而不是后者需要：

```bash
docker run myip curl -s http://myip.ipip.net -i
```

> 若 `dockerfile` 的最后一行是 CMD 就要这么做



只可以出现一次，如果写了多个，只有最后一个生效



场景二：应用前的准备

通常用于一些初始化(特别是可能需要 root 的)

```dockerfile
FROM alpine:3.4
...
RUN addgroup -S redis && adduser -S -G redis redis
...
ENTRYPOINT ["docker-entrypoint.sh"]

EXPOSE 6379
CMD [ "redis-server" ]
```

其 `docker-entrypoint.sh` 为：

```bash
#!/bin/sh
...
# allow the container to be started with `--user`
if [ "$1" = 'redis-server' -a "$(id -u)" = '0' ]; then
    find . \! -user redis -exec chown redis '{}' +
    exec gosu redis "$0" "$@"
fi

exec "$@"
```

该脚本的内容就是根据 `CMD` 的内容来判断，如果是 `redis-server` 的话，则切换到 `redis` 用户身份启动服务器，否则依旧使用 `root` 身份执行，如：

```bash
docker run -it redis id
```



##### ENV

设置环境变量

```
ENV <key> <value>
```

```
ENV <key1>=<value1> <key2>=<value2>...
```

换行，以及对含有空格的值用双引号括起来的办法，如：

```dockerfile
ENV VERSION=1.0 DEBUG=on \
    NAME="Happy Feet"
```

环境变量可以被后文使用，如：

```dockerfile
ENV NODE_VERSION 7.2.0

RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz"
```

> 下列指令可以支持环境变量展开： `ADD`、`COPY`、`ENV`、`EXPOSE`、`FROM`、`LABEL`、`USER`、`WORKDIR`、`VOLUME`、`STOPSIGNAL`、`ONBUILD`、`RUN`。



##### ARG

构建参数和 `ENV` 的效果一样，都是设置环境变量。所不同的是，`ARG` 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的

`docker history` 还是可以看到所有值的(所以不可以存敏感信息)

该默认值可以在构建命令 `docker build` 中用 `--build-arg <参数名>=<值>` 来覆盖。

ARG 指令有生效范围，如果在 `FROM` 指令之前指定，那么只能用于 `FROM` 指令中



##### VOLUME

定义匿名卷

容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中

可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据，如：

```dockerfile
VOLUME /data
```

任何向 `/data` 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：

```bash
docker run -d -v mydata:/data xxxx
```



##### EXPOSE

格式为 `EXPOSE <端口1> [<端口2>...]`

声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 `docker run -P` 时，会自动随机映射 `EXPOSE` 的端口

要将 `EXPOSE` 和在运行时使用 `-p <宿主端口>:<容器端口>` 区分开来。`-p`，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 `EXPOSE` 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射



##### WORKDIR

使用 `WORKDIR` 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，`WORKDIR` 会帮你建立目录，如：

```dockerfile
WORKDIR /app

RUN echo "hello" > world.txt
```

```dockerfile
WORKDIR /a
WORKDIR b
WORKDIR c

RUN pwd
```

> pwd在 `/a/b/c`



##### USER

`USER <用户名>[:<用户组>]`

注意，`USER` 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换

如果以 `root` 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 `su` 或者 `sudo`，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 [`gosu`](https://github.com/tianon/gosu)

```dockerfile
# 建立 redis 用户，并使用 gosu 换另一个用户执行命令
RUN groupadd -r redis && useradd -r -g redis redis
# 下载 gosu
RUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64" \
    && chmod +x /usr/local/bin/gosu \
    && gosu nobody true
# 设置 CMD，并以另外的用户执行
CMD [ "exec", "gosu", "redis", "redis-server" ]
```



##### HEALTHCHECK

`HEALTHCHECK [选项] CMD <命令>`：设置检查容器健康状况的命令

`HEALTHCHECK NONE`：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令

当在一个镜像指定了 `HEALTHCHECK` 指令后，用其启动容器，初始状态会为 `starting`，在 `HEALTHCHECK` 指令检查成功后变为 `healthy`，如果连续一定次数失败，则会变为 `unhealthy`。

`HEALTHCHECK` 支持下列选项：

- `--interval=<间隔>`：两次健康检查的间隔，默认为 30 秒；
- `--timeout=<时长>`：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；
- `--retries=<次数>`：当连续失败指定次数后，则将容器状态视为 `unhealthy`，默认 3 次

和 `CMD`, `ENTRYPOINT` 一样，`HEALTHCHECK` 只可以出现一次，如果写了多个，只有最后一个生效。

如：

```dockerfile
FROM nginx
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
HEALTHCHECK --interval=5s --timeout=3s \
  CMD curl -fs http://localhost/ || exit 1
```

构建和启动、检查：

```bash
docker build -t myweb:v1 .
docker run -d --name web -p 80:80 myweb:v1
docker container ls
```

检查：

```bash
docker inspect --format '{{json .State.Health}}' web | python -m json.tool
```



##### ONBUILD

`ONBUILD` 是一个特殊的指令，它后面跟的是其它指令，比如 `RUN`, `COPY` 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行



##### LABEL

`LABEL` 指令用来给镜像以键值对的形式添加一些元数据（metadata）

```dockerfile
LABEL <key>=<value> <key>=<value> <key>=<value> ...
```

如：

```dockerfile
LABEL org.opencontainers.image.authors="yeasy"

LABEL org.opencontainers.image.documentation="https://yeasy.gitbooks.io"
```



##### SHELL

格式：`SHELL ["executable", "parameters"]`

`SHELL` 指令可以指定 `RUN` `ENTRYPOINT` `CMD` 指令的 shell，Linux 中默认为 `["/bin/sh", "-c"]`

```dockerfile
SHELL ["/bin/sh", "-c"]

RUN lll ; ls

SHELL ["/bin/sh", "-cex"]

RUN lll ; ls
```

两个 `RUN` 运行同一命令，第二个 `RUN` 运行的命令会打印出每条命令并当遇到错误时退出。



### 容器

容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用



#### 启动

`docker run 镜像`

`-t` 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， `-i` 则让容器的标准输入保持打开，如：

```bash
docker run -t -i ubuntu:18.04 /bin/bash
```

当利用 `docker run` 来创建容器时，Docker 在后台运行的标准操作包括：

- 检查本地是否存在指定的镜像，不存在就从 registry 下载
- 利用镜像创建并启动一个容器
- 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层
- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
- 从地址池配置一个 ip 地址给容器
- 执行用户指定的应用程序
- 执行完毕后容器被终止



可以利用 `docker container start` 命令，直接将一个已经终止（`exited`）的容器启动运行。

可以在伪终端中利用 `ps` 或 `top` 来查看进程信息



#### 守护态运行

更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 `-d` 参数来实现

如果不使用 `-d` 参数运行容器，容器会把输出的结果 (STDOUT) 打印到宿主机上面

如果使用了 `-d` 参数运行容器，输出结果可以用 `docker logs` 查看

容器是否会长久运行，是和 `docker run` 指定的命令有关，和 `-d` 参数无关

使用 `-d` 参数启动后会返回一个唯一的 id，也可以通过 `docker container ls` 命令来查看容器信息



#### 终止

可以使用 `docker container stop` 来终止一个运行中的容器。

此外，当 Docker 容器中指定的应用终结时，容器也自动终止

中只启动了一个终端的容器，用户通过 `exit` 命令或 `Ctrl+d` 来退出终端时，所创建的容器立刻终止

终止状态的容器可以用 `docker container ls -a` 命令看到

处于终止状态的容器，可以通过 `docker container start` 命令来重新启动。

此外，`docker container restart` 命令会将一个运行态的容器终止，然后再重新启动它



#### 进入

在使用 `-d` 参数时，容器启动后会进入后台。

某些时候需要进入容器进行操作，包括使用 `docker attach` 命令或 `docker exec` 命令，如：

```bash
docker run -dit ubuntu
docker container ls
docker attach 243c  #CONTAINER ID的前缀
```

*注意：* 如果从这个 stdin 中 exit，会导致容器的停止



`docker exec` 后边可以跟多个参数，这里主要说明 `-i` `-t` 参数。

只用 `-i` 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。

当 `-i` `-t` 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符，如：

```bash
docker run -dit ubuntu
docker container ls
docker exec -i 69d1 bash
docker exec -it 69d1 bash
```

如果从这个 stdin 中 exit，不会导致容器的停止



```bash
docker exec --help
```



#### 导出导入

导出：`docker export CONTAINER_ID > 文件名.tar`

导入：

- `cat 文件名.tar | docker import 镜像名/镜像:版本`
- `docker import URL 镜像`

如：

```bash
docker export 7691a814370e > ubuntu.tar
cat ubuntu.tar | docker import - test/ubuntu:v1.0
docker import http://example.com/exampleimage.tgz example/imagerepo
```

*注：用户既可以使用* *`docker load`* *来导入镜像存储文件到本地镜像库，也可以使用* *`docker import`* *来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。*



#### 删除

`docker container rm` ，如：

```bash
docker container rm trusting_newton
```

如果要删除一个运行中的容器，可以添加 `-f` 参数。Docker 会发送 `SIGKILL` 信号给容器。

用下面的命令可以清理掉所有处于终止状态的容器：

```bash
docker container prune
```



### 仓库

仓库（`Repository`）是集中存放镜像的地方。

一个容易混淆的概念是注册服务器（`Registry`）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 `docker.io/ubuntu` 来说，`docker.io` 是注册服务器地址，`ubuntu` 是仓库名

docker hub 是官方公共仓库

基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字

比如 `ansible/centos7-ansible` 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 `username/` 来指定使用某个用户提供的镜像，比如 `ansible` 用户

私有仓库、Nexus3.x 略，有需要再看



#### 登录

可以通过执行 `docker login` 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。

你可以通过 `docker logout` 退出登录。



#### 搜索

通过 `docker search` 命令来查找官方仓库中的镜像，如：

```bash
docker search centos
```

描述包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（`OFFICIAL`）、是否自动构建 （`AUTOMATED`）

查找的时候通过 `--filter=stars=N` 参数可以指定仅显示收藏数量为 `N` 以上的镜像



#### 拉取

```bash
docker pull
```



#### 推送

```bash
docker tag 镜像:版本 用户名/镜像:版本
docker push 用户名/镜像:版本
```

验证：

```bash
docker search username
```



### 数据

![image-20220207124300680](img/image-20220207124300680.png)

在容器中管理数据主要有两种方式：

- 数据卷（Volumes）
- 挂载主机目录 (Bind mounts)

`数据卷` 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：

- `数据卷` 可以在容器之间共享和重用
- 对 `数据卷` 的修改会立马生效
- 对 `数据卷` 的更新，不会影响镜像
- `数据卷` 默认会一直存在，即使容器被删除

`数据卷` 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）



#### 数据卷

##### 创建

```bash
docker volume create my-vol
```



##### 查看

列出全部：

```bash
docker volume ls
```

查看某个卷：

```bash
docker volume inspect my-vol
```

或(可能其实是两个不同的指令)

```bash
docker inspect my-vol
```



##### 启动

在用 `docker run` 命令的时候，使用 `--mount` 标记来将 `数据卷` 挂载到容器里。在一次 `docker run` 中可以挂载多个 `数据卷` ，如：

```bash
docker run -d -P \
    --name web \
    # -v my-vol:/usr/share/nginx/html \
    --mount source=my-vol,target=/usr/share/nginx/html \
    nginx:alpine
```



##### 删除

```bash
docker volume rm my-vol
```

`数据卷` 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 `数据卷`，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 `数据卷`。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 `docker rm -v` 这个命令。

无主的数据卷可能会占据很多空间，要清理请使用以下命令

```bash
docker volume prune
```



#### 主机目录

本地目录的路径必须是绝对路径，以前使用 `-v` 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 `--mount` 参数时如果本地目录不存在，Docker 会报错。如：

```bash
docker run -d -P \
    --name web \
    # -v /src/webapp:/usr/share/nginx/html \
    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \
    nginx:alpine
```

Docker 挂载主机目录的默认权限是 `读写`，用户也可以通过增加 `readonly` 指定为 `只读`，如：

```bash
docker run -d -P \
    --name web \
    # -v /src/webapp:/usr/share/nginx/html:ro \
    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \
    nginx:alpine
```

`--mount` 标记也可以从主机挂载单个文件到容器中，如：

```bash
docker run --rm -it \
   # -v $HOME/.bash_history:/root/.bash_history \
   --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \
   ubuntu:18.04 \
   bash
```

这样就可以记录在容器输入过的命令了。



### 网络

#### 端口

容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 `-P` 或 `-p` 参数来指定端口映射

当使用 `-P` 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口

如：

```bash
docker run -d -P nginx:alpine
docker container ls -l #port处看端口
```

同样的，可以通过 `docker logs` 命令来查看访问记录，如：

```bash
docker logs sth
```

`-p` 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 `ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort`。

使用 `hostPort:containerPort` 格式本地的 80 端口映射到容器的 80 端口，可以执行，如：

```bash
docker run -d -p 80:80 nginx:alpine
```

可以使用 `ip:hostPort:containerPort` 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1，可以：

```bash
docker run -d -p 127.0.0.1:80:80 nginx:alpine
```

使用 `ip::containerPort` 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口

```bash
docker run -d -p 127.0.0.1::80 nginx:alpine
```

还可以使用 `udp` 标记来指定 `udp` 端口

```bash
docker run -d -p 127.0.0.1:80:80/udp nginx:alpine
```



使用 `docker port` 来查看当前映射的端口配置，也可以查看到绑定的地址，如：

```bash
docker port sth 80
```

容器有自己的内部网络和 ip 地址（使用 `docker inspect` 查看，Docker 还可以有一个可变的网络配置。）

`-p` 标记可以多次使用来绑定多个端口，如：

```bash
docker run -d \
    -p 80:80 \
    -p 443:443 \
    nginx:alpine
```



#### 互联

> 建议将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 `--link` 参数

创建网络：

```bash
docker network create -d bridge my-net
```

运行一个容器并连接到新建的 `my-net` 网络

```bash
docker run -it --rm --name busybox1 --network my-net busybox sh
```

打开新的终端，再运行一个容器并加入到 `my-net` 网络

```bash
docker run -it --rm --name busybox2 --network my-net busybox sh
```

再在第三个终端查看容器信息：

```bash
docker container ls
```

此时两个容器可以互相 ping 通，如：

```bash
ping busybox2
```



#### DNS

 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。

在容器中使用 `mount` 命令可以看到挂载信息：

这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 `/etc/resolv.conf` 文件立刻得到更新。

配置全部容器的 DNS ，也可以在 `/etc/docker/daemon.json` 文件中增加以下内容来设置。

```bash
{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}
```

检验生效：

```bash
docker run -it --rm ubuntu:18.04 cat etc/resolv.conf
```

如果用户想要手动指定容器的配置，可以在使用 `docker run` 命令启动容器时加入如下参数：

`-h HOSTNAME` 或者 `--hostname=HOSTNAME` 设定容器的主机名，它会被写到容器内的 `/etc/hostname` 和 `/etc/hosts`。但它在容器外部看不到，既不会在 `docker container ls` 中显示，也不会在其他的容器的 `/etc/hosts` 看到。

`--dns=IP_ADDRESS` 添加 DNS 服务器到容器的 `/etc/resolv.conf` 中，让容器用这个服务器来解析所有不在 `/etc/hosts` 中的主机名。

`--dns-search=DOMAIN` 设定容器的搜索域，当设定搜索域为 `.example.com` 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 `host.example.com`。

> 注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 `/etc/resolv.conf` 来配置容器。



## Compose

`Compose` 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 `OpenStack` 中的 `Heat` 十分类似

定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」

它允许用户通过一个单独的 `docker-compose.yml` 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）

`Compose` 中有两个重要的概念：

- 服务 (`service`)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。
- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元，在 `docker-compose.yml` 文件中定义。

> 原版本是 Python 写的，目前 Docker 官方用 GO 语言 [重写](https://github.com/docker/compose-cli) 了 Docker Compose，并将其作为了 docker cli 的子命令，称为 `Compose V2`。你可以参照官方文档安装，然后将熟悉的 `docker-compose` 命令替换为 `docker compose`，即可使用 Docker Compose。

`Docker Desktop for Mac/Windows` 自带 `docker-compose` 二进制文件，安装 Docker 之后可以直接使用(默认为v2)

使用如下命令查看是否装了：

```bash
docker-compose --version
```

Linux 有多种方法安装



### 使用

#### Hello world

在新的目录编写 `app.py` ：

```python
from flask import Flask
from redis import Redis

app = Flask(__name__)
redis = Redis(host='redis', port=6379)

@app.route('/')
def hello():
    count = redis.incr('hits')
    return 'Nya! lr580\'s here ovo <br/> 该页面已被访问 {} 次。\n'.format(count)

if __name__ == "__main__":
    app.run(host="0.0.0.0", debug=True)
```

> 每次重启 count 会被清零

编写 `Dockerfile` ，内容：

```dockerfile
FROM python:3.6-alpine
ADD . /code
WORKDIR /code
RUN pip install redis flask
CMD ["python", "app.py"]
```

编写 `docker-compose.yml` ，内容：

```yml
version: '3'
services:

  web:
    build: .
    ports:
     - "5000:5000"

  redis:
    image: "redis:alpine"
```

运行：

```bash
docker-compose up
```

在同一目录下执行以下指令结束：

```bash
docker-compose down
```



### 指令

通用格式：

```bash
docker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]
```

`-f, --file FILE` 指定使用的 Compose 模板文件，默认为 `docker-compose.yml`，可以多次指定。

`-p, --project-name NAME` 指定项目名称，默认将使用所在目录名称作为项目名。

`--verbose` 输出更多调试信息。

`-v, --version` 打印版本并退出。



#### help

```bash
docker-compose help
docker-compose 指令 --help
```



#### build

格式为 `docker-compose build [options] [SERVICE...]`。

构建（重新构建）项目中的服务容器。

服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。

可以随时在项目目录下运行 `docker-compose build` 来重新构建服务。

选项包括：

- `--force-rm` 删除构建过程中的临时容器。
- `--no-cache` 构建镜像过程中不使用 cache（这将加长构建过程）。
- `--pull` 始终尝试通过 pull 来获取更新版本的镜像。



#### config

验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。



#### down

此命令将会停止 `up` 命令所启动的容器，并移除网络



#### exec

进入指定的容器



#### images

列出 Compose 文件中包含的镜像。

`up` 时才能看到，如果全部关闭是看不到的



#### kill

格式为 `docker-compose kill [options] [SERVICE...]`。

通过发送 `SIGKILL` 信号来强制停止服务容器。

支持通过 `-s` 参数来指定发送的信号，例如通过如下指令发送 `SIGINT` 信号。

```bash
docker-compose kill -s SIGINT
```



#### logs

格式为 `docker-compose logs [options] [SERVICE...]`。

查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 `--no-color` 来关闭颜色。

该命令在调试问题的时候十分有用。



#### pause

格式为 `docker-compose pause [SERVICE...]`。

暂停一个服务容器。



#### port

格式为 `docker-compose port [options] SERVICE PRIVATE_PORT`。

打印某个容器端口所映射的公共端口。

选项：

- `--protocol=proto` 指定端口协议，tcp（默认值）或者 udp。
- `--index=index` 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。



#### ps

格式为 `docker-compose ps [options] [SERVICE...]`。

列出项目中目前的所有容器。

选项：

- `-q` 只打印容器的 ID 信息。



#### pull

格式为 `docker-compose pull [options] [SERVICE...]`。

拉取服务依赖的镜像。

选项：

- `--ignore-pull-failures` 忽略拉取镜像过程中的错误。



#### push

推送服务依赖的镜像到 Docker 镜像仓库。



#### restart

格式为 `docker-compose restart [options] [SERVICE...]`。

重启项目中的服务。

选项：

- `-t, --timeout TIMEOUT` 指定重启前停止容器的超时（默认为 10 秒）。



#### rm

格式为 `docker-compose rm [options] [SERVICE...]`。

删除所有（停止状态的）服务容器。推荐先执行 `docker-compose stop` 命令来停止容器。

选项：

- `-f, --force` 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。
- `-v` 删除容器所挂载的数据卷。



#### run

格式为 `docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]`。

在指定服务上执行一个命令。例如：

```bash
docker-compose run ubuntu ping docker.com
```

将会启动一个 ubuntu 服务容器，并执行 `ping docker.com` 命令。

默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。

该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。

两个不同点：

- 给定命令将会覆盖原有的自动运行命令；
- 不会自动创建端口，以避免冲突。

如果不希望自动启动关联的容器，可以使用 `--no-deps` 选项，例如

```bash
docker-compose run --no-deps web python manage.py shell
```

将不会启动 web 容器所关联的其它容器。

选项：

- `-d` 后台运行容器。
- `--name NAME` 为容器指定一个名字。
- `--entrypoint CMD` 覆盖默认的容器启动指令。
- `-e KEY=VAL` 设置环境变量值，可多次使用选项来设置多个环境变量。
- `-u, --user=""` 指定运行容器的用户名或者 uid。
- `--no-deps` 不自动启动关联的服务容器。
- `--rm` 运行命令后自动删除容器，`d` 模式下将忽略。
- `-p, --publish=[]` 映射容器端口到本地主机。
- `--service-ports` 配置服务端口并映射到本地主机。
- `-T` 不分配伪 tty，意味着依赖 tty 的指令将无法运行。



#### scale

格式为 `docker-compose scale [options] [SERVICE=NUM...]`。

设置指定服务运行的容器个数。

通过 `service=num` 的参数来设置数量。例如：

```bash
docker-compose scale web=3 db=2
```

一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器

选项：

- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）



#### start

格式为 `docker-compose start [SERVICE...]`。

启动已经存在的服务容器。



#### stop

格式为 `docker-compose stop [options] [SERVICE...]`。

停止已经处于运行状态的容器，但不删除它。通过 `docker-compose start` 可以再次启动这些容器。

选项：

- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。



#### top

查看各个服务容器内运行的进程。



#### unpause

格式为 `docker-compose unpause [SERVICE...]`。

恢复处于暂停状态中的服务。



#### up

格式为 `docker-compose up [options] [SERVICE...]`。

该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。

链接的服务都将会被自动启动，除非已经处于运行状态。

可以说，大部分时候都可以直接通过该命令来启动一个项目。

默认情况，`docker-compose up` 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。

当通过 `Ctrl-C` 停止命令时，所有容器将会停止。

如果使用 `docker-compose up -d`，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。

默认情况，如果服务容器已经存在，`docker-compose up` 将会尝试停止容器，然后重新创建（保持使用 `volumes-from` 挂载的卷），以保证新启动的服务匹配 `docker-compose.yml` 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 `docker-compose up --no-recreate`。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 `docker-compose up --no-deps -d <SERVICE_NAME>` 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。

选项：

- `-d` 在后台运行服务容器。
- `--no-color` 不使用颜色来区分不同的服务的控制台输出。
- `--no-deps` 不启动服务所链接的容器。
- `--force-recreate` 强制重新创建容器，不能与 `--no-recreate` 同时使用。
- `--no-recreate` 如果容器已经存在了，则不重新创建，不能与 `--force-recreate` 同时使用。
- `--no-build` 不自动构建缺失的服务镜像。
- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。



### compose文件

默认的模板文件名称为 `docker-compose.yml`，格式为 YAML 格式。

注意每个服务都必须通过 `image` 指令指定镜像或 `build` 指令（需要 Dockerfile）等来自动构建生成镜像。

如果使用 `build` 指令，在 `Dockerfile` 中设置的选项(例如：`CMD`, `EXPOSE`, `VOLUME`, `ENV` 等) 将会自动被获取，无需在 `docker-compose.yml` 中重复设置。



#### build

指定 `Dockerfile` 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 `Compose` 将会利用它自动构建这个镜像，然后使用这个镜像。如：

```yml
version: '3'
services:

  webapp:
    build: ./dir
```

你也可以使用 `context` 指令指定 `Dockerfile` 所在文件夹的路径。

使用 `dockerfile` 指令指定 `Dockerfile` 文件名。

使用 `arg` 指令指定构建镜像时的变量。

```yml
version: '3'
services:

  webapp:
    build:
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1
```

使用 `cache_from` 指定构建镜像的缓存

```yml
build:
  context: .
  cache_from:
    - alpine:latest
    - corp/web_app:3.14
```



#### cap_add,cap_drop

指定容器的内核能力（capacity）分配。

例如，让容器拥有所有能力可以指定为：

```yml
cap_add:
  - ALL
```

去掉 NET_ADMIN 能力可以指定为：

```yml
cap_drop:
  - NET_ADMIN
```



#### command

覆盖容器启动后默认执行的命令。

```yml
command: echo "hello world"
```



#### container_name

指定容器名称。默认将会使用 `项目名称_服务名称_序号` 这样的格式。

```yml
container_name: docker-web-container
```

> 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。



#### dns

自定义 `DNS` 服务器。可以是一个值，也可以是一个列表。

```yml
dns: 8.8.8.8

dns:
  - 8.8.8.8
  - 114.114.114.114
```

配置 `DNS` 搜索域。可以是一个值，也可以是一个列表。

```yml
dns_search: example.com

dns_search:
  - domain1.example.com
  - domain2.example.com
```



#### env_file

从文件中获取环境变量，可以为单独的文件路径或列表。

如果通过 `docker-compose -f FILE` 方式来指定 Compose 模板文件，则 `env_file` 中变量的路径会基于模板文件路径。

如果有变量名称与 `environment` 指令冲突，则按照惯例，以后者为准。

```yml
env_file: .env

env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env
```

环境变量文件中每一行必须符合格式，支持 `#` 开头的注释行。

设置环境变量。你可以使用数组或字典两种格式。

只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。

```yml
environment:
  RACK_ENV: development
  SESSION_SECRET:

environment:
  - RACK_ENV=development
  - SESSION_SECRET
```

如果变量名称或者值中用到 `true|false，yes|no` 等表达 [布尔](https://yaml.org/type/bool.html) 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括

```yml
y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF
```



Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 `.env` 文件中的变量。

例如，下面的 Compose 文件将从运行它的环境中读取变量 `${MONGO_VERSION}` 的值，并写入执行的指令中。

```yml
version: "3"
services:

db:
  image: "mongo:${MONGO_VERSION}"
```





#### image

指定为镜像名称或镜像 ID。如果镜像在本地不存在，`Compose` 将会尝试拉取这个镜像。

```yml
image: ubuntu
image: orchardup/postgresql
image: a4bc65fd
```



> 网络看文档吧，我不知道有什么用



#### secrets

存储敏感数据，例如 `mysql` 服务密码。

```yml
version: "3.1"
services:

mysql:
  image: mysql
  environment:
    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password
  secrets:
    - db_root_password
    - my_other_secret

secrets:
  my_secret:
    file: ./my_secret.txt
  my_other_secret:
    external: true
```



#### volumes

数据卷所挂载路径设置。可以设置为宿主机路径(`HOST:CONTAINER`)或者数据卷名称(`VOLUME:CONTAINER`)，并且可以设置访问模式 （`HOST:CONTAINER:ro`）。

该指令中路径支持相对路径。

```yml
volumes:
 - /var/lib/mysql
 - cache/:/tmp/cache
 - ~/configs:/etc/configs/:ro
```

如果路径为数据卷名称，必须在文件中配置数据卷。

```yml
version: "3"

services:
  my_src:
    image: mysql:8.0
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:
```



## swarm

咕咕咕