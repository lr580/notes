> 阅读前的前置知识：`(C/C++),(PYTHON),(JAVA),HTML,CSS,JS`

# PHP

## 概述

Personal Home Page  / Hypertext Preprocessor

多平台，兼容多服务器、多数据库、协议

PHP代码不是由Web服务器来执行，而是由PHP应用程序服务器负责解析。因此，从本质上来说，PHP是一种HTML代码生成器



## 使用

### 安装

#### windows

照着课件来

Zend 安装遇到 `已安装此产品的另一版本` 提示时，直接找缓存目录 `C:\ProgramData\Package Cache` ，按时间找最近的一个，点开看到安装包继续安装 [参考资料](https://blog.csdn.net/chb_1_2/article/details/88932088)

改windows-preferences-php-code style-code templates-code-simple php file-edit 修改为模板：

```php+HTML
<!DOCTYPE html>
<html>

<head>
    <meta charset='UTF-8'>
    <title></title>
</head>

<body>
    <?php
    echo "Hello World!"
    ?>
</body>

</html>
```

修改zend默认服务器配置：windows-preferences-php-servers-进行更改即可

vsc 格式化插件：PHP Intelephense

配置 php.ini ，开启拓展：

```ini
extesion_dir = "目录/php7/ext"
extension=php_pdo_mysql.dll
extension=php_mysqli.dll
```

若 mysql 为 8.0 ，对要登录的账号设置，如：

```mysql
use mysql;
alter user root@localhost identified with mysql_native_password by '123456';
flush privileges;
```





## 基本语法

### 基本格式

代码文件是`.php`。上面允许出现HTML语法。

php脚本的长标志是`<?php ?>`，注释同C语言格式。

单行代码可以不用分号，多行一定要。缩进格式同C语言。

> 在php的配置文件（php.ini）中有一个short_open_tag的值，开启以后可以使用PHP的短标签：`<? ?>`
>
> PHP 5.4以后，总会被识别并且合法，而不管short_open_tag的设置是什么

开启短标签后，可以用`<?=`代替`<?echo`。

在标记之外的地方写什么都被认为是 HTML 语句。

用户定义的类和函数、内置的结构以及关键字，如echo、while、class等，是不区分大小的；而变量是区分大小写的。

可以用 C++ 风格注释，也可以用 Shell 风格注释 (即 `#` 单行注释)。对行文档性注释的开头结尾分别是 `/**` ， `*/` 。

如：

```php
<?php echo "123"?>
<?= "123" ?>  //这两行代码等效
```

> [php7新特性参见这里](https://www.runoob.com/php/php7-new-features.html)

### 变量

#### 命名规则

变量以`$`开头。命名规则与C类似。创建和使用与PYTHON类似(弱类型)。如：

```php
<?php
$lr=580;
echo $lr*2;
?>
```

不能是保留字：

![image-20220513155543154](img/image-20220513155543154.png)

可以用 `unset(变量名)` 销毁一个变量，如 `unset($x)` 



#### 作用域

##### local

即函数的局部变量

##### global

函数外定义的变量都有全局作用域。可以跨段使用，如：

```php
<?php$x=3;?>
<?=$x?>//$x写成x暴毙
```

函数内使用全局变量需要global关键字。如：

```php
<?php
$x=5; /*运行环境：SCNUOJ */
function f()
{
    global $x; //没有这一行，即使没有下一行也会报错(但是可以$x=1)
    ++$x;
    echo $x; //1
    echo " ";
}
f();
echo $x; //5
?>
```

事实上全局变量是存在字典`$GLOBALS`里的，即全局`$x`等效`于$GLOBALS['x']`。

```php
<?php
$x=5;
$y=10;
function myTest()
{
    $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];
} 
myTest();
echo $y;
?>
```

> 注：在SCNUOJ上跑不动这个代码，原因未知。



##### static

同C语言static。如：

```php
<?php
function myTest()
{
    static $x=0;
    echo $x;
    $x++;
    echo PHP_EOL; // 换行符，同HTML一样，输出等于一个空格
}
 
myTest();
myTest();
myTest();
?>
```



##### parameter

参数作用域。



#### 数据类型

有String,Integer,Float,Boolean,Array,Object,NULL

三大类：标量数据类型、复合数据类型和特殊数据类型。

`var_dump()`函数输出变量数据类型和值。如：

```php
<?php
$x=1;
var_dump($x);//int(1)
?>
```



##### 字符串

###### 定义

可以单双引号。区别：

1. 双引号可以自带变量占位
2. 双引号内`\`转义，单引号代表普通字符(所以`'\n'`是错误的)
3. 单引号内可以不转义地用双引号，反之相反
4. 单引号处理速度略快于双引号

举例：

```php
<?php
$a = '\n12\n34';
$b = "\\n12\\n34";
echo $a,'<br/>',$b, '<br/>';
echo "$a, $b",'<br/>','$a, $b';
?>
```

可以定义多行字符，以`<<<EOF`开始，以`EOF;`结束。然后中间任意文本，如：

```php
<?php
$name="lr580"; 
$a= <<<EOF
        abc$name
            "1 23
EOF;
// 结束需要独立一行且前后不能空格
//里面的引号就是输出可显示的引号，换行和tab没用，空格有用
echo $a;
?>
```



###### 运算

不支持`+`运算符。(能`+`运算的都是数值).但支持并置运算符进行字符串连接。

```php
<?php
$t1="nice";
echo $t1.' lad!';
?>
```

支持`strlen`函数。返回长度。

```php
<?php
echo strlen("lr580");
echo strlen("你好"); //中文字符3个长度
?>
```

支持`strpos`函数，返回子串出现位置。查无返回FALSE。

可以直接比较，用 `==`，和不等号。如：

```php
<?php
//加X防止转整数比较
echo "X123">"X1200";
echo "X123"=="X123";
echo "X1233"<"X12a";
```



> [更多运算函数](https://www.runoob.com/php/php-ref-string.html)



##### 整数

三种赋值方法，十进制，十六进制 `0x`，八进制前导 `0` ，二进制前导 `0b` 。进制可以前导负，如 `-0b` 。

支持四则运算，除法不是整除，零除报错，取模(浮点数会强转整数，右操作数是负数等同于正数)，位运算。

数据范围是C的signed long long。

PHP不支持无符号整型，其字长用常量PHP_INT_SIZE表示，自PHP 4.4.0和PHP 5.0.5后，最大值用常量 PHP_INT_MAX表示，最小值在PHP 7.0.0 及以后的版本中用常量PHP_INT_MIN表示。



##### 浮点数

同一般程序语言的赋值方法和运算方法。字长与平台有关。在PHP 4.0以前的版本中，浮点型数据的标识为double，也叫做双精度浮点数，在使用过程中，float与double，以及 real 没有区别。



##### 布尔值

TRUE或FALSE，不区分大小写。echo输出true为1，false啥也不输出

整数0、浮点数0.0 (都含负0)、空字符串和字符串“0” (不含`-0`)、没有成员的数组、特殊类型NULL等，都可以表示“假”

```php
<?php
$x=TRue;
echo $x;
?>
```

##### NULL

不区分大小写。以下都是NULL：被赋值为NULL；没有被赋值的变量；使用unset进行类型转换后的返回值。

```php
<?php
$x=null;
$y;
var_dump($x);
echo $x; //nothing
// echo $y; //$y不仅不可以输出，也不可以vardump，不然都会报错
$xx = 1;
$x4 = (unset)$xx;
echo $x4;
?>
```



##### resource

资源类型

资源是一种特殊的变量类型，它保存着对外部数据源的引用，如文件、数据库连接等，直到通信结束。
只有PHP脚本中，负责将资源绑定到变量的函数才能返回资源，无法将其他数据类型转换成资源类型。
资源变量里并不真正保存一个值，实际只保存了一个指针。在使用资源时，系统会自动启用垃圾回收机制，释放不再使用的资源，避免内存的无效消耗。

如：

```php
$v = fopen('index.php', 'r');
var_dump($v);
```



##### callable

需要回调的函数。如：

```php
function giz($name)
{
    echo "Hello $name<br/>";
}
function add(callable $f, $a, $b)
{
    echo $a . $b;
    $f($a);
    $f($b);
}
add('giz', 'baicha', 'hefeng');
```



##### 其他

PHP7支持以下：

nullable 可空

函数返回值的 void 类型

iterable 伪类型



#### 常量

##### 普通常量

使用`define()`定义常量，第一个参数字符串，名字；第二个参数值，第三个参数若true，大小写默认敏感。

只能是标量数据类型。常量必须先定义、然后再使用，并且与值只能绑定一次。

常量是全局的。如：

```php
<?php
function f()
{
    define("lr",580);
}
f();
echo lr;
?>
```

也可以用const。调用输出常量名或 `constant('常量名')`

使用const关键字定义常量，声明语句必须处于最上层的作用域内。也就是说，不能使用该方法在函数、循环以及if语句内定义常量。

如：

```php
<?php
const x=3;
echo x;
echo constant('x');//二者等效
?>
```

也可以用 `constant(字符串)` 来动态调用不同的常量。

```php
define('baicha', 'QwQ');
define('jinle', '>_<');
$a = ['baicha', 'jinle'];
echo constant($a[time() % 2]);
```



##### 预定义常量

PHP的系统预定义常量，包括内核预定义常量与标准预定义常量，它们可以在程序中直接使用。
需要注意的是，系统预定义常量往往由不同的扩展库定义，因此，只有加载了相应的扩展库，某些常量才可以使用。

![image-20220513164554884](img/image-20220513164554884.png)



##### 魔术常量

值随着它们在代码中的位置改变而改变。不区分大小写。

`__LINE__`是当前在脚本.php文件中的行数

`__FILE__`是当前文件绝对路径

`__DIR__`是当前文件所在目录的绝对路径(不含后缀`/`)，等价于`dirname(__FILE__)`

`__FUNCTION__`是当前函数的名字(不在函数内调用是输出空)。PHP5起得到的值区分大小写，PHP4中总是小写的。(PHP4.3.0新增)

`__CLASS__`返回类的名字。同PHP5起区分大小写。PHP5.4起对trait也起作用(调用 trait 方法的类的名字)。同理类外无输出。

`__METHOD__`方法名。对函数也可用。

`__NAMESPACE__`命名空间名称。PHP5.3.0。未定义(`namespace 空间名;`)时为空。

`__TRAIT__`



#### 运算

##### 逻辑

###### 比较相等

有`==`,`===`

> 细则：
>
> ![image-20211007194417871](img/image-20211007194417871.png)
>
> ![image-20211007194437384](img/image-20211007194437384.png)
>
> ![image-20211007194450604](img/image-20211007194450604.png)
>
> ![image-20211007194458827](img/image-20211007194458827.png)



###### 不等号

不等于是`<>`或`!=`，其他同C。绝对不等于是`!==`。



###### 逻辑运算

`and`,`or`,`xor`,`&&`,`||`,`!`



###### 三元运算

PHP5.3起，可以省略中间部分而写成`expr1?:expr2`

PHP7+版本有运算符`expr1??expe2`，当且仅当`expr1`为NULL返回`expr2`，否则返回`expr1`。



###### 组合比较

`$a<=>$b`，若`$a>$b`，返回$1$，若`$a<$b`，返回$-1$，否则返回$0$



##### 优先级

| 结合方向 | 运算符                                                   | 附加信息                 |
| :------- | :------------------------------------------------------- | :----------------------- |
| 无       | clone new                                                | clone 和 new             |
| 左       | [                                                        | array()                  |
| 右       | ++ -- ~ (int) (float) (string) (array) (object) (bool) @ | 类型和递增／递减         |
| 无       | instanceof                                               | 类型                     |
| 右       | !                                                        | 逻辑运算符               |
| 左       | * / %                                                    | 算术运算符               |
| 左       | + – .                                                    | 算术运算符和字符串运算符 |
| 左       | << >>                                                    | 位运算符                 |
| 无       | `== != === !== <>`                                       | 比较运算符               |
| 左       | &                                                        | 位运算符和引用           |
| 左       | ^                                                        | 位运算符                 |
| 左       | \|                                                       | 位运算符                 |
| 左       | &&                                                       | 逻辑运算符               |
| 左       | \|\|                                                     | 逻辑运算符               |
| 左       | ? :                                                      | 三元运算符               |
| 右       | = += -= *= /= .= %= &= \|= ^= <<= >>= =>                 | 赋值运算符               |
| 左       | and                                                      | 逻辑运算符               |
| 左       | xor                                                      | 逻辑运算符               |
| 左       | or                                                       | 逻辑运算符               |
| 左       | ,                                                        | 多处用到                 |

注意：or,and和||&&优先级不一样，虽然效果相同。如：

```php
<?php
// 优先级： &&  >  =  >  and
// 优先级： ||  >  =  >  or
 
$a = 3;
$b = false;
$c = $a or $b;
var_dump($c);          // 这里的 $c 为 int 值3，而不是 boolean 值 true
$d = $a || $b;
var_dump($d);          //这里的 $d 就是 boolean 值 true 
?>
```



#### 数组

有数值数组，关联数组(类似PYTHON字典)和多维数组。

> [完整参考手册](https://www.runoob.com/php/php-ref-array.html)

##### 创建

构造数值函数`array(值, ...)`，自动分配，下标从0递增。也可以用 `[]` 语法。

也可以手动分配，如PYTHON。即`$数组变量[下标]=值`。如果不填，默认为max下标+1。

构造关联数组：`array(键=>值, ...)`，`$数组变量[键]=值` 。注意键 `1` 与 `'1'` 等效，以此类推。键可以是字符串。键可以是标量，不能是数组等。

数值和关联可以混用。

如：

```php
<?php
$x=array(1,3,5);
echo $x[0]+($x[1]*$x[2]);
$x[6]=7;
echo $x[6]+count($x);//11
?>
```

```php
<?php
$x=array('lr'=>580,'bc'=>998);
$x['awa']=13;
echo count($x),' ',$x['awa']+$x['bc'];
?>
```

```php
<?php
$cars = array
(
    array("Volvo",100,96),
    array("BMW",60,59),
    array("Toyota",110,100)
);
?>
```



##### 遍历

用`foreach($数组 as $键变量=>$值变量)`或`foreach($数组 as $值变量)`，如：

```php
<?php
$x=array(1,-1);
foreach($x as $key=>$v)
{
    echo $key,' ', $v, '<br/>';
}
$y=array('lr'=>580,'bc'=>998);
foreach($y as $key=>$v)
{
    echo $key,' ', $v, '<br/>';
}
?>
```

直接输出整个数组用`var_dump`或`print_r`，不用`echo`。



##### 运算

`+`运算符取交集，如果都有某个下标，取左操作数的，如：

```php
<?php
$x=array(1,2);
$y=array(3,2=>4);
var_dump($x);
echo '<br/>';
print_r($y);
echo '<br/>';
print_r($x+$y);//1,2,4
?>
```

`==`当且仅当有相同的键值对。

`===`在上述前提下还要求顺序相同。

类推定义`!=,<>,!==`。如：

```php
<?php
$x=array(1,2);
$y=array(1=>2,0=>1);
echo $x==$y?'yes':'no','<br/>',$x===$y?'yes':'no';
?>
```





##### 函数

`is_array($数组)`判定是否是数组

`count($数组)`长度取元素数量。

`sort($数组)`升序排序，`rsort`降序。

​	`asort`根据关联数组值升序，`ksort`根据关联数组键。

​	同理有：`arsort,krsort`。

`end`将内部指针指向数组中的最后一个元素，并输出

> - [current()](https://www.runoob.com/php/func-array-current.html) - 返回数组中的当前元素的值。
> - [next()](https://www.runoob.com/php/func-array-next.html) - 将内部指针指向数组中的下一个元素，并输出。
> - [prev()](https://www.runoob.com/php/func-array-prev.html) - 将内部指针指向数组中的上一个元素，并输出。
> - [reset()](https://www.runoob.com/php/func-array-reset.html) - 将内部指针指向数组中的第一个元素，并输出。
> - [each()](https://www.runoob.com/php/func-array-each.html) - 返回当前元素的键名和键值，并将内部指针向前移动。

`in_array(一些值,$数组)`，可以有第三个参数表示是否区分大小写

如：

```php
<?php
$arr=array('a','B','A'); //ASCII顺序
sort($arr);
print_r($arr);
?>
```



#### 超级全局变量

- $GLOBALS

- $_SERVER

  包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。如有属性`PHP_SELF,SERVER_NAME,HTTP_HOST,HTTP_REFERER,HTTP_USER_AGENT,SCRIPT_NAME`

- $_REQUEST

  收集HTML表单提交的数据。

- $_POST

  收集HTML表单提交的数据。

- $_GET

  收集HTML表单提交的数据。

- $_FILES

- $_ENV

- $_COOKIE

- $_SESSION



> [表单相关参见](https://www.runoob.com/php/php-forms.html)



##### _SERVER

详细：

| 元素/代码                       | 描述                                                         |
| :------------------------------ | :----------------------------------------------------------- |
| $_SERVER['PHP_SELF']            | 当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $_SERVER['PHP_SELF'] 将得到 /test.php/foo.bar。__FILE__ 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 |
| $_SERVER['GATEWAY_INTERFACE']   | 服务器使用的 CGI 规范的版本；例如，"CGI/1.1"。               |
| $_SERVER['SERVER_ADDR']         | 当前运行脚本所在的服务器的 IP 地址。                         |
| $_SERVER['SERVER_NAME']         | 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: www.runoob.com) |
| $_SERVER['SERVER_SOFTWARE']     | 服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache/2.2.24) |
| $_SERVER['SERVER_PROTOCOL']     | 请求页面时通信协议的名称和版本。例如，"HTTP/1.0"。           |
| $_SERVER['REQUEST_METHOD']      | 访问页面使用的请求方法；例如，"GET", "HEAD"，"POST"，"PUT"。 |
| $_SERVER['REQUEST_TIME']        | 请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496)   |
| $_SERVER['QUERY_STRING']        | query string（查询字符串），如果有的话，通过它进行页面访问。 |
| $_SERVER['HTTP_ACCEPT']         | 当前请求头中 Accept: 项的内容，如果存在的话。                |
| $_SERVER['HTTP_ACCEPT_CHARSET'] | 当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如："iso-8859-1,*,utf-8"。 |
| $_SERVER['HTTP_HOST']           | 当前请求头中 Host: 项的内容，如果存在的话。                  |
| $_SERVER['HTTP_REFERER']        | 引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。) |
| $_SERVER['HTTPS']               | 如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。      |
| $_SERVER['REMOTE_ADDR']         | 浏览当前页面的用户的 IP 地址。                               |
| $_SERVER['REMOTE_HOST']         | 浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。 |
| $_SERVER['REMOTE_PORT']         | 用户机器上连接到 Web 服务器所使用的端口号。                  |
| $_SERVER['SCRIPT_FILENAME']     | 当前执行脚本的绝对路径。                                     |
| $_SERVER['SERVER_ADMIN']        | 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：someone@runoob.com) |
| $_SERVER['SERVER_PORT']         | Web 服务器使用的端口。默认值为 "80"。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。 |
| $_SERVER['SERVER_SIGNATURE']    | 包含了服务器版本和虚拟主机名的字符串。                       |
| $_SERVER['PATH_TRANSLATED']     | 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 |
| $_SERVER['SCRIPT_NAME']         | 包含当前脚本的路径。这在页面需要指向自己时非常有用。__FILE__ 常量包含当前脚本(例如包含文件)的完整路径和文件名。 |
| $_SERVER['SCRIPT_URI']          | URI 用来指定要访问的页面。例如 "/index.html"。               |



##### \_REQUEST

预定义的 \$_REQUEST 变量包含了 ​\$\_GET、\$\_POST 和 \$\_COOKIE 的内容。

\$\_REQUEST 变量可用来收集通过 GET 和 POST 方法发送的表单数据。

举例：

```php
<!DOCTYPE html>
<html>
<body>

<form method="post" action="<?php echo $_SERVER['PHP_SELF'];?>">
Name: <input type="text" name="fname">
<input type="submit">
</form>

<?php 
$name = htmlspecialchars($_REQUEST['fname']); 
echo $name; 
?>

</body>
</html>
```



##### _POST

举例：

```php+HTML
<!DOCTYPE html>
<html>
<body>

<form method="post" action="<?php echo $_SERVER['PHP_SELF'];?>">
Name: <input type="text" name="fname">
<input type="submit">
</form>

<?php 
$name = htmlspecialchars($_POST['fname']); 
echo $name; 
?>

</body>
</html>
```



##### _GET

举例：

```html
<html>
<body>
<a href="test_get.php?subject=PHP&web=runoob.com">Test $GET</a>
</body>
</html>
```

```php+HTML
<!DOCTYPE html>
<html>
<body>

<a href="test_get.php?subject=PHP&web=runoob.com">测试 $_GET</a>

</body>
</html>
```



##### _COOKIE

是关联数组。通常用`isset`函数查找某个键值是否存在。

操作函数：`setcookie(键,值,过期时间)`

删除即更改过期时间为当前之前的时间即可，如：

```php
<?php
// 设置 cookie 过期时间为过去 1 小时
setcookie("user", "", time()-3600);
?>
```



##### _SESSION

PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。

> （未核实）该信息是临时的，在用户离开网站后将被删除。

删除某些 session 数据，可以使用 unset() 或 session_destroy() 函数。后者彻底删除全部session数据。



#### 对象

##### 概述

定义用`class`关键字(语法类似java)。成员属性用`var`关键字，可以声明初始值。

新建变量用`new 类名`，如果没有构造函数可以不写括号。访问变量的成员都用`->`操作符。

`$this`表示self指针，用`$this->`运算符访问成员属性。

构造函数是`__construct`，析构函数是`__destruct`。子类构造方法不能自动调用父类的构造方法。

继承用`extends`，不支持多继承。`parent`关键字加`::`访问父类。

访问控制关键字同C：

> - **public（公有）：**公有的类成员可以在任何地方被访问。
> - **protected（受保护）：**受保护的类成员则可以被其自身以及其子类和父类访问。
> - **private（私有）：**私有的类成员则只能被其定义所在的类访问。

(有关键字时可以不声明`var`，`var`认为是共有)。成员函数不设置控制关键字默认为公有。子类不能重定义私有成员，其他可以。

接口的语法同JAVA。显然类中必须实现接口中定义的所有方法。

常成员(常量)用`const`定义，调用为`类名::常量名`或`$实例名::常量名`，或字符串值为类名的：`$字符串::常量名`。常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。

抽象类语法同JAVA。

> 继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。
>
> 此外，子类方法可以包含父类抽象方法中不存在的可选参数。
>
> 例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则也是可以正常运行的。

静态成员语法同java。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。调用为`类名::静态成员`

> 自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static。

final语法同JAVA。类为final不可继承。

如：

```php
<?php
/**
 * Define MyClass
 */
class MyClass
{
    public $public = 'Public';
    protected $protected = 'Protected';
    private $private = 'Private';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj = new MyClass();
echo $obj->public; // 这行能被正常执行
echo $obj->protected; // 这行会产生一个致命错误
echo $obj->private; // 这行也会产生一个致命错误
$obj->printHello(); // 输出 Public、Protected 和 Private


/**
 * Define MyClass2
 */
class MyClass2 extends MyClass
{
    // 可以对 public 和 protected 进行重定义，但 private 而不能
    protected $protected = 'Protected2';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj2 = new MyClass2();
echo $obj2->public; // 这行能被正常执行
echo $obj2->private; // 未定义 private
echo $obj2->protected; // 这行会产生一个致命错误
$obj2->printHello(); // 输出 Public、Protected2 和 Undefined

?>
```

```php
<?php
abstract class AbstractClass
{
    // 我们的抽象方法仅需要定义需要的参数
    abstract protected function prefixName($name);

}

class ConcreteClass extends AbstractClass
{

    // 我们的子类可以定义父类签名中不存在的可选参数
    public function prefixName($name, $separator = ".") {
        if ($name == "Pacman") {
            $prefix = "Mr";
        } elseif ($name == "Pacwoman") {
            $prefix = "Mrs";
        } else {
            $prefix = "";
        }
        return "{$prefix}{$separator} {$name}";
    }
}

$class = new ConcreteClass;
echo $class->prefixName("Pacman"), "\n";
echo $class->prefixName("Pacwoman"), "\n";
?>
```



##### trait

一种代码复用的方法。

声明：`trait 名字{}`，调用：`use 名字;`

如：

```php
<?php
class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}
 
trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}
 
class MyHelloWorld extends Base {
    use SayWorld;
}
 
$o = new MyHelloWorld();
$o->sayHello();
?>
```



#### 可变变量

`$普通变量` ，如 `$$x` 。那么这个变量的变量名是可以变化的。（初始赋值是变，再改就不动了）

```php
$name = "lr580";
$$name = 580;
echo $lr580;
$name = "baicha";
echo $baicha; //NULL
echo $lr580; //可以
$baicha = 233; //重新赋值
echo $$name; //233
echo $baicha; //233
echo $lr580; //580
```

换言之就是跟一个数组一样的用法，即 `$key` 。然后 `$$` 就是当前指向的 key 。



#### 传引用

跟 C++ 一样，赋值时只要 `$x = &$y` 那么 `$x` 就是传引用

通过引用赋值定义的变量与原变量并不是表示同一个内存单元，而仅仅是其值相互关联而已。所以，若对原变量使用销毁(unset)操作，则不会导致引用变量的消失。销毁操作后，仅仅是取消了2个变量值的关联，如：

```php
$x = 580;
$y = &$x;
unset($x);
var_dump($y);
```



#### 运算符

除法默认是浮点除。

![image-20220513173643295](img/image-20220513173643295.png)

如：

```php
echo 1 <=> 2, 2 <=> 2, 3 <=> 2, null ?? 1 ?? 2, 3 ?? null;
```

逻辑运算可以用 `&&,||,!` 以及 `and,or,xor,not` ，返回布尔值。

位运算跟 C 一样。

其他：

`instanceof` 判断一个对象是否是某个类的对象。类型运算符。

\` 运算符会把反引号内内容作为操作系统系统命令执行并返回结果。执行运算符。

@ 错误抑制运算符，报错不输出。

类型转换：显式转换有 `setType(), intval(), floatval(), strval()` 和强转。

如：

```php
class people
{
};
$x = new people();
echo $x instanceof object; //false
echo "|";
echo $x instanceof people;
```

```php
@(1 / 0);
1 / 0;
```

```php
$x1 = 1 / 3;
settype($x1, 'string');
var_dump($x1);
$x2 = '580LR2';
settype($x2, 'int');
var_dump($x2); //580
$x3 = 10;
settype($x3, 'object');
var_dump($x3); //有一个属性 scalar
$x4 = 'QwQ';
settype($x4, 'array');
var_dump($x4); //首元素是它
```

```php
echo intval(5 / 3); //1
$x1 = 3;
var_dump((object)$x1);
var_dump((array)$x1); //同settype
```



### 流程控制

#### 条件判断

##### if

使用`if(),elseif(),else()`，大括号括起来语句(或不括起来单行)，语法大同C。`elseif`写成`else if`也行。

##### switch

语法同C。case可以是字符串或浮点数。如：

```php
<?php
$x=3.1;
switch($x)
{
    case 3.1:
        echo 'awa';
}
?>
```



#### 循环

`for`,`while`和`do...while`格式同C。

有`foreach($数组 as $下标变量 => $值变量)`。



#### 函数

以字母或下划线开头（不能以数字开头）。

创建语法：

```php
function 函数名(参数)
{
    
}
```

可以有默认参数。如：

```php
<?php
function f($x=1)
{
    echo $x;
}
f();
f(2);
?>
```

可以传引用，如`function foo(&$bar){...`

用函数作参数(callable)见变量-数据类型-callable



#### 命名空间

##### 定义

未定义命名空间时，所有常量、类和函数放在全局空间。

文件包含命名空间时，必须在所有其他代码之前声明：`namespace 空间名;`或`namespace 名{代码块}`。第二种解法常用于一个代码文件有多个空间时。

全局代码用无名的`namespace{}`。声明了之后整个文件部分都必须在任何一个命名空间或全局代码大括号内，不能在别的地方。

调用命名空间：`空间名\空间内的内容名`

如：

```php
<?php
namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace { // 全局代码
session_start();
$a = MyProject\connect();
echo MyProject\Connection::start();
}
?>
```

有命名空间后，声明空间前唯一合法的代码是`declare`，如：

```php
<?php
declare(encoding='UTF-8'); //定义多个命名空间和不包含在命名空间中的代码
namespace {...
?>
```

可以定义子空间，如`namespace MyProject\Sub\Level`。

全局变量可以使用完全限定名称调用，如全局函数`f`可写作调用`\f()`，常量、类等同理。



##### 引用

`use 命名空间`

`use 命名空间 as 别名`

可以用关键字`namespace`显式访问当前命名空间及其子空间的元素，等价类的`self`操作符。

如：

```php
<?php
namespace MyProject;

use blah\blah as mine; // 引入了 blah\blah 命名空间，并定义了个别名mine

mine\mine(); // 调用函数 blah\blah\mine()
namespace\blah\mine(); // 调用函数 MyProject\blah\mine()

namespace\func(); // 调用函数 MyProject\func()
namespace\sub\func(); // 调用函数 MyProject\sub\func()
namespace\cname::method(); // 调用 MyProject\cname 类的静态方法
$a = new namespace\sub\cname(); // 实例化 MyProject\sub\cname 类的对象
$b = namespace\CONSTANT; // 将常量 MyProject\CONSTANT 的值赋给 $b
?>
```

```php
<?php
namespace\func(); // calls function func()
namespace\sub\func(); // calls function sub\func()
namespace\cname::method(); // calls static method "method" of class cname
$a = new namespace\sub\cname(); // instantiates object of class sub\cname
$b = namespace\CONSTANT; // assigns value of constant CONSTANT to $b
?>
```

```php
<?php
namespace foo;
use My\Full\Classname as Another;

// 下面的例子与 use My\Full\NSname as NSname 相同
use My\Full\NSname;

// 导入一个全局类
use \ArrayObject;

$obj = new namespace\Another; // 实例化 foo\Another 对象
$obj = new Another; // 实例化 My\Full\Classname　对象
NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func
$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象
// 如果不使用 "use \ArrayObject" ，则实例化一个 foo\ArrayObject 对象
?>
```

```php
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // 实例化 My\Full\Classname 对象
NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func
?>
```

甚至可以用字符串动态生成命名空间对象：

```php
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // 实例化一个 My\Full\Classname 对象
$a = 'Another';
$obj = new $a;      // 实际化一个 Another 对象
?>
```

> 名称解析遵循下列规则：
>
> 1. 对完全限定名称的函数，类和常量的调用在编译时解析。例如 *new \A\B* 解析为类 *A\B*。
>
> 2. 所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 *A\B\C* 被导入为 *C*，那么对 *C\D\e()* 的调用就会被转换为 *A\B\C\D\e()*。
>
> 3. 在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 *A\B* 内部调用 *C\D\e()*，则 *C\D\e()* 会被转换为 *A\B\C\D\e()* 。
>
> 4. 非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 *A\B\C* 导入为C，则 *new C()* 被转换为 *new A\B\C()* 。
>
> 5. 在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数
>
>     
>
>    foo()
>
>     
>
>    的调用是这样解析的：
>
>    1. 在当前命名空间中查找名为 *A\B\foo()* 的函数
>    2. 尝试查找并调用 *全局(global)* 空间中的函数 *foo()*。
>
> 6. 在命名空间（例如
>
>    A\B
>
>    ）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用
>
>     
>
>    new C()
>
>     
>
>    及
>
>     
>
>    new D\E()
>
>     
>
>    的解析过程：
>
>     
>
>    new C()
>
>    的解析:
>
>    1. 在当前命名空间中查找*A\B\C*类。
>    2. 尝试自动装载类*A\B\C*。
>
>    new D\E()
>
>    的解析:
>
>    1. 在类名称前面加上当前命名空间名称变成：*A\B\D\E*，然后查找该类。
>    2. 尝试自动装载类 *A\B\D\E*。
>
>    为了引用全局命名空间中的全局类，必须使用完全限定名称
>
>     
>
>    new \C()



#### 包含文件

使用`include`或`require`操作符加上字符串文件名，表示在此处插入别的文件的代码。

> 这两个操作符的区别在于
>
> ①错误处理方式：
>
> - require 生成`E_COMPILE_ERROR`，错误发生后脚本停止执行
> - include 生成`E_WARNING`，错误发生后脚本继续执行
>
> ②位置：
>
> - require 一般放在文件最前面，程序执行前先导入要引用的文件
> - include 一般放在程序的流程控制中，程序执行时碰到才会引用
>
> [更多区别](https://www.runoob.com/w3cnote/php-different-include-and-require.html)

如：

```php
<?php
$color='red'; //vars.php
$car='BMW';
?>
```

```php+HTML
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>
<h1>欢迎来到我的主页!</h1>
<?php 
include 'vars.php';
echo "I have a $color $car"; // I have a red BMW
?>
</body>
</html>
```



#### 错误处理

##### 错误处理函数

`set_error_handler(处理函数名字符串)`，设置自定义错误处理程序，当触发了报错时执行。可选参数是规定显示何种错误报告级别的用户定义错误。默认是 `"E_ALL"`。

错误处理函数格式：

```php
error_function(error_level,error_message,
error_file,error_line,error_context)
```

| 参数          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| error_level   | 必需。为用户定义的错误规定错误报告级别。必须是一个数字。参见下面的表格：错误报告级别。 |
| error_message | 必需。为用户定义的错误规定错误消息。                         |
| error_file    | 可选。规定错误发生的文件名。                                 |
| error_line    | 可选。规定错误发生的行号。                                   |
| error_context | 可选。规定一个数组，包含了当错误发生时在用的每个变量以及它们的值。 |

`trigger_error($msg,[$level])`函数触发一个报错，调用设置的错误处理函数，传入对应参数。触发能执行的前提是设置了自定义错误处理函数。

如：

```php
<?php
 // 用户定义的错误处理函数
 function myErrorHandler($errno, $errstr, $errfile, $errline) {
     echo "<b>Custom error:</b> [$errno] $errstr<br>";
     echo " Error on line $errline in $errfile<br>";
 }

 // 设置用户定义的错误处理函数
 set_error_handler("myErrorHandler");

 $test=2;

 // 触发错误
 if ($test>1) {
     trigger_error("A custom error has been triggered");
 }
 ?> 
```

```php
<?php
// 错误处理函数
function customError($errno, $errstr)
{
    echo "<b>Error:</b> [$errno] $errstr<br>";
    echo "已通知网站管理员";
    error_log("Error: [$errno] $errstr",1,
    "someone@example.com","From: webmaster@example.com");
}

// 设置错误处理函数
set_error_handler("customError",E_USER_WARNING);

// 触发错误
$test=2;
if ($test>1)
{
    trigger_error("变量值必须小于等于 1",E_USER_WARNING);
}
?>
```

```php
<?php
function myException($exception)
{
    echo "<b>Exception:</b> " , $exception->getMessage();
}
 
set_exception_handler('myException');
 
throw new Exception('Uncaught Exception occurred');
?>
```



> [详见](https://www.w3school.com.cn/php/php_ref_error.asp)



##### 异常

> 异常处理用于在指定的错误（异常）情况发生时改变脚本的正常流程。这种情况称为异常。
>
> 当异常被触发时，通常会发生：
>
> - 当前代码状态被保存
> - 代码执行被切换到预定义（自定义）的异常处理器函数
> - 根据情况，处理器也许会从保存的代码状态重新开始执行代码，终止脚本执行，或从代码中另外的位置继续执行脚本

当异常被抛出时，其后的代码不会继续执行，PHP 会尝试查找匹配的 "catch" 代码块。

如果异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么将发生一个严重的错误（致命错误），并且输出 "Uncaught Exception" （未捕获异常）的错误消息/直接服务器内部错误(SCNUOJ环境)。

如：

```php
<?php
throw new Exception("Value must be 1 or below");
?>
```

格式：

```php
try
{
    ...
}
catch(错误类 $变量) //若干个catch
{
    
}
```

`set_exception_handler()` 函数可设置处理所有未捕获异常的用户定义函数。函数参数是一个错误处理函数名，该函数需要处理一个参数，该参数为异常实例。

异常具有的方法有：`getLine`,`getFile`,`getMessage`。

抛出异常的语句为`throw new 异常类(构造函数参数)`

如：

```php
<?php
// 创建一个有异常处理的函数
function checkNum($number)
{
    if($number>1)
    {
        throw new Exception("变量值必须小于等于 1");
    }
        return true;
}
    
// 在 try 块 触发异常
try
{
    checkNum(2);
    // 如果抛出异常，以下文本不会输出
    echo '如果输出该内容，说明 $number 变量';
}
// 捕获异常
catch(Exception $e)
{
    echo 'Message: ' .$e->getMessage();
}
?>
```

可以定义自定义异常类如：

```php
<?php
class customException extends Exception
{
    public function errorMessage()
    {
        // 错误信息
        $errorMsg = '错误行号 '.$this->getLine().' in '.$this->getFile()
        .': <b>'.$this->getMessage().'</b> 不是一个合法的 E-Mail 地址';
        return $errorMsg;
    }
}
?>
```





### 内建函数

##### 变量操作

###### isset

检测变量是否设置，并且不是 `null`

如果一次传入多个参数，那么 isset() 只有在全部参数都以被设置时返回 `true` 计算过程从左至右，中途遇到没有设置的变量时就会立即停止。

###### unset

销毁若干个变量(可变参数)。

如果是全局变量，在函数中销毁，只在函数生效。但对`$_GLOBALS`则全局生效。

如果是引用参数变量，只在函数内销毁。

如果是函数静态变量，只在此次生效，下次调用还在。

如：

```php
<?php
$x=1;
unset($x);
echo empty($x);
?>
```



###### filter_var

检测变量是否符合过滤器要求。如果成功，则返回已过滤的数据，如果失败，则返回 false。

第一个参数是待检验变量，第二个是过滤器ID。

如：

```php
<?php
if(!filter_var("someone@example....com", FILTER_VALIDATE_EMAIL))
 {
 echo("E-mail is not valid");
 }
else
 {
 echo("E-mail is valid");
 }
?>
```

```php
<?php
$int = 123;
 
if(!filter_var($int, FILTER_VALIDATE_INT))
{
    echo("不是一个合法的整数");
}
else
{
    echo("是个合法的整数");
}
?>
```

```php
<?php
$var=300;
 
$int_options = array(
    "options"=>array
    (
        "min_range"=>0,
        "max_range"=>256
    )
);
 
if(!filter_var($var, FILTER_VALIDATE_INT, $int_options))
{
    echo("不是一个合法的整数");
}
else
{
    echo("是个合法的整数");
}
?>
```

```php
<?php
$filters = array
(
    "name" => array
    (
        "filter"=>FILTER_SANITIZE_STRING
    ),
    "age" => array
    (
        "filter"=>FILTER_VALIDATE_INT,
        "options"=>array
        (
            "min_range"=>1,
            "max_range"=>120
        )
    ),
    "email"=> FILTER_VALIDATE_EMAIL
);
 
$result = filter_input_array(INPUT_GET, $filters);
 
if (!$result["age"])
{
    echo("年龄必须在 1 到 120 之间。<br>");
}
elseif(!$result["email"])
{
    echo("E-Mail 不合法<br>");
}
else
{
    echo("输入正确");
}
?>
```



过滤器分类：

Validating 过滤器：

- 用于验证用户输入
- 严格的格式规则（比如 URL 或 E-Mail 验证）
- 如果成功则返回预期的类型，如果失败则返回 FALSE

Sanitizing 过滤器：

- 用于允许或禁止字符串中指定的字符
- 无数据格式规则
- 始终返回字符串



通过使用 FILTER_CALLBACK 过滤器，可以调用自定义的函数，把它作为一个过滤器来使用。

```php
<?php
function convertSpace($string)
{
    return str_replace("_", ".", $string);
}
 
$string = "www_runoob_com!";
 
echo filter_var($string, FILTER_CALLBACK,
array("options"=>"convertSpace"));
?>
```



> [过滤器参见这里](https://www.w3school.com.cn/php/php_ref_filter.asp)
>
> - filter_var() - 通过一个指定的过滤器来过滤单一的变量
> - filter_var_array() - 通过相同的或不同的过滤器来过滤多个变量
> - filter_input - 获取一个输入变量，并对它进行过滤
> - filter_input_array - 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤
>
> [过滤器使用](https://www.runoob.com/php/php-filter.html)
>
> [更多举例](https://www.runoob.com/php/php-filter-advanced.html)



##### 字符处理

###### htmlspecialchars

将HTML标签失效。例如字符串里有`<b></b>`，将会直接输出，而不是渲染加粗。

失效字符包括：`&,",',<,>`，转化为`&amp,&qpot,&#039,&lt,&gt`



###### trim

去除手尾空白字符。



###### stripslashes

去除所有`\`，如：

```php
<?php
echo stripslashes('1\2\n3'); //12n3
// echo stripslashes("1\2\n3"); //nope
?>
```



###### empty

是否为空。变量为$0$、空字符、不存在或NULL时为真。如：

```php
<?php
echo empty($t);
echo empty('');
echo empty(NULL); //都是true
echo empty(0);
echo empty(1);
echo empty(0.0);
?>
```



###### preg_match

正则表达式匹配。参数为`$pattern,$subject,[$matches(array),[$flags]]`。`$matches[0]`包含于整个模式匹配的文本，`$matches[1]`包含第一个括号的子模式匹配文本。相当于返回的数组。

正则表达式文本格式同json。

如：

```php
if (!preg_match("/^[a-zA-Z ]*$/",$name)) {
  $nameErr = "只允许字母和空格"; 
}
```

常用正则：

- 邮箱 `/([\w\-]+\@[\w\-]+\.[\w\-]+)/`

  `/^\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/`
- URL `/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&@#\/%?=~_|!:,.;]*[-a-z0-9+&@#\/%=~_|]/`



###### explode

字符串分割，第一个参数是分割符，第二个参数是字符串变量。可选第三个参数表示结果数组元素限制最大数。



###### strpos

即find，第一个参数是被查找串，第二个参数是要查找的子串。大小写敏感。失败返回false。

大小写不敏感用`stripos`，倒找用`strrpos,strripos`。



##### 日期时间

###### date

> [时间日期参考手册](https://www.runoob.com/php/func-date-date.html)

第一个参数是字符串输出格式，`Y,m,d`代表年(四位)月($[01,12]$)日($01,31$)，其他字符代表本身的含义。返回字符串。第二个参数是整数时间戳，可缺省。如：

```php
<?php
echo date('Y/m/d H:i:s');
?>
```



> 具体格式有：
>
> | `format` 字符        | 说明                                                         | 返回值例子                                                   |
> | :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
> | *日*                 | ---                                                          | ---                                                          |
> | *d*                  | 月份中的第几天，有前导零的 2 位数字                          | *01* 到 *31*                                                 |
> | *D*                  | 星期中的第几天，文本表示，3 个字母                           | *Mon* 到 *Sun*                                               |
> | *j*                  | 月份中的第几天，没有前导零                                   | *1* 到 *31*                                                  |
> | *l*（"L"的小写字母） | 星期几，完整的文本格式                                       | *Sunday* 到 *Saturday*                                       |
> | *N*                  | ISO-8601 格式数字表示的星期中的第几天（PHP 5.1.0 新加）      | *1*（表示星期一）到 *7*（表示星期天）                        |
> | *S*                  | 每月天数后面的英文后缀，2 个字符                             | *st*，*nd*，*rd* 或者 *th*。可以和 *j* 一起用                |
> | *w*                  | 星期中的第几天，数字表示                                     | *0*（表示星期天）到 *6*（表示星期六）                        |
> | *z*                  | 年份中的第几天                                               | *0* 到 *365*                                                 |
> | *星期*               | ---                                                          | ---                                                          |
> | *W*                  | ISO-8601 格式年份中的第几周，每周从星期一开始（PHP 4.1.0 新加的） | 例如：*42*（当年的第 42 周）                                 |
> | *月*                 | ---                                                          | ---                                                          |
> | *F*                  | 月份，完整的文本格式，例如 January 或者 March                | *January* 到 *December*                                      |
> | *m*                  | 数字表示的月份，有前导零                                     | *01* 到 *12*                                                 |
> | *M*                  | 三个字母缩写表示的月份                                       | *Jan* 到 *Dec*                                               |
> | *n*                  | 数字表示的月份，没有前导零                                   | *1* 到 *12*                                                  |
> | *t*                  | 给定月份所应有的天数                                         | *28* 到 *31*                                                 |
> | *年*                 | ---                                                          | ---                                                          |
> | *L*                  | 是否为闰年                                                   | 如果是闰年为 *1*，否则为 *0*                                 |
> | *o*                  | ISO-8601 格式年份数字。这和 *Y* 的值相同，只除了如果 ISO 的星期数（*W*）属于前一年或下一年，则用那一年。（PHP 5.1.0 新加） | Examples: *1999* or *2003*                                   |
> | *Y*                  | 4 位数字完整表示的年份                                       | 例如：*1999* 或 *2003*                                       |
> | *y*                  | 2 位数字表示的年份                                           | 例如：*99* 或 *03*                                           |
> | *时间*               | ---                                                          | ---                                                          |
> | *a*                  | 小写的上午和下午值                                           | *am* 或 *pm*                                                 |
> | *A*                  | 大写的上午和下午值                                           | *AM* 或 *PM*                                                 |
> | *B*                  | Swatch Internet 标准时                                       | *000* 到 *999*                                               |
> | *g*                  | 小时，12 小时格式，没有前导零                                | *1* 到 *12*                                                  |
> | *G*                  | 小时，24 小时格式，没有前导零                                | *0* 到 *23*                                                  |
> | *h*                  | 小时，12 小时格式，有前导零                                  | *01* 到 *12*                                                 |
> | *H*                  | 小时，24 小时格式，有前导零                                  | *00* 到 *23*                                                 |
> | *i*                  | 有前导零的分钟数                                             | *00* 到 *59*>                                                |
> | *s*                  | 秒数，有前导零                                               | *00* 到 *59*>                                                |
> | *u*                  | 毫秒 （PHP 5.2.2 新加）。需要注意的是 **date()** 函数总是返回 *000000* 因为它只接受 integer 参数， 而 DateTime::format() 才支持毫秒。 | 示例: *654321*                                               |
> | *时区*               | ---                                                          | ---                                                          |
> | *e*                  | 时区标识（PHP 5.1.0 新加）                                   | 例如：*UTC*，*GMT*，*Atlantic/Azores*                        |
> | *I*                  | 是否为夏令时                                                 | 如果是夏令时为 *1*，否则为 *0*                               |
> | *O*                  | 与格林威治时间相差的小时数                                   | 例如：*+0200*                                                |
> | *P*                  | 与格林威治时间（GMT）的差别，小时和分钟之间有冒号分隔（PHP 5.1.3 新加） | 例如：*+02:00*                                               |
> | *T*                  | 本机所在的时区                                               | 例如：*EST*，*MDT*（【译者注】在 Windows 下为完整文本格式，例如"Eastern Standard Time"，中文版会显示"中国标准时间"）。 |
> | *Z*                  | 时差偏移量的秒数。UTC 西边的时区偏移量总是负的，UTC 东边的时区偏移量总是正的。 | *-43200* 到 *43200*                                          |
> | *完整的日期／时间*   | ---                                                          | ---                                                          |
> | *c*                  | ISO 8601 格式的日期（PHP 5 新加）                            | 2004-02-12T15:19:21+00:00                                    |
> | *r*                  | RFC 822 格式的日期                                           | 例如：*Thu, 21 Dec 2000 16:01:07 +0200*                      |
> | *U*                  | 从 Unix 纪元（January 1 1970 00:00:00 GMT）开始至今的秒数    | 参见 time()                                                  |



##### JSON

###### json_encode

对传入变量进行JSON编码。成功返回数据，否则false。

> 有可选参数：由以下常量组成的二进制掩码 JSON_HEX_QUOT, JSON_HEX_TAG, JSON_HEX_AMP, JSON_HEX_APOS, JSON_NUMERIC_CHECK, JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES, JSON_FORCE_OBJECT, JSON_PRESERVE_ZERO_FRACTION, JSON_UNESCAPED_UNICODE, JSON_PARTIAL_OUTPUT_ON_ERROR。
>
>  JSON_UNESCAPED_UNICODE 选项跳过中文编码

如：

```php
<?php
   $arr = array('a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5);
   echo json_encode($arr);
?>
```



###### json_decode

解码并转化为php变量。

`mixed json_decode ($json_string [,$assoc = false [, $depth = 512 [, $options = 0 ]]])`

- **json_string**: 待解码的 JSON 字符串，必须是 UTF-8 编码数据
- **assoc**: 当该参数为 TRUE 时，将返回数组，FALSE 时返回对象。
- **depth**: 整数类型的参数，它指定递归深度
- **options**: 二进制掩码，目前只支持 JSON_BIGINT_AS_STRING 。



##### 流程控制

###### exit

`exit($msg)`。`die`的别名。输出一条消息并结束执行当前脚本`.php`文件。

###### exec

执行本地指令，如 `exec('python test.py')`。

也可以用 `shell_exec`



##### 文件操作

###### file_exists

文件或目录是否存在

###### move_uploaded_file

将上传的文件(参数1)移动到新位置(参数2)。若成功，则返回 true，否则返回 false。参数1一般是`$_FILES[表单控件name属性]["tmp_name"]`

> 如果目标文件已经存在，将会被覆盖



##### 配置控制

###### ini_set

修改配置文件，如显示报错：

```php
ini_set('display_errors',1);
```



##### cookie

```php
setcookie($key, $value);
echo $_COOKIE[$key];
```



##### session

```php
session_start();
$_SESSION['views']=1;
echo "浏览量：". $_SESSION['views'];
if(isset($_SESSION['views']))
{
    unset($_SESSION['views']);
}
session_destroy(); //重置 session，失去所有已存储的 session 数据
```





### 输入输出

#### 标准输出

##### echo

一次输出一个或多个字符串，多个用逗号隔开，输出时等效于echo多次，不会有分割符，无返回值

可以用echo或echo()，即关键字语法或函数语法

输出效果同js的document.write，所以可以用标签，甚至可以直接在字符串里输出变量：

```php
<?php
echo "<h1>这是","一个标题</h1>";
echo 1e9+7,PHP_EOL,"1"+'234'; //注意字符输出235
echo(1/3); //很多位
//注意加了括号就只能有一个参数了
// echo "s"+"y"; 没有字符串+运算符
?>
```

```php
<?php $x="lr580";echo "I am $x";?> //注意php和$x之间有空格
```

一般而言用`'<br/>'`代表换行。

实现特定秒后自动跳转：[参考](https://blog.csdn.net/qq_36527174/article/details/111574534) (下文例子3秒)

```php
echo "<meta http-equiv='refresh' content ='3;url=index.html'>";
```





##### print

一次输出一个字符串，返回值为1，比echo慢。用法语法完全同echo。



##### print_r

打印变量，以更容易理解的形式展示。常用于输出一个数组。



##### var_dump



##### var_export

`var_export` 可以将一个数组转为一个字符串不同于`var_dump` , `var_export` 并不会输出数据的类型以及字符大小等,只会简单把数组的key跟value拼接成一个字符串



##### 常量

PHP_EOL 换行符



#### 表单I/O

##### POST

默认情况下，POST 方法的发送信息的量最大值为 8 MB（可通过设置 php.ini 文件中的 post_max_size 进行更改）。

在前端，提交的`post`表单，提交后跳转到其`action`指向的网页，并传入提交信息。用`$_POST[键]`即可得到这些信息，如：

```html
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>
 
<form action="welcome.php" method="post">
名字: <input type="text" name="fname">
年龄: <input type="text" name="age">
<input type="submit" value="提交">
</form>
 
</body>
</html>
```

```php
欢迎<?php echo $_POST["fname"]; ?>!<br>
你的年龄是 <?php echo $_POST["age"]; ?>  岁。
```

对自己搭的服务器，可能需要配置：

```php
header("Access-Control-Allow-Origin:*");
header("Access-Control-Allow-Methods:GET,POST");
```



##### GET

HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的

如：

```HTML
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>

<form action="welcome.php" method="get">
名字: <input type="text" name="fname">
年龄: <input type="text" name="age">
<input type="submit" value="提交">
</form>

</body>
</html>
```

```php+HTML
欢迎 <?php echo $_GET["fname"]; ?>!<br>
你的年龄是 <?php echo $_GET["age"]; ?>  岁。
```



##### 表单控件

###### 下拉菜单

可以通过后端`.php`代码创建下拉菜单。单选举例：表单使用 GET 方式获取数据，action 属性值为空表示提交到当前脚本，我们可以通过 select 的 name 属性获取下拉菜单的值。

```php+HTML
<?php //按下提交后 if $q部分显示
$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';
if($q) {
        if($q =='RUNOOB') {
                echo '菜鸟教程<br>http://www.runoob.com';
        } else if($q =='GOOGLE') {
                echo 'Google 搜索<br>http://www.google.com';
        } else if($q =='TAOBAO') {
                echo '淘宝<br>http://www.taobao.com';
        }
} else { //按下提交前下面部分显示
?>
<form action="" method="get"> 
    <select name="q">
    <option value="">选择一个站点:</option>
    <option value="RUNOOB">Runoob</option>
    <option value="GOOGLE">Google</option>
    <option value="TAOBAO">Taobao</option>
    </select>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```

多选举例：

```php+HTML
<?php
$q = isset($_POST['q'])? $_POST['q'] : '';
if(is_array($q)) {
    $sites = array(
            'RUNOOB' => '菜鸟教程: http://www.runoob.com',
            'GOOGLE' => 'Google 搜索: http://www.google.com',
            'TAOBAO' => '淘宝: http://www.taobao.com',
    );
    foreach($q as $val) {
        // PHP_EOL 为常量，用于换行
        echo $sites[$val] . PHP_EOL;
    }
      
} else {
?>
<form action="" method="post"> 
    <select multiple="multiple" name="q[]">
    <option value="">选择一个站点:</option>
    <option value="RUNOOB">Runoob</option>
    <option value="GOOGLE">Google</option>
    <option value="TAOBAO">Taobao</option>
    </select>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



###### 单选按钮

```php+HTML
<?php
$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';
if($q) {
        if($q =='RUNOOB') {
                echo '菜鸟教程<br>http://www.runoob.com';
        } else if($q =='GOOGLE') {
                echo 'Google 搜索<br>http://www.google.com';
        } else if($q =='TAOBAO') {
                echo '淘宝<br>http://www.taobao.com';
        }
} else {
?><form action="" method="get"> 
    <input type="radio" name="q" value="RUNOOB" />Runoob
    <input type="radio" name="q" value="GOOGLE" />Google
    <input type="radio" name="q" value="TAOBAO" />Taobao
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



###### 复选框

```php+HTML
<?php
$q = isset($_POST['q'])? $_POST['q'] : '';
if(is_array($q)) {
    $sites = array(
            'RUNOOB' => '菜鸟教程: http://www.runoob.com',
            'GOOGLE' => 'Google 搜索: http://www.google.com',
            'TAOBAO' => '淘宝: http://www.taobao.com',
    );
    foreach($q as $val) {
        // PHP_EOL 为常量，用于换行
        echo $sites[$val] . PHP_EOL;
    }
      
} else {
?><form action="" method="post"> 
    <input type="checkbox" name="q[]" value="RUNOOB"> Runoob<br> 
    <input type="checkbox" name="q[]" value="GOOGLE"> Google<br> 
    <input type="checkbox" name="q[]" value="TAOBAO"> Taobao<br>
    <input type="submit" value="提交">
</form>
<?php
}
?>
```



##### 表单检验

> 当黑客使用跨网站脚本的HTTP链接来攻击时，$_SERVER["PHP_SELF"]服务器变量也会被植入脚本，所以下面两段代码中不安全：
>
> ```php+HTML
> <form method="post" action="<?php echo $_SERVER["PHP_SELF"];?>">
> ```
>
> ```php+HTML
> <form method="post" action="test_form.php">
> ```
>
> 对于下面的代码，网址为`http://www.runoob.com/test_form.php/%22%3E%3Cscript%3Ealert('hacked')%3C/script%3E`时，解析为：
>
> ```html
> <form method="post" action="test_form.php/"><script>alert('hacked')</script>
> ```
>
> 因此，用`htmlspecialchars()`来避免攻击：
>
> ```php+HTML
> <form method="post" action="<?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?>">
> ```
>
> 此外可以用`trim()`函数去除空白字符。

一般而言，综上所述，使用三件套自定义函数：

```php
function test_input($data) {
  $data = trim($data);
  $data = stripslashes($data);
  $data = htmlspecialchars($data);
  return $data;
}
```

检验空的代码示例：

```php+HTML
<form method="post" action="<?php echo htmlspecialchars($_SERVER['PHP_SELF']);?>"> 
   名字: <input type="text" name="name">
   <span class="error">* <?php echo $nameErr;?></span>
   <input type="submit" name="submit" value="Submit"> 
</form>
```

```php
<?php
// 定义变量并默认设为空值
$nameErr = "";
$name = "";

if ($_SERVER["REQUEST_METHOD"] == "POST") {
  if (empty($_POST["name"])) {
    $nameErr = "名字是必需的。";
  } else {
    $name = test_input($_POST["name"]);
  }
}
?>
```



#### 文件I/O

##### 读写

使用`fopen(路径,模式)`。打开失败返回$0$(false)，否则返回文件流。

记得关闭`fclose($文件流)`。

模式有：

| 模式 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| r    | 只读。在文件的开头开始。                                     |
| r+   | 读/写。在文件的开头开始。                                    |
| w    | 只写。打开并清空文件的内容；如果文件不存在，则创建新文件。   |
| w+   | 读/写。打开并清空文件的内容；如果文件不存在，则创建新文件。  |
| a    | 追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。 |
| a+   | 读/追加。通过向文件末尾写内容，来保持文件内容。              |
| x    | 只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。  |
| x+   | 读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 |

如：

```php
<?php
$file=fopen("welcome.txt","r") or exit("Unable to open file!");
?>
```

有`feof($file)`。

逐行读取用`fgets($file)`。

逐字符用`fgetc`

> [更多请参考这里](https://www.runoob.com/php/php-ref-filesystem.html)



##### 上传

用户上传文件到服务器，前端脚本示例：

```html
<form action="upload_file.php" method="post" enctype="multipart/form-data">
    <label for="file">文件名：</label>
    <input type="file" name="file" id="file"><br>
    <input type="submit" name="submit" value="提交">
</form>
```

上传后，全局变量`$_FILES`可以看到文件。一维键是表单的`input`的`name`，二维键可以是：

- `$_FILES["file"]["name"]` - 上传文件的名称

- `$_FILES["file"]["type"] `- 上传文件的类型

  如：`"image/gif"`

- `$_FILES["file"]["size"]` - 上传文件的大小，以字节计

- `$_FILES["file"]["tmp_name"]` - 存储在服务器的文件的临时副本的名称

- `$_FILES["file"]["error"]` - 由文件上传导致的错误代码

要保存上传的文件，需要拷贝到另外的位置。不然脚本结束就会消失。



如：

```php
<?php
// 允许上传的图片后缀
$allowedExts = array("gif", "jpeg", "jpg", "png");
$temp = explode(".", $_FILES["file"]["name"]);
echo $_FILES["file"]["size"];
$extension = end($temp);     // 获取文件后缀名
if ((($_FILES["file"]["type"] == "image/gif")
|| ($_FILES["file"]["type"] == "image/jpeg")
|| ($_FILES["file"]["type"] == "image/jpg")
|| ($_FILES["file"]["type"] == "image/pjpeg")
|| ($_FILES["file"]["type"] == "image/x-png")
|| ($_FILES["file"]["type"] == "image/png"))
&& ($_FILES["file"]["size"] < 204800)   // 小于 200 kb
&& in_array($extension, $allowedExts))
{
    if ($_FILES["file"]["error"] > 0)
    {
        echo "错误：: " . $_FILES["file"]["error"] . "<br>";
    }
    else
    {
        echo "上传文件名: " . $_FILES["file"]["name"] . "<br>";
        echo "文件类型: " . $_FILES["file"]["type"] . "<br>";
        echo "文件大小: " . ($_FILES["file"]["size"] / 1024) . " kB<br>";
        echo "文件临时存储的位置: " . $_FILES["file"]["tmp_name"] . "<br>";
        
        // 判断当前目录下的 upload 目录是否存在该文件
        // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777
        if (file_exists("upload/" . $_FILES["file"]["name"]))
        {
            echo $_FILES["file"]["name"] . " 文件已经存在。 ";
        }
        else
        {
            // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下
            move_uploaded_file($_FILES["file"]["tmp_name"], "upload/" . $_FILES["file"]["name"]);
            echo "文件存储在: " . "upload/" . $_FILES["file"]["name"];
        }
    }
}
else
{
    echo "非法的文件格式";
}
?>
```



#### 邮件

mail() 函数用于从脚本中发送电子邮件。数需要一个已安装且正在运行的邮件系统(如：sendmail、postfix、qmail等)。所用的程序通过在 php.ini 文件中的配置设置进行定义。

> [请参见这里](https://www.runoob.com/php/php-mail.html) 下一节还有防止`E-mail`注入的例子



## 功能

### MySQL

#### mysqli

##### 链接

链接到数据库：

`mysqli_connect(host, username, password, dbname,port, socket);`

| 参数       | 描述                                        |
| :--------- | :------------------------------------------ |
| *host*     | 可选。规定主机名或 IP 地址。                |
| *username* | 可选。规定 MySQL 用户名。                   |
| *password* | 可选。规定 MySQL 密码。                     |
| *dbname*   | 可选。规定默认使用的数据库。                |
| *port*     | 可选。规定尝试连接到 MySQL 服务器的端口号。 |
| *socket*   | 可选。规定 socket 或要使用的已命名 pipe。   |

成功链接到 MySQL 后返回连接标识，失败返回 FALSE 。

断开链接：

`bool mysqli_close ( mysqli $link )`

关闭指定的连接标识所关联的到 MySQL 服务器的非持久连接。如果没有指定 link_identifier，则关闭上一个打开的连接。

通常不需要使用 `mysqli_close()`，因为已打开的非持久连接会在脚本执行完毕后自动关闭。

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
    die('Could not connect: ' . mysqli_error());
}
echo '数据库连接成功！';
mysqli_close($conn);
?>
```



##### 报错输出

`mysqli_error(connection)`，返回字符串



##### 语句执行

mysqli_query 函数来创建或者删除 MySQL 数据库。

该函数有两个参数，在执行成功时返回 TRUE，否则返回 FALSE。

`mysqli_query(connection,query,resultmode);`

| 参数         | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| *connection* | 必需。规定要使用的 MySQL 连接。                              |
| *query*      | 必需，规定查询字符串。                                       |
| *resultmode* | 可选。一个常量。可以是下列值中的任意一个：MYSQLI_USE_RESULT（如果需要检索大量数据，请使用这个）MYSQLI_STORE_RESULT（默认） |

可以执行的指令有：

- 数据库创建、删除
- 数据表创建、删除、查询
- 数据插入

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die('连接错误: ' . mysqli_error($conn));
}
echo '连接成功<br />';
$sql = 'CREATE DATABASE RUNOOB';
$retval = mysqli_query($conn,$sql );
if(! $retval )
{
    die('创建数据库失败: ' . mysqli_error($conn));
}
echo "数据库 RUNOOB 创建成功\n";
mysqli_close($conn);
?>
```

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
  die('连接失败: ' . mysqli_error($conn));
}
echo '连接成功<br />';
// 设置编码，防止中文乱码
mysqli_query($conn , "set names utf8");
 
$runoob_title = '学习 Python';
$runoob_author = 'RUNOOB.COM';
$submission_date = '2016-03-06';
 
$sql = "INSERT INTO runoob_tbl ".
        "(runoob_title,runoob_author, submission_date) ".
        "VALUES ".
        "('$runoob_title','$runoob_author','$submission_date')";
 
 
mysqli_select_db( $conn, 'RUNOOB' );
$retval = mysqli_query( $conn, $sql );
if(! $retval )
{
  die('无法插入数据: ' . mysqli_error($conn));
}
echo "数据插入成功\n";
mysqli_close($conn);
?>
```





##### 数据库选择

`mysqli_select_db(connection,dbname);`

即等效于`use`。

如：

```php
<?php
$dbhost = 'localhost';  // mysql服务器主机地址
$dbuser = 'root';            // mysql用户名
$dbpass = '123456';          // mysql用户名密码
$conn = mysqli_connect($dbhost, $dbuser, $dbpass);
if(! $conn )
{
    die('连接失败: ' . mysqli_error($conn));
}
echo '连接成功';
mysqli_select_db($conn, 'RUNOOB' );
mysqli_close($conn);
?>
```



##### 数据查询

首先用`mysqli_query`取`mysql`查询语句的返回值，然后用：

`mysqli_fetch_array(connection, 返回值)`获得所有查询的数据。

从结果集中取得一行作为关联数组，或数字数组，或二者兼有 返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。

可以设置第二个参数为`MYSQLI_ASSOC`，将返回列名作为数组索引。



#### 对象式mysqli

#### 例子

##### 注册登录1

###### conn.php

```php
<?php //conn.php
header("Access-Control-Allow-Origin:*");
header("Access-Control-Allow-Methods:GET,POST");
function salt($str){
    return md5($str.'QwQ'.$str);
}
function getCode($id,$secret){
    return salt($id.$secret);
}
$dbname='cv';
$dbuser='l';
$dbpsw='1';
// if(!$conn) {
//     return;
// }
$conn = new mysqli('localhost', $dbuser, $dbpsw, $dbname);
if($conn->connect_error) {
    die('Could not connect: ' . $conn->connect_error);
}
```

###### register.php

```php
<?php //register.php
include "conn.php";
// $name = json_encode($_POST['name']);
// $password = json_encode($_POST['password']);
$name = $_POST['name'];
$password = $_POST['password'];
if (!strlen($name)){
    echo json_encode(array('state'=>'用户名为空'));
    return;
}
if (!strlen($password)){
    echo json_encode(array('state'=>'密码为空'));
    return;
}
$password=salt($password);
// $result = $conn->query("select * from `user` where id="); #不防SQL注入
$stmt = $conn->prepare("select * from `user` where name=?");
$stmt->bind_param('s',$name);
$stmt->execute();
$result = $stmt->get_result();
// if(!$result){
//     echo json_encode(array('state'=>'用户已存在'));
//     return;
// }
if($row=$result->fetch_assoc()){
    echo json_encode(array('state'=>'用户已存在'));
    return;
}
$stmt->close();

$stmt2 = $conn->prepare('insert into `user` (name, secret) values (?,?)');
$stmt2->bind_param('ss',$name,$password);
$stmt2->execute();
$stmt2->close();

$stmt3 = $conn->prepare('select id from `user` where name=?');
$stmt3->bind_param('s',$name);
$stmt3->execute();
$result = $stmt3->get_result();
$row=$result->fetch_assoc();
$id=$row['id'];
$stmt3->close();

echo json_encode(array('state'=>'ok','code'=>getCode($id,$password)));

// echo json_encode(array('state'=>'ok'));
// echo array('state'=>'ok');
```

###### login.php

```php
<?php
include "conn.php";
$name = $_POST['name'];
$password = $_POST['password'];
if (!strlen($name)){
    echo json_encode(array('state'=>'用户名为空'));
    return;
}
if (!strlen($password)){
    echo json_encode(array('state'=>'密码为空'));
    return;
}
$password=salt($password);

$stmt4 = $conn->prepare("select * from `user` where name=? and secret=?");
ini_set('display_errors',1);
$stmt4->bind_param('ss',$name,$password);
$stmt4->execute();
$result = $stmt4->get_result();
$row=$result->fetch_assoc();

if(!$row){
    echo json_encode(array('state'=>'用户或密码不正确'));
    return;
}
$stmt4->close();

$id=$row['id'];
echo json_encode(array('state'=>'ok','code'=>getCode($id,$password)));

/*
error_reporting(E_ALL);
function f(){
    $_error = error_get_last();
    if ($_error && in_array($_error['type'], array(1, 4, 16, 64, 256, 4096, E_ALL))) {
              header("Content-Type: text/html; charset=utf-8");
              echo '<font color=red>代码出错：</font></br>';
              echo '致命错误:' . $_error['message'] . '</br>';
              echo '文件:' . $_error['file'] . '</br>';
              echo '在第' . $_error['line'] . '行</br>';
    }
}
register_shutdown_function(f);
*/
```

###### index.php

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="jqueryc.js"></script>
  <script>
    function register(){
      let name = $('[name="name"]').val();
      let password = $('[name="password"]').val();
      $.post("register.php",{
        name:name,
        password:password,
      },function(res){
        let obj = JSON.parse(res);
        $('#board').html(obj.state + " " + obj.code);
      });
    }
    function login(){
      let name = $('[name="name"]').val();
      let password = $('[name="password"]').val();
      $.post("login.php",{
        name:name,
        password:password,
      },function(res){
        alert(res);
        let obj = JSON.parse(res);
        $('#board').html(obj.state + " " + obj.code);
      });
    }
  </script>
</head>
<body>
  <h1 align="center">这是一个服务器主页</h1>
  <h4 align="right">--powered by lr580</h4>
  <form>
    用户名：<input type="text" name="name">
    密码：<input type="text" name="password">
    <input type="button" value="注册" onclick="register();">
    <input type="button" value="登录" onclick="login();">
  </form>
  <div id="board"></div>
</body>
</html>
```





## 框架

### ThinkPHP

#### 安装和配置

##### 初始化

环境要求

- PHP 版本在 5.4.0 或以上

- 配置里开启(有 `;` 开头注释的删掉注释符号 `;` ，没有就加)

  ```ini
  extension=php_pdo_mysql.dll
  extension=php_mbstring.dll
  extension=php_curl.dll
  
  [mbstring]
  mbstring.language = Chinese
  mbstring.internal_encoding = UTF-8
  mbstring.encoding_translation = On
  mbstring.http_input = UTF-8
  mbstring.http_output = UTF-8
  mbstring.detect_order = UTF-8
  mbstring.substitute_character = none
  ```

免安装， [官网](http://www.thinkphp.cn/down.html) 下载 ，如 `thinkphp_5.0.24_full` 

将 `tp5` 文件夹复制到 `AppServ/www` ，调试输入：`http://localhost:88/tp5/public/` ，预期能访问到一个主页



##### 配置

显然当前根目录是 `AppServ/www/` 代表 `/`

5.0 版本自带入口文件在 `public/index.php` 

该文件定义了应用目录 APP_PATH 和加载 ThinkPHP 框架的入口文件

显然根据内含代码可以发现该 `index.php` 的源代码位于 `application/index/controller/index.php`



开启调试模式：在 `application/config.php` ，改 `app_debug` 。调试模式在异常的时候可以显示尽可能多的信息，所以对性能有一定的影响



##### 项目新建

将 `tp5` 文件夹复制到自己的项目里，作为基础

可以根目录新建一个 `index.php` 并输入：

```c++
<?php
define('APP_PATH',    __DIR__ . '/application/');
require     __DIR__ . '/thinkphp/start.php';
?>
```



> 可以在根目录下 cmd 输入命令新建样例模块：
>
> ```shell
> php think build --module 模块名
> ```



##### 数据库配置

在 `application/database.php` ，按照提示设置数据库连接即可。

取消 `Db::table` 警告，在 vscode 设置输入 `intelephense languageConstraints` ，取消勾选即可。

如果使用了多个模块且每个模块都用不同的数据库连接，那么每个模块下面单独配置，如： `application/模块名/database.php` ，可以自己新建，如：

```php
return [ 
 	// 服务器地址
	'hostname'  => '192.168.190.129',
 	// 数据库名
    'database'  => 'testdb',
 ];
```





#### 基本概念

##### 目录结构

![image-20220424155126332](img/image-20220424155126332.png)

![image-20220424155136373](img/image-20220424155136373.png)

![image-20220424155142376](img/image-20220424155142376.png)

在根目录下用命令行输出指令，生成展示模块 `demo` ：

```shell
php think build --module demo
```



##### 模块



##### 控制器

关系：一个模块有多个控制器，一个控制器有多个方法

命名规范：驼峰命名法(首字母大写)，调用时每个单词转化为 `_` 间隔

新建一个名为 `Index` 的控制器(命名不能出现大小写 `controller`)，放在 `application/模块名/controller/控制器名.php` ，格式：

```php
<?php
namespace app\index\controller;
class Index
{
    public function index()
    {
        return 'Hello World!';
    }
}
```

控制器可以继承。方法可以定义参数。参数相当于URL参数，如：

```php
<?php
namespace app\index\controller;
class Index
{
    public function index($name='World!'){
        	return	'Hello ' . $name;
    }
}
```

然后根据 `index.php?name=输入的东西` 不同，就等于传入不同的 `$name` 

只有 public 类型的方法才是可以通过URL访问的。要调用哪个方法，就直接 HTML 里打这个方法名，如：

>  `index.php/index/index/hello`  (假设在上述代码定义了这个函数)
> 表示 `Index` 模块的 `index` 控制类的 `hello` 方法
>
> `http://localhost:88/tp5/?name=baicha`



##### 视图

在 `application/模块名` 创建目录 `view` ，尝试添加一个与控制类名字相同的目录名，然后在目录里添加一个 `html` 文件，随便写点内容，如果有变量，用 `{$变量名}` 表示占位。如在 `application/index/hello.html` ：

```html
<div>Ohh, it's {$visitor}</div>
```

使用控制器渲染变量，需要继承 `Controller` 类，如：

```php
<?php
namespace app\index\controller;
use think\Controller;
class Index extends Controller{
    public function hello($name = 'lr580')    {
        $this->assign('visitor', $name);
        return $this->fetch();
    }
}

```

然后打开网页，如：`http://localhost:88/tp5/index.php/index/index/hello?name=QwQ`



如果写成 `return view();` 也行，同理地只需要保证确实有这一个视图即可，区别在于没有参数。



#### 基本语法

##### 控制器

###### 报错输出

```php
$this->error(错误信息str);
```

遇到后弹窗(URL后面的html变成了当前方法名.html)，有自带样式，默认3秒后回到原页面。可以用全称 url ，以导向其他网站，如 oi-wiki 。

```php
if(empty(session('email'))){
       $this->error('请先登录!','index/login/login');
}
```

###### 成功回显

```php
$this->success('注册成功, 跳转到主页', url('index/index'));
```

没有第二个参数就本来在哪回到哪里

###### 重定向

是助手函数，不需要引入就能用。 

```php
$this->redirect(url('index/index'));
```

```php
$this->redirect('index/index');
```

默认使用 302 跳转，可以传第二个参数输入 301 。



##### 视图

###### Controller类

> 可以通过继承Controller类的方式来创建视图类，在新版本中，控制器类可以无需继承Controller类，此时需要自己实例化视图类

对 Contoller 类，可以调用方法：

- `fetch` 渲染html模板输出。如果带参数，参数名就是放在 `view` 文件夹里的 html 名(不带后缀)，不带参数就以当前函数名作为参数。

- `display` 直接输出 HTML 文本，等效于直接 return 。即如：

  ```php+HTML
  return "<h1>QwQ $name</h1>";
  return $this->display("<h1>QwQ $name</h1>");
  ```

- `assign` ，第一个参数是 key ，第二个是 value ，渲染一个变量





助手函数： `view([模板文件],[模板变量],[模板替换])` ，不管继承不继承都可以用。如：`view();view("hello");view("userview/hello")` ，最后一个是同一模块下另一个文件夹内的模板。不带参数就是以自己为参数。

对模板变量，用 `[key=>val]` 形式。

对模板替换，把模板文件内任意(可不在`{}`)key字符串替换为value。



###### PHP语法

在视图代码里，语法用 `{}` 括起来，有：

- PHP变量的常规调用 (直接嵌HTML里进行文本乃至URL拼接都行)

- `foreach $数组变量 as $迭代变量` 开头和 `/foreach` 结尾，如：

  ```php+HTML
  {foreach $result as $flower}
  <table><tr><td>{$flower.fname}</td></tr></table>
  {/foreach}
  ```

- `if condition=""` ， `else`  ， `/if` ，运算符可以是 `eq` 等，如：

  ```php+HTML
  {if condition="$Think.session.email eq ''"}
  <a href="{:url('login/login')}" style="font-size:x-small;text-decoration:none;">登录</a>&nbsp;&nbsp; 
  {else}
  <a href="{:url('login/logOut')}" style="font-size:x-small;text-decoration:none;">退出</a>&nbsp;&nbsp; 
  {/if}
  ```

- `:url('控制器名/方法名')` 超链接(也可以再加一个前缀 `模块名/` ) ，(不区分大小写)，如：

  ```html
  <a href="{:url('order/showorder')}" > QwQ </a>
  ```

- `include file="路径"/` 导入一个HTML (import功能)，如：

  ```php
  {include file="./public/common/top.html"/}
  ```
  
- `volist name="数组名" id="迭代变量名"` `/volist` ，像 Python 的 for，如：

   ```php+HTML
   {volist name="result" id="cart"}
   	<td>{$cart.flowerID}</td>
   {/volist}
   ```

  

其他，如 `__ROOT__` 全局变量。更多系统变量参见 [这里](https://www.kancloud.cn/manual/thinkphp5/125004)

支持输出 `$_SERVER`、`$_ENV`、 `$_POST`、 `$_GET`、 `$_REQUEST`、`$_SESSION`和 `$_COOKIE`变量。

![image-20220517160535460](img/image-20220517160535460.png)

![image-20220517160549072](img/image-20220517160549072.png)



###### 内置标签

普通标签用 `{}` 括起来，中间有空格或者换行则被视为**非模板标签**直接输出。还有可以是 `{ /}` 或 `{}  {/   }` 。

可以在配置参数修改定界符，默认就是上文的 `{}` 。如：

```php
'template'  => [
    // 模板引擎
    'type'   => 'think',
    // 普通标签开始标记 
    'tpl_begin' =>    '{',
    // 普通标签结束标记
    'tpl_end'   =>    '}'        
],
```

标签里可以直接塞一个变量，或它的属性，如 `{$x}, {$x.name}` 



###### 数组遍历

可以用 volist 标签实现循环输出数组。该标签的属性 name 接变量名， id 接遍历时作为遍历变量名， offset 是起始下标， length 是遍历次数， empty 是为空输出。如：

```html
{volist name="result" id="flower" offset="5" length="10" empty="无数据"}
	{$flower.flowerID}:{$flower.fname}
{/volist}
```

可以套子标签 eq ，属性 name 是操作名，对下标运算， value 是比较值。比如换行：

```html
{volist name="result" id="vo" mod="5" }
{$vo.name}
{eq name="mod" value="4"}<br/>{/eq}
{/volist}
```

注意 id 是一个变量，即可以 `{$id名}` 。缺省为 `i` 。



foreach 类似，但是只有 name, item, key(默认为 key) 。也是普通遍历。如

```html
{foreach name="result" item="flower" key="k"}
{$k}|{$flower.id}:{$flower.name}
{/foreach}
```



for：

```html
{for start="开始值" end="结束值" comparison="" step="步进值" name="循环变量名"}{/for}
```

name 默认是 i ，步进默认是 1。会写解析为 for PHP语句。



###### 选择判断

switch 标签，可以接属性 name 代表选择值。内置标签 case 有属性 value ，有 default 标签。

```php+HTML
{switch name="$admin.level"}
    {case value="1"}admin{/case}
    {case value="2"}user{/case}
    {default /}default
{/switch}
```

case 可以设置 break 属性为 0，使得逻辑跟 C++ 的 switch 一样：

```php+HTML
{foreach $result as $admin}
{switch name="$admin.level"}
    {case value="1" break="0"}admin{/case}
    {case value="2"}user{/case}
    {default /}default
{/switch}
{/foreach}
```

name 可以使用函数、系统变量、参数，如 get 的一个属性： `Think.get.userId` ，传入靠 `?userId=xxx` 

value 属性可以用 `|` 分割，如：

```php+HTML
{switch name="Think.get.type"}
    {case value="gif|png|jpg"}图像格式{/case}
    {default /}其他格式
{/switch}
```



可以用 if ，有属性名 condition 接表达式。有内嵌配套的 elseif 和  else 如：

```php+HTML
{foreach $result as $admin}
{if condition="$admin.level eq 1"}
    <h2>admin</h2>
{elseif condition="($admin.level == 2) or ($admin.level>10)"/}
    <h2>user</h2>
{else/}
	<h2>default</h2>   
{/if}
{/foreach}
```

可以用 php 代码在 condition 里：

```php+HTML
{if condition="strtoupper($user['name']) eq 'THINKPHP5'"}
<h2>ThinkPHP5</h2>
{else /} 
<h2>other Framework</h2>
{/if}
```

三者等效：

```php+HTML
{if condition="表达式"}
{if (表达式)}
{if 表达式}
```



###### 比较标签

标签名可以是 `eq` , `equal` , `neq` , `notequal` , `gt` , `egt` ( $\ge$ ) , `lt` , `elt` , `heq` (恒等于) , `nheq` 。用法参数跟 eq 基本一样，如：

```php+HTML
{eq name="name" value="value"}value{/eq}
```

也可以用内嵌 else ，如：

```php+HTML
{eq name="name" value="value"}
相等
{else/}
不相等
{/eq}
```

用函数：

```php+HTML
{eq name="$user['name']|strlen" value='9'}
    <h2>长度=9</h2>
{/eq}
```

用变量：

```php+HTML
{eq name="$user.name" value="$a"}{$user.name}{/eq}
```

用统一标签，用 type 指明类型：

```php+HTML
{compare name="name" value="5" type="eq"}value{/compare}
```



范围判断用标签： `in` , `notin` , `between` , `notbetween` ，如：

```php+HTML
{in name="id" value="1,2,3"}
id在范围内
{/in}
```

对 between ，可以是整数、字符等。

```php+HTML
{between name="id" value="A,Z"} <!--或如 "1,5"-->
输出内容1
{/between}
```

可以用 range 标签统一，如：

```php+HTML
{range name="id" value="1,2,3" type="in"}
输出内容1
{/range}
```



present , `notpresent` 接属性 name ，判定某个变量是否已经定义。

empty, `notepmty` 判断是否为空。

```php+HTML
{empty name="Think.get.name"}
$_GET['name']为空值
{/empty}
```



##### Session

[参考](https://blog.csdn.net/qq_37675827/article/details/77978396)

```php
use think\Session;
```

如：

```php
$rs = Session::get('email')
```



当然也可以暴力用原生的，即 `session('email')`



##### 表单

> 貌似是基本语法，而不是ThinkPHP语法

###### 数据获取

在控制器方法里使用，如：

```php
input('post.email') //对应post的form表单，name=email的表单项
```

###### 数据存储

如：

```php
session('email', $rs['email']);
```



##### 数据库

###### 动态连接

可以不事先配置，而是动态定义，，使用 `Db::connect` 然后一个数组参数(跟配置一样)，如：

```php
Db::connect([
    // 数据库类型
    'type'        => 'mysql',
    // 数据库连接DSN配置
    'dsn'         => '',
    // 服务器地址
    'hostname'    => '127.0.0.1',
    // 数据库名
    'database'    => 'thinkphp',
    // 数据库用户名
    'username'    => 'root',
    // 数据库密码
    'password'    => '',
    // 数据库连接端口
    'hostport'    => '',
    // 数据库连接参数
    'params'      => [],
    // 数据库编码默认采用utf8
    'charset'     => 'utf8',
    // 数据库表前缀
    'prefix'      => 'think_',
]);
```

也可以使用字符串，URL形式，`数据库类型://用户名:密码@数据库地址:数据库端口/数据库名#字符集`，  如：

```php
Db::connect('mysql://root:123456@localhost:3306/flower#utf8');
```

返回一个变量，用这个变量不断调用数据库函数即可实现数据库功能 



###### 基础

在配置好数据库的基础上，在控制器方法，进行读取，例如：

```php
use think\Db;
//...
Db::name(名字str)->find(); //返回读取单行数据
Db::table(名字str)->select(); //读取多行数据
->order(关键字str,'desc') //排序，在table后接
```

name 与 table 的区别在于，若配置项有 `prefix` ， name ， db() 会加上前缀， table 不会

find 找单行，不存在返回 null ； select 找数据集，不存在返回空数组。

value 只返回某一列(属性)，找单次，找不到 null ； column 返回某一列值，找不到返回空数组

可以加 distinct(true) 来去重

可以加 order 来排序

> 综合示例：`->distinct(true)->field('value')->select()`

> ```php
> $data=Db::table('think_user')->where('id',1)->value('name');
> // 返回数组
> $data=Db::table('think_user')->where('name','like','%thinkphp')->column('name');
> // 指定索引
> $data=Db::table('think_user')->where('name','like','%thinkphp')->column('name','id');
> ```

> ```php
> public function index()
> {
>     $fclass = Db::table('flower')->distinct('true')->field('fclass')->select();
>     $this->assign('fclasses', $fclass);
>     $fname = input('post.fname');
>     $fcls = input('post.fclass');
>     $minprice = input('post.minprice');
>     $maxprice = input('post.maxprice');
>     if (empty($maxprice)) {
>         $maxprice = 114514;
>     }
>     if (empty($minprice)) {
>         $minprice = 0;
>     }
>     $searchstr = "yourprice between $minprice and $maxprice";
>     if (!empty($fcls)) {
>         $searchstr .= " and fclass='$fcls'";
>     }
>     if (!empty($fname)) {
>         $searchstr .= " and fname like '%$fname%'";
>     }
>     $data = Db::table('flower')->where($searchstr)->order('SelledNum desc')->select();
>     $this->assign('flowers', $data);
>     return $this->fetch();
> }
> ```



在 HTML 进行php语句操作，如：

```html
{foreach $result as $mem}
<tr><td>{$mem.email}</td>
	<td>{$mem.mname}</td>
	<td>{$mem.mobile}</td>
</tr>
{/foreach}
```

> 例如：
>
> ```php
> <?php
> 
> namespace app\index\controller;
> 
> use think\Controller;
> use think\Db;
> 
> class Index extends Controller
> {
>     public function hellodb()
>     {
>         $data = Db::table('myorder')->select();
>         $this->assign('res', $data);
>         return $this->fetch();
>     }
> }
> ```
>
> ```html
> <table>
>     <tr>
>         <th>orderID</th>
>         <th>custID</th>
>     </tr>
>     {foreach $res as $it}
>     <tr>
>         <td>{$it.orderID}</td>
>         <td>{$it.custID}</td>
>     </tr>
>     {/foreach}
> </table>
> ```



###### 分页

先使用分页查询，如：

```php
$list = Db::name('user')->where('status',1)->paginate(10);
$data = Db::table('flower')->order('SelledNum','desc')->paginate(5);
```

使用 paginate 函数：

![image-20220424161841250](img/image-20220424161841250.png)

例如：

```php
public function showflower(){
    $data = Db::table('flower')->order('SelledNum','desc')->paginate(5);
    $this->assign('result',$data);
    $page=$data->render();
    $this->assign('page',$page);
    return $this->fetch();
}
```

导航使用一次标志即可：

```html
<div class="page">{$page}</div>
```

为了修改分页的样式，可以更改 `thinkphp/library/think/paginator/driver/` 的 `Bootstrap.php` ，如改为：

> ```php
> <?php
> // +----------------------------------------------------------------------
> // | ThinkPHP [ WE CAN DO IT JUST THINK ]
> // +----------------------------------------------------------------------
> // | Copyright (c) 2006~2018 http://thinkphp.cn All rights reserved.
> // +----------------------------------------------------------------------
> // | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )
> // +----------------------------------------------------------------------
> // | Author: zhangyajun <448901948@qq.com>
> // +----------------------------------------------------------------------
> 
> namespace think\paginator\driver;
> 
> use think\Paginator;
> 
> class Bootstrap extends Paginator
> {
>     /*
>      * 上一页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getPreviousButton($text = "上一页")
>     {
>     
>         if ($this->currentPage() <= 1) {
>             return $this->getDisabledTextWrapper($text);
>         }
>     
>         $url = $this->url(
>             $this->currentPage() - 1
>             );
>     
>         return $this->getPageLinkWrapper($url, $text);
>     }
>     
>     /**
>      * 下一页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getNextButton($text = '下一页')
>     {
>         if (!$this->hasMore) {
>             return $this->getDisabledTextWrapper($text);
>         }
>     
>         $url = $this->url($this->currentPage() + 1);
>     
>         return $this->getPageLinkWrapper($url, $text);
>     }
>     
>     /**
>      * 首页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getFirstButton($text = '首页')
>     {
>         $nowPage = $this->rollPage;//计算分页临时变量
>         //当  总页数大于定义的页数时  且  当前页数大于前几页时  显示首页
>         if ($this->lastPage > $this->showPage && $this->currentPage > $nowPage) {
>     
>             $url = $this->url(1);
>     
>             return $this->getPageLinkWrapper($url, $text);
>         }
>     }
>     
>     /**
>      * 末页按钮
>      * @param string $text
>      * @return string
>      */
>     protected function getLastButton($text = '末页')
>     {
>         $nowPage = $this->rollPage;//计算分页临时变量
>     
>         //当  总页数大于定义的页数时  且  当前页数小于最后的几页时  显示末页
>         if ($this->lastPage > $this->showPage && $this->currentPage < ($this->lastPage - $nowPage)) {
>     
>             $url = $this->url($this->lastPage);
>     
>             return $this->getPageLinkWrapper($url, $text);
>         }
>     }
>     
>     /**
>      * 页码按钮
>      * @return string
>      */
>     protected function getLinks()
>     {
>         if ($this->simple)
>             return '';
>     
>             $block = [
>                 'first'  => null,
>                 'slider' => null,
>                 'last'   => null
>             ];
>     
>             $side   = 3;
>             $window = $side * 2;
>     
>             if ($this->lastPage < $window + 6) {
>                 $block['first'] = $this->getUrlRange(1, $this->lastPage);
>             } elseif ($this->currentPage <= $window) {
>                 $block['first'] = $this->getUrlRange(1, $window + 2);
>                 $block['last']  = $this->getUrlRange($this->lastPage - 1, $this->lastPage);
>             } elseif ($this->currentPage > ($this->lastPage - $window)) {
>                 $block['first'] = $this->getUrlRange(1, 2);
>                 $block['last']  = $this->getUrlRange($this->lastPage - ($window + 2), $this->lastPage);
>             } else {
>                 $block['first']  = $this->getUrlRange(1, 2);
>                 $block['slider'] = $this->getUrlRange($this->currentPage - $side, $this->currentPage + $side);
>                 $block['last']   = $this->getUrlRange($this->lastPage - 1, $this->lastPage);
>             }
>     
>             $html = '';
>     
>             if (is_array($block['first'])) {
>                 $html .= $this->getUrlLinks($block['first']);
>             }
>     
>             if (is_array($block['slider'])) {
>                 $html .= $this->getDots();
>                 $html .= $this->getUrlLinks($block['slider']);
>             }
>     
>             if (is_array($block['last'])) {
>                 $html .= $this->getDots();
>                 $html .= $this->getUrlLinks($block['last']);
>             }
>     
>             return $html;
>     }
>     
>     /**
>      * 渲染分页html
>      * @return mixed
>      */
>     public function render()
>     {
>         if ($this->hasPages()) {
>             if ($this->simple) {
>                 return sprintf(
>                     '%s %s',
>                     $this->getPreviousButton(),
>                     $this->getNextButton()
>                     );
>             } else {
>                 return sprintf(
>                     '%s %s %s',
>                     $this->getPreviousButton(),
>                     $this->getLinks(),
>                     $this->getNextButton()
>                     );
>             }
>         }
>     }
>     
>     /**
>      * 生成一个可点击的按钮
>      *
>      * @param  string $url
>      * @param  int    $page
>      * @return string
>      */
>     protected function getAvailablePageWrapper($url, $page)
>     {
>         return '&nbsp;&nbsp;<a href="' . htmlentities($url) . '">' . $page . '</a>&nbsp;&nbsp;';
>     }
>     
>     /**
>      * 生成一个禁用的按钮
>      *
>      * @param  string $text
>      * @return string
>      */
>     protected function getDisabledTextWrapper($text)
>     {
>         return '<span>&nbsp;&nbsp;' . $text . '&nbsp;&nbsp;</span>';
>     }
>     
>     /**
>      * 生成一个激活的按钮
>      *
>      * @param  string $text
>      * @return string
>      */
>     protected function getActivePageWrapper($text)
>     {
>         return '<span>&nbsp;&nbsp;' . $text . '&nbsp;&nbsp;</span>';
>     }
>     
>     /**
>      * 生成省略号按钮
>      *
>      * @return string
>      */
>     protected function getDots()
>     {
>         return $this->getDisabledTextWrapper('...');
>     }
>     
>     /**
>      * 批量生成页码按钮.
>      *
>      * @param  array $urls
>      * @return string
>      */
>     protected function getUrlLinks(array $urls)
>     {
>         $html = '';
>     
>         foreach ($urls as $page => $url) {
>             $html .= $this->getPageLinkWrapper($url, $page);
>         }
>     
>         return $html;
>     }
>     
>     /**
>      * 生成普通页码按钮
>      *
>      * @param  string $url
>      * @param  int    $page
>      * @return string
>      */
>     protected function getPageLinkWrapper($url, $page)
>     {
>         if ($page == $this->currentPage()) {
>             return $this->getActivePageWrapper($page);
>         }
>     
>         return $this->getAvailablePageWrapper($url, $page);
>     }
>     }
> 
> ```



###### 复杂查询

`->view(表名str,列名str(, 条件))` ，列名str里内部逗号分隔表示多个列

`->where(列名str, 运算符str, 运算数)`  (可以叠多个where，显然)

最后 `->select()` 或 `->find()` 

如：

```php
public function view1()
{
    $conn=Db::connect('mysql://root:123456@localhost:3306/student#utf8');
    dump('OK');
    $data = $conn->view('S', 'SNO,SNAME')->view('SC', 'GRADE', 'SC.SNO=S.SNO')
        ->view('C', 'CNO,CNAME', 'SC.CNO=C.CNO')
        ->where('GRADE', '>', 80)
        ->select();
    $this->assign("results", $data);
    return $this->fetch();
}
```

多个条件 and 为：

```php
Db::table('think_user')->where('name&uname','like','%thinkphp')->find(); // % 是 SQL通配符
```

多个 or 用 whereOr ：

```php
Db::table('think_user')->where('name','like','%thinkphp')->whereOr('email','tp@163.com')->find();
```

也可以用 `|` ：

```php
Db::table('think_user')->where('name|title','like','%thinkphp')->find();
```

混合且，或，用括号搞顺序。

![image-20220429160653178](img/image-20220429160653178.png)



###### 查询语法

```php
where('字段名','表达式','查询条件');
whereOr('字段名','表达式','查询条件');
```

表达式语法：(都是字符串)(查询条件就可以不是字符串) 

```
EQ、=	等于（=）  //如果只写两个参数，where('字段名','查询条件') 也是 EQ
NEQ、<>	不等于（<>）
GT、>	大于（>）
EGT、>=	大于等于（>=）
LT、<	小于（<）
ELT、<=	小于等于（<=）
LIKE	模糊查询
[NOT] BETWEEN	（不在）区间查询
[NOT] IN	（不在）IN 查询
[NOT] NULL	查询字段是否（不）是NULL  //这时没有查询条件
[NOT] EXISTS	EXISTS查询
EXP	表达式查询，支持SQL语法，后接函数使用
> time	时间比较
< time	时间比较
between time	时间比较
not between time	时间比较
```

5.0.4  支持对同一个字段多次调用查询方法  

EXP 举例：

```php
where('id','exp',' IN (1,3,8) ');
```

综合举例：

```php
Db::table('think_user')->where('name|title','like','thinkphp%')->where('create_time&update_time','>',0)->find();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' OR `title` LIKE 'thinkphp%' ) AND ( `create_time` > 0 AND `update_time` > 0 ) LIMIT 1
> ```



区间查询是一种同一字段多个查询条件的简化写法：

区间查询的查询条件必须使用数组定义方式，支持所有的查询表达式。

```php
Db::table('think_user')->where('name',['like','thinkphp%'],['like','%thinkphp'])->where('id',['>',0],['<>',10],'or')->find();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' AND `name` LIKE '%thinkphp' ) AND ( `id` > 0 OR `id` <> 10 ) LIMIT 1
> ```



批量查询

```php
Db::table('think_user')
    ->where([
        'name'  =>  ['like','thinkphp%'],
        'title' =>  ['like','%thinkphp'],
        'id'    =>  ['>',0],
        'status'=>  1
    ])
    ->select();
```

> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE `name` LIKE 'thinkphp%' AND `title` LIKE '%thinkphp' AND `id` > 0 AND `status` = '1'
> ```



可以用箭头混合叠起来用上述的全部东西，如：

> ```php
> Db::table('think_user')
>     ->where('name',['like','thinkphp%'],['like','%thinkphp'])
>     ->where(function($query){
>         $query->where('id',['<',10],['>',100],'or');
>     })
>     ->select();
> ```
>
> 对应：
>
> ```sql
> SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' AND `name` LIKE '%thinkphp' ) AND ( `id` < 10 or `id` > 100 )
> ```



可以套原生：

```php
Db::table('think_user')->where('id > 0 AND name LIKE "thinkphp%"')->select();
```



可以占位符：

```php
Db::table('think_user')
    ->where('id > :id AND name LIKE :name ',['id'=>0, 'name'=>'thinkphp%'])
    ->select();
```



> V5.0.4+开始，ThinkPHP支持对同一个字段多次调用查询条件
>
> ```php
> Db::table('think_user')
>     ->where('name','like','%think%')
>     ->where('name','like','%php%')
>     ->where('id','in',[1,5,80,50])
>     ->where('id','>',10)
>     ->find();
> ```



可以定义别名：

```php
$data = $conn->view(['S'=>'Stu'], ['SNO'=>'Stu_No','SNAME'=>'Stu_Name'])
    ->view('SC', ['GRADE'=>'score'], 'SC.SNO=Stu.SNO')
    ->view('C', 'CNO,CNAME', 'SC.CNO=C.CNO')
    ->where('GRADE', '>', 80)
    ->select();
```

> 对应：
>
> ```sql
> Select  Stu.SNO  as Stu_No,Stu.SNAME as Stu_Nname,SC.GRADE as score 
> From  S Stu inner join SC on SC.SNO=Stu.SNO inner join C on SC.CNO=C.CNO
> Where grade>80;
> ```



###### 模型类

如果在某个模型类里面定义了connection属性的话，则该模型操作的时候会自动连接给定的数据库连接，而不是配置文件中设置的默认连接信息，通常用于某些数据表位于当前数据库连接之外的其它数据库。格式同配置里的数据即这是一个数组或字符串格式。如：

```php
//在模型里单独设置数据库连接信息
namespace app\index\model;
use think\Model;
class User extends Model
{
    protected $connection = [
        // 数据库类型
        'type'        => 'mysql',
        // 数据库连接DSN配置
        'dsn'         => '',
        // 服务器地址
        'hostname'    => '127.0.0.1',
        // 数据库名
        'database'     => 'flower',
        // 数据库用户名
        'username'    => 'root',
        // 数据库密码
        'password'    => '12345678',
        // 数据库连接端口
        'hostport'    => '',
        // 数据库连接参数
        'params'     =>[],
        // 数据库编码默认采用utf8
        'charset'     => 'utf8',
        // 数据库表前缀
        'prefix'      => 'think_',
    ];
}

```

```php
protected $connection = 'mysql://root:12345678@localhost:3306/flower#utf8';
```

需要注意的是，ThinkPHP的数据库连接是**惰性**的，所以并不是在实例化的时候就连接数据库，而是在有实际的数据操作的时候才会去连接数据库。



###### 原生操作

query 和 execute 两个方法，分别用于查询和写入，直接使用 SQL 语句

除了查询都用 execute (如更新)。查询返回 array ，下标从 0 开始，值是对象型数组，其key和value对应查询。execute方法的返回值是影响的行数

支持 `?` 参数绑定和命名占位符 `:名字` 绑定，如：

```php
Db::query('select * from think_user where id=?',[8]);    // id=8
Db::execute('insert into think_user (name, email) values (?, ?)',['thinkphp','tp5@163.com']);
```

```php
Db::query('select * from think_user where id=:id',['id'=>8]);
Db::execute('insert into think_user (name, email) 
values (:name, :email)',['name'=>'thinkphp','email'=>'tp5@163.com']);
```

```php
$result=Db::execute('insert into think_user(id,name,email)	values(null,"thinkphp","tp@163.com")');
dump($result);
```

如：

```html
<form action="{:url('index/create')}" name="f" method="post">
<table border="1">
<tr><td>name:</td><td><input type="text" name="name" value="a1"></td></tr>
<tr><td>email:</td><td><input type="text" name="email" value="a1@163com"></td></tr>
<tr><td>score:</td><td><input type="text" name="score" value="91"></td></tr>
<tr><td colspan="2"><input type="submit" value="添加"></td></tr>
</table>
</form>
```

```php
public function create(){
        $name = input('post.name');
        $email=input('post.email');
        $score=input('post.score');
        Db::execute("insert into think_user(id,name,email,score) 
            values(null,'".$name."','".$email."','".$score."')");
        $this->success('添加成功',url('index/index')); 
    }
}
```



```html
<br/>
<a href="{:url('index/add')}">添加</a>
<br/><br/>
<table border="1">
<tr><th>name</th><th>email</th><th>score</th><th>修改</th><th>删除</th></tr>
{volist name="$result" id="row"}
<tr>
	<td>{$row.name}</td>
	<td>{$row.email}</td>
	<td>{$row.score}</td>
	<td><a href="{:url('index/update')}?id={$row.id}">修改</a></td>
	<td><a href="{:url('index/delete')}?id={$row.id}">删除</a></td>
</tr>	
{/volist}
</table>
```

```html
<form action="{:url('index/doUpdate')}" name="f" method="post">
{foreach $result as $user}
<table border="1">
<input type="hidden" name="id" value="{$user.id}">
<tr><td>name:</td><td><input type="text" name="name" value="{$user.name}"></td></tr>
<tr><td>email:</td><td><input type="text" name="email" value="{$user.email}"></td></tr>
<tr><td>score:</td><td><input type="text" name="score" value="{$user.score}"></td></tr>
<tr><td colspan="2"><input type="submit" value="修改"></td></tr>
</table>
{/foreach}
</form>
```

```php
public function update(){
    $id=input('get.id');
    $user=Db::query("select * from think_user where id=$id");
    dump($user);
    $this->assign('result',$user);
    return $this->fetch();
}
public function doUpdate(){
    $id = input('post.id');
    $name = input('post.name');
    $email=input('post.email');
    $score=input('post.score');
    Db::execute("update think_user 
            set name='$name',
            email='$email',
            score='$score' 
            where id=$id");       
    $this->success('修改成功',url('index/index'));
}

```



###### 表格信息

使用getTableInfo可以获取表信息，信息类型 包括 fields,type,bind,pk，以数组的形式展示，可以指定某个信息进行获取

```php
// 获取`think_user`表所有信息
Db::getTableInfo('think_user');
// 获取`think_user`表所有字段
Db::getTableInfo('think_user', 'fields');
// 获取`think_user`表所有字段的类型
Db::getTableInfo('think_user', 'type');
// 获取`think_user`表的主键
Db::getTableInfo('think_user', 'pk');
```



###### 助手函数

`db(数据表名)` = 前缀 + 数据表名选择。可选参数：第二个参数为数据库的连接参数，留空数组(默认)表示采用数据库配置文件的配置；第三个参数是一个布尔值，默认值是false，如果设置为true表示每次都会重新连接数据库。db函数如果采用相同的链接，可以设置第三个参数false.

> 一个MySQL好似只能同时有至多150个连接



###### 其他查询

使用**查询对象**进行查询，例如：

```php
$query = new \think\db\Query();
$query->table('think_user')->where('name','like','%thinkphp');
// $data=Db::find($query);
$data=Db::select($query);
dump($data);
```

或者直接使用闭包函数查询，例如：

```php
$data=Db::select(function($query){
    $query->table('think_user')->where('name','like','%thinkphp');
});
dump($data);
```



###### 聚合查询

内置方法，可以填参数(也可以不填)代表要统计的字段名：count, max, min, avg, sum

如：

```php
Db::table('think_user')->count();
Db::table('think_user')->where('score>0')->min('score');
```



###### 子查询

使用 select 方法且填参数 false ，表示不进行查询只是返回构建SQL (dump 输出得到语句)

那么使用字符串连接符，如 `'(' . $变量 . ') 子表名'` 为 table 参数，就可以子查询了

```php
$subQuery = $conn->table('SC')
    ->field('SNO,GRADE')
    ->where('CNO','=','k5')
    ->select(false);

$data = $conn->table('('.$subQuery.') a')
    ->view('S','SNO,SNAME','a.SNO=S.SNO')
    ->where('a.GRADE','>',80)
    ->select();
```

也可以用 fetchSql 方法，表示不进行查询而只是返回构建的SQL语句，并且不仅仅支持select，而是支持所有的CURD查询。用法： `->fetchSql(true)->select()` ，得到的还是一样的，后面套子表用法跟上面一样。

调用buildSql方法后不会进行实际的查询操作，而只是生成该次查询的SQL语句（为了避免混淆，结果上会在SQL两边加上括号），我们在后续的查询中直接调用。(字符串连接时可以不用括号了，直接子表名)。调用就查询时把 select 换成 buildSql

如果需要 IN/EXISTS 查询，需要用函数闭包，如：

```php
$data = $conn->table('S')
    ->where('SNO','IN',function($query){
        $query->table('SC')->where('CNO','k5')->field('SNO');
    })
    ->select();
```

```php
$data = $conn->table('S')
    ->where(function($query){
        $query->table('SC')
            ->where('CNO','k5')
            ->where('S.SNO=SC.SNO');
    },'exists')
    ->select(); 
```



###### 管理数据

插入：

```php
$data = ['name' => 'zhangsan', 'email' => 'zs@163.com'];
Db::table('think_user')->insert($data);
```

insert 方法添加数据成功返回添加成功的条数，insert 正常情况返回 1

返回新增数据的自增主键，可以使用：

```php
$userId = Db::name('user')->getLastInsID();
```

或直接合并，插入并返回 (成功返回添加数据的自增主键)：

```php
Db::name('user')->insertGetId($data);
```

多条就二维数组， insertAll ，返回添加数据成功返回添加成功的条数



更新：

返回影响数据的条数，没修改任何数据返回 0

```php
Db::table('think_user')->where('id', 1)->update(['name' => 'tp5_1']);
```

若更新的数据包含主键，不需要 where ：

```php
Db::table('think_user')->update(['name' => 'thinkphp','id'=>1]);
```

只更新一个字段，返回影响数据的条数：

```php
Db::table('think_user')->where('id',1)->setField('name', 'thinkphp');
```

setInc/setDec 如不加第二个参数，默认值为1：

```php
Db::table('think_user')->where('id', 1)->setInc('score');
```

支持延时更新，如果需要延时更新则传入第三个参数，单位为秒



删除：

根据主键删除直接传主键值（多个就数组），返回影响数据的条数，无则 0 ：

```php
Db::table('think_user')->delete(1);
Db::table('think_user')->delete([1,2,3]);
```

也可以 where ：

```php
Db::table('think_user')->where('name','bb')->delete();
Db::table('think_user')->where('id','<',10)->delete();
```



##### 模型类

模型类和 Db 类的区别主要在于对象的封装， Db 类的查询默认返回的是数组（或者集合），而模型类返回的是当前的模型对象实例（或者集合），模型是比 Db 类更高级的数据封装，支持模型关联、模型事件。

###### 定义

要放在 `application/模块/model/模型类名.php` ，如：

```php
namespace app\index\model;
use	think\Model;
class 模型类名 extends Model
{
}
```

大多情况下无需为模型定义任何的属性和方法即可完成基础的操作。

模型会自动对应一个数据表，规范是：

```php
数据表前缀+当前的模型类名（不含命名空间）
```

如果你的模型命名不符合这一数据表对应规范，可以给当前模型定义单独的数据表，包括两种方式。

如：

```php
namespace app\index\model;
use think\Model;
class User extends Model{
// 设置完整的数据表（包含前缀）
	protected $table = 'think_user';
}
```

```php
namespace app\index\model;
use think\Model;
class User extends Model
{
// 设置数据表（不含前缀）
	protected $name ='member';
}
```

果当前模型类需要使用不同的数据库连接，可以定义模型的 connection 属性。即

```php
protected $connection = 按照数据库链接的数组/DSN格式来就行;
```

有一种方式可以让你省去别名定义，系统支持统一对控制器类添加 Controller 后缀，修改配置参数**：**

```php
//是否启用控制器类后缀
'controller_suffix'      =>  true,
```



###### 方法

成员属性就是数据库读出来的每个属性。还有方法如下(含静态方法)：



增加数据：

执行 save 操作都是执行的数据库 insert 操作，如果你需要实例化执行save 执行数据库的 update 操作，请确保在save方法之前调用 isUpdate 方法，如：

```php
$user->isUpdate()->save(); //isUpdate填false
```

静态 create 方法可以传入数组或者标准对象，可以在外部统一赋值后传入，当然也可以直接传入表单数据

可以搞成一个数组，然后用 saveAll 传数组

可以用 return getError 方法的返回值得到报错内容



查询数据：

静态 get 方法，传主键值，返回当前的模型对象实例。如果没有传入任何值的话，则表示获取第一条数据。

模型的 get 方法和 Db 类的 find 方法返回结果的区别在于， Db 类默认返回的只是数组（注意这里说的默认，其实仍然可以设置为对象），而模型的 get 方法查询返回的一定是当前的模型对象实例。但是系统为模型实现了 ArrayAccess 接口，因此仍然可以通过数组的方式访问对象实例。

静态 getBy属性名 方法，传值返回实例。注意命名法。每个单词大写，get除外。或者传一个数组，key => value 形式。

查询构建器：静态方法 where ，第一个参数属性，第二个值(或第二个运算符，第三个值，就跟之前的 where 方法用法一样的)，然后再套无参数的 find 。

全部读取用 all ，然后 for 一下就好了。这个也可以传一个数组，key => value 形式作为查询条件。



更新数据：

先查询得到对象，然后直接暴力改，然后用一下 save 即可。

默认情况下，查询模型数据后返回的模型实例执行 save 操作都是执行的数据库 update 操作，如果你需要实例化模型类后执行 save 执行数据库的 insert 操作，请确保在save方法之前调用 isUpdate 方法。

ActiveRecord 模式的更新数据方式需要首先读取对应的数据，如果需要更高效的方法可以搞一个对象，然后静态方法 update 传进去就行。



删除数据：

先查询得到对象，然后跑一下 delete 方法就行。查到的对象是数组就 for 进去一个一个的 delete 。

也可以用静态方法 destroy(主键)



###### 增数据

> 在当前文件中给 app\index\model\User 模型定义了一个别名 UserModel 是为了避免和当前的app\index\controller\User 产生冲突，如果你当前的控制器类不是 User 的话可以不需要定义UserModel 别名

直接操作对应的控制器类就行，不需要对模型类搞别的东西了。如：

```php
<?php
namespace app\index\controller;
use think\Controller;
use app\index\model\User as UserModel;
class User extends Controller
{//	新增用户数据
	public function add(){
		$user=new UserModel();
		$user->name	= '流年';
		$user->email='thinkphp@qq.com';
		$user->birthday ='1977-03-05';
		if($user->save()){
			return '用户['.$user->name.':'.$user->id.']新增成功';
		}else	{
			return	$user->getError();
		}
	}
}
```

> 如果加了控制器类后缀，那么：
>
> ```php
> <?php
> namespace app\index\controller;
> use think\Controller;
> use app\index\model\User;
> class UserController extends Controller
> {//	新增用户数据
> 	public function add(){
> 		$user=new User();
> 		$user->name= '方圆圆';
> 		$user->email='thinkphp@qq.com';
> 		$user->birthday ='1999-05-20';
> 		if($user->save()){
> 			return '用户['.$user->name.':'.$user->id.']新增成功';
> 		}else	{
> 			return	$user->getError();
> 		}
> 	}
> }
> ```

> 关于 isUpdate：
>
> ```php
> //添加数据
> public function addu()
> {
>     $user=new UserModel();
>     $user->id=15;
>     $user->name='刘晨';
>     $user->email='liuchen@gmail.com';
>     if(false!==$user->isUpdate(false)->save()){
>         return '添加用户成功';
>     }else{
>         return $user->getError();
>     }
> }
> ```
>
> 使用 create 方法：
>
> ```php
> <?php
> namespace app\index\controller;
> use think\Controller;
> use app\index\model\User as UserModel;
> class User extends Controller
> {
>  // 新增用户数据
>     public function add()
>     {
>         $user['name'] = '李丽';
>         $user['email'] = 'lili@qq.com';
>         $user['birthday'] = '2015-04-02';
>         if ($result=UserModel::create($user)) {
>             return '用户['.$result->name.':'.$result->id.']新增成功';
>         } else {
>             return '新增出错';
>         }
>     }
> }
> 
> ```

调用如 `http://localhost:89/MyModel/index.php/index/user/add`



###### 查数据

```php
//	读取用户数据
public function read($id='')
{
    $user=UserModel::get($id);
    echo $user->name.'<br/>';
    echo $user->email.'<br/>';
    echo $user->birthday.'<br/>';
}
public function read3()
{
    $user = UserModel::getByEmail('thinkphp@qq.com');
    echo $user->name.'<br/>';
    echo $user->email.'<br/>';
    echo $user->birthday.'<br/>';
}
public function read4()
{
    $user = UserModel::get(['name'=>'李丽']);
    echo $user->name . '<br/>';
    echo $user->email . '<br/>';
    echo $user->birthday . '<br/>';
}
public function read5()
{
    $user =	UserModel::where('name','李丽')->find();
    echo $user->name.'<br/>';
    echo $user->email.'<br/>';
    echo $user->birthday.'<br/>';
}
public function readall()
{
    $list=UserModel::all();
    foreach	($list as $user)	{
        echo $user->id.'<br/>';
        echo $user->name.'<br/>';
        echo $user->email.'<br/>';
        echo $user->birthday.'<br/>';
        echo '----------------------------------<br/>';
    }
}

```

如： `http://localhost:89/MyModel/index/user/read/?id=1`



###### 改数据

```php
public function update($id)
{
    $user=UserModel::get($id);
    $user->name='刘晨';
    $user->email='liuchen@gmail.com';
    if(false!==$user->save()){
        return '更新用户成功';
    }else{
        return $user->getError();
    }
}
```

如： `http://localhost:89/MyModel/index/user/update?id=3`



###### 删数据

```php
public function delete($id)
{
    $user=UserModel::get($id);
    if($user){
        $user->delete();
        return '删除用户成功';
    }else{
        return '删除的用户不存在';
    }
}
public function delete3()
{
    $users= UserModel::where('id','>',6)->select();
    foreach($users as $user){
        if($user){
            $user->delete();
            echo $user->id.'删除成功</br>';
        }else{
            echo '删除的用户不存在';
        }
    }
}
public function delete2($id)
{
    $result	= UserModel::destroy($id);
    if($result){
        return '删除用户成功';
    }else{
        return '删除的用户不存在';
    }
}

```



###### 关联模型

一对一关系：

对 Model 类，其自带方法(可以 `$this->` 调用)有 `hasOne` ，参数是表名、外键名、被关联表属性名。

自带方法 belongsTo ，参数是数据表名。

```php
<?php
namespace app\index\model;
use think\Model;
class User extends Model
{
    public function user_address(){
        return $this->hasOne('user_address','user_id','id');
    }  
}// user_id是外键名，user_address表中的user_id，关联user表的id，
// 而id是user_address表中的主键
```

```php
public function user(){
    return $this->belongsTo('user');
}
```



一对多关系：

hasMany。belongsTo也行。

```php
return $this->hasMany('Sc','sno','id');
//sno是外键，成绩表sc中的sno，关联student表的sno，id是sc表中的主键
return $this->belongsTo('student');
```



多对多关系：

belongsToMany，参数是：关联模型名、中间表名(不用写前缀)、外键名、当前模型关联外键

```php
return $this->belongsToMany('course','sc','cno','sno');
```



创建关联模型就直接如上 return 即可



这个被返回的玩意可以用 save 等增删改查玩意，可以用 attach(模型实例)，也可以 detach(实例) 。

```php
namespace app\index\model;
use think\Model;
class Student extends Model{ 
    public function sc(){
        return $this->hasMany('Sc','sno','id');
    }
    
    public function Course(){
        return $this->belongsToMany('course','Sc','cno','sno');
    }
}
```

```php
namespace app\index\model;
use think\Model;
class Course extends Model{       
    public function Student(){
        return $this->belongsToManay('student','Sc','sno','cno');
    }
}
```

```php
namespace app\index\model;
use think\Model;
class Sc extends Model{
    public function student(){
        return $this->belongsTo('student');
    }
}
```

```php
<?php
namespace app\index\controller;
use think\Controller;
use app\index\model\Student;
class Index extends Controller
{
    public function addRelate($sname='李强'){
        $student=Student::getBySname($sname);
        $res=$student->Course()->save(['cname'=>'计算机组成原理','teacher'=>'吴昊']);
        if($res){
            echo "新增成功";
        }
    }
```

```php
namespace app\index\controller;
use think\Controller;
use app\index\model\Student;
use app\index\model\Course;
class Index extends Controller
{
  public function addRelate1($sname='李强',$cname='编译原理') {
        $student=Student::getBySname($sname);
        $course = Course::getByCname($cname);
        $res=$student->Course()->attach($course);
        if($res){
            echo "关联成功";
        }
    }
```

```php
<?php
namespace app\index\controller;
use think\Controller;
use app\index\model\Student;
use app\index\model\Course;
class Index extends Controller
{
    public function detach(){
        $student=Student::getBySname('李强');
        $course = Course::getByCname('计算机组成原理');
        $res=$student->Course()->detach($course);
        if(!$res){
            echo "取消成功";
        }
    }

```

```php
public function show1(){
    $students = Student::all();
    foreach ($students as $student) {       
        echo "=================1对多显示==============<br/>";   
        echo '姓名：'.$student->sname.'，学号：'.$student->sno.'，所选课程成绩:<br/>';
        foreach ($student->sc as $sc) {
            if ($student->sno == $sc->sno){
                echo '课程ID：' . $sc->cno . '<br/>';
                echo 'GRADE：' . $sc->grade . '<br/>';
                echo '-----------------------<br/>';
            }
        }
    }
}

```

```php
public function show2(){
    $students = Student::all();
    foreach ($students as $student) { //多对多显示 
        echo '===================多对多显示================<br/>';
        echo '姓名：'.$student->sname.'，学号：'.$student->sno.'，所选修课程:<br/>';
        foreach ($student->Course as $course) {
            echo '课程编号：'. $course->cno.'<br/>';
            echo '课程名称：'. $course->cname . '<br/>';
            echo '任课老师：' . $course->teacher . '<br/>';
            echo '-----------------------<br/>';            
        }
    }
}

```

不知道有什么用。



##### URL

###### pageinfo

ThinkPHP 采用单一入口模式访问应用，对应用的所有请求都定向到应用的入口文件。

页面跳转需要进入 `\traits\controller\Jump` ，而继承 `Controller` 有这个，不需要额外引入。

301和302都是HTTP状态的编码，都代表着某个URL发生了转移。

1) 301跳转，也叫“永久性转移”，301会把原网页权重转移到重定向目标的网站上面,搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。二次请求。

2) 302跳转也称为，“临时性跳转”。搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。一次请求。

可以用 success, error 和 redirect 。

标准 URL 格式：(pathinfo格式)

```shell
http://serverName:端口号/index.php/模块/控制器/操作
```

模块是 application 下子目录，官方的规范是目录名小写，因此模块全部采用小写命名，无论URL是否开启大小写转换，模块名都会强制小写。URL地址中的控制器和操作名是不区分大小写的。

驼峰命名的控制器如 `HelloWorld` ，在 url 输入 `hello_world` 。

如果希望严格区分大小写访问（或者要支持驼峰法进行控制器访问），可以在应用配置文件中”application/config.php”中设置：

```php
// 关闭URL自动转换（支持驼峰访问控制器）
'url_convert' => false,
```

关闭URL自动转换之后，必须使用下面的URL地址访问（控制器名称必须严格使用控制器类的名称，不包含控制器后缀）：

```plain
http://localhost:89/TestTP/index.php/index/HelloWorld/index
```

操作方法的访问本身不会受URL自动转换的影响，但会影响默认的模板渲染输出。



如果我们直接访问入口文件的话，由于URL中没有模块、控制器和操作，因此系统会访问默认模块（index）下面的默认控制器（Index）的默认操作（index），如下面等效：

```plain
http://localhost:89/TestTP/index.php
http://localhost:89/TestTP/index.php/index/index/index
```

传入参数：

```text
http://localhost:89/TestTP/index.php/index/index/hello/name/thinkphp
http://localhost:89/TestTP/index.php/index/index/hello/?name=thinkphp
```



不支持 pathinfo 的话可以用兼容方式：

```html
http://localhost:89/TestTP/index.php?s=/index/Index/hello
```

其中变量 s 的名称如果改为u，则访问的是默认的控制器和index方法。s可以配置的。

TP5.0不再支持普通的URL访问方式，所以下面的访问是无效的：

```
http://localhost:89/TestTP/index.php?m=index&c=index&a=hello
```



###### 参数

pageinfo 方法来写，顺序任意；或 ?：

```phpw
http://localhost:89/TestTP/index.php/index/index/hello/name/tp5
http://localhost:89/TestTP/index.php/index/index/hello1/name/tp5/city/guangzhou 
http://localhost:89/TestTP/index.php/index/index/hello1?name=tp5&city=guangzhou
```

 还可以进一步对URL地址做简化，前提就是我们必须明确参数的顺序代表的变量，我们更改下URL参数的获取方式，把应用配置文件中的 url_param_type 参数的值修改如下：

```php
// 按照参数顺序获取
'url_param_type' => 1,
```

省略后：

```php1
http://localhost:89/TestTP/index.php/index/index/hello1/tp5/shanghai
```

按顺序绑定参数的话，操作方法的参数只能使用URL pathinfo变量，而不能使用get或者post变量。(即?格式)



###### index.php

可以去掉URL地址里面的入口文件 index.php ，但是需要额外配置WEB服务器的重写规则。

以 Apache 为例，需要在入口文件的同级（index.php所在文件夹）添加 .htaccess 文件（官方默认自带了该文件），内容如下：

```htaccess
<IfModule mod_rewrite.c>
Options +FollowSymlinks -Multiviews
RewriteEngine on
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]
</IfModule>
```

用 phpstudy 则：

```htaccess
<IfModule mod_rewrite.c>
Options +FollowSymlinks -Multiviews
RewriteEngine on
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1]
</IfModule>
```

用 nginx 在 `nginx.conf` ：

```js
location / { // …..省略部分代码
    if (!-e $request_filename) {
    	rewrite ^(.*)$ /index.php?s=/$1 last;
    	break;
    }
}

```

去掉后，如：

```php1
http://localhost:89/TestTP/index/index/index
http://localhost:89/TestTP/index/index/hello
```

隐藏后可以用去掉和不去掉两种写法来写。



###### 路由

我们在路由定义文件（ application/route.php ）里面添加一些路由规则，如下：

```php
return [
    // 添加路由规则 路由到 index控制器的hello操作方法
    'hello/[:name]' => 'index/index/hello',
];
```

该路由规则表示所有 hello 开头的并且带参数的访问都会路由到 index 控制器的 hello 操作方法。中括号表示可选。

可以恒简化：

```php1
http://localhost:89/TestTP/index/index/hello/name/tp5
http://localhost:89/TestTP/hello/tp5
```

定义路由规则后，原来的URL地址将会失效，变成非法请求。



动态，在路由配置文件开头添加：

```php
use think\Route;
Route::rule('hello/[:name]', 'index/hello');
```

完成的效果和使用配置方式定义是一样的。

无论是配置方式还是通过Route类的方法定义路由，都统一放到路由配置文件 application/route.php文件中。

提示：注意路由配置不支持在模块配置文件中设置。



若需要完整匹配：

```php
return [
    // 路由参数name为可选
    'hello/[:name]$' => 'index/hello',
];
```

那么：

```abc
http://localhost:89/TestTP/hello   // 正确匹配
http://localhost:89/TestTP/hello/tp5    // 正确匹配
http://localhost:88/TestTP/hello/val/value // 不会匹配
```



闭包：

```php
return [
    // 定义闭包
    'hello/[:name]' => function ($name) {
    	return 'Hello,' . $name . '!';
    },
];
```

或：

```php
use think\Route;
    Route::rule('hello/[:name]', function ($name) {
    	return 'Hello,' . $name . '!';
});
```

闭包函数的参数就是路由规则中定义的变量。



###### 分割符

如果需要改变URL地址中的 pathinfo 参数分隔符，只需要在应用配置文件（application/config.php ）中设置：

```php
// 设置pathinfo分隔符
'pathinfo_depr' => '-',
```

路由规则定义无需做任何改变，我们就可以访问下面的地址：

```a
http://localhost:88/TestTP/hello-tp5
```



###### 路由参数

我们还可以约束路由规则的请求类型或者URL后缀之类的条件，例如：

```php
return [
    // 定义路由的请求类型和后缀
    'hello/[:name]' => ['index/hello', ['method' => 'get', 'ext' => 'html']],
];
```

上面定义的路由规则限制了必须是 get 请求，而且后缀必须是 html 的，所以下面的访问地址：

```ab
http://localhost:89/TestTP/hello    // 无效
http://localhost:89/TestTP/hello.html // 有效
```



###### 变量规则

如：

```php
<?php
namespace app\index\controller;

class Blog
{
    public function get($id){
        return '查看id=' . $id . '的内容';
    }
    public function read($name){
        return '查看name=' . $name . '的内容';
    }
    public function archive($year, $month){
        return '查看' . $year . '/' . $month . '的归档内容';
    }    
}
```

规则：

```php
return [
    'blog/:year/:month' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}', 'month' => '\d{2}']],
    'blog/:id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
    'blog/:name' => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
];
```

如：

```phpa
http://localhost:89/TestTP/blog/5
http://localhost:89/TestTP/blog/thinkphp
http://localhost:89/TestTP/blog/2015/05
```

简化：

```php
return [
'[blog]' => [
    ':year/:month' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}', 'month' => '\d{2}']],
    ':id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
    ':name' => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
],
];

```

对 `blog-<year>-<month>` 这样的非正常规范，我们需要使用 <变量名> 这样的变量定义方式，而不是

:变量名 方式。如：

```php
return [
'blog/:id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
'blog/:name' => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
'blog-<year>-<month>' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}',
'month' => '\d{2}']],
];

```

简单起见，我们还可以把变量规则统一定义，例如：

```php
return [
// 全局变量规则定义
'__pattern__' => [
'name' => '\w+',
'id' => '\d+',
'year' => '\d{4}',
'month' => '\d{2}',
],
// 路由规则定义
'blog/:id' => 'blog/get',
'blog/:name' => 'blog/read',
'blog-<year>-<month>' => 'blog/archive',
];

```

在 \_\_pattern\_\_ 中定义的变量规则我们称之为全局变量规则，在路由规则里面定义的变量规则我们称之为局部变量规则，如果一个变量同时定义了全局规则和局部规则的话，当前的局部规则会覆盖全局规则的。



###### Url类

定义路由规则之后，我们可以通过Url类来方便的生成实际的URL地址（路由地址）

```php
// 输出 blog/thinkphp
Url::build('blog/read', 'name=thinkphp');
Url::build('blog/read', ['name' => 'thinkphp']);

Url::build('blog/archive', 'year=2015&month=05');
Url::build('blog/archive', ['year' => '2015', 'month' => '05']);
```

url助手函数简化：

```php
url('blog/read', 'name=thinkphp');
```

```html
<a href="{:url('blog/read','name=thinkphp')}">跳转</a>
```



##### 请求响应

###### input

助手函数。

```php
input('提交类型.变量名/修饰符');
```

s 字符串，d 整型，b布尔值，a数组，f浮点

如：

```php
$num = input('post.num/d');
manage = input('post.manage/a');
$str = implode(',', $manage);
```



###### Request

> ThinkPHP5 的架构设计和之前版本的主要区别之一就在于增加了 Request 请求对象和 Response 响应对象的概念

请求对象。Request 对象的作用是与客户端交互，收集客户端的Form、Cookies、超链接，或者收集服务器端的环境变量。

Request对象是从客户端向服务器发出请求，包括用户提交的信息以及客户端的一些信息。客户端可通过HTML表单或在网页地址后面提供参数的方法提交数据，然后通过Request对象的相关方法来获取这些数据。

Request的各种方法主要用来处理客户端浏览器提交的请求中的各项参数和选项。

ThinkPHP5 的 Request 对象由 think\Request 类完成。

Request 对象的一个主要职责是统一和更安全地获取当前的请求信息，最好是需要避免直接操作 \$_GET 、\$\_POST 、 \$\_REQUEST 、 \$\_SESSION 、 \$\_COOKIE ，甚至 \$\_FILES 等全局变量，而是统一使用Request 对象提供的方法来获取请求变量。

一种少用的方法：

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello($name = 'World') {
        $request = Request::instance();
		// 获取当前URL地址 不含域名
		echo 'url: ' . $request->url() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```

返回值距离：

```sdsd
/TestTP/index.php/index/index/hello?name='abc'
```

当继承 think\\Controller 时，可以改为 `$this->request->url()` ，也不用 use 和 instance 。

如果没有继承 think\Controller ，则可以使用 Request 对象注入的方式来简化调用：

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request, $name = 'World')    {
		echo 'url: ' . $request->url() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```

hello方法的request参数是系统自动注入的，而不需要通过URL请求传入。



可以给Request请求对象绑定属性，方便全局调用，例如我们可以在公共控制器中绑定当前登录的用户模型到请求对象：

```php
<?php
namespace app\index\controller;
use app\index\model\User;
use think\Controller;
use think\Request;
use think\Session;
class Base extends Controller{
	public function  _initialize(){
        $user = User::get(Session::get('user_id'));
        Request::instance()->bind('user', $user);
    }
}
```

```php
<?php
namespace app\index\controller;
use app\index\controller\Base;
use think\Request;
class Index extends Base{
	public function index(Request $request)    {
		echo $request->user->id;
		echo $request->user->name;
    }
}
```



###### request助手

```php
<?php
namespace app\index\controller;
class Index{
	public function hello($name = 'World')    {
		// 获取当前URL地址 不含域名
		echo 'url: ' . request()->url() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```



###### param

系统推荐使用 param 方法统一获取当前请求变量，该方法最大的优势是让你不需要区分当前请求类型而使用不同的全局变量或者方法

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
    public function hello(Request $request)    {
        echo '请求参数：';
        dump($request->param());
        echo 'name:' . $request->param('name');
    }
}
```

dump 那一行还可以简化为： `dump(input());`

param 方法获取的参数会自动判断当前的请求，以 POST 请求为例的话，参数的优先级别为：路由变量 > 当前请求变量（\$\_POST变量） \> \$\_GET变量

注意：这里的路由变量指的是路由规则里面定义的变量或者 PATH\_INFO 地址中的变量。路由变量无法使用get 方法或者 \$\_GET 变量获取。

param 方法支持变量的过滤和默认值：

```php
echo 'name:' . $request->param('name', 'World', 'strtolower');
echo '<br/>test:' . $request->param('test', 'thinkphp', 'strtoupper');
```

防止代码注入，在 `application/config.php` ：

```php
'default_filter' => 'htmlspecialchars ',
```



###### 其他输入

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request) {
		echo 'GET参数：';
       dump($request->get());
		echo 'GET参数：name';
       dump($request->get('name'));
		echo 'POST参数：name';
        dump($request->post('name'));
		echo 'cookie参数：name';
        dump($request->cookie('name'));
		echo '上传文件信息：image';
        dump($request->file('image'));
    }
}
```

写法二：

```php
<?php
namespace app\index\controller;
class Index{
	public function hello()    {
		echo 'GET参数：';
        dump(input('get.'));
		echo 'GET参数：name';
        dump(input('get.name'));
		echo 'POST参数：name';
        dump(input('post.name'));
		echo 'cookie参数：name';
        dump(input('cookie.name'));
		echo '上传文件信息：image';
        dump(input('file.image'));
    }
}
```

![image-20220524164459786](img/image-20220524164459786.png)

除了 file 都支持默认值和过滤方式。



###### 请求参数

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request) {
		echo '请求方法：' . $request->method() . '<br/>';
		echo '资源类型：' . $request->type() . '<br/>';
		echo '访问IP：' . $request->ip() . '<br/>';
		echo '是否AJax请求：' . var_export($request->isAjax(), true) . '<br/>';
		echo '请求参数：';
        dump($request->param());
		echo '请求参数：仅包含name';
        dump($request->only(['name']));
		echo '请求参数：排除name';
        dump($request->except(['name']));
    }
}
```

`var_export` 可以将一个数组转为一个字符串不同于`var_dump` , `var_export` 并不会输出数据的类型以及字符大小等,只会简单把数组的key跟value拼接成一个字符串



###### URL信息

```php
<?php
namespace app\index\controller;
use think\Request;
class Index{
	public function hello(Request $request, $name = 'World'){
		// 获取当前域名
		echo 'domain: ' . $request->domain() . '<br/>';
		// 获取当前入口文件
		echo 'file: ' . $request->baseFile() . '<br/>';
		// 获取当前URL地址 不含域名
		echo 'url: ' . $request->url() . '<br/>';
		// 获取包含域名的完整URL地址
		echo 'url with domain: ' . $request->url(true) . '<br/>';
		// 获取当前URL地址 不含QUERY_STRING
		echo 'url without query: ' . $request->baseUrl() . '<br/>';
		// 获取URL访问的ROOT地址
		echo 'root:' . $request->root() . '<br/>';
		// 获取URL访问的ROOT地址
		echo 'root with domain: ' . $request->root(true) . '<br/>';
		// 获取URL地址中的PATH_INFO信息
		echo 'pathinfo: ' . $request->pathinfo() . '<br/>';
		// 获取URL地址中的PATH_INFO信息 不含后缀
		echo 'pathinfo: ' . $request->path() . '<br/>';
		// 获取URL地址中的后缀信息
		echo 'ext: ' . $request->ext() . '<br/>';
		return 'Hello,' . $name . '！';
    }
}
```

![image-20220524164802059](img/image-20220524164802059.png)

url、baseUrl、baseFile、root方法如果传入true，表示获取包含域名的地址。



###### MCV信息

```php
public function hello(Request $request, $name = 'World') {
		echo '模块：' . $request->module();
		echo '<br/>控制器：' . $request->controller();
		echo '<br/>操作：' . $request->action();
    }
```

controller方法获取的是驼峰命名的实际的控制器名，其它都是小写返回。



###### Response

Response 对象用于动态响应客户端请示,通常用于输出数据给客户端或者浏览器。

ThinkPHP5 的 Response 响应对象由 think\\Response 类或者子类完成

大多数情况，我们不需要关注 Response 对象本身，只需要在控制器的操作方法中返回数据即可，系统会根据 default_return_type 和 default_ajax_return 配置决定响应输出的类型。

默认的自动响应输出会自动判断是否 AJAX 请求，如果是的话会自动输出 default_ajax_return 配置的输出类型。

```php
<?php
namespace app\index\controller;
class Index{
	public function test(){
		$data = ['name' => 'thinkphp', 'status' => '1'];
		return $data;
	}
}
```

若修改配置文件：

```php
// 默认输出类型
'default_return_type' => 'json',
```

那么上文访问会保存一个 json 。改为 xml 就保存一个 xml 。

手动输出控制：

```php
<?php
namespace app\index\controller;
use think\Controller;
class Index{
    public function test(){
        $data = ['name' => 'thinkphp', 'status' => '1'];
        return json($data);
    }  
}
```

![image-20220524165137668](img/image-20220524165137668.png)



##### 事务

`mysql` 的 `myisam` 不支持， `unnodb` 支持。

###### transaction

发生异常自动回滚。

自动控制事务处理：

```php
Db::transaction(function(){
    //执行语句
    //Db::table('think_user')->find(1);
    //Db::table('think_user')->delete(1);
});
```

手动，如：

```php
Db::startTrans();
try{
    Db::table('think_user')->find(1);
    Db::table('think_user')->delete(1);
    // 提交事务
    Db::commit();    
} catch (\Exception $e) {
    // 回滚事务
    Db::rollback();
}
```

注意在事务操作的时候，确保你的数据库连接是相同的。



##### 文件

###### 定义

使用 `think\File`。创建一个控制器：

```php
<?php
namespace app\index\controller;
use think\controller;
use think\Request;
class Upload extends Controller{ 
    // 文件上传表单
    public function index()    {
        return $this->fetch();
    }
    // 文件上传提交
    public function up(Request $request)    {
        // 获取表单上传文件
        $file = $request->file('file');
        if (empty($file)) {
            $this->error('请选择上传文件');
        }
        // 移动到框架应用根目录/public/uploads/ 目录下
        $info = $file->move(ROOT_PATH . 'public' . DS . 'uploads');
        if ($info) {
            $this->success('文件上传成功：' . $info->getRealPath());
        } else {
            // 上传失败获取错误信息
            $this->error($file->getError());
        }
    }
}
```

HTML：

```html
<!doctype html>
<html><head>
<meta charset="UTF-8">
<title>文件上传示例</title>
</head><body>
	<h2>文件上传示例</h2>
	<FORM method="post" enctype="multipart/form-data" action="{:url('up')}">
		选择文件：<INPUT type="file"  name="file"><br/> 
		<INPUT type="submit" value="提交">
	</FORM>
</body>
</html>
```

默认的上传文件会按照当前的日期自动保存



###### 验证

可以嵌套使用。如：

```php
$info=$file->validate(['ext'=>'jpg,png'])->move(ROOT_PATH	.'public'.DS.'uploads');
```

![image-20220607160002845](img/image-20220607160002845.png)

不只是检验后缀，强行改后缀也会说是错的。文件上传验证用到了 **exif 扩展**，如果没有开启请自行开启。



###### 验证类

统一使用验证类 think\Validate 对表单进行验证，也可以直接使用控制器类 think\Controller 的 validate 方法进行上传文件验证

```php
// 文件上传提交
    public function up(Request $request){
 		$file = $request->file('file');
        // 上传文件验证
        $result = $this->validate(['file' => $file],
            ['file' => 'require|image'], 
            ['file.require' => '请选择上传文件','file.image' => '非法图像文件']);
        if (true !== $result) {
            $this->error($result);
        }
        // 移动到框架应用根目录/public/uploads/ 目录下
        $info = $file->move(ROOT_PATH.'public'.DS .'uploads');
        if ($info) {
            $this->success('文件上传成功：'. $info->getRealPath());
        } else {
            // 上传失败获取错误信息
            $this->error($file->getError());
        }
    }

```

由于设置了 require 验证规则（表示必须上传文件），所以如果没有选择任何文件直接提交的话，页面会提示报错。

![image-20220607160214083](img/image-20220607160214083.png)



###### 保存规则

rule 方法设置。

![image-20220607160312054](img/image-20220607160312054.png)

其中md5和sha1规则会自动以散列值的前两个字符作为子目录，后面的散列值作为文件名。

```php
$info = $file->rule('md5')->move(ROOT_PATH . 'public' . DS . 'uploads');
$info=$file->rule('uniqid')->move(ROOT_PATH	.'public'.DS.'uploads');
```

这里使用了 uniqid 函数来生成唯一的ID命名上传文件，如果必要，还可以支持使用闭包定义规则，例如：

```php
// 移动到框架应用根目录/public/uploads/ 目录下
	$info = $file->rule(function ($file) {
    // 使用自定义的文件保存规则
    return $file->getInfo('type').uniqid();
})->move(ROOT_PATH . 'public' . DS . 'uploads');
```

如果希望指定某个文件的保存文件名，还可以直接使用：

```php
// 移动到框架应用根目录/public/uploads/test.后缀 目录下
$info = $file->move(ROOT_PATH . 'public' . DS . 'uploads', 'test');
```

如果希望保持上传文件的原文件名保存，则可以使用：

```php
$info = $file->move(ROOT_PATH . 'public' . DS . 'uploads', '');
```

默认同名覆盖，不想覆盖就：

```php
$file->move(ROOT_PATH . 'public' . DS . 'uploads', true, false);
```

要获取上传的保存文件名(不含路径)，可以调用返回对象的 getSaveName 方法：

```php
$info = $file->rule('md5')->move(ROOT_PATH . 'public' . DS . 'uploads','');
if ($info) {
    echo $info->getSaveName();
} else {
    $this->error($file->getError());
}
```



###### 多文件

如表单。

```html
<h2>多文件上传示例</h2>
<FORM	method="post" enctype="multipart/form-data" action="{:url('up1')}">
<input	type="file"	name="image[]"	/>	<br>	
<input	type="file"	name="image[]"	/>	<br>	
<input	type="file"	name="image[]"	/>	<br>	
<INPUT	type="submit"	class="btn"	value="	提交">
</FORM>
```

```php
public function up1(Request $request)    {
    // 获取表单上传文件
    $files = $request->file('image');
    $item = [];
    foreach ($files as $file) {
        // 移动到框架应用根目录/public/uploads/ 目录下
        $info = $file->move(ROOT_PATH . 'public' . DS . 'uploads');
        if ($info) {
            $item[] = $info->getRealPath();
        } else {
            // 上传失败获取错误信息
            $this->error($file->getError());
        }
    }
    $this->success('文件上传成功' . implode('<br/>', $item));
}
```



###### 文件操作

上传成功后返回的是 File 对象，除了可以使用 SplFileObject 的属性和方法之外，还可以使用File类自身提供的下列方法，便于进行后续的文件处理（例如对图像文件进行剪裁处理或者移动到远程服务器）。

![image-20220607160712006](img/image-20220607160712006.png)

```php
public function up(Request $request) {
    $file = $request->file('file');
    $info = $file->move(ROOT_PATH . 'public' . DS . 'uploads');
    if ($info) {
        // 移动文件到FTP服务器
        $link = ftp_connect('212.45.5.78');
        ftp_login($link, 'root', 'password');
        /* 移动文件 */
        $path = ftp_pwd($link) . '/uploads/';
        if	(!ftp_put($link,$path.$info->getFilename(),	$info->getRealPath(),FTP_BINARY)){
            $this->error('文件上传保存错误！');
        }
    } else {
        // 上传失败获取错误信息
        $this->error($file->getError());
    }
}
```





##### 库

###### 验证码

修改 `php.ini` 配置，增加(取消注释号`;`)：

```ini
extension_dir="./"
extension_dir="ext"
```

添加一个拓展包：

```ini
extension=php_openssl.dll
```

添加：

```ini
openssl.cafile=
```

下载并放置：`AppServ\php7\verify\cacert.pem` 

thinkphp5.0版本安装验证码类库,必须安装1.* 版本，安装2.0版将会出错。

使用 composer，在应用根目录：

```shell
composer require topthink/think-captcha  1.*
```



### Yii

[教程](https://dev.mysql.com/downloads/windows/installer/8.0.html)





# MySQL

## 基本

### 基本概念

RDBMS(Relational Database Management System：关系数据库管理系统)，基本特点：

- 数据以表格的形式出现
- 每行为各种记录名称
- 每列为记录名称所对应的数据域
- 许多的行和列组成一张表单
- 若干的表单组成database

> mongodb(nosql) 是非关系型数据库

mysql是rdbms。

- **数据库:** 数据库是一些关联表的集合。
- **数据表:** 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。
- **列:** 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。
- **行：**一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。
- **冗余**：存储两倍数据，冗余降低了性能，但提高了数据的安全性。
- **主键**：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。
- **外键：**外键用于关联两个表。
- **复合键**：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。
- **索引：**使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。
- **参照完整性:** 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。

> MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
>
> - MySQL 是开源的，目前隶属于 Oracle 旗下产品。
> - MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。
> - MySQL 使用标准的 SQL 数据语言形式。
> - MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。
> - MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。
> - MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。
> - MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。



### 使用

导入导出等其他指令可见指令-其他指令

#### 使用

在线测试 [fiddle](https://dbfiddle.uk/)

> 以下均以linux系统为准

安装略。

验证安装：(mysql admin)

```shell
mysqladmin --version
```

输出了有效信息代表安装成功。

启动：(可能需要管理员`sudo`)(-u是`user`,`-uroot`是`root`用户；`-p`是password，同理可以诸如`-p123456`)

```shell
mysql
```

```shell
mysql -u 用户名 -p
```

然后输入密码。

退出：`exit`或`\q`或`quit`

启动后可以直接交互，类似于`python shell`交互方法。

参数：

- `-h 主机` ，如`localhost, 127.0.0.1, 10.191.65.243`
- `-P 端口`
- `-u 用户名`
- `-p` 密码（随后输入）；或`-p密码` 

示例：

```shell
mysqladmin -h 127.0.0.1 -u root -p123 create test
cmd /c mysql -h 127.0.0.1 -u root -p123 test < tb_thu.sql
```



检查MySQL服务器是否启动：

```shell
ps -ef | grep mysqld
```

启动服务器：

```shell
cd /usr/bin
./mysqld_safe &
```

关闭服务器：

```shell
cd /usr/bin
./mysqladmin -u 用户名 -p shutdown
```

文件配置路径：`/etc/my.cnf`

> 上述文件配置在SCNUOJ服务器不存在



重启：[参考](https://blog.csdn.net/m0_67402914/article/details/124131630)

windows win+r `net stop mysql` 然后 `net start mysql`



#### sql 脚本

一系列 sql 语句的集合。可以用 shell 执行，重定向输入输出。后缀名是 `.sql `。以 shell 为例：

```shell
sudo mysql < xxx.sql > xxx.out
```



#### 开关服务

##### windows

开关分别是：

```shell
mysqld --console
mysqladmin -uroot shutdown
```



##### linux

查看是否启动：

```shell
ps -ef | grep mysqld
```

启动：

```shell
cd /usr/bin
./mysqld_safe &
```

关闭：

```shell
mysqladmin -u root -p shutdown
```



#### vscode

可以使用插件：`SQL Formatter`



#### my.ini

可以查看数据存放的路径



### 基本格式

指令不区分大小写，以分号结束。如可以输入：

```mysql
SHOW DATABASES;
```

> 列出所有数据表

单行注释用`#`或`--`

> `#`和`--`的区别就是：`#`后面直接加注释内容，而`--`的第 2 个破折号后需要跟一个空格符在加注释内容。

多行注释用`/**/`

```mysql
use mysql; #选定数据库，之后所有语句针对这个数据库
SHOW TABLES; -- 展示所有数据表
SHOW /*多行
注释*/ TABLES;
SHOW COLUMNS FROM user; #查看user数据表的所有属性
SHOW INDEX FROM user; #显示数据表的详细索引信息，包括PRIMARY KEY（主键）
SHOW TABLE STATUS from mysql; # 输出数据库性能和统计信息
SHOW TABLE STATUS from mysql LIKE 'time%';     # 表名以time开头的表的信息
SHOW TABLE STATUS from mysql LIKE 'time%'\G;   # 加上 \G，查询结果按列打印
```

名字(数据库名、数据表名、用户名等)可以不用任何引号，数据库名、数据表名、列名都不区分大小写，也可以用单引号或反勾号(esc下面的键)。两者在linux下和windows下不同，linux下不区分，windows下区分。如果SQL服务器模式包括ANSI_QUOTES模式选项，还可以用双引号将识别符引起来。

一般引号用途是避免关键字冲突，如对`date`为列名时，需要引号。三种引号：

- 飘号 \`\` ，通常用于表示可能会产生歧义的列名
- 单引号 \'\' ，用于字符串，也可以用双引号
- 数值不能用引号；字符串不能不用引号也不能用飘号；列名不能用引号

退出：

```mysql
exit
```

> `use,exit`是不需要分号的语句



算术运算符，除法可以用`/`或`DIV`，整除整是小数，取模用`%`或`MOD` 。零除返回 null 。

关系运算符有`between 值 and 值` ，是 $[x,y]$ 区间，`in` , `is null` 及其 `not` 前缀的。还有 greatest, least, like, regexp 。is null (isnull()) ， is not null 。`least(v1, v2, v3, ...)` 。存在 null 返回 null 。有 `in(v1, v2, ...)` ，找不到、括号里有或本来要判断的左操作数是 null 返回 null 。like 里 `%` 是零到多个， `_` 是任意一个。输入左/右 null(不带引号) 返回 null， regexp 同理。

`=`是是否等于，任一方为`NULL`得`NULL`，否则是`0/1` 。一个字符串一个整数按数值比较。还有安全等与 `<=>` ，唯一区别是都为 null 返回 1 。不等于用 `<>` 或 `!= ` 。null 参与比较运算符返回 null，如 `<=` 。字符串比较字典序。

因为 windows 下不区分大小写，所以字符串比较也不区分。要区分的话在字符串前添加 binary 关键字，即如 `binary 'a' != 'A'` 

逻辑有 `!` 或 `NOT` ，有 `AND, OR , XOR` 。操作数为 null 得 null 。对 not 而言， `''` , `'0'` 都返回 1 。xor 的等效是 `(a and (not b))` 或反之即 `((not a) and b)` 。

可以有位运算符 `&|^!<<>>~`，其中`!`取反。返回64位无符号整数。

如：

```mysql
select 22 div 3;
```

最低优先级为： **:=**。(注意这里1最低而不是最高)

![img](img/1011652-20170416163043227-1936139924.png)

最高优先级为： **!**、**BINARY**、 **COLLATE**。



### 数据类型

![image-20220505113640805](img/image-20220505113640805.png)

#### 数值

支持所有标准 SQL 数值数据类型。

这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。

关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。

BIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB表。

作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。

| 类型         | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| :----------- | :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- |
| TINYINT      | 1 Bytes                                  | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| SMALLINT     | 2 Bytes                                  | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| MEDIUMINT    | 3 Bytes                                  | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| INT或INTEGER | 4 Bytes                                  | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| BIGINT       | 8 Bytes                                  | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| FLOAT        | 4 Bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| DOUBLE       | 8 Bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |

------

int 可以用 int(数值)，表示显示宽度。实际存储宽度可能会大于显示宽度，也就是说显示不出但后台可以存更高。默认显示宽度分别为 4,6,9,11,20 。可以使用 `unsigned` 修饰符。

decimal 默认是 10,0 。[即 numeric]

 

#### 日期时间

表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。

每个时间类型有一个有效值范围和一个"零"值，当指定不合法的MySQL不能表示的值时使用"零"值。

TIMESTAMP类型有专有的自动更新特性，将在后面描述。

year 的输入可以输入字符串，如直接 insert 时 `'2010'` ，可以输入二位，那么范围 $[1,69]$ 前缀为 `20` ，$[70,99]$ 的前缀为 `19`  。特别地输入 `0` 表示 `0000` 

time 的输入可以 `D HH:MM:SS` , `HH:MM:SS` , `HH:MM` , `D HH:MM` `D HH` , `SS` 字符串，其中 D 为 $[0,34]$ 。转换为小时，即 $24D+HH$ ，因为 $HH$ 可以大于 $24$ 。有含义的 `HHMMSS` 数值也合法，但诸如 `1112` 被解释为 `00:11:12` 。同理 `12` 是 `00:00:12` 。冒号则不一样。注意 `D HH` 的 `HH` 一定是 `02d` 格式的。也可以用函数 `NOW()` 或常数 `CURRENT_TIME` (前者有年月日，后者没有) (可以加括号，下同)。

date 可以用字符串 `YYYY-MM-DD` , `YYYYMMDD` , `YY-MM-DD` ，或数值 `YY-MM-DD` , `YYMMDD` ，或 `NOW()` 或 `CURRENT_DATE`。任何标点符号，如 `-./@` 都可以作为日期部分分割符。

datetime `YYYY-MM-D HH:MM:SS` , `YYYYMMDDHHMMSS` ，范围是 `1000-01-01 00:00:00` 到 `9999-12-3 23:59:59` 。其中 `YYYY` 可简写为 `YY` ，可以有 `00` 。也可以用数字格式。同理分隔符可以不严格。可以用 `now()`

timestamp 范围为 `1970-01-01 00:00:01 UTC` 到 `2038-01-19 03:14:07 UTC` 。 UTC 是 coordinated universal time ，世界标准时间。timestamp 存储时转换，查询时按当前时区输出，所以不同时区对同一数据输出不同。

修改时区例如： `set time_zone='+10:00'`

存储时的实质是存储字符串，而不是十进制数值

| 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                     |
| :-------- | :------------ | :----------------------------------------------------------- | :------------------ | :----------------------- |
| DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |
| TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                   |
| DATETIME  | 8             | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4             | 1970-01-01 00:00:00/2038结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |

日期比较如：`select count(*) from solution where created_at > '2022-12-29';` (datetime 字段比较)



#### 字符串

字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。

| 类型       | 大小                  | 用途                            |
| :--------- | :-------------------- | :------------------------------ |
| CHAR       | 0-255 bytes           | 定长字符串                      |
| VARCHAR    | 0-65535 bytes         | 变长字符串                      |
| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                    |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535 bytes        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                    |

char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。(没赋值的地方用空格补全)

CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。

**查询不区分大小写**，若 binary 才区分大小写。

char 定长； varchar 可变长；前者查询快，后者查询慢。若对 char(n) ，那么多出部分右侧空格填充。

BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。

> 如果使用了 `binary` 字符集或字段是 `BINARY` 类型，则会区分大小写。
>
> 可以通过设置表或列的字符集和排序规则来控制大小写敏感性。例如，使用 `utf8mb4_bin` 排序规则将使比较区分大小写

BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。blob变长。

有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。text变长。

此外还有 enum ，1 或 2 字节(最大65535) 。定义时只能取指定值，即 `字段名 enum('x', 'y', ..)` ，当然可以是字符串，因为实际存的是下标。从 1 开始编号。取时， NULL 对 NULL， 0 对 `"` ，其他照常对。插入时可以输入字符串值或下标。若声明为 null，null值是该列首个有效值，默认值是null。声明not null默认为允许的值列表第一个元素。比较适合诸如性别选择。

有 set ，有多个成员， 1,2,3,4或8字节，取决成员数量(最多64个)。定义和存储原理类似。会自动去重。按定义顺序显示。比如插入 `'a'` ,  `'a,b,c'` 。比较适合诸如爱好选择。

实际存储长度是字符串长度+1，多出一位存长度数值

二进制字符串有 bit , (var)binary , (tiny/medium/long/)blob 。如 bit(二进制位数)，然后插入数值即可。bin函数转数字为二进制，可以用来 select 显示。多余左补 0 ，如 `b'1010'` 。因为二进制，可以存图片、音频等，但不建议这么做。建议存路径。

(var)binary 可以包含二进制字节。前者可右补足 `\0`



### 安装

#### windows

> 废置：官网下载 [这里](https://dev.mysql.com/downloads/windows/installer/8.0.html) ，下载安装包
>
> 选custom，然后点击右边列表的每一项，更改小字点击advance更改安装路径

 [这里](https://dev.mysql.com/downloads/mysql/) 选 No thanks 即可。下完到合适位置直接解压，就是目录了。

接下来配置：在该安装目录(如：`D:\Temps\mysql-8.0.27-winx64`)

新建文件 `my.ini` ，输入：

```ini
[mysql]
default-character-set=utf8

[mysqld]
port = 3306 
basedir=D:\Temps\mysql-8.0.27-winx64
datadir=D:\Temps\mysql-8.0.27-winx64\data
max_connections=200
character-set-server=utf8
default-storage-engine=INNODB 
```

> 对其中路径改成合适的安装路径

以管理员身份运行 cmd (`C:\Windows\System32` 里找到右击) ，进入安装目录，输入：

```shell
mysqld --remove mysql #清除原有
mysqld -install #或install
mysqld --initialize 
net start mysql
```

在安装目录的 `\data` 找到 `.err` 后缀文件，打开看到最后一行，找到初始密码。

登录：

```shell
mysql -uroot -p
```

输入初始密码。

修改密码：

```mysql
ALTER USER 'root'@'localhost' IDENTIFIED BY '新的密码';
exit; -- 退出
```

> 注意: 在 5.7 需要初始化 data 目录：
>
> ```shell
> cd C:\web\mysql-8.0.11\bin 
> mysqld --initialize-insecure 
> ```
>
> 初始化后再运行 net start mysql 即可启动 mysql



#### Linux安装

##### ubuntu

一系列应用如下：

> - **MySQL** - MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。
> - **MySQL-client** - MySQL 客户端程序，用于连接并操作Mysql服务器。
> - **MySQL-devel** - 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。
> - **MySQL-shared** - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。
> - **MySQL-bench** - MySQL数据库服务器的基准和性能测试工具。
>
> 可以使用 MariaDB 代替，MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。
>
> MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。
>
> ```shell
> yum install mariadb-server mariadb 
> ```
>
> mariadb数据库的相关命令是：
>
> ```shell
> systemctl start mariadb  #启动MariaDB
> systemctl stop mariadb  #停止MariaDB
> systemctl restart mariadb  #重启MariaDB
> systemctl enable mariadb  #设置开机启动
> ```

> rpm下卸载参考：
>
> ```shell
> rpm -e mysql　　// 普通删除模式
> rpm -e --nodeps mysql　　// 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除
> ```

##### centos

> 如未安装 mysql，以 centos 为例，gpt：(注意有可能自带 mariadb)
>
> ```sh
> yum update
> yum install wget
> wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm
> rpm -Uvh mysql80-community-release-el7-3.noarch.rpm
> yum install --nogpgcheck mysql-server
> ```

##### 8降5

因特殊需求，如mycat，可能需要降级。以 centos 为例，先卸载：

```sh
systemctl stop mysqld
systemctl disable mysqld
yum remove mysql
```

删库跑路：

```sh
rm -rf /var/lib/mysql/*
```

可能有残留，继续卸载已有的 mysql 相关：

```sh
yum list installed | less #对着这个找，一个个remove
```

安装：[参考](https://blog.csdn.net/weixin_65870997/article/details/124191390)

```sh
rpm -ivh https://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm
yum install -y mysql-server --nogpgcheck
```

启动和开机自启和检查状态

```sh
systemctl start mysqld
systemctl enable mysqld
systemctl status mysqld
```

可能需要按下文改一下 root 密码，可以用 8 + 5 的方法(即开 skip 修改 user 表)

改密码上点强度，否则正常启动时会要求改密码如 `set password=password('abcDEF1+');` 才能执行任何其他操作。

要让外机可连，可以：

```mysql
update mysql.user set host='%' where user='root';
flush privilges;
```



> 下文作废：
>
> 因为 yum 不到，gpt 让去 [mysql官网](https://dev.mysql.com/downloads/mysql/) 装 mysql，点 [archive](https://downloads.mysql.com/archives/community/)，下个压缩包。选 RHEL，看看自己的大版本：(任意执行一个)
>
> ```sh
> cat /etc/centos-release
> cat /etc/redhat-release
> uname -r
> ```
>
> 查看架构是 x86 还是 arm，并查看操作系统位数：
>
> ```sh
> uname -m
> ```
>
> 下一个 server。





#### root密码修改

##### 5

> 开一个快捷键：
>
> ```sh
> #根据 ps -aux | grep mysql 找到 /www/server/mysql/ 为根目录
> ln -s /www/server/mysql/bin/mysqld_safe /usr/bin/mysqld_safe
> ```
>

关闭 mysql：

```sh
service mysql stop
```

开启安全模式：(如果找不到安全模式，按8的操作改 `my.cnf`)

```sh
mysqld_safe --skip-grant-tables &
```

进行免密登录：

```sh
mysql -u root
```

给一个新的代替 root 的用户，因为在安全模式，所以只能修改表，不能 create user，为此先临时修改 root 密码：

```mysql
use mysql;
select authentication_string,user from user; #记录下root的密码
update user set authentication_string=password('password') where user='root';
flush privileges;
exit
```

关闭 mysql 服务，然后重启：

```sh
service mysql stop
service mysql start
```

之后就可以用刚刚设的密码进入 root 账号了，这时开一个有全部权限的新用户：

```mysql
create user 'baicha'@'localhost' identified by 'password';
grant all privileges on *.* to 'baicha'@'localhost' with grant option;
flush privileges;
```

然后测试成功后，可以把 root 的密码改回去。

##### 8

mysql 8 没有 `mysqld_safe`，关掉 service，找到 `/etc/my.cnf`，追加：

```properties
[mysqld]
skip-grant-tables
```

重启，进去，先清空密码然后重建密码：

```mysql
use mysql;
update user set authentication_string='' where user='root'; 
FLUSH PRIVILEGES;
alter user 'root'@'localhost' identified by 'Guodong1+';
```

注意密码要保持强度，不然可能创不了。关掉 `skip-grant-tables`，重启。

目前没有发现 `root` 在非 `localhost` 能修改的办法，如果想要别的用户有全部权限在远程登录，需要用 root 额外创建用户：

```mysql
create user 'baicha'@'%' identified by 'Guodong1+';
grant all privileges on *.* to 'baicha'@'%' with grant option;
FLUSH PRIVILEGES;
```

连接测试：(记得开防火墙)

```sh
mysql -u baicha -h 192.168.126.129 -P 3306 -p
```





## 指令

### 权限指令

#### 理论

用户分为普通和 `root`。后者可以增删改用户，普通用户一般不行。权限表由 `MYSQL_install_db` 脚本初始化。权限信息表主要有 `user,db,host,tables_priv,columns_priv,procs_priv`。

##### 权限表

在数据库 `mysql`。

###### user

记录允许连接到服务器的账户信息，全局级的权限，即有权限就能操作所有数据库。可以 `desc user;` 看表结构。

用户列包括 `Host`, `User`, `authentication_string` 表示主机名、用户名、密码(显然经过加密)。前两者是该表的联合主键。只有这三个值都匹配，才能连接建立。修改用户密码的本质是修改密码列。

权限列表明了允许的操作，字段值类型是 enum，修改权限可以直接改这个列，也可以用 `grant` 语句。

安全列有 6 个子段，两个是 `ssl` 加密，两个是 `x509` 标准用于识别用户，另外两个是授权插件相关的 (`plugin` 字段)，为空使用内部授权验证机制。通过 `show variables like 'have_openssl';` 检查是否支持 `ssl` 功能。

资源控制列，限制用户使用的资源， `max_questions` 每小时允许执行查询操作数； `max_updates` , `max_connections` (连接操作次数)，`max_user_connections` 同时建立连接数。若超出限制，会被锁定，直到下一个小时才能执行对应操作。



###### db

存储用户对某个数据库的操作权限。主键是 `host,user,db`。其中 `create_routine_priv,aalter_routine_priv` 是创建和修改存储过程的权限。host 可以为空。



###### tables_priv

对表设置操作权限。

![image-20220528180802581](img/image-20220528180802581.png)

![image-20220528180823335](img/image-20220528180823335.png)



###### columns_priv

![image-20220528182931268](img/image-20220528182931268.png)



###### procs_priv

存储过程/函数。

![image-20220528183033295](img/image-20220528183033295.png)



##### 访问控制

两个阶段：

- 连接核实阶段，即对密码
- 请求核实阶段，即查命令是否有权做



#### 登录

SHELL 命令。可以查看帮助： `mysql --help`

`mysql` 登陆命令的参数：

- `-h` 主机名，默认 `localhost`
- `-u` 用户名
- `-p` 指定登录密码或随后输入(无密码直接回车)
- `-P` 端口号
- `数据库名` 
- `-e` 执行该参数后的指令 SQL 语句并退出(输出执行结果)

如：

```shell
mysql -u root -p #或mysql -uroot -p
mysql -u root -p test_db -e "DESC person;"
```



> 使用 `mysqld -initialize` 安装 `mysql` 是安全的，因为自动为 `root` 生成标记过期的随机密码，不创建任何匿名账户和 `test` 数据库。



匿名用户：`user`表里 `user` 子段为空字符串，使得任何用户可以连接到数据库。检查是否存在并删除：

```mysql
select * from user where user='';
delete from user where user='';
```





#### 新建

首先选择一个数据库，用：

```mysql
use 数据库名;
```

> 数据库名不需要加引号；列出所有数据库用指令`SHOW DATABASES;`



命令为 

```sql
CREATE USER 用户名 IDENTIFIED BY '密码';
```

如：

```mysql
create user oj identified by 'scnunoj';
```

> 标准格式：
>
> ```mysql
> create user user_specification[,user_speci..]
> ```
>
> 其中后面的参数可以是：
>
> ```mysql
> user@host
> identified by [password] 'password'
> | identified with auth_plugin [as 'auth_string']
> ```
>
> 若选上 `password` 关键字，表示用哈希值设置密码。插件名字可以单引号或双引号。新添加的账号没有任何权限。不能跟已有账户重复。

也可以直接操作表，就插入数据的格式，即：

```mysql
insert into mysql.user(host, user, authentication_string,[权限名字,...]) values ('host','username',md5('密码'),['Y'/'N',...])
```

如：

```mysql
INSERT INTO user
	(host, user, authentication_string,
    select_priv, insert_priv, update_priv)
VALUES ('IP地址', '用户名', MD5(密码), 'Y', 'Y', 'Y')
```

> password() 加密函数已经在 8.0.11 中移除了，可以使用 MD5() 函数代替
>
> 在`5.7`以下，`authentication_string` 是 `password`

可以设置 `Y/N` 的包括：

- Select_priv
- Insert_priv
- Update_priv
- Delete_priv
- Create_priv
- Drop_priv
- Reload_priv
- Shutdown_priv
- Process_priv
- File_priv
- Grant_priv
- References_priv
- Index_priv
- Alter_priv



#### 删除

```mysql
drop user 用户名,[用户名];
```

如：

```mysql
drop user 'user'@'localhost';
drop user; -- 干掉全部
```

不能自动删掉任何打开的用户对话，删的话要等到该用户对话关闭后才会生效。

也可以：

```mysql
delete from mysql.user where host='' and user=''
```

如：

```mysql
delete from mysql.user where host='localhost' and user='baicha';
```



#### 修改

修改密码，直接改表，如：

```mysql
update mysql.user set authentication_string=md5('新密码') where user='root' and host='localhost';
```

修改后要生效，需要刷新：

```mysql
flush privileges;
```

对非 `root` 用户，修改密码可以：

```mysql
set password for 'user'@'localhost' = '密码';
```

也可以跟上面一样的改法。但无论如何都要刷新。

> 没试过：
>
> ```sql
> alter user <username> identified by “<new_password>”;
> ```



#### 授权

使用 grant 命令授权，撤回是 revoke。全局权限是 `grant all on *.*` ，撤回同理。数据库层级就 `on 数据库.*`，表就后者改成表名。子程序可以是全局或数据库、子程序级别的。有 grant 权限的可以执行。语法：

```mysql
grant priv_type [(columns)] [,priv_type columns...]
on [object_type] table1,...
to user [with grant option]
```

`object_type` 有 `table,function,procedure`。升级时要用就要升级授权表。若不指定 `columns` 就是全表。旧版本 `mysql` 。可以设置密码。with 后一个或多个参数：

![image-20220528192244500](img/image-20220528192244500.png)

```mysql
GRANT ALL PRIVILEGES ON 数据库名.* to 用户名@'%' IDENTIFIED BY 'scnuoj';
```

```mysql
FLUSH PRIVILEGES; # 重新加载
```

如：

```mysql
grant all privileges on scnuoj.* to oj@'%' identified by 'scnuoj';
flush privileges;
```

```mysql
-- 给指定数据库TUTORIALS添加用户 zara ，密码为 zara123 
GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
ON TUTORIALS.*
TO 'zara'@'localhost'
IDENTIFIED BY 'zara123';
```

```mysql
grant select,insert on *.* to 'grantUser'@'localhost'
identified by 'grantpwd'
with grant option;
```

```mysql
grant select(classNo,className,institute),update(classNo,className,institute) on scoredb.class to user01, user02;
flush privileges;
-- 那么这两个用户可以查和改这几个列(单独或同时)
```





##### 权限列表

![image-20220528192630499](img/image-20220528192630499.png)

可以使用的权限：

![image-20220528191315792](img/image-20220528191315792.png)

![image-20220528191322149](img/image-20220528191322149.png)

![image-20220528191533380](img/image-20220528191533380.png)

其它权限是管理性操作，用 `mysqladmin` 或 `sql` 语句：

![image-20220528191646834](img/image-20220528191646834.png)

![image-20220528191658497](img/image-20220528191658497.png)



#### 收回

revoke。从 `db,host,table_priv,columns_priv` 删除。语法：

```mysql
revoke all privileges, grant option
from 'user'@'host' [,'user'@'host'...]
```

```mysql
revoke priv_type [(columns)] [,...]
on table1, ...
from 'user'@'host' ,...
```

有全局 `create user,update` 之一的可以使用该权限。

如：

```mysql
revoke update on *.* from 'user'@'localhost';
```



#### 查询

```mysql
show grants for 'user'@'host';
```

或者查表的字段，如：

```mysql
select privileges_list from user where user='' ,  host=''
```

`privileges_list` 如 `select_priv` 等。



#### 自动换密码

8.0

设置账户密码过期时间，过期用户要连接需要更改密码。查看：

```mysql
select user,host,password_last_changed,password_lifeftime,password_expired from mysql.user \G;
```

时间为 `null` 永不过期。设置永不过期，如：

```sql
alter user root@localhost password expire default;
alter user root@localhost password expire interval 260 day; -- 260天过期
```



#### 角色

用户组。

```sql
create role role_name;
```

```mysql
grant select on db.* to role_name;
revoke select on db.* from role_name;
```

```mysql
grant role_name to user@host;
```

```mysql
select * from mysql.default_roles;
select * from mysql_role_edges; -- 用户属于什么角色
```

```mysql
drop role role_name;
```

#### 连接

也可以参见 `其他指令-查询-连接数` 和 `连接最大时长`。

查询到的 id 可以清除：

```mysql
kill connection +6; # 断开id6的连接
```

处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到报错。

> 查看当前所有连接
>
> ```mysql
> show processlist;
> ```
>
> command 列是 sleep 就是连接完 MySQL 服务就没有再执行过任何命令（空闲连接）
>
> time 列是空闲时长（秒）
>
> `wait_timeout` 参数控制最大空闲时长，默认 28800s (8h)，超时自动断开。
>
> ```sql
> show variables like 'wait_timeout';
> ```
>
> 最大连接数：
>
> ```sql
> show variables like 'max_connections';
> ```
>
> 超过最大连接数就拒绝接下来的请求。

### 数据库指令

#### 查询

显示所有数据库。

```mysql
SHOW DATABASES;
```

显示编码：

```mysql
SHOW VARIABLES LIKE 'character_set_database';
```





#### 创建

```mysql
CREATE DATABASE 数据库名;
```

可以用管理员权限在shell时创建：

```shell
mysqladmin -u 管理员帐号名 -p create 数据库名
```

已存在同名时不能创建。



变体：不存在则创建

```mysql
CREATE DATABASE IF NOT EXISTS 数据库名
```

设定编码：

```mysql
CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;
```

`utf8_general_ci` 数据库的校验规则,ci是case insensitive的缩写,意思是大小写不敏感;相对的是cs,即case sensitive,大小写敏感;

MYSQL8.0前默认字符集是 `latin1` ，`utf8` 是 `utf8mb3` ； 8.0 开始，默认编码是 `utf8mb4` 。

> utf8_unicode_ci，用来定义排序的规则，对于mysql中那些字符类型的列，如VARCHAR，CHAR，TEXT类型的列，都需要有一个COLLATE类型来告知mysql如何对该列进行排序和比较。
> GBK编码的默认COLLATE为gbk_chinese_ci，
> utf8mb4编码的默认值为utf8mb4_general_ci
>
> mysql中的utf8最多只能支持3bytes长度的字符编码，对于一些需要占据4bytes的文字，mysql的utf8就不支持了，要使用utf8mb4才行。
>
> \_ci字样，是Case Insensitive的缩写，即大小写无关，也就是说”A”和”a”在排序和比较的时候是一视同仁的。`selection * from table1 where field1=”a”`同样可以把field1为”A”的值选出来。
> 与此同时，对于那些\_cs后缀的COLLATE，则是Case Sensitive，即大小写敏感的。



#### 删除

```mysql
DROP DATABASE 数据库名;
```

或shell：

```shell
mysqladmin -u 管理员帐号名 -p drop 数据库名
```

执行后会出现提示，确认是否删除。而PHP脚本删除，不会出现提示消息。

> 删除数据库对象（表、库、索引、视图等）都用 drop ，删除数据都用 delete

drop 不可以回滚

#### 选择

```mysql
USE 数据库名;
```

选择后，mysql指令会针对这个数据库。



### 数据表指令

#### 枚举

```mysql
SHOW TABLES;
```



#### 查看概况

```mysql
DESC 数据表名;
```

或全称：

```mysql
DESCRIBE 数据表名;
```

查看列名。

查看建表语句(跟真实输入的建表语句不一样，经过转换的)：

```mysql
SHOW CREATE TABLE 数据表名;
```

查看数据库默认编码直接查看建表语句。



可以看当前全部数据表类型：

```mysql
SHOW TABLE STATUS ;
```

查看特定库：

```mysql
show table status from 数据库;
```





其他更多指令：

```mysql
SHOW COLUMNS FROM user; #查看user数据表的所有属性
SHOW INDEX FROM user; #显示数据表的详细索引信息，包括PRIMARY KEY（主键）
SHOW TABLE STATUS from mysql; # 输出数据库性能和统计信息
SHOW TABLE STATUS from mysql LIKE 'time%';     # 表名以time开头的表的信息
SHOW TABLE STATUS from mysql LIKE 'time%'\G;   # 加上 \G，查询结果按列打印
```



#### 创建

```mysql
CREATE TABLE table_name (column_name column_type);
```

```mysql
CREATE TABLE 数据表名(`列名` 列类型, `列名` 列类型, ..., PRIMARY KEY(`主键列名`) ) ENGINE=存储引擎 CHARSET=编码 DEFAULT
```

当数据库有规定 `ENGINE, CHARSET` 时，数据表大概可以不规定

如：

```mysql
CREATE TABLE IF NOT EXISTS runoob_tbl(
   runoob_id INT UNSIGNED AUTO_INCREMENT,
   runoob_title VARCHAR(100) NOT NULL,
   runoob_author VARCHAR(40) NOT NULL,
   submission_date DATE,
   PRIMARY KEY ( runoob_id )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```



#### 删除

```mysql
DROP TABLE 数据表名;
```

> 只清空数据不删掉表可以用 truncate (见数据指令-删除)

drop 不可以回滚，truncate 可以回滚。[力扣](https://leetcode.cn/leetbook/read/job-hunting-all-in-one-school/0sgua6/)

#### 更改

`ALTER`

增删改字段：

```mysql
ALTER TABLE 数据表名 DROP 列名;
ALTER TABLE 数据表名 ADD 列名 数据类型;
ALTER TABLE 数据表名 MODIFY 列名 数据类型;
ALTER TABLE 数据表名 CHANGE 列名 新列名 数据类型;
ALTER TABLE 数据表名 SET DEFAULT 值;
ALTER TABLE 数据表名 DROP DEFAULT;
ALTER TABLE 数据表名 DROP FOREIGN KEY 约束名;
ALTER TABLE 数据表名 ENGINE = 新数据表类型;
ALTER TABLE 数据表名 RENAME TO 数据表名; -- TO 可以不写
```

增加时可以设置位置，用`first`或`after 列名`；增加后会得到全空值。不设置就默认在最后添加。可以设置默认值，`default` 加值。(删掉就默认`NULL`)，修改时也可以用，作为调整位置。设置数据类型时可以附加约束。修改时原列名可以和新列名一样。如果本来`not null`修改时不能漏，不然会默认改成`null`允许的。`modify` 可以实现重排序。

引擎默认为 `InnoDB` ，还支持 `FEDERATED, MRG_MYISAM, MyISAM, BLACKHOLE, CSV, MEMORY, ARCHIVE, PERFORMANCE_SCHEMA` 。

如：

```mysql
alter table student add haha int first;
alter table student drop haha;
alter table student add haha int after id;
alter table student drop haha;
alter table student add haha int;
alter table student drop haha;
alter table student add haha int not null default 580;
alter table student modify haha bigint not null;
alter table student change haha xixi bigint not null;
```

```mysql
ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;
ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;
ALTER TABLE testalter_tbl ENGINE = MYISAM;
ALTER TABLE testalter_tbl RENAME TO alter_tbl;
```

> `show table status;`可以看数据表类型

重命名：rename [参考](https://blog.csdn.net/Kingsea442/article/details/140370507)

```mysql
rename table 旧名字 to 新名字;
```

约束相关：

```mysql
alter table WorksAt add constraint new_primary_key primary key (staffId, firmName);
alter table WorksAt drop primary key;
alter table Staff add constraint CHK_age check (age between 20 and 40);
alter table Staff modify age not null;
```



#### 复制

先复制表结构：

```mysql
CREATE TABLE 新表名 LIKE 旧表名;
```

或：

```mysql
CREATE TABLE 新表名 SELECT * FROM 旧表;
```



再覆盖数据：

```mysql
INSERT INTO 新表名 SELECT * FROM 旧表名; 
```

可以部分复制并同时复制数据：

```mysql
CREATE TABLE 新表名 AS
(
    SELECT 列名, 列名 FROM 旧表名
)
```

可以改列名并同时复制数据：

```mysql
CREATE TABLE 新表名 AS
(
    SELECT 列名 AS 新名字 FROM 旧表名
)
```

如：

```mysql
create table hhh as (select id,student_name as `name` from student);
```

可以用新规则覆盖旧列名，如：

```mysql
create table hhh (id int) as (select * from student);
```

> 部分更新：
>
> ```mysql
> update b set b.col=a.col from a,b where a.id=b.id;
> update b set col=a.col from b inner join a on a.id=b.id;
> update b set b.col=a.col from b left Join a on b.id = a.id;
> ```





#### 计算列

通过别的列计算得到的列。定义：

```sql
col_name data_type [generated always] as (expression) [virtual | stored] [unique [key]] [comment comm] [not null|null] [[primary] key]
```

可以通过 `create table` 或 `alter table` 来搞，例如：

```sql
c int(9) generated always as ((a+b)) virtual
```





#### 检查

查看数据库的类似哈希值(long)

```mysql
checksum table 表名;
```

得到 `Checksum` 属性是 `long` ，跟其他表的作对比可以检查两表是否数据一致



#### explain

后接一条命令。如：

```mysql
explain select * from cart;
```

可以查看性能(如filtered列)。

MySQL中提供了EXPLAIN语句和DESCRIBE语句，用来分析查询语句，EXPLAIN语句的基本语法如下：

```mysql
EXPLAIN [EXTENDED] SELECT select_options
```

使用EXTENED关键字，EXPLAIN语句将产生附加信息。

DESCRIBE语句的使用方法与EXPLAIN语句是一样的，分析结果也是一样的，并且可以缩写成DESC

```mysql
DESCRIBE SELECT select_options
```

执行该语句，可以分析EXPLAIN后面SELECT语句的执行情况，并且能够分析出所查询表的一些特征。下面对查询结果进行解释：

1. id：SELECT识别符。这是SELECT的查询序列号。
2. select_type：表示SELECT语句的类型。
3. table：表示查询的表。
4. type：表示表的连接类型。
5. possible_keys：给出了MySQL在搜索数据记录时可选用的各个索引。
6. key：是MySQL实际选用的索引。(NULL 表示不用到)
7. key_len：给出索引按字节计算的长度，key_len数值越小，表示越快。
8. ref：给出了关联关系中另一个数据表里的数据列名。
9. rows：是MySQL在执行这个查询时预计会从这个数据表里读出的数据行的个数。(近似值)
10. Extra：提供了与关联操作有关的信息。

> extra 里若有 using filesort 表明是外部排序，证明效率较低

重点要关注如下几列：

| 列名    | 备注                                                         |
| ------- | ------------------------------------------------------------ |
| type    | 本次查询表联接类型，从这里可以看到本次查询大概的效率。       |
| key     | 最终选择的索引，如果没有索引的话，本次查询效率通常很差。     |
| key_len | 本次查询用于结果过滤的索引实际长度。                         |
| rows    | 预计需要扫描的记录数，预计需要扫描的记录数越小越好。         |
| Extra   | 额外附加信息，主要确认是否出现 Using filesort、Using temporary 这两种情况。 |

其中，type包含以下几种结果，从上之下依次是最差到最好：

| 类型            | 备注                                                         |
| --------------- | ------------------------------------------------------------ |
| ALL             | 执行full table scan，这是最差的一种方式。                    |
| index           | 执行full index scan，并且可以通过索引完成结果扫描并且直接从索引中取的想要的结果数据，也就是可以避免回表，比ALL略好，因为索引文件通常比全部数据要来的小。 |
| range           | 利用索引进行范围查询，比index略好。                          |
| index_subquery  | 子查询中可以用到索引。                                       |
| unique_subquery | 子查询中可以用到唯一索引，效率比 index_subquery 更高些。     |
| index_merge     | 可以利用index merge特性用到多个索引，提高查询效率。(分别扫描各索引，然后合并结果集) |
| ref_or_null     | 表连接类型是ref，但进行扫描的索引列中可能包含NULL值。        |
| fulltext        | 全文检索。                                                   |
| ref             | 基于索引的等值查询，或者表间等值连接。                       |
| eq_ref          | 表连接时基于主键或非NULL的唯一索引完成扫描，比ref略好。      |
| const           | 基于主键或唯一索引唯一值查询，最多返回一条结果，比eq_ref略好。 |
| system          | 查询对象表只有一行数据，这是最好的情况。                     |

另外，Extra列需要注意以下的几种情况：

| 关键字                       | 备注                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| Using filesort               | 将用外部排序而不是按照索引顺序排列结果，数据较少时从内存排序，否则需要在磁盘完成排序，代价非常高，需要添加合适的索引。 |
| Using temporary              | 需要创建一个临时表来存储结果，这通常发生在对没有索引的列进行GROUP BY时，或者ORDER BY里的列不都在索引里，需要添加合适的索引。 |
| Using index                  | 表示MySQL使用覆盖索引避免全表扫描，不需要再到表中进行二次查找数据，这是比较好的结果之一。注意不要和type中的index类型混淆。 |
| Using index condition        | 使用了索引下推 [参考](https://www.xiaolincoding.com/mysql/base/how_select.html#%E6%89%A7%E8%A1%8C%E5%99%A8) |
| Using where                  | 通常是进行了全表/全索引扫描后再用WHERE子句完成结果过滤，需要添加合适的索引。 |
| Impossible WHERE             | 对Where子句判断的结果总是false而不能选择任何数据，例如where 1=0，无需过多关注。 |
| Select tables optimized away | 使用某些聚合函数来访问存在索引的某个字段时，优化器会通过索引直接一次定位到所需要的数据行完成整个查询，例如MIN()\MAX()，这种也是比较好的结果之一。 |



#### 直方图

8.0

近似获得一列数据分布情况。支持等宽 singleton 和等高 equi-height 。

创建语法：

```sql
analyze table table_name [update histogram on col_name with n buckets | drop histogram on col_name]
```

buckets 默认值 100 ，合法范围是 $[1,100]$ ，取决：这列不同值数目，数据分布情况和准确性要求。存储在数据字典表 `column_statistics` 中，可以通过查询视图 `information_schema.COLUMN_STATISTICS` 访问。以 json 格式存储。`analyze` 会基于表大小自动判断是否取样，和建立什么图。可以多列。如：

```mysql
analyze table flower update histogram on yourprice with 60 buckets;
```

删除：

```mysql
analyze table flower drop histogram on yourprice；
```

直方图创建后永不更新。建立时数据读到内存，然后进行操作。为了避免 MLE ，会根据 `histogram_generation_max_mem_size` 计算读多少行数据到内存，可以用 `set` 语句设置它的值。



#### 注释

每个列可以添加注释，使用 `comment` 关键字接字符串

```mysql
create table server_load( 
	id int not null default 0 comment '用户id' 
) 
```

查看带注释列的表信息：

```mysql
show full columns from server_load;
```

对已有表插入注释：(`alter add column` 等同理)

```mysql
alter table server_load modify column id int not null default 0 comment '用户ID!';
```

表注释：

```mysql
create table test2( 
    field_name int comment '字段的注释' 
)comment='表的注释'; 
```

修改：

```mysql
alter table test2 comment '修改后的表的注释';
```

查看表注释：

```mysql
show create table test2;
```

或：

```mysql
use information_schema; 
select * from TABLES where TABLE_SCHEMA='my_db' and TABLE_NAME='test2' \G
-- 元数据看字段注释
select * from COLUMNS where TABLE_SCHEMA='my_db' and TABLE_NAME='test2' \G
```

#### 临时表

```sql
CREATE TEMPORARY TABLE temp_solved AS SELECT ...;
DROP TEMPORARY TABLE IF EXISTS temp_solved;
```

1. 会话范围：临时表只在创建它的数据库会话中可见，其他会话无法看到或访问它。
2. 自动删除：当创建它的数据库会话结束时，临时表会自动被删除。这意味着通常不需要手动删除临时表，除非你有特定的原因需要在会话结束前删除它。
3. 安全性：使用 `TEMPORARY` 关键字确保即使有同名的持久表存在，也只会删除临时表，不会影响持久表。

检查临时表存在：(任选一个)

```sql
SELECT 1 FROM temp_table_name LIMIT 1; # 不存在报错
CREATE TEMPORARY TABLE IF NOT EXISTS temp_table_name (id INT); # 存在不成功
SHOW TABLES LIKE 'temp_table_name';
```



#### 优化建议

MySQL数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统的反应速度。例如，通过优化文件系统，提高磁盘I\O的读写速度；通过优化操作系统调度策略，提高MySQL在高负荷情况下的负载能力；优化表结构、索引、查询语句等使查询响应更快。

针对查询，我们可以通过使用索引、使用连接代替子查询的方式来提高查询速度。

针对慢查询，我们可以通过分析慢查询日志，来发现引起慢查询的原因，从而有针对性的进行优化。

针对插入，我们可以通过禁用索引、禁用检查等方式来提高插入速度，在插入之后再启用索引和检查。

针对数据库结构，我们可以通过将字段很多的表拆分成多张表、增加中间表、增加冗余字段等方式进行优化。



##### 查询

如果查询时没有使用索引，查询语句将扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。如果使用索引进行查询，查询语句可以根据索引快速定位到待查询记录，从而减少查询的记录数，达到提高查询速度的目的。

索引可以提高查询的速度，但并不是使用带有索引的字段查询时索引都会起作用。有几种特殊情况，在这些情况下有可能使用带有索引的字段查询时索引并没有起作用。

1. 使用LIKE关键字的查询语句

   在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置，索引才会起作用。

2. 使用多列索引的查询语句

   MySQL可以为多个字段创建索引。一个索引可以包括16个字段。对于多列索引，只有查询条件中使用了这些字段中的第1个字段时索引才会被使用。

3. 使用OR关键字的查询语句

   查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，查询中才使用索引。否则，查询将不使用索引。



使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作。

子查询虽然可以使查询语句很灵活，但执行效率不高。执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表。然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。因此，子查询的速度会受到一定的影响。如果查询的数据量比较大，这种影响就会随之增大。

在MySQL中，可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引，性能会更好。



数据量大，建议按照如下顺序进行优化：

1. 优化SQL和索引；
2. 增加缓存，如memcached、redis；
3. 读写分离，可以采用主从复制，也可以采用主主复制；
4. 使用MySQL自带的分区表，这对应用是透明的，无需改代码，但SQL语句是要针对分区表做优化的；
5. 做垂直拆分，即根据模块的耦合度，将一个大的系统分为多个小的系统；
6. 做水平拆分，要选择一个合理的sharding key，为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表。



##### 插入

影响插入速度的主要是索引、唯一性校验、一次插入记录条数等。针对这些情况，可以分别进行优化。

对于MyISAM引擎的表，常见的优化方法如下：

1. 禁用索引

   对于非空表，插入记录时，MySQL会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引会降低插入记录的速度。为了解决这种情况，可以在插入记录之前禁用索引，数据插入完毕后再开启索引。对于空表批量导入数据，则不需要进行此操作，因为MyISAM引擎的表是在导入数据之后才建立索引的。

2. 禁用唯一性检查

   插入数据时，MySQL会对插入的记录进行唯一性校验。这种唯一性校验也会降低插入记录的速度。为了降低这种情况对查询速度的影响，可以在插入记录之前禁用唯一性检查，等到记录插入完毕后再开启。

3. 使用批量插入

   插入多条记录时，可以使用一条INSERT语句插入一条记录，也可以使用一条INSERT语句插入多条记录。使用一条INSERT语句插入多条记录的情形如下，而这种方式的插入速度更快。

   ```
   INSERT INTO fruits VALUES ('x1', '101', 'mongo2', '5.7'), ('x2', '101', 'mongo3', '5.7'), ('x3', '101', 'mongo4', '5.7');
   ```

4. 使用LOAD DATA INFILE批量导入

   当需要批量导入数据时，如果能用LOAD DATA INFILE语句，就尽量使用。因为LOAD DATA INFILE语句导入数据的速度比INSERT语句快。

对于InnoDB引擎的表，常见的优化方法如下：

1. 禁用唯一性检查

   插入数据之前执行set unique_checks=0来禁止对唯一索引的检查，数据导入完成之后再运行set unique_checks=1。这个和MyISAM引擎的使用方法一样。

2. 禁用外键检查

   插入数据之前执行禁止对外键的检查，数据插入完成之后再恢复对外键的检查。

3. 禁用自动提交

   插入数据之前禁止事务的自动提交，数据导入完成之后，执行恢复自动提交操作。



##### 慢查询日志

MySQL中慢查询日志默认是关闭的，可以通过配置文件my.ini或者my.cnf中的log-slow-queries选项打开，也可以在MySQL服务启动的时候使用--log-slow-queries[=file_name]启动慢查询日志。

启动慢查询日志时，需要在my.ini或者my.cnf文件中配置long_query_time选项指定记录阈值，如果某条查询语句的查询时间超过了这个值，这个查询过程将被记录到慢查询日志文件中。

直接分析mysql慢查询日志，利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。

常见慢查询优化：

1. 索引没起作用的情况(上述三种)

2. 优化数据库结构

   - 对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。
   - 对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。

3. 分解关联查询

   很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效。

4. 优化LIMIT分页

   当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。

### 查询指令

#### 概述

读取所有数据：

```mysql
SELECT * FROM 数据表名;
```

通用：

```mysql
SELECT [ALL | DISTINCT] <目标列表达式> [AS] [<别名>]
                 [, <目标列表达式> [AS] [<别名>] ... ]
FROM {<表名> | <视图名> | <查询表>} [AS] [<别名>]
             [, {<表名> | <视图名> | <查询表>} [AS] [<别名>] ... ]
[ WHERE <条件表达式> ]
[ GROUP BY <列名1> [, <列名2> ... ]
   [ HAVING <条件表达式> ] ]
[ ORDER BY <列名表达式> [ASC | DESC] 
                [, <列名表达式> [ASC | DESC] ... ] ]
```

```mysql
SELECT 列名, 列名, ...
FROM 数据表名
[WHERE 从句判断] /*可选：包含任何条件*/
[LIMIT 数目] /*可选：返回记录数*/
[OFFSET 数目] /*可选：开始查询的数据偏移量，默认0*/
```

```mysql
SELECT 字段列表 FROM 数据表名
[WHERE xx] [GROUP BY 字段名] [HAVING 分组条件]
[ORDER BY ASC|DESC]
```

> **having：**用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作
>
> > WHERE是一个约束声明，使用WHERE约束来自数据库的数据，WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数。
> >
> > HAVING是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在HAVING中可以使用聚合函数。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。
> >
> > 从性能的角度来说，HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好
>
> 顺序：
>
> 1. FROM, including JOINs
> 2. WHERE
> 3. GROUP BY
> 4. HAVING
> 5. WINDOW functions
> 6. SELECT
> 7. DISTINCT
> 8. UNION
> 9. ORDER BY
> 10. LIMIT and OFFSET

如：

```mysql
select * from student;
select * from student where id=1;
select * from student where id in (1,2,3) and grade >= 10;
select name,age from tb_emp where sex="female" order by age;
select 'abc'; -- 直接输出，单双引号都行，表达式也行如 3*4，行是写进去的内容，值是计算结果
```



- offset 必须在 limit 下才能用，作用为先偏移后获取不超过 limit 个

- order by 也可以用列名，之后可以加升序降序(默认升序)，可以有多个排序依据。8.0后对 group by 不再隐式排序

  按拼音排序(utf8)为例：`order by convert(列名 using gbk)`

  一个 desc 只对当前关键字起作用

- distinct 关键字取不重复值

- between and 关键字可以取区间(字符串也行)，包含边界

- `%`代表任意零到多个字符，`_`是任一个字符，可以用\\转义

  需要用 like 关键字才能用(不含`%`时等效于`=`)，注意不区分大小写

  需要转移时，用 `escape` ，如 `like '%16\_%' escape '\'` 。

  可以使用能用的正则表达式，用`REGEXP`代替`=`位置即可(^$分别是开头和结尾)，也可以用 `RLIKE`，如 `WHERE CONDITIONS REGEXP '^DIAB1|\\sDIAB1'`

- 不等于可以用 `!=` 或 `<>`

- 使用 binary 关键字设定区分大小写；默认不区分

- 运算符`IS NULL` 当列值是`NULL`返回true；同理有`IS NOT NULL`，有`<=>`运算符，当相等或都为`NULL`返回真

  (不可以使用`=NULL`,`!=NULL`作为比较条件，恒假)

  可以用函数`ifnull(值,成真值)`将`NULL`转掉

- `limit [offset,] length` (或 `limit length offset offsetval`)

- 比较运算符，若比较者是集合(大于一个元组)，需要用 all 或 any(some) 修饰，如 `=any, >all, !=any`。聚合函数不可以直接使用在WHERE子句中所以不能用 max,min取代。(=any 是 in, !=all 是not in)

- as 列别名字符串用任意(单双反)引号括起来(如无空格不用引号也行，下同)，如as 表别名只能反引号或不引号

如：

```mysql
select * from student order by grade;
select * from student order by grade desc;
select * from student_1 order by convert(major using gbk), student_number;
select distinct grade from student;
select * from student where id between 2 and 7;
select * from student where id between '2' and '7';
select * from student_1 where name like '张%' and id>5;
select * from student where binary student_name='abc';
select * from student_1 where student_number regexp "^20202005\\d{3}"; #可以再加一个$
```

> 子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。
>
> 实际可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式

select 可以是表达式即对列名的运算，如：(表达式字符串是结果里新的列名)

```sql
select empId+1 from Employee;
```

#### limit

跳过前三个，输出第四第五个：(limit, offset 参数可以是非负数)

```mysql
select * from orders limit 2 offset 3; -- 不能顺序反过来
select * from orders limit 3,2; -- 第二种写法
```

在偏移量非常大的时候，例如 LIMIT 10000,20 这样的查询，这时MySQL需要查询10020条记录然后只返回最后20条，前面的10000条记录都将被抛弃，这样的代价是非常高的。如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。

优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候，这样做的效率会提升非常大。考虑下面的查询：

```mysql
SELECT film_id,description FROM sakila.film ORDER BY title LIMIT 50,5;
```

可以优化为：

```mysql
SELECT film.film_id,film.description  FROM sakila.film INNER JOIN (  SELECT film_id FROM sakila.film ORDER BY title LIMIT 50,5 ) AS lim USING(film_id);
```

这里的“延迟关联”将大大提升查询效率，它让MySQL扫描尽可能少的页面，获取需要访问的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用于优化关联查询中的LIMIT子句。

> 有时候也可以将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得对应的结果。例如，如果在一个位置列上有索引，并且预先计算出了边界值，上面的查询就可以改写为：
>
> ```mysql
> SELECT film_id,description FROM skila.film WHERE position BETWEEN 50 AND 54 ORDER BY position;
> ```

对数据进行排名的问题也与此类似，但往往还会同时和GROUP BY混合使用，在这种情况下通常都需要预先计算并存储排名信息。

LIMIT和OFFSET的问题，其实是OFFSET的问题，它会导致MySQL扫描大量不需要的行然后再抛弃掉。如果可以使用书签记录上次取数的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET。例如，若需要按照租赁记录做翻页，那么可以根据最新一条租赁记录向后追溯，这种做法可行是因为租赁记录的主键是单调增长的。首先使用下面的查询获得第一组结果：

```mysql
SELECT * FROM sakila.rental ORDER BY rental_id DESC LIMIT 20;
```

假设上面的查询返回的是主键16049到16030的租赁记录，那么下一页查询就可以从16030这个点开始：

```mysql
SELECT * FROM sakila.rental  WHERE rental_id < 16030 ORDER BY rental_id DESC LIMIT 20;
```

该技术的好处是无论翻页到多么后面，其性能都会很好。

由于关键字优先级缘故，如果用了 limit，然后要 union 的话，要用命名子查询，如：

```sql
SELECT * FROM (
    SELECT sex, substr(name,1,1) AS first_name, count(*) AS c1
    FROM student_table
    WHERE sex = '男'
    GROUP BY first_name
    LIMIT 3
) t1
UNION ALL
SELECT * FROM (
    SELECT sex, substr(name,1,1) AS first_name, count(*) AS c1
    FROM student_table
    WHERE sex = '女'
    GROUP BY first_name
    LIMIT 3
) t2;
```



#### UNION

将两个`select`结果组合到一起输出，并去重，如：

```mysql
select id from student union select id from score order by id;
```

所联合的东西必须具有一致列数。如果使用`union all` ，那么不会去重。

可以联合多个表，如：

```mysql
select * from student_2 union select * from student_3 union select * from student_4;
```

同样可以使用 `all` ，使用一次对一次生效(从左到右)

![image-20220519114408219](img/image-20220519114408219.png)

[deepseek](https://chat.deepseek.com/a/chat/s/4337b01d-274a-40ec-8419-d39b4f783a6a)

 - `UNION`：合并结果集并**去重**（删除重复的行）。
 - `UNION ALL`：合并结果集并**保留所有行**，包括重复的行。

性能：

- `UNION ALL` 比 `UNION` 性能更高，因为它不需要去重操作。
- 如果明确知道结果集不会有重复行，或者需要保留重复行，应该使用 `UNION ALL`。

#### GROUP BY

语法：

```mysql
SELECT column_name, function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;
```

可以加上关键字`with rollup` 统计总结果(均值是总均值，累积就累积)在最后一行输出。可以设置分组列名为`coalesce(a,b,c)`，顺次判断，a空选b，b空选c

所用函数通常有：`count, sum, avg, max, min, std`(总体方差)。可以聚多个，如 `sum(price*number)`。聚合函数不能进行运算，如 `>80` 。聚合函数使用 `f(distinct 列名)` 先去重再计算。不去重就不填或填 all。除 `count(*)` 外所有的函数皆跳过空值，只处理非空值。count(字段名)只计算该列非NULL的(若 count(1) 就包含 NULL 行，等效于 `count(*)`)。min,max 可以求字典序

> std, stddev, stddev_pop 都是总体方差，stddev_samp 是样本方差。

> having 是聚合后筛选，where 是聚合前筛选，所以：
>
> having 也可以用非聚合函数，但 where 不能用聚合

例如，统计每个人有多少条记录：

```mysql
select student_id, count(*) from score_1 group by student_id;
select student_id, avg(value) from score_1 group by student_id;
```

统计分数均值、总值和计次：

```mysql
select student_id, avg(value), sum(value), count(*) from score_1 group by student_id with rollup;
```

使得求和列名有意义（非NULL）：

```mysql
select coalesce(student_id, '统计量'), avg(value), sum(value), count(*) from score_1 group by student_id with rollup;
```

```mysql
select sum(distinct value) from infos;
```

函数里可以套 case：

```mysql
CASE [column_name] WHEN [value1] THEN [result1]... ELSE [default] END
```

如：

```mysql
select sum(case usertype when 0 then id when 1 then password else email end) from user;
```

```mysql
select sum(case when usertype<=0 then id when usertype=1 then password else email end) as res from user;
```

使用这种方法可以sum不同的列。也可以完成行列转换(只对特定条件加，其他ignore)

可以将组内每个值连在一起，用 `group_concat`，可以加 distinct, order, separator，如：

```mysql
select sell_date, count(distinct product) as `num_sold`,
    group_concat(distinct product order by product separator ',') as `products`
from Activities group by sell_date order by sell_date
```

上述可以简写为 `group_concat(distinct product)`



#### JOIN

联合多表查询；可以在`SELECT,UPDATE,DELETE` 中使用，分为：

- `INNER JOIN` 内连接(等值连接)(简写为`JOIN`)，得到两表交集 (join 默认 inner)
- `LEFT JOIN` (left outer join)左连接(获取左表所有记录，即使右表没有对应匹配的记录)(得到左表和两表)，区别在于即使右匹配不到，也会强行得到一个NULL作为结果；即：left/right选哪个哪个不为null，如left就左非空右可空
- `RIGHT JOIN` (right outer join)右连接
- `full outer join` (full join)全外连接，左+右 (mysql不支持)
- `cross join` 等价于直接 `,`
- natural join (把 on 自动判定，不需要手写)

> 等值连接：通过WHERE子句中的条件，将两张表连接在一起，它的实际效果等同于内连接。出于语义清晰的考虑，一般更建议使用内连接，而不是等值连接

> 自然连接会去掉重复的列，只保留一个。与内连接区别在于 on 的那两个列，内连接保留两个，自然保留一个。

要配合联合列名的约束条件，用`on`关键字；为了区分开，通常把表名定义，然后用`a.列名` 这样的方法指出 `a` 表的列(若歧义)，如：

```mysql
SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
```

也可以用 using，即代表联表条件的 on=：

```mysql
SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON using(runoob_author);
```

使用 using 的条件：

1. 查询必须是等值连接。
2. 等值连接中的列必须具有相同的名称和数据类型

可以多表查询，如：(?处随便填点什么，#同理写个数字)

```mysql
select a.name, a.major, b.name, b.semester, c.value from 
`student_#` a join
`subject_#` b join
`score_#` c on
a.id = c.student_id and
b.id = c.subject_id and
c.value>=? and 
c.value <=? and
a.name like ? and 
a.major like ? and 
b.name like ? and 
b.semester like ?;
```

> 区分：
>
> - 一对多关联：这种关联形式最为常见，一般是两张表具有主从关系，并且以主表的主键关联从表的外键来实现这种关联关系。另外，以从表的角度来看，它们是具有多对一关系的，所以不再赘述多对一关联了。
> - 多对多关联：这种关联关系比较复杂，如果两张表具有多对多的关系，那么它们之间需要有一张中间表来作为衔接，以实现这种关联关系。这个中间表要设计两列，分别存储那两张表的主键。因此，这两张表中的任何一方，都与中间表形成了一对多关系，从而在这个中间表上建立起了多对多关系。
> - 自关联：自关联就是一张表自己与自己相关联，为了避免表名的冲突，需要在关联时通过别名将它们当做两张表来看待。一般在表中数据具有层级（树状）时，可以采用自关联一次性查询出多层级的数据。

##### 例子

笛卡尔积：

```sql
SELECT Student.StudentID, Course.CourseID
FROM Student
CROSS JOIN Course;
#等价于
SELECT Student.StudentID, Course.CourseID
FROM Student, Course;
```



三种 join

数据：

```sql
CREATE TABLE departments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    department_name VARCHAR(255) NOT NULL
);
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(id)
);
INSERT INTO departments (department_name) VALUES ('Human Resources');
INSERT INTO departments (department_name) VALUES ('Engineering');
INSERT INTO departments (department_name) VALUES ('Marketing');
INSERT INTO employees (name, department_id) VALUES ('Alice', 1);
INSERT INTO employees (name, department_id) VALUES ('Bob', 2);
INSERT INTO employees (name, department_id) VALUES ('Charlie', NULL);
INSERT INTO employees (name, department_id) VALUES ('David', 2);
INSERT INTO employees (name, department_id) VALUES ('Eve', NULL);
```

inner join:

```sql
SELECT employees.name, departments.department_name
FROM employees
INNER JOIN departments ON employees.department_id = departments.id;
```

```
+-------+-----------------+
| name  | department_name |
+-------+-----------------+
| Alice | Human Resources |
| Bob   | Engineering     |
| David | Engineering     |
+-------+-----------------+
```

left join: (对每个左边，要么找到所有右边，要么返回 NULL)(即 left outer join)

```sql
SELECT employees.name, departments.department_name
FROM employees LEFT JOIN departments ON employees.department_id = departments.id;
```

```
+---------+-----------------+
| name    | department_name |
+---------+-----------------+
| Alice   | Human Resources |
| Bob     | Engineering     |
| Charlie | NULL            |
| David   | Engineering     |
| Eve     | NULL            |
+---------+-----------------+
```

right join:

```sql
SELECT employees.name, departments.department_name
FROM employees RIGHT JOIN departments ON employees.department_id = departments.id;
```

```
+-------+-----------------+
| name  | department_name |
+-------+-----------------+
| Alice | Human Resources |
| Bob   | Engineering     |
| David | Engineering     |
| NULL  | Marketing       |
+-------+-----------------+
```

full outer join / full join: 返回两个表中的所有行，包括左表和右表中没有匹配的行,缺失的值用 NULL 填充



natural join

自动匹配：`NATURAL JOIN` 会自动根据两个表中同名的列进行连接。

去重列：在结果集中，同名的列只会出现一次

```sql
select * from person natural join address;
```

natural 只是自动 on，还可以搭配 left / right 如：

```sql
select * from person natural left outer join address;
```



##### 应用例子

求中转一次的(找到所有不存在 `a->b` 但存在 `a->c->b` 的)

```sql
with flights_trunc as (
    select distinct origin_city, dest_city from flights
)
select distinct f2.dest_city as city
from flights_trunc as f1
join flights_trunc as f2 on f1.dest_city = f2.origin_city
where f1.origin_city = 'San Diego ca'
  and f2.dest_city != 'San Diego ca'
  and not exists (
    select 1
    from flights_trunc as f3
    where f3.origin_city = 'San Diego CA'
      and f3.dest_city = f2.dest_city
  )
order by city; -- with 是重要优化; 区分city字符串大小写
```



#### case

参见 `函数指令-流程控制`，也可以用 if。如给树节点分类：

```mysql
select id,
    case when (id in (select id from tree where isnull(p_id))) then 'Root'
    when (id in (select distinct p_id from tree)) then 'Inner'
    else 'Leaf' end as `Type`
from tree -- 或 is null 关键字而不是用函数
```

可以等价于：

```mysql
SELECT
    atree.id,
    IF(ISNULL(atree.p_id),
        'Root',
        IF(atree.id IN (SELECT p_id FROM tree), 'Inner','Leaf')) Type
FROM tree atree
```



```sql
select origin_city, 
round(
sum(case when actual_time < 180 then 1 else 0 end) * 100.0 / count(*), 2
) as percentage
from flights
where canceled = false
group by origin_city
order by percentage desc, origin_city;
```



#### with

8.0

通用表表达式 CTE (Common Table Expressions) ，命名临时结果集

```mysql
with [recursive]
	cte_name [cols] as (subquery)
	[,cte_name [cols] as (subquery) ...]
select / update / delete 
-- 或诸如 insert ... with ... select
-- 或诸如 select ... where in (with ... select ...) ...
```

> ```sql
> with a as(
> SELECT * 
> FROM Student 
> WHERE sex='女')
> SELECT studentNo, studentName, convert(varchar(10),birthday, 111) as birthday
> FROM  a
> WHERE year(birthday)=1999 # convert 是 SQL Server
> ```



> 多个 with:
>
> ```postgresql
> WITH flights_trunc AS (
>     SELECT DISTINCT origin_city, dest_city FROM flights
> ), DirectFlights AS (
>     SELECT DISTINCT dest_city
>     FROM flights_trunc
>     WHERE origin_city = 'San Diego CA'
> ), OneStopFlights AS (
>     SELECT f1.dest_city AS transit_city, f2.dest_city AS final_destination
>     FROM flights_trunc f1
>     JOIN flights_trunc f2 ON f1.dest_city = f2.origin_city
>     WHERE f1.origin_city = 'San Diego CA'
>       AND f2.dest_city != 'San Diego CA'
>       AND f2.dest_city NOT IN (SELECT dest_city FROM DirectFlights)
> )
> SELECT DISTINCT final_destination AS city
> FROM OneStopFlights
> ORDER BY city;
> ```
>
> 



#### 嵌套

同时选修两门课：

```mysql
SELECT a.studentNo, studentName, b.courseNo, b.score, c.courseNo, c.score
FROM Student a, Score b, 
(SELECT * FROM Score WHERE courseNo='002') c
WHERE b.courseNo='001' 
   AND a.studentNo=b.studentNo # 表a与表b的连接条件
   AND a.studentNo=c.studentNo # 表a与表c的连接条件
```

> 对 select 子查询做 from 子表，必须规定名字，如上文的 c (或 as c)

等价于：

```sql
SELECT a.studentNo, studentName, b.courseNo, b.score, c.courseNo, c.score
  FROM Student a, Score b, Score c
  WHERE a.studentNo=b.studentNo # 表a与表b的连接条件
    AND a.studentNo=c.studentNo # 表a与表c的连接条件
        AND b.courseNo='001' # 表b上的选择条件
        AND c.courseNo='002' # 表c上的选择条件
  ORDER BY a.studentNo
```



选修过包含`系统`二字的课程的学生信息：(同理不含就是 not like)

```mysql
SELECT studentNo, studentName, classNo
FROM Student
WHERE studentNo IN 
           ( SELECT studentNo FROM Score
            WHERE courseNo IN 
            ( SELECT courseNo FROM Course
             WHERE courseName LIKE '%系统%' ))
```

```mysql
SELECT studentNo, studentName, classNo
FROM Student
WHERE studentNo IN 
           ( SELECT studentNo 
            FROM Score b, Course c
            WHERE b.courseNo=c.courseNo 
            AND courseName LIKE '%系统%' )
```

```mysql
SELECT DISTINCT a.studentNo, studentName, classNo
FROM Student a, Score b, Course c
WHERE a.studentNo=b.studentNo
 AND b.courseNo=c.courseNo 
 AND courseName LIKE '%系统%' 
```

并不是每一个IN子查询都可以转化为连接运算来实现



除法运算，同时选修两门课的人选的所有课：(也可以用 in 三层)

```mysql
SELECT  a.studentNo, studentName, courseName, score
FROM Student a, Course b, Score c
WHERE  a.studentNo=c.studentNo AND b.courseNo=c.courseNo
AND   a.studentNo IN 
 ( SELECT studentNo FROM Score x, Course y
             WHERE x.courseNo=y.courseNo 
             AND courseName='计算机原理' )
AND   a.studentNo IN 
  ( SELECT studentNo FROM Score x, Course y
             WHERE x.courseNo=y.courseNo 
             AND courseName='高等数学' )
ORDER BY a.studentNo, score DESC
```



查询最高分：

```mysql
SELECT studentNo, courseNo, score
FROM Score
WHERE score=( SELECT max(score) FROM Score )
```

年龄小于班上某个人(即出生日期晚于)

```mysql
SELECT studentNo, studentName, year(getdate())-year(birthday) AS age
FROM Student
WHERE birthday>ANY
( 	SELECT birthday
	FROM Student a, Class b
	WHERE className='计算机科学与技术16-01班' 
	AND a.classNo=b.classNo )
```



exists是逻辑表达式，若子句非空条件为真

exists 的使用：(将元组扔到 exists 子句里判断)(选修了课程的人)

```mysql
SELECT studentName, classNo 
FROM Student x
WHERE EXISTS 
     ( SELECT * FROM Score a, Course b
      WHERE a.courseNo=b.courseNo 
      AND a.studentNo=x.studentNo 
      AND courseName='计算机原理' )
```



全称量词转存在量词：
$$
(\forall c)P(x,c)\Leftrightarrow\lnot(\exists c(\lnot P(x,c)))
$$
如选修了所有课程的学生：

```mysql
SELECT studentName 
FROM Student x
WHERE NOT EXISTS 
( SELECT * FROM Course c
WHERE NOT EXISTS   
-- 判断学生x.studentNo没有选修课程c.courseNo
    ( SELECT * FROM Score
     WHERE studentNo=x.studentNo 
     AND courseNo=c.courseNo )
)
```

解析：

- 整体逻辑：先找一个集合，集合里的人没选修全部课程，然后找出不属于这个集合的人；对于这个集合，等价于这些人不在选修关系里
- 如果一个人选修了所有课程，那么每门课它都修了即最内层select结果非空，所以exists(非空)为真，not exists为假，那么中间层select没有结果，是空集，那么最外层成立
- 如果一个人有一门课没选修，那么这门课not exists为真，中间层不空，所以not exists为假

如：至少选修了特定学号学生所选修的所有课程的学生：

即：不存在一门课程，特定学号学生选修了，且该学生没选修

```mysql
SELECT studentName
FROM Student x
WHERE NOT EXISTS 
    ( SELECT * FROM Score y      // 不能用Course表
     WHERE studentNo='1600002'  
     -- 查询学生'1600002'所选修课程的情况
     AND NOT EXISTS    
     -- 判断学生x.studentNo没有选修课程y.courseNo
         ( SELECT * FROM Score
          WHERE studentNo=x.studentNo 
          AND courseNo=y.courseNo )
    )
```

至少选修了学号为1600002学生所选修的所有课程的学生学号、姓名以及该学生所选修的1600002学生选修过的所有课程的课程名和成绩：

```mysql
SELECT  x.studentNo,  studentName,  courseName,  score 
FROM  Student x, Course y, Score z
WHERE  x.studentNo=z.studentNo AND y.courseNo=z.courseNo 
      AND   NOT EXISTS
   ( SELECT * FROM Score b
    WHERE studentNo='1600002'   -- 查询学生'1600002'所选修课程的情况
    AND NOT EXISTS    -- 判断学生x.studentNo没有选修课程b.courseNo
        ( SELECT * FROM Score
         WHERE studentNo=x.studentNo AND courseNo=b.courseNo )
   )
    AND  y.courseNo IN ( SELECT courseNo FROM Score WHERE studentNo='1600002')
```



至少拿了 28 学分的人：

```mysql
SELECT a.studentNo, studentName, courseName, score, creditHour
FROM Student a, Course b, 
    ( SELECT studentNo, courseNo, max(score) score
     FROM Score
     WHERE score>=60    -- 仅列示已经获得学分(即及格了)的课程
     GROUP BY studentNo, courseNo ) AS c      -- 查询表c
WHERE a.studentNo=c.studentNo AND c.courseNo=b.courseNo 
       AND a.studentNo IN 
   ( SELECT studentNo     -- 子查询Q
     FROM Course x, 
    ( SELECT studentNo, courseNo, max(score) score
     FROM Score
     WHERE score>=60    -- 只有及格才能获得学分
     GROUP BY studentNo, courseNo ) AS y
    WHERE y.courseNo=x.courseNo
    GROUP BY studentNo
    HAVING sum(creditHour)>=28 )
ORDER BY a.studentNo
```



查询至少选修了5门课程且课程平均分最高的同学的学号和课程平均分。如果一个学生选修同一门课程多次，则选取最高成绩：

```mysql
SELECT studentNo, avg(score) avgScore
FROM  ( SELECT studentNo, courseNo, max(score) score
       FROM Score
       GROUP BY studentNo, courseNo ) AS a
GROUP BY studentNo
HAVING count(*)>=5 
 AND avg(score)=
    ( SELECT max(avgScore)    -- 子查询Q2
     FROM ( SELECT studentNo, avg(score) avgScore    -- 子查询Q1
           FROM  ( SELECT studentNo, courseNo, max(score) score
                  FROM Score
                  GROUP BY studentNo, courseNo ) AS b
           GROUP BY studentNo
           HAVING count(*)>=5 ) AS x)
```

非相关子查询指子查询的结果不依赖于上层查询
相关子查询指当上层查询的元组发生变化时，其子查询必须重新执行



查询平均分最高的课程：

```mysql
SELECT a.courseNo, courseName, avg(score) 最高平均分
FROM Course a, Score b
WHERE a.courseNo=b.courseNo
GROUP BY a.courseNo, courseName
HAVING avg(score)=
   ( SELECT max(avgScore)
    FROM ( SELECT avg(score) avgScore
          FROM Score
          GROUP BY courseNo ) x)
```



集合运算 union(并), intersect(交), except(减)可以用其他语句改写

order by表达式可以是列名或表达式

#### 窗口函数

[参考](https://blog.csdn.net/Annabel_CM/article/details/125840831)。mysql8 支持，对旧版本需要手写

窗口函数也称为OLAP（Online Anallytical Processing）函数，意思是对数据库数据进行实时分析处理

```mysql
<窗口函数> OVER (partition by <用于分组的列名>
                order by <用于排序的列名>)
```



###### rank

序号函数。举例：

```mysql
select y, rank() over (order by y desc) as 'rank' from test0;
```

rank 会以后面 over 为排序依据(默认升序，所以要 desc 表示高的第一)

- rank 的排名同名并列时，会占用后边的排名。即如会出现 `1,2,2,4,5,5,7` 的排名
- dense\_rank 并列时，不占用后边的排名，即如 `1,2,2,3,4,4,5`。
- row\_number 仅仅是在排序后给排序后的下标顺序，即如 `1,2,3,4,5,6,7`

mysql8 支持，对旧版本需要手写，以 dense_rank 为例，写成：

```mysql
select 
    s1.Score,
    count(distinct(s2.score)) `rank`
from
Scores s1,Scores s2
where
s1.score<=s2.score
group by s1.Id
order by `rank`
```

在不加 where 时，count 算的就是共有多少个不同的值。如果还不加 group，只有一列，count 结果不变。加了 where 实现排序效果，等同于：

```mysql
select a.Score as Score,
(select count(distinct b.Score) from Scores b where b.Score >= a.Score) as Rank
from Scores a
order by a.Score DESC
```

> 窗口函数效率不一定更优，如下面的需要 1500ms：
>
> ```sql
> select distinct origin_city, dest_city, actual_time as time
> from (
>     select origin_city, dest_city, actual_time,
>            rank() over (partition by origin_city order by actual_time desc) as rank
>     from flights
> ) as ranked_flights
> where rank = 1
> order by origin_city, dest_city;
> ```
>
> 但用其他办法只需要 438ms：
>
>  ```sql
>  with b as (
>  select distinct origin_city, max(actual_time) as time
>  from flights
>  group by origin_city )
>  select distinct a.origin_city, a.dest_city, a.actual_time as time 
>  from flights as a, b where
>  a.origin_city = b.origin_city and 
>  a.actual_time = b.time
>  order by origin_city, dest_city;
>  ```



###### 分布函数

`percent_rank`，即 `(rank-1)/(rows-1)`，语义为严格小于除自己外的整体的百分之多少的人，即如 `0,1/6,1/6,1/2,4/6,4/6,1` (会成浮点)

`cume_dist`，分组内大于等于当前rank值的行数/分组内总行数，即小于等于自己的百分之多少，即如 `1/7,3/7,3/7,4/7,6/7,6/7,1`

###### 前后函数

`lead(列名,v),lag(列名,v)`，表示当前行的前/后v行的该列的值，查无 null，如：

```mysql
select y, lead(y,1) over (order by y desc) as 'prev', lag(y,1) over (order by y desc) as 'post' from test0;
```

###### 头尾函数

截止当前列位置，第一列的某属性 `first_value(列名)` 和当前列的某属性 `last_value(列名)`(注意不保证遍历，即如y相同时有多个x,只恒输出其中一个)

```mysql
select y, first_value(x) over (order by y desc) as 'st', last_value(x) over (order by y desc) as 'ed' from test0;
```

拓展到，`nth_value(列名,n)`，即截止当前列位置，第几行的什么列

> `nfile()`，将分区中的有序数据分为n个桶，记录桶号

###### 聚类函数

`sum,avg,count,max,min(列名)`

#### force index

强制使用索引

```sql
SELECT * 
FROM table_name
FORCE INDEX (index_name)
WHERE condition;
```

```sql
SELECT * FROM users FORCE INDEX (idx_name) WHERE age > 30;
```

#### 慢查询日记

查看是否开启

```sql
SHOW VARIABLES LIKE 'slow_query_log';
```

开启：

```sql
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 秒数;
```

日志文件位置：

```sql
SHOW VARIABLES LIKE 'slow_query_log_file';
```

### 约束指令

#### 概述

- 如果不想字段为 **NULL** 可以设置字段的属性为 **NOT NULL**， 在操作数据库时如果输入该字段的数据为**NULL** ，就会报错。

- PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。单个主键可以直接在定义属性时定义(`属性 类型 PRIMARY KEY [默认值]`)，多个必须用 `PRIMARY KEY(属性,属性, ...)` (也可以加前缀 `CONSTRAINT 约束名`)

  主键的特性：非空，唯一，非必须

- AUTO_INCREMENT定义列为自增的属性，只能用于主键，数值会自动加1。

  MYSQL 5.7 自增起始值重启后会以当前 `MAX` 初始化；而 `8.0` 不会

  可以定义自增起始，如 `) ENGINE=InnoDB AUTO_INCREMENT=6382 DEFAULT CHARSET=utf8 COMMENT='秒杀成功明细表';`

- ENGINE 设置存储引擎，CHARSET 设置编码

- 外键约束：(约束名字不能重复)

  ```mysql
  CONSTRAINT 约束名字 FOREIGN KEY(属性1) REFERENCES 数据表名(该表属性名)
  ```

  (也可以一行属性1，属性2 一一对应)，数据类型、数据表引擎必须匹配，否则报错

  可以写在定义属性时如

  ```sql
  carrier_id varchar(7) references CARRIERS(cid),
  ```

  有外键约束的，不可删除被外键指向的一列；数据表也是

- 也可以做表达式判定，用 `check(逻辑表达式)` ，如：

  ```mysql
  check(classNum > 0 and classNum < 50)
  constraint checkClassNum check(classNum > 0 and classNum < 50)
  ```

  如果使用了如 `sysdate()` ，那么是动态的，不是以建表时日期为准

- 唯一性约束：`UNIQUE` ，可以单独定义，也可以定义属性时定义，允许为空但只允许一次

- 默认值：`DEFAULT 值 `，定义属性时定义

  当前时间默认值如 `create_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP`

- `on delete cascade` 来设置外键约束，以便在删除父表中的记录时，自动删除子表中相关的记录

> 规定行格式和存储用 BTREE (参考 `数据库.md-理论-MySQL-架构组成-存储层-行格式`)
>
> ```sql
> CREATE TABLE `t_user` (
> `id` int(11) NOT NULL,
> `name` VARCHAR(20) DEFAULT NULL,
> `phone` VARCHAR(20) DEFAULT NULL,
> `age` int(11) DEFAULT NULL,
> PRIMARY KEY (`id`) USING BTREE
> ) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
> ```

#### 外键约束

- foreign key (键) 指向另外一个表的主键
- 级联删除：删除主键，对应外键的一起删了

```mysql
drop table if exists m1;
create table m1 (mid int primary key); -- 必须主键
insert into m1 values (10);
drop table if exists t1 ;
create table t1 (tid int, managerid int);
insert into t1 values (1, NULL);
insert into t1 values (2, 10);
insert into t1 values (3, 10);
-- insert into t1 values (5, 11); 有这个就无法添加外键
alter table t1 add foreign key (managerid) references  m1(mid) on delete cascade;
-- insert into t1 values (5, 11); will fail
select * from t1;
delete from m1;
select * from t1; -- only 1 NULL left
```



### 索引指令

> 索引是一个单独的、存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针。使用索引可以快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。
>
> 索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。MySQL中索引的存储类型有两种，即BTREE和HASH，具体和表的存储引擎相关。MyISAM和InnoDB存储引擎只支持BTREE索引；MEMORY/HEAP存储引擎可以支持HASH和BTREE索引。
>
> 索引的优点主要有以下几条：
>
> 1. 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。
> 2. 可以大大加快数据的查询速度，这也是创建索引的主要原因。
> 3. 在实现数据的参考完整性方面，可以加速表和表之间的连接。
> 4. 在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间。
>
> 增加索引也有许多不利的方面，主要表现在如下几个方面：
>
> 1. 创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。
> 2. 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。
> 3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。
>
> 
>
> 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。
>
> 1. 普通索引和唯一索引
>
>    普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。
>
>    唯一索引要求索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
>
>    当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度
>
>    主键索引是一种特殊的唯一索引，不允许有空值。
>
> 2. 单列索引和组合索引
>
>    单列索引即一个索引只包含单个列，一个表可以有多个单列索引。
>
>    组合索引是指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀集合。
>
>    假设在id、name、age字段上已经成功建立了一个名为MultiIdx的组合索引。索引行中按id、name、age的顺序存放，索引可以搜索id、（id,name）、（id, name, age）字段组合。如果列不构成索引最左面的前缀，那么MySQL不能使用局部索引，如（age）或者（name,age）组合则不能使用该索引查询。
>
>    在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。
>
> 3. 全文索引
>
>    全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。
>
> 4. 空间索引
>
>    空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MyISAM的表中创建。
>
> 创建索引时，需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。
>
> 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。
>
> 所有引擎支持每个表至少 16 个索引，总长度至少 256 byte 。类型有 btree 和 hash 。myisam 和 innodb 只支持 btree , memory / heap 可以同时支持。
>
> 普通索引可以重复和null。唯一索引可以null但不可以重复。组合索引那么组合值必须唯一。主键索引不能null。全文索引是 fulltext 类型，在定义的列上全文查找，允许重复和空，可以在 char, varchar, text 里，只有 myisam 支持。空间索引有  geomerty, point, linestring, polygon ，使用 spatial 关键字拓展，使得能用个创建正则索引类似的语法创建空间索引；必须是 not null 和 myisam 。
>
> 经验原则：不要太多以影响磁盘 IO ，避免在常更新的表设很多，数据小的不要设，条件表达式经常用的且取值范围大的可以设，频繁排序和分组的可以设，唯一性可以设。
>
> > 1. 避免对经常更新的表进行过多的索引，并且索引中的列要尽可能少。应该经常用于查询的字段创建索引，但要避免添加不必要的字段。
> > 2. 数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。
> > 3. 在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引，如果建立索引不但不会提高查询效率，反而会严重降低数据更新速度。
> > 4. 当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。
> > 5. 在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。

#### 主键索引

一张表最多只有一个主键索引，索引列的值不允许有空值。(USING BTREE 可以不写)

```mysql
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```

#### 普通索引

##### 创建

```mysql
CREATE INDEX indexName ON table_name (column_name);
```

> 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。

建表时添加的详细为：

```mysql
create table name [col_name data_type] 
[unique|fulltext|spatial] [index|key] [index_name] (col_name [length]) [asc|desc]
```

> index 和 key 是同义词。索引长度只对字符串类型能用。默认 col_name 为索引值。 8.0 支持降序排序(5.7实际创建还是升序的)

添加索引：

```mysql
ALTER table tableName ADD INDEX indexName(columnName)
```

创建时指定：

```mysql
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
INDEX [indexName] (username(length))  
 
);  
```

> 升序索引比降序索引效率高

如：  

```mysql
index(bookNo)
unique index uniqIdx(bookNo)
index(bookNo, readerNo) # 联合索引
fulltext index idx2(info)
```



##### 删除

```mysql
DROP INDEX [indexName] ON mytable; 
```

或

```mysql
ALTER TABLE testalter_tbl DROP INDEX c;
```



#### 唯一指引

索引列的值必须唯一，但允许有空值(可以有多个 null)。如果是组合索引，则列值的组合必须唯一。指令如下：

```mysql
CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
```

```mysql
ALTER table mytable ADD UNIQUE [indexName] (username(length))
```

```mysql
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
UNIQUE [indexName] (username(length))   
 -- (usrname) 括号不好省略
);  
```

#### 前缀索引

前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。

使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。

在创建表时，创建前缀索引的方式如下：

```sql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 
```

建表后，如果要创建前缀索引，可以使用这面这条命令：

```sql
CREATE INDEX index_name
ON table_name(column_name(length)); 
```

#### 函数索引

MySQL 8.0 开始：

```sql
alter table t_user add key idx_name_length ((length(name)));
```



#### 修改

有四种方式来添加数据表的索引：

- **ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):**

  该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。

- **ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):** 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。

- **ALTER TABLE tbl_name ADD INDEX index_name (column_list):** 添加普通索引，索引值可出现多次。

- **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。

如：

```mysql
ALTER TABLE testalter_tbl ADD INDEX (c);
ALTER TABLE testalter_tbl DROP INDEX c;
```

主键作用于列上（可以一个列或多个列联合主键），添加主键索引时，你需要确保该主键默认不为空（NOT NULL）

```mysql
ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;
ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
ALTER TABLE testalter_tbl DROP PRIMARY KEY;
```



#### 显示

```mysql
SHOW INDEX FROM 数据表名
```

> 可以加\G以列表而不是表格来显示结果

也可以查看建表来看 `show create table 表名 \G`

![image-20220519183246250](img/image-20220519183246250.png)



#### 使用检查

可以使用EXPLAIN语句查看索引是否正在使用。

举例，假设已经创建了book表，并已经在其year_publication字段上建立了普通索引。执行如下语句：

```mysql
EXPLAIN SELECT * FROM book WHERE year_publication=1990;
```

EXPLAIN语句将为我们输出详细的SQL执行信息，其中：

- possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。
- key行是MySQL实际选用的索引。

如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。



> 索引是否起作用，主要取决于字段类型：
>
> - 如果字段类型为字符串，需要给in查询中的数值与字符串值都需要添加引号，索引才能起作用。
> - 如果字段类型为int，则in查询中的值不需要添加引号，索引也会起作用。
>
> IN的字段，在联合索引中，按以上方法，也会起作用。
>
> 在MySQL中模糊查询 mobile like ‘%8765’，这种情况是不能使用 mobile 上的索引的，那么如果需要根据手机号码后四位进行模糊查询，可以添加冗余转置列，然后查 `5678%` 方法进行改造。



可以采用以下几种方式，来避免索引失效：

1. 使用组合索引时，需要遵循“最左前缀”原则；

2. 不在索引列上做任何操作，例如计算、函数、类型转换，会导致索引失效而转向全表扫描；

3. 尽量使用覆盖索引（之访问索引列的查询），减少 select * 覆盖索引能减少回表次数；

   覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖

4. MySQL在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描；

5. LIKE以通配符开头（%abc）MySQL索引会失效变成全表扫描的操作；

6. 字符串不加单引号会导致索引失效（可能发生了索引列的隐式转换）；

7. 少用or，用它来连接时会索引失效。

> 我们可以加入冗余列（MySQL5.7之后加入了虚拟列，使用虚拟列更合适，思路相同），比如 mobile_reverse，内部存储为 mobile 的倒叙文本，如 mobile为17312345678，那么 mobile_reverse 存储 87654321371，为 mobile_reverse 列建立索引，查询中使用语句 mobile_reverse like reverse(’%5678’) 即可。
>
> reverse 是 MySQL 中的反转函数，这条语句相当于 mobile_reverse like ‘8765%’ ，这种语句是可以使用索引的。

下列几种情况，是不适合创建索引的：

1. 频繁更新的字段不适合建立索引；
2. where条件中用不到的字段不适合建立索引；
3. 数据比较少的表不需要建索引；
4. 数据重复且分布比较均匀的的字段不适合建索引，例如性别、真假值；
5. 参与列计算的列不适合建索引。



#### 原理

##### 存储

在MySQL中，索引是在存储引擎层实现的，不同存储引擎对索引的实现方式是不同的

m阶B+树的性质：

- 每个节点至多m个叶子节点
- 根节点外每个节点至少m/2(下取整)个叶子节点；根节点至少两个叶子节点
- k个叶子的节点有k个关键字
- 所有叶子节点高度相等

B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止

> m阶B树：(只写区别)
>
> - 非根节点关键字个数在m/2上取整-1到m-1之间(含边界)
> - 非根非叶节点度数是关键字个数+1

B+树由B树和索引顺序访问方法演化而来，它是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接

B+树索引在数据库中的一个特点就是高扇出性，例如在InnoDB存储引擎中，每个页的大小为16KB。在数据库中，B+树的高度一般都在2～4层，这意味着查找某一键值最多只需要2到4次IO操作，这还不错。因为现在一般的磁盘每秒至少可以做100次IO操作，2～4次的IO操作意味着查询时间只需0.02～0.04秒。



MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址，MyISAM索引的原理图如下。这里假设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复

<img src="img/B6A769BBCE3D6116F2514841EA0AB92D.png" alt="img" style="zoom:67%;" />

> 从本质上来说，联合索引还是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2，参考下图。另外，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，所以使用联合索引时遵循最左前缀集合
>
> <img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645693369847/12531E6FCCD03F60C46C9397E1DD8ACA" alt="img" style="zoom:50%;" />

如果我们在Col2上建立一个辅助索引，则此索引的结构同样也是一颗B+Tree

而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

> 在InnoDB存储引擎中，可以将B+树索引分为聚簇索引和辅助索引（非聚簇索引）。无论是何种索引，每个页的大小都为16KB，且不能更改。
>
> 聚簇索引是根据主键创建的一棵B+树，聚簇索引的叶子节点存放了表中的所有记录。辅助索引是根据索引键创建的一棵B+树，与聚簇索引不同的是，其叶子节点仅存放索引键值，以及该索引键值指向的主键。也就是说，如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚簇索引来得到数据，这种查找方式又被称为书签查找。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚簇索引。

下图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

<img src="img/E93917AAC699168036AF5C36393FFC04.png" alt="img" style="zoom:67%;" />

InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。下图为定义在Col3上的一个辅助索引。这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录

不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

##### 重构

需要重构：

1. 表上频繁发生update,delete操作；
2. 表上发生了alter table ..move操作（move操作导致了rowid变化）。

一般看索引是否倾斜的严重，是否浪费了空间，对索引进行结构分析(实测好像无效，没这条指令)

```mysql
analyze index index_name validate structure;
```

在相同的session中查询index_stats表：

```mysql
select height,DEL_LF_ROWS/LF_ROWS from index_stats;
```

当查询的height>=4（索引的深度，即从根到叶节点的高度）或DEL_LF_ROWS/LF_ROWS>0.2的情况下，就应该考虑重建该索引

- drop原索引，然后再创建索引：

  ```mysql
  drop index index_name;
  create index index_name on table_name (index_column);
  ```

  这种方式相当耗时，一般不建议使用。

- 直接重建索引：

  ```mysql
  alter index indexname rebuild;
  alter index indexname rebuild online;
  ```

  此方法较快，建议使用。

rebuild是快速重建索引的一种有效的办法，因为它是一种使用现有索引项来重建新索引的方法。如果重建索引时有其他用户在对这个表操作，尽量使用带online参数来最大限度的减少索引重建时将会出现的任何加锁问题。由于新旧索引在建立时同时存在，因此，使用这种重建方法需要有额外的磁盘空间可供临时使用，当索引建完后把老索引删除，如果没有成功，也不会影响原来的索引。利用这种办法可以用来将一个索引移到新的表空间。

1. Rebuild以index fast full scan或table full scan方式（采用那种方式取决于cost）读取原索引中的数据来构建一个新的索引，重建过程中有排序操作，rebuild online执行表扫描获取数据，重建过程中有排序的操作；
2. Rebuild会阻塞DML操作，rebuild online不会阻塞DML操作；
3. rebuild online时系统会产生一个SYS_JOURNAL_xxx的IOT类型的系统临时日志表，所有rebuild online时索引的变化都记录在这个表中，当新的索引创建完成后，把这个表的记录维护到新的索引中去，然后drop掉旧的索引，rebuild online就完成了。

注意：

1. 执行rebuild操作时，需要检查表空间是否足够；
2. 虽然说rebuild online操作允许DML操作，但还是建议在业务不繁忙时间段进行；
3. Rebuild操作会产生大量Redo Log；



##### hash

hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树，对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。它们有以下的不同：

- hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
- hash索引不支持使用索引进行排序，原理同上。
- hash索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为hash函数的不可预测。
- hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
- hash索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。

因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。



### 数据指令

#### 插入

```mysql
INSERT INTO 数据表名 (列名1, ...) VALUES (值1, ...);
```

如：

```mysql
INSERT INTO runoob_tbl
(runoob_title, runoob_author, submission_date)
VALUES
("学习 MySQL", "菜鸟教程", NOW());
```

```mysql
insert into tb_emb values(2,'lr580','啊','啊啊');
```

对有自增主键的，列里可以不包含这个列；没定义 `not null` 的也可以缺省

为了防止中文乱码，可以事先设置：

```mysql
set names utf8;
```

可以一次插入多个行，逗号隔开，多条记录一个语句插效率更高，如：

```mysql
insert into student (student_name, grade) values ('abc',3),('aBC',4);
```

其实可以插入值`NULL`

如果列按顺序来且都有赋值，第一个括号可以不要，如：

```mysql
insert into student values (14,'aaa',55);
```

可以用 `ignore` 关键字，无则插有则忽略(但warning)。可以用 `replace into` ，无则插有则换。如：

```mysql
replace into student values (7,'qwq',666);
insert ignore into student values (7,'qwq',666);
```

如果插入多个时，其中一个出错(比如重复主键(跟已有或输入的多个重复))，整个语句打断，一条插入也不执行。

可以将查询结果批量插入，如：(见数据表指令-复制)

```mysql
insert into test2 select * from test;
```



#### 更新

```mysql
UPDATE 数据表名 SET 字段名 = 新字段值 WHERE 条件表达式
```

可以逗号分隔，更改多列

可以自增自减

如：

```mysql
update tb_emp set age = 24 where id = 2;
update student set student_name='www',grade=123 where id=7;
update student set grade=grade-1 where id=7;
```

可以多表查然后更改：

> ```mysql
> update t1,t2 set t1.v=t2.v where t1.id=t2.id;
> ```



#### 删除

```mysql
DELETE FROM 数据表名 WHERE 条件表达式
```

如：

```mysql
delete from tb_emp where id = 1024;
```

> 如果没有`where` 子句就是删掉整个表。
>
> delete，drop，truncate 都有删除表的作用，区别在于：
>
> -  1、delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除
> -  2、delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚(不记日志)
> -  3、执行的速度上，**drop>truncate>delete**
>
> truncate 约等于 drop + create ，变为初始大小。delete 删了之后数据表大小不变。
>
> drop 不可以回滚，delete, truncate 可以回滚 [参考](https://leetcode.cn/leetbook/read/job-hunting-all-in-one-school/0sgua6/)

```mysql
delete a from Person a, Person b
where a.email=b.email and a.id>b.id #功能:对所有重复的邮箱只保留id最小的
```

### 视图指令

视图：虚表，不存数据，只存定义。建视图不会随着关闭 CLI 而删除。

#### 创建

不执行查询指令，创建跟查询相同定义的视图

```mysql
create view 视图名 as 查询指令;
```

通用格式：

```mysql
create view 视图名 [(列名[,列名……])] as 子查询 [with check option]
```

详细：

```sql
create [on replace] [algorithm = {undefined | merge | temptable}] view view_name [cols] as select_statement [with [cascade | local] check option]
```

如果 `with check option` ，那么增删改必须满足创建时的条件。如果增改了不符合条件的元素，那么查询时查不出来。

列名不定义就跟查询得到的一样。但若目标列是聚集函数或表达式、多表连接同列名时必须写列名。(select 处定义也行)

> replace 表示替换已存在的，需要有 drop 权限。算法分别表示自动选择、试图语句与试图定义合并(定义的某一部分取代语句对应部分)、存入临时表然后用临时表执行语句。cascade 默认，更新时满足相关条件，local满足视图条件即可。
>
> 跨选择的数据库建视图要作用域，如 `db_name.view_name` 

视图的常用功能之一是计算一些由数据库基本信息计算得出的信息，如出生日期计算年龄

> 基于保留主码基本表的视图是行列子集视图；视图可建立在多个基本表，或视图上

> 如：
>
> ```mysql
> CREATE VIEW ScoreView
> AS
>       SELECT a.studentNo, studentName, courseName, creditHour, score
>       FROM Student a, Course b, Score c
>       WHERE a.studentNo=c.studentNo AND b.courseNo=c.courseNo
>              AND score>=60     -- 成绩必须大于等于60分才能获得学分
> ```
>
> ```mysql
> CREATE VIEW SourceView(courseNo, courseName, courseCount, courseAvg)
> AS
>       SELECT a.courseNo, courseName, count(*), avg(score)
>       FROM Course a, Score b
>       WHERE a.courseNo=b.courseNo
>       GROUP BY a.courseNo, courseName
> ```
>
> 上例也可以在 select 取名，不在一开始取，即：
>
> ```mysql
> SELECT a.courseNo, courseName, count(*) courseCount, avg(score) courseAvg
> ```
>
> ```mysql
> CREATE VIEW SourceView2
> AS SELECT * FROM SourceView WHERE courseCount>=5
> ```



#### 查询

等价于把查询条件和视图条件融合起来再查基本表。 (视图消解)

对聚合函数的运算，会被消解为 having 。如：

> ```mysql
> SELECT * FROM SourceView WHERE courseAvg>=80
> ```



#### 更新

通过视图来直接增删改及本表数据。如果创建视图的语句中包含了表达式，或聚合运算，或消除重复值运算，则不能对视图进行更新操作(一般行列子集视图可以更新，其他类型的一般不更新)。不建议对视图更新。语法同数据指令。

更新字段可以 `create or relpace view` 或 `alter` 。如：

```mysql
create or replace view view_t as select * from flower;
```

或 alter ：

```mysql
alter view view_t as select * from flower;
```



#### 删除

```mysql
drop view 数据表名 [cascade]
```

cascade 是级联删除，选中时，若该视图导出了其他视图，一并删除。

删除基本表时，由该基本表导出的所有视图都必须显式地使用DROP VIEW语句删除。



#### 查看

可以 `describe` / `desc`。也可以 `show table statuc like 'view_name' \G` 。也可以 `show create view view_name \G` 。也可以看系统表：

```mysql
select * from infomation_schema.views;
```





### 事务指令

#### 事务理论

##### 概念

并发情况下，读操作可能存在的三类问题：脏读、不可重复读、幻读

读脏数据：如果事务T2读取事务T1修改但未提交的数据后，事务T1由于某种原因中止而撤销，这时事务T2就读取了不一致的数据。数据库中将这种读未提交且被撤销的数据为读“脏数据”。

丢失更新：两个或多个事务都读取了同一数据值并修改，最后提交事务的执行结果覆盖了前面提交事务的执行结果，从而导致前面事务的更新被丢失

不可重复读。是指事务Ti两次从数据库中读取的结果不同，可分为三种情况：

- 事务Ti读取一数据后，事务Tj对该数据进行了更改。当事务Ti再次读该数据时，则会读到与前一次不同的值。
- 事务Ti按某条件读取数据库中某些记录后，事务Tj删除了其中部分记录。当事务Ti再次按相同条件读取时，发现记录数变少了。（幻影现象1）
- 事务Ti按某条件读取数据库中某些记录后，事务Tj插入了新的记录。当事务Ti再次按相同条件读取时，发现记录数变多了。（幻影现象2）

脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。

不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。

##### ACID

> - 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
> - 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
> - 事务用来管理 insert,update,delete 语句
>
> 一般来说，事务是必须满足4个条件（ACID）：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）
>
> - **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
> - **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
> - **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
> - **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失
>
> 实现：
>
> - 实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚靠的是undo log，当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
>
>   undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作。对于insert，回滚时会执行delete。对于delete，回滚时会执行insert。对于update，回滚时则会执行相反的update，把数据改回去。
>
> - InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool。当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。
>
>   Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。
>
>   于是，redo log被引入来解决这个问题。当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作。当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。
>
>   既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：
>
>   - 刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。
>   - 刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入。而redo log中只包含真正需要写入的部分，无效IO大大减少。
>
> - 隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们主要考虑最简单的读操作和写操作(加锁读等特殊读操作会特殊说明)，那么隔离性的探讨，主要可以分为两个方面。
>
>   第一方面，(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。
>
>   隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。
>
>   按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差。行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。
>
>   第二方面，(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性。
>
>   InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题，使用的是MVCC。MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：
>
>   1. 隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log的指针等。
>   2. 基于undo log的版本链：每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。
>   3. ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本。但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。
>
> - 可以说，一致性是事务追求的最终目标。前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。实现一致性的措施包括：
>
>   - 保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。
>   - 数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等。
>   - 应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。
>
> 
>
> 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交
>
> 8.0 InnoDB 支持 DDL 事务完整性， DDL 操作要么成功要么回滚，后者写入日志到 `data dictionary` 数据字典隐藏表 `mysql.innodb_ddl_log` 。通过设置参数可以将 DDL 操作日志打印输出到错误日志中。意思是执行到一半发现报错的指令，会全部撤销掉，而不是一半执行一半不执行。 
>
> TPL 事务处理语言

##### 日志

binlog（Binary Log）：

二进制日志文件就是常说的binlog。二进制日志记录了MySQL所有修改数据库的操作，然后以二进制的形式记录在日志文件中，其中还包括每条语句所执行的时间和所消耗的资源，以及相关的事务信息。

默认情况下，二进制日志功能是开启的，启动时可以重新配置--log-bin[=file_name]选项，修改二进制日志存放的目录和文件名称。

redo log：

重做日志用来实现事务的持久性，即事务ACID中的D。它由两部分组成：一是内存中的重做日志缓冲（redo log buffer），其是易失的；二是重做日志文件（redo log file），它是持久的。

InnoDB是事务的存储引擎，它通过Force Log at Commit机制实现事务的持久性，即当事务提交（COMMIT）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的COMMIT操作完成才算完成。这里的日志是指重做日志，在InnoDB存储引擎中，由两部分组成，即redo log和undo log。

redo log用来保证事务的持久性，undo log用来帮助事务回滚及MVCC的功能。redo log基本上都是顺序写的，在数据库运行时不需要对redo log的文件进行读取操作。而undo log是需要进行随机读写的。

undo log：

重做日志记录了事务的行为，可以很好地通过其对页进行“重做”操作。但是事务有时还需要进行回滚操作，这时就需要undo。因此在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。

redo存放在重做日志文件中，与redo不同，undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment），undo段位于共享表空间内。

##### 事务类别

> 事务可以分为以下几种类型：
>
> - 扁平事务：是事务类型中最简单的一种，而在实际生产环境中，这可能是使用最为频繁的事务。在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束。处于之间的操作是原子的，要么都执行，要么都回滚。
> - 带有保存点的扁平事务：除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。
> - 链事务：可视为保存点模式的一个变种。链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的。
> - 嵌套事务：是一个层次结构框架。有一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。
> - 分布式事务：通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。对于分布式事务，同样需要满足ACID特性，要么都发生，要么都失效。
>
> 对于MySQL的InnoDB存储引擎来说，它支持扁平事务、带有保存点的扁平事务、链事务、分布式事务。对于嵌套事务，MySQL数据库并不是原生的，因此对于有并行事务需求的用户来说MySQL就无能为力了，但是用户可以通过带有保存点的事务来模拟串行的嵌套事务。

##### 锁

锁是数据库系统区别于文件系统的一个关键特性，锁机制用于管理对共享资源的并发访问。

共享锁（shared lock, 记为S）：如果事务T获得了数据对象Q的共享锁，则事务T可读Q但不能写Q。

排它锁（exclusive lock, 记为X）：如果事务T获得了数据对象Q上的排它锁，则事务T既可读Q又可写Q。

> 理解锁的作用：（ for update 就是排他锁，相对地 lock in share mode 是共享锁）
>
> 两个会话如果正在：
>
> ```mysql
> start transaction;
> select * from test where id = 1 lock in share mode;
> ```
>
> 这两个会话可以同时进行。但如果添加第三个会话如下：
>
> ```mysql
> start transaction;
> select * from test where id = 1 for update;
> ```
>
> 则第三个会话超时报错 [参考](https://blog.csdn.net/u011547570/article/details/121232774)

如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，称这种情况为锁兼容。但若有其他的事务T3想获得行r的排他锁，则其必须等待事务T1、T2释放行r上的共享锁，这种情况称为锁不兼容。下图显示了共享锁和排他锁的兼容性，可以发现X锁与任何的锁都不兼容，而S锁仅和S锁兼容。需要特别注意的是，S和X锁都是行锁，兼容是指对同一记录（row）锁的兼容性情况。

“锁相容”是指如果Ti已持有数据对象Q的某类型锁后，事务Tj也申请对Q的封锁。如果允许事务Tj获得对Q的锁，则称事务Tj申请锁类型与事务Ti的持有锁类型相容；否则称为不相容。

基本锁类型的封锁相容性原则：共享锁与共享锁相容，排它锁与共享锁、排它锁与排它锁是不相容的。

InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。

InnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：(I: Intention)

- 意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。
- 意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。

由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫以外的任何请求。故表级意向锁与行级锁的兼容性如下图所示。

![img](img/C8651AED80A6A771DDAFBECABC9D6BED.png)

InnoDB存储引擎有3种行锁的算法，其分别是：

- Record Lock：单个行记录上的锁。

  只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁

  当表中锁定其中的某几行时，不同的事务可以使用不同的索引锁定不同的行。另外，不论使用主键索引、唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁

- Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。

  阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生。

- Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。

Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。Next-Key Lock是结合了Gap Lock和Record Lock的一种锁定算法，在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。采用Next-Key Lock的锁定技术称为Next-Key Locking，其设计的目的是为了解决Phantom Problem（幻读）。而利用这种锁定技术，锁定的不是单个值，而是一个范围，是谓词锁（predict lock）的一种改进。

死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。

> A等待B、B等待A，这种死锁问题被称为AB-BA死锁。
>
> ![img](img/5600879DF5CAE148E2EF7CC23C367B6E.png)

解决死锁问题最简单的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。

除了超时机制，当前数据库还都普遍采用wait-for graph（等待图）的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。InnoDB存储引擎也采用的这种方式。wait-for graph要求数据库保存以下两种信息：

- 锁的信息链表；
- 事务等待链表；

通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。这是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务。

锁升级（Lock Escalation）是指将当前锁的粒度降低。举例来说，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。

InnoDB存储引擎不存在锁升级的问题。因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。



##### 隔离级别

> SQL 标准定义了四种隔离级别，这四种隔离级别分别是：
>
> - 读未提交（READ UNCOMMITTED）；
> - 读提交 （READ COMMITTED）；
> - 可重复读 （REPEATABLE READ）；
> - 串行化 （SERIALIZABLE）。
>
> 事务隔离是为了解决脏读、不可重复读、幻读问题，下表展示了 4 种隔离级别对这三个问题的解决程度：
>
> | 隔离级别         | 脏读   | 不可重复读 | 幻读   |
> | ---------------- | ------ | ---------- | ------ |
> | READ UNCOMMITTED | 可能   | 可能       | 可能   |
> | READ COMMITTED   | 不可能 | 可能       | 可能   |
> | REPEATABLE READ  | 不可能 | 不可能     | 可能   |
> | SERIALIZABLE     | 不可能 | 不可能     | 不可能 |
>
> 上述4种隔离级别MySQL都支持，并且InnoDB存储引擎默认的支持隔离级别是REPEATABLE READ，但是与标准SQL不同的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock的锁算法，因此避免了幻读的产生。所以，InnoDB存储引擎在默认的事务隔离级别下已经能完全保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE隔离级别。
>
> 这四种隔离级别的实现机制如下：
>
> 1. READ UNCOMMITTED & READ COMMITTED：
>
>    通过Record Lock算法实现了行锁，但READ UNCOMMITTED允许读取未提交数据，所以存在脏读问题。而READ COMMITTED允许读取提交数据，所以不存在脏读问题，但存在不可重复读问题。
>
> 2. REPEATABLE READ：
>
>    使用Next-Key Lock算法实现了行锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。
>
> 3. SERIALIZABLE：
>
>    对每个SELECT语句后自动加上LOCK IN SHARE MODE，即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。
>
> 





#### 支持查看

查看支持事务操作的引擎：

```mysql
show engines;
```

查看一个表的引擎：

#### 事务控制

- BEGIN 或 START TRANSACTION 显式地开启一个事务；
- COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；
- ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
- SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；
- RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；(但是不会回滚)
- ROLLBACK TO identifier 把事务回滚到标记点；
- SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

处理事务的两种方法：

1、用 BEGIN, ROLLBACK, COMMIT来实现

- **BEGIN** 开始一个事务
- **ROLLBACK** 事务回滚
- **COMMIT** 事务确认

2、直接用 SET 来改变 MySQL 的自动提交模式:

- **SET AUTOCOMMIT=0** 禁止自动提交
- **SET AUTOCOMMIT=1** 开启自动提交

> 使用`savepoint`必须关

例如：

```mysql
begin;
insert into score values(5);
# 当前生效，但不永久生效；
insert into score values(6);
commit;
select * from score;
begin;
insert into score values(7);
rollback;
select * from score;
```

```mysql
set autocommit=0;
begin;
insert into score values(5);
savepoint svp;
select * from score;
insert into score values(6);
rollback to svp;
select * from score;
insert into score values(7);
release savepoint svp;
commit;
```

#### 超时时间

参数 如 InnoDB, `innodb_lock_wait_timeout` 默认 50 秒。

#### 事务开始

- 第一种：begin 或 start transaction 命令；(begin 单独打一个单词)
- 第二种：start transaction with consistent snapshot 命令；

这两种开启事务的命令，事务的启动时机是不同的：

- 执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机；
- 执行了 start transaction with consistent snapshot 命令，就会马上启动事务。

#### autocommit

执行一条语句是否自动提交事务，是由 `autocommit` 参数决定的，默认是开启。所以，执行一条 update 语句也是会使用事务的。

#### 当前读

普通 select 是快照读，这个是当前读

`SELECT ... FOR UPDATE` 是一种 SQL 语句，用于在进行事务处理时锁定一组数据行，直到事务结束。加上排它锁（exclusive lock）

```mysql
START TRANSACTION;
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;
UPDATE accounts SET balance = balance + 100 WHERE id = 1;
COMMIT;
```

`SELECT ... FOR UPDATE` 只在事务中有效，且该事务必须支持行级锁定

#### 两阶段事务

eXtended Architecture

```sql
XA START 'xid'; -- 开启一个XA事务，其中xid是事务ID
-- 执行一些SQL操作
XA END 'xid'; -- 结束事务的操作阶段
XA PREPARE 'xid'; -- 准备提交事务
XA COMMIT 'xid'; -- 提交事务
XA ROLLBACK 'xid'; -- 回滚事务(结束后)
```



### 锁指令

#### 全局锁

使用：

```sql
flush tables with read lock
```

会阻塞的：数据 CUD，表结构更改(alter, drop)

释放：手动或会话断开

```sql
unlock tables
```

#### 表锁

```sql
lock tables t_student read; -- 表级别的共享锁，也就是读锁
lock tables t_student write; -- 表级别的独占锁，也就是写锁
```

查看所有表锁：(in_use 列是 1)

```sql
SHOW OPEN TABLES WHERE In_use > 0;
```

每次执行 lock 之前会把先前的锁全部释放，所以要同时多表加锁：

```sql
lock tables tmp write, employees read;
```

释放所有：(没有释放特定， lock 可以实现特定)

```sql
unlock tables;
```

#### 行级锁

InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁

普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为锁定读。

```mysql
select ... lock in share mode -- 对读取的记录加共享锁
select ... for update; -- 对读取的记录加独占锁
```

必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。

同时会自动加意向锁。

#### 锁查询

```sql
select * from performance_schema.data_locks\G;
```

开启事务才有用(如 `start transaction`)，而且要设置 `performance_schema=ON`。检查：

```sql
SHOW VARIABLES LIKE 'performance_schema';
```

列解释：

- `LOCK_TYPE` 行级/表级
- `LOCK_MODE` 哪种行级，是 X 还是 S 等。
- `LOCK_DATA` 索引数据。有虚拟正无穷数据 supremum pseudo-record
- `INDEX_NAME` 所用索引，如 `primary`
- `LOCK_STATUS` GRANTED(成功)或WAITING(阻塞)

#### 死锁检测

参数 `innodb_deadlock_detect` 设置为 on。

### 操作指令

暂时不会分类的东西

#### 临时表

> 临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表
>
> 临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间；使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁

创建数据表时，增加关键字 `TEMPORARY` 即可，其他操作基本是一样的；特别的，`show tables;` 不会看到临时表；可以用 `drop table` 手动删除，不过退出时会自动删除的

如：

```mysql
CREATE TEMPORARY TABLE SalesSummary (
    product_name VARCHAR(50) NOT NULL,
    total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00,
    avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00
    ,total_units_sold INT UNSIGNED NOT NULL DEFAULT 0
);
```

可以查询时创建：

```mysql
CREATE TEMPORARY TABLE 临时表名 AS
(
    SELECT *  FROM 旧的表名
    LIMIT 0,10000
);
```



#### 元数据

以下命令语句可以在 MySQL 的命令提示符使用，也可以在脚本中 使用，如PHP脚本。

| 命令               | 描述                      |
| :----------------- | :------------------------ |
| SELECT VERSION( )  | 服务器版本信息            |
| SELECT DATABASE( ) | 当前数据库名 (或者返回空) |
| SELECT USER( )     | 当前用户名                |
| SHOW STATUS        | 服务器状态                |
| SHOW VARIABLES     | 服务器配置变量            |

后两个很长；user是`名@IP`，如：`root@localhost`



#### 序列

即自增 `auto_increment` 。

使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。

要重置这个值需要删掉该列再加入，但是需要谨防数据混乱。

默认值起始为1，修改的话建表的时候`auto_increment=起始值`即可，或：

```mysql
ALTER TABLE t AUTO_INCREMENT = 100;
```



#### 重复处理

在 MySQL 数据表中设置指定的字段为 **PRIMARY KEY（主键）** 或者 **UNIQUE（唯一）** 索引来保证数据的唯一性

可以尝试双主键：

```mysql
CREATE TABLE person_tbl
(
   first_name CHAR(20) NOT NULL,
   last_name CHAR(20) NOT NULL,
   sex CHAR(10),
   PRIMARY KEY (last_name, first_name)
);
```

或 UNIQUE 索引：

```mysql
CREATE TABLE person_tbl
(
   first_name CHAR(20) NOT NULL,
   last_name CHAR(20) NOT NULL,
   sex CHAR(10),
   UNIQUE (last_name, first_name)
);
```



如果我们设置了唯一索引，那么在插入重复数据时，SQL 语句将无法执行成功,并抛出错。

INSERT IGNORE INTO 与 INSERT INTO 的区别就是 INSERT IGNORE INTO 会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。如：

```mysql
INSERT IGNORE INTO person_tbl (last_name, first_name)
VALUES( 'Jay', 'Thomas'), ( 'Jay', 'Thomas');
```

插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而 REPLACE INTO 如果存在 primary 或 unique 相同的记录，则先删除掉。再插入新记录。



统计重复：

```mysql
SELECT COUNT(*) as repetitions, last_name, first_name
FROM person_tbl
GROUP BY last_name, first_name
HAVING repetitions > 1;
```



选择时读取不重复数据，加入`distinct`，如：

```mysql
SELECT DISTINCT last_name, first_name FROM person_tbl;
```

或用`group by`列，如：

```mysql
SELECT DISTINCT last_name, first_name FROM 
GROUP BY (last_name, first_name);
```

数据表去重，先建一个表，插入选中的所有去重后元素，然后删掉原表，然后这个表改名为原表名，或单纯增加一下主键，如：

```mysql
ALTER IGNORE TABLE person_tbl
ADD PRIMARY KEY (last_name, first_name);
```



#### 手动报错

如：

```mysql
signal sqlstate 'HY000' set message_text = '不允许插入';
```



#### 注入

1. 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双"-"进行转换等。
2. 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。
3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
4. 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。
5. 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装
6. sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。







### 其他指令

看不到的可以看基本-使用章节或基本

#### 导出

##### SQL格式

需要 process 权限，如果没有的话 grant 下。

```shell
mysqldump -uroot -p 数据库名 数据表名 > 输出文件名.sql
mysqldump -uroot -p 数据库名 数据表名,表名2,... > 输出文件名.sql
mysqldump -uroot -p 数据库名 > 输出文件名.sql
mysqldump -uroot -p --databases 库名,库名.. > 输出文件名.sql
mysqldump -uroot -p --all-databases > 输出文件名.sql #含系统数据库
```

> 或 `-p密码` ，这种方法通常用于非输入式。注意文件名所在的目录要存在。

如：

```shell
mysqldump -uroot -p javase > test.sql
mysqldump -uroot -p javase score > test.sql
mysqldump -uroot -p javase s1, s2 > test.sql
```

可以 `-P端口 -hIP` , `-u用户名 -p密码` 的方式导出非本地数据库如：

```shell
mysqldump -uroot -p -P3306 -h127.0.0.1 went > abcc.sql
```

> 可以用 `--tab=路径`，如：
>
> ```shell
> mysqldump -u root -p --no-create-info
> --tab=/tmp RUNOOB runoob_tbl
> ```

输出的文件 `.sql` 实质是指令集，执行后能够得到与之一样的数据库格式和数据，会在注释里表明工具版本号、备份账号名称、主机信息、数据库名、服务器版本号。会看到格式为诸如 `/*!40101 set @a=1*/;` 的语句，这些语句会被 `mysql` 执行，其他DBMS当成注释。意思是当且仅当版本号不小于那个数字时执行。`@@` 是系统变量，不能够自己新建。

> `mysqldump`，加 `–single-transaction` 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持可重复读隔离级别的事务的存储引擎。对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。

##### 文本格式

也可以上指令：在`select`时`into outfile '路径'`

在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。(具体见下)

```mysql
SELECT a,b,a+b INTO OUTFILE '/tmp/result.text'
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
LINES TERMINATED BY '\n'
FROM test_table;
```

- LOAD DATA INFILE是SELECT ... INTO OUTFILE的逆操作，SELECT句法。为了将一个数据库的数据写入一个文件，使用SELECT ... INTO OUTFILE，为了将文件读回数据库，使用LOAD DATA INFILE。

- SELECT...INTO OUTFILE 'file_name'形式的SELECT可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。

- 输出不能是一个已存在的文件。防止文件数据被篡改。

- 你需要有一个登陆服务器的账号来检索文件。否则 SELECT ... INTO OUTFILE 不会起任何作用。

- 在UNIX中，该文件被创建后是可读的，权限由MySQL服务器所拥有。这意味着，虽然你就可以读取该文件，但可能无法将其删除

- 分割符可以是字符串而不是单字符，注意 line 的末行也会分隔，如：

  ```mysql
  FIELDS TERMINATED BY '|0F1e1d+|' LINES TERMINATED BY '|0Tup1e+|'
  ```

- 可以对换行符，`"` 等字符加转义符特殊处理，即：

  ```mysql
  OPTIONALLY ENCLOSED BY '"'
  ```

   `OPTIONALLY ENCLOSED BY` 子句，指定了一个字符来包围字段值，但这只在必要时才会发生。这意味着如果字段值中包含字段分隔符（如逗号）或其他特殊字符，那么这个值将被指定的字符包围。

  例如，假设你有一个字段值 `New York, NY`，在导出为 CSV 时：

  - 没有使用 `OPTIONALLY ENCLOSED BY`： 字段可能会被错误地分割为 "New York" 和 "NY" 两个不同的字段。
  - 使用 `OPTIONALLY ENCLOSED BY '"'`： 字段会被导出为 `"New York, NY"`，因此即使包含逗号，它也会被视为一个完整的字段。

> 在写出的时候会出现The MySQL server is running with the --secure-file-priv option so it cannot execute this statement的错误解决方法：
>
> 出现这个错误是因为没有给数据库指定写出文件的路径或者写出的路径有问题。
>
> 首先使用下面的命令 **show variables like '%secure%';** 查看数据库的存储路径。如果查出的 secure_file_priv 是 null 的时候就证明在 my.ini 文件里面没有配置写出路径。
>
> 这时候就可以在 mysql.ini 文件的 [mysqld] 代码下增加 secure_file_priv=E:/TEST 再重启 mysql 就可以了。然后在导出的地址下面写上刚才配置的这个地址 eg: **select \* from tb_test into outfile "E:/TEST/test.txt"；**就可以了。



> 若在服务器上备份且表都是 `myisam`，应该考虑使用 `MYSQLhotcopy`。
>
> ```shell
> mysqlhotcopy db_name_1, .... /path/new_directory
> ```
>
> 如：
>
> ```shell
> pysqlhotcupy -u root -p test /usr/backup
> ```
>
> 需要有 `select,reload(即flush tables),lock table` 权限。本质是将表所在目录复制到另一个位置，只适用于 `myisam,archive`，也不能跨操作系统。

> 也可以暴力复制备份，如对 windows，在 `C:\Documents and Settings\All Users\Application Data\MYSQL\MYSQL Server 8.0\data` 或用户自定义，对 linux 在 `/var/lib/MYSQL/` 具体情况具体分析，直接复制。需要版本相同。主版本号(第一个数字)相同的话，数据库文件格式相同。
>
> 保持备份一致性，要备份前执行：
>
> ```mysql
> lock tables;
> flush tables;
> -- 或者：
> flush tables with read lock;
> ```
>
> 这样复制时允许用户查询；flush 作用是确保备份前所有激活的索引页写入硬盘。



单表

```mysql
select ... into outfile 'filename' [option];
```

将一个查询语句结果导出到外部文件。默认`\t`分割，`\n`换行，`NULL`得`\N`。选项有：

![image-20220529160802020](img/image-20220529160802020.png)

`files` 和 `lines` 都有时，前者必须在前面。一般是在服务器用的，客户端只能用这样的形式调用：

```shell
mysql -e "select ... > file_name"
```

导出的可以用 `load data infile` 导入。

导出的目录有权限限制，可以查看：

```mysql
show global variables like '%secure%';
```

要自定义导出路径需要修改 `my.ini` ，如注释掉 `secure-file-priv` 行，添加 `secure-file-priv="D:/"` 来修改。

如：

```mysql
select * from db1.tb1 into outfile 'D:/abc.txt';
select * from d.t into outfile 'D:/abc2.txt'
fields terminated by ',' enclosed by '\"' escaped by '\''
lines terminated by '\r\n';
```

 

也可以用 `MYSQLdump`，指定 `-T` 参数和选项，那么多导出一个 `txt`：

![image-20220529161857041](img/image-20220529161857041.png)

如：

```shell
mysqldump -T D:\ test_db person -u root -p
mysqldump -T D:\ test_db person -u root -p --fields-terminated-by=, --fields-optionally-enclosed-by\" --files-escaped-by? --lines-terminated-by=\r\n
```

也可以用 `mysql -e 语句`，如：

```shell
mysql -u root -p --execute="select * from abc;" dbname > filename.txt
```

 输入 `--vertical` 输出显示结果。输入 `--html` 导出为 `html` 格式文件，得到一张表格。也可以用 `--xml` ，得到 `resultset,row,field`等子段。

##### 路径

如果 `select into outfile` 的路径没有权限，可以查看权限：

```sh
SHOW VARIABLES LIKE 'secure_file_priv';
```

`--secure-file-priv` 选项用于限制 MySQL 服务器读写文件的位置，以增强安全性。这个选项可以设置为三种值之一：

1. 空字符串 (`''`)：表示禁止服务器读写文件。
2. NULL：表示没有限制，服务器可以在任何位置读写文件。
3. 特定的路径：服务器只能在该路径下读写文件。

更改调配置文件。

#### 导入

##### 创建数据库

`mysqladmin -h 端口号 -u 用户名 -p密码 create 数据库名`

也可以输入密码的方式，下同

如：

```shell
mysqladmin -h 127.0.0.1 -u root -p1 create test
```



##### 导入数据表

`cmd /c mysql -h 端口号 -u 用户名 -p密码 < 文件名.sql`

> cmd /k在执行命令后不关掉命令行窗口 cmd /c在执行完命令行后关掉命令行窗口 

如：(本地的话 `-h 127.0.0.1` 可以不写)

```shell
mysql -h 127.0.0.1 -u root -p1 test < tb_thu.sql
```

数据库主版本号相同可以直接迁移，如：

```shell
mysqldump -h www.bac.cm -uroot -ppassword dbname |
mysql -h www.bcd.com -uroot -ppasword
```

> 旧升新好升，新降旧比较麻烦。
>
> windows 下可以用 `MyODBC` 实现 `MySQL` 和 `SQL Server` 迁移。官方工具 `MYSQL Migration Toolkit` 也可以做迁移。



##### source

source 命令导入数据库需要先登录到数库终端：

```mysql
create database abc;      # 创建数据库
use abc;                  # 使用已创建的数据库 
set names utf8;           # 设置编码
source /home/abc/abc.sql  # 导入备份数据库
```



##### load data

MySQL 中提供了LOAD DATA INFILE语句来插入数据。通用格式：

```mysql
load data infile 'filename.txt' into table tablename [option] [ignore number lines]
```

ignore 是忽略头多少行。

以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。

```shell
mysql> LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl;
```

如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。

你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。

两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。

如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。

```mysql
LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl
FIELDS TERMINATED BY ':'
LINES TERMINATED BY '\r\n';
```

LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。

如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下：

```mysql
LOAD DATA LOCAL INFILE 'dump.txt' 
INTO TABLE mytbl (b, c, a);
```



##### mysqlimport

mysqlimport 客户端提供了 LOAD DATA INFILEQL 语句的一个命令行接口。不需要登录 mysql 客户端。mysqlimport 的大多数选项直接对应 LOAD DATA INFILE 子句。 

从文件 dump.txt 中将数据导入到 mytbl 数据表中, 可以使用以下命令：

```shell
mysqlimport -u root -p --local mytbl dump.txt
```

mysqlimport 命令可以指定选项来设置指定格式,命令语句格式如下：

```shell
mysqlimport -u root -p --local --fields-terminated-by=":" --lines-terminated-by="\r\n"  mytbl dump.txt
```

mysqlimport 语句中使用 --columns 选项来设置列的顺序：

```shell
mysqlimport -u root -p --local --columns=b,c,a mytbl dump.txt
```

------

mysqlimport的常用选项介绍

| 选项                         | 功能                                                         |
| :--------------------------- | :----------------------------------------------------------- |
| -d or --delete               | 新数据导入数据表中之前删除数据数据表中的所有信息             |
| -f or --force                | 不管是否遇到错误，mysqlimport将强制继续插入数据              |
| -i or --ignore               | mysqlimport跳过或者忽略那些有相同唯一 关键字的行， 导入文件中的数据将被忽略。 |
| -l or -lock-tables           | 数据被插入之前锁住表，这样就防止了， 你在更新数据库时，用户的查询和更新受到影响。 |
| -r or -replace               | 这个选项与－i选项的作用相反；此选项将替代 表中有相同唯一关键字的记录。 |
| --fields-enclosed- by= char  | 指定文本文件中数据的记录时以什么括起的， 很多情况下 数据以双引号括起。 默认的情况下数据是没有被字符括起的。 |
| --fields-terminated- by=char | 指定各个数据的值之间的分隔符，在句号分隔的文件中， 分隔符是句号。您可以用此选项指定数据之间的分隔符。 默认的分隔符是跳格符（Tab） |
| --lines-terminated- by=str   | 此选项指定文本文件中行与行之间数据的分隔字符串 或者字符。 默认的情况下mysqlimport以newline为行分隔符。 您可以选择用一个字符串来替代一个单个的字符： 一个新行或者一个回车。 |

mysqlimport 命令常用的选项还有 -v 显示版本（version）， -p 提示输入密码（password）等

![image-20220529163124940](img/image-20220529163124940.png)



##### hotcopy

用 `MYSQLhotcopy` 备份后的恢复，在服务器停止运行时，直接复制、给权限和重启即可，如：

```shell
chown -R abc.sql /var/lib/mysql/dbname
cp -R /usr/backup/abc usr/local/mysql/data
```

若数据库已存在，先删掉。注意版本必须兼容。



#### 查询

##### 引擎

系统表类型：

```mysql
select distinct(engine) from information_schema.tables;
```



##### 警告

```mysql
show warnings;
```



##### 连接数

查看当前所有连接

```mysql
show processlist;
```

command 列是 sleep 就是连接完 MySQL 服务就没有再执行过任何命令（空闲连接）

time 列是空闲时长（秒）。更多参见 `权限指令-连接`

##### 连接最大时长

`wait_timeout` 参数控制最大空闲时长，默认 28800s (8h)，超时自动断开。

```sql
show variables like 'wait_timeout';
```

更多参见 `权限指令-连接`

##### 储存目录

```mysql
SHOW VARIABLES LIKE 'datadir';
```

更多参见 `数据库.md-理论-MySQL-架构组成-存储层`。

#### 配置

##### 全局设置

###### 时区

例如： `set time_zone='+10:00'`  设置为东十区



###### 编码

在 `my.ini` ，找到 `default-character-set` , `character-set-server` ，改为想要的，如 `gbk, gb2312, latin1` ，然后重启。

查询： `show variables like 'character_set_%'` 

临时修改，如： `set names utf8;`

###### 临时表

```mysql
SET GLOBAL tmp_table_size =512*1024*1024; （512M）
SET global innodb_buffer_pool_size= 1*1024*1024*1024 (1G);
```



##### 严格模式

非严格模式不会理字符串越界。



### 函数指令

#### 内置

> 可以见 [列表](https://www.runoob.com/mysql/mysql-functions.html)
>



常用：数学函数、字符串函数、日期和时间函数、聚合函数和系统函数等

##### 数学

有 `abs, pi, sign` 。

有 `sqrt` ，负数返回 null 。`mod(x,y)` 返回 $x\bmod y$ ，可以是小数。有 `power(a,b)`。会丢失精度如 2^62 不准。

有 `ceil` / `ceiling` ，不小于目标的最小整数 (bigint) 和 `floor` 。

有 `rand(种子)` 取随机数 $[0,1]$ 

`round(x,y)` 返回最接近 $x$ 的保留小数点后 $y$ (若负则前) $y$ 位。四舍五入。truncate 参数同理，截断小数部分。

有 `pow` / `power` ，有 `exp` ，输出常数则 `exp(1)` 。有 `log` (以 $e$ 为底)，有 `log10` 。负数返回 null 。

有 `radians` ， `degrees` 。用弧度制有六种三角函数。超出值返回 null 。

`conv(n, base1, base2)` 进制转换，从 base1 到 base2 。英文用大写。基数范围 $[2,36]$

`inet_aton(expr)` 将 4 或 8 位地址转换为十进制数。如 `inet_aton('192.168.1.1')` 。反函数是 `inet_ntoa` 。

窗口函数(传入集合，返回多行结果)，8.0 新增，如 rank 。按升序排序，使用举例：

```mysql
select *,rank() over w1 from infos window w1 as (order by value);
select *,(value/sum(value) over()) from infos; -- 求百分比
```



##### 字符串

求长度 `char_length` ，中文算 1 。而用 `length` 的话，中文算 3 。

合并 `concat(s1, s2, ...)` 。存在 null 就 null。存在二进制就变二进制。用 `concat_ws(sep, s1, s2, ...)` ，在两两之间添加分割符 (with separator)

替换 `insert(s1, x, len, s2)` 将 s1 从 x 开始的长为 len 被取代。若 x 超过越界返回原始，下标从 1 开始，若大于从 x 开始。如 `insert('quest',2,4,'what)='qwhat'` , `insert('quest',-1,4,'what)='quest'` , `insert('quest',3,100,'what)='quwhat'` , `insert('jinle',4,1,'sangze')='jinsangzee` 

大小写转换， `lower` 或 `lcase` ； `upper` 或 `ucase` 。希腊字母也行。

取长为 n 的前/后缀 `left(s,n)` , `right(s,n)` 

填充 `lpad(s1, len ,s2)` , 将 s1 长度变为 len ，不足部分用 s2 填充。如 `lpad('xingyue',10,'xo')='xoxxingyue'`  , `rpad('xingyue',5,'qwq')=lpad('xingyue',5,'qwq')='xingy'` 

删除空白字符 `ltrim, rtrim, trim` 。可以 `trim(s1 from s)` ，把 s 里的首尾 s1 全部干掉。

字符串乘法 `repeat(s,n)` 。用 `space(n)` 等于 `repeat(' ',n)` 。

字符串替换 `replace(s,s1,s2)` , 用 s2 替换 s 里所有 s1 子串。不会递归下去。

字典序比较 `strcmp` ，返回 $\pm1$ 或 $0$ 

获得子串 `substring(s,n,len)` ，从 n 开始(负的语法同 python),len越界就本来长度有多长算多长。同名函数是 `mid` 。若 len 小于 1 得到空串。(n 1-indexed)

匹配子串开始的位置 `locate(substr, str), position(subs in str), instr(str, substr)` (instr首次出现位置,1-indexed)。找不到返回 0 。

转置 `reverse` 。

`elt(n, s1, s2, s3, ...)` 返回 `sn` 。越界返回 null 。

`fleld(s, s1, s2, ..., sn)` 返回 s 第一次出现的位置 i 。找不到得 0 。

`find_in_set(s1, s2)` 等效于上面，其中 `s2=concat_ws(',',s1,s2,...,sn)` 。所以 `s1` 不要有逗号。

`make_set(x,s1,s2,...,sn)` ，按二进制枚举用 `,` 拼接选出来的字符串，可以是空串。其中最小位代表 s1

转换编码 `convert(str using 编码集)` 如 `convert('abc' using latin1)`

格式化 `format(x,n)` 将数字 x 四舍五入保留 n 位返回字符串。若 n 为 0 不含小数部分。注意每个三位输出一个逗号。如 `format(1e9,2)`

查询分组拼接：`group_concat(key)` ，如：

```mysql
select value,group_concat(`key`) from infos group by value;
```

转换大小写：lower(str), upper(str)

去除空格 ltrim(str), rtrim(str), trim(str) (不能去除\n \t)



##### 时间

now 是当时的年月日时分秒

current\_time 或 curtime 是当时的时分秒。同理年月日替换为字 date

还有 `current_timestamp, localtime, sysdate` 。`current_date` 是年月日如 `2024-11-23`

`unix_timestamp(date)` ，无参数返回 now 与 `1970-01-01 00:00:00 GMT` 的秒数差。GMT是 green wich mean time 格林尼治标准时间。跟这个时间作差。`from_unixtime(date)` 就是时间戳转时间，可以传入字符串/数值。其实这两个就是两种格式互转。

`utc_date()` 返回 UTC (世界标准时间)格式日期值，返回当前时区日期值。

用 `month, monthname` 截取 date 。值域是 $[1,12]$ 或英文全名(首字母大写)；用 `dayname,dayofweek,weekday` 取 $[1,7]$ 或全名，或周索引 $[0,6]$ ；用 `week,weekofyear` 获取一年中的第几周， week 第二个参数：

![image-20220518202055242](img/image-20220518202055242.png)

默认为 0 ；天数用 `dayofyear, dayofmonth` ，一年中的第几天。

year 获取年份，值域 $[1970,2069]$ 。 quarter 返回 $[1,4]$ ， minute(time) 返回 $[0,59]$ ， second 同理。

`extract(type from date)` 用类型获取日期的某个值，如 `extract(year from '2018-07-02')` 。参数有 `year, year_month, day_minute` (时分秒)

> 如 `where extract(year from order_date)='2019'`

`time_to_sec` 返回时间的秒数。反函数 `sec_to_time` 。

日期运算 `date_add, adddate, date_sub, subdate, addtime, subtime, date_diff`  。对 `date_add(date, interval expr type)` ，date 是起始值，expr 表达式，type 关键字。

![image-20220518202657628](img/image-20220518202657628.png)

![image-20220518202704401](img/image-20220518202704401.png)

例如：`date_add('2010-12-31 23:59:59', interval 1 second)` , `date_add('2010-12-31 23:59:59', interval 1:1 minute_second)` 。 add 放负数也可以。或者粗暴一点， `addtime(date, expr)` ，如 `addtime('02:02:02', '02:00:00')` 。而 `datediff` 计算日期的间隔天数。

格式化：`date_format(date, format)` 

![image-20220518204702276](img/image-20220518204702276.png)

同理有 `time_format` 。可以用 `get_format(type, area)` 表示某个地区显示的格式，即根据表的第一项(不用引号)和第二项(要)查第三项：

![image-20220518205341135](img/image-20220518205341135.png)

![image-20220518205348783](img/image-20220518205348783.png)

`datediff(a,b)` 两个日期a-b相减(date的话单位是天)，等效于 `timestampdiff(day,a,b)`

`last_day` 最后一天。

```sql
select last_day('2024-2-2'); -- 2024-02-29 
```





##### 条件判断

`if(expr, v1, v2)` ，为真返回 `v1` ，否则 `v2` 。`ifnull(v1,v2)` 。

`case expr when v1 then r1 [when v2 then r2] ... [else rn] end` ，具体返回字符串还是数值看需要用到处的运算。



##### 系统

`version()` ，如 `8.0.27` 。

`connection_id()` 当前连接 id 整数。

`processlist` 连接数和所有链接状态，前 100 条(`full processlist` 可以全部)。只有 root 能看到全部，一般用户看到自己。如果不行，用 `select * from information_schema.processlist;` 

![image-20220518210337407](img/image-20220518210337407.png)

`database()` 当前数据库名。可能是 null 。 `schema()`  同。

`user(),current_user,current_user(),system_user(),session_user()` 获取用户名。格式是 `主机名字@IP` 如 `root@localhost`

`charset(str)` 获得当前字符串所用字符集。`collation(str)` 返回排列方式。

`last_insert_id()` 最后生成的 `auto_increment` 。一个语句插入多条时，以第一条为准。与表无关。

`get_lock(str, timeout)` 给字符串 str 名字加 timeout 秒的锁，成功得到 1 ，超时得到 0 ，错误得到 null 。 `release_lock(str)` 或连接断开断开这个锁，前者锁被解开返回 1，没有创建锁返回0，不存在这个所返回null。提前解开或未get过就是不存在。`is_free_lock(str)` 检查名为 str 的锁是否可用(未被封锁)，可用返回 1，被占用返回 0，其他返回 null 。`is_used_lock(str)` 同理，但被封锁返回用锁客户端的connection ID，否则返回 null

`benchmark(count, expr)` 执行 count 次 expr 。返回值是运行时间(客户端时间，而不是服务端CPU时间)，通常是 0 。





##### 加密

在 8.0 新增 

一般都传入 null 得 null

`md5(str)` 进行 MD5 128比特校验和，以32位十六进制二进制字符串返回

`sha(str)` 返回格式一样

`sha2(str, hash_length)` ，第二个参数支持 `224,256,384,512,0` ，其中 0=256

`aes_encrypt(src,pwd), aes_decrypt`，正常查看加密后的显示是一段乱码或十六进制数字。解码得到十六进制数字。

##### 类型转换

`cast(x as type)` 或 `convert(x, type)` 进行类型转换。type 有 `binary, char(n), date, time, datetime, decimal, signed ,unsigned` 。如 `cast(100 as char(2))`

```mysql
select * from t_user where CAST(phone AS signed int) = 1300000001;
```

##### uuid

36 字符长的字符串，代表 128 位整数(十六进制形式)

```
xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
```

`Mxxx`: `M` 表示 UUID 的版本，在 MySQL 中通常是 `4`

`Nxxx`: `N` 表示 UUID 的变体，通常为 `8`、`9`、`A` 或 `B`

同一个事务一般第一部分随机，其他不变。

#### 存储过程

是一条或多条 SQL 语句集合，类似批处理。

```sql
create procedure sp_name ([proc_parameter]) [characteristics ...] routine_body ;
```

参数列表形式如下：

```mysql
[in | out | inout] param_name type
```

存储过程特性 characteristics 取值如下：

- `language sql` 由 SQL 语句组成
- `[not] deterministic` 存储过程执行结果是否是确定的(同一输入得到同一输出)，默认 not 
- `[contains sql | no sql | reads sql data | modifies sql data]` 子程序限制。依次是：
  - 包含 SQL 但不包含读写数据。默认
  - 不包含 SQL
  - 包含读数据
  - 包含写数据
- `sql security {definer | invoker}` 有权限执行者，定义者或有权调用者。默认前者。
- `comment 'string'` 注释

routine body 用 `begin` , `end` 开始和结束。

使用 `delimiter` 符号修改结束符，避免存储过程 `;` 与语义 `;` 冲突，将其换为别的。一般不用 `\` ，其他随便用。

不支持修改代码，想修改只能删掉重写。函数同。可以调用其他存储过程，但不能 drop  其他存储过程。中文阐述建议规定字符集，如：

```mysql
create procedure userinfo(in u_name varchar(50) character set gbk, out u_age int)
```

如：

```mysql
delimiter $
create procedure AvgPrice ()
begin
select avg(`yourprice`) as `AvgPrice` from `flower`;
end$
delimiter ;
call AvgPrice(); -- 调用
drop procedure AvgPrice; -- 删除
```

调用通式是 `call dbmane.procname` ，即可能跨库调用。IO 示例如下：

```mysql
delimiter //
create procedure countgt (in pr int, out num int)
begin
select count(*) into num from flower where yourprice >= pr;
end //
delimiter ;
call countgt(100, @tmp);
select @tmp;
```



#### 自定义函数

UDF(User-Defined Function)

本质上都是存储程序。区别在于 return 与否，以及限制的多寡。例如函数不能用临时表，只能用表变量，一些函数不可用，但是可以嵌入到 sql 语句内使用。

```sql
create function func_name ([func_parameter])
returns type [characteristics ...] routine_body
```

默认参数总是 in 。函数体必须包含 `return value` 语句。

可以显示当前是否允许不指定特性：

```mysql
show variables like 'log_bin_trust_function_creators';
```

设置为允许，防止下面例子报错：

```mysql
set global log_bin_trust_function_creators=1;
```

> 这样设置显然是临时的，可以在 `my.cnf` 添加  `log_bin_trust_function_creators=1`

如：

```mysql
delimiter //
create function hello()
returns char(20)
return (select fName from flower limit 1); //
delimiter ;
select hello(); -- 函数调用
drop function if exists hello; -- 函数删除
```

```mysql
delimiter lr580
create function countpr2 (pr int) returns int begin
return (select count(*) from flower where yourprice>pr);
end; lr580
delimiter ;
select countpr2(200);
```





#### 变量

不区分大小写。

##### 常规

定义：

```mysql
declare var_name[,var_name, ...] data_type [default value]
```

如：

```sql
declare myparam int default 100;
```

赋值：

```mysql
set var_name = expr [,var_name = expr ...];
```

如：

```mysql
set myparam = myparam * 2;
```

也可以用下面方法为一个或多个变量赋值：

```mysql
select col_name[, ...] into var_name[, ...] table_expr;
```

如：

```mysql
select fName, flowerId into name, id from flower where flowerId = 1;
```

##### 用户变量

`@var_name` 是用户变量，用 set 赋值，与连接有关，一个客户定义的不能被其他用户看到，连接释放自动释放。如：

```sql
select @x; -- NULL
set @x=1;
select @x;
```

可以使用变量笛卡尔积联表然后自增来标号：

(大意是 i从100开始增长，循环 person 表行数次，把 person 表遍历与 i=100 两个表笛卡尔积，nx1=n)

```mysql
select (@i:=@i+1) as rownum, person_name 
from person, (select @i:=100) as init; 
```

将其与 insert 配合，可以翻倍增加元素。

##### 全局变量

加 global 关键字。数据库重启后从配置项重新读取。

如：

```mysql
set global MAX_EXECUTION_TIME = 2000;
```

而用 `persist` 则保存到 `mysqld-auto.cnt` 下次启动会读取，覆盖默认配置，如：

```mysql
set persist max_connections = 1000;
```

可以查询：

```mysql
show variables like '%max_connections%';
```





#### 条件处理

类似于 try...catch 。

定义处理的条件：

```sql
declare condition_name condition for [condition_type]
[condition_type]:
sqlstate [value] sqlstate_value | mysql_error_code
```

`sqlstate_value` 是长度为 $5$ 是字符串错误类型代码，`mysql_error_code` 是数值错误代码。如：

```mysql
declare cmd_not_allow condition for sqlstate '42000';
declare cmd_not_allow condition for sqlstate 1148;
```

定义处理条件的程序：

```sql
declare handler_type handler for condition_value[,...] sp_statement
handler_type: continue | exit | undo
condition_value: sqlstate [value] sqlstate_value | condition_name | sqlwarning | not found | sqlexception | mysql_error_code
```

`handler_type` 为错误处理方式，分别为不处理、马上退出和撤回之前的操作(不支持 undo )。`sqlwarning` 匹配所有 `01` 开头的 `sqlstate` 错误代码，`not found` 则以 `02` 开头， `sqlexception` 则是没有被上述两种捕获的全部错误代码

如：

```sql
declare continue handler for sqlstate '42S02' set @info='NO_SUCH_TABLE';
declare no_such_table condition for 1146;
declare continue handler for no_such_table set @info='NO_SUCH_TABLE';
declare exit handler for sqlwarning set @info='ERROR';
```

综合使用：

```sql
delimiter //
create procedure fdemo ()
begin
declare continue handler for sqlstate '23000' set @x2 = 1;
-- 主键冲突忽略
set @x = 1;
insert into test_db.t values (1);
insert into test_db.t values (1); -- 主键冲突
set @x = 2; -- 理论上调用后得到 @x=2
end;//
delimiter ;
```



#### 光标

声明：

```sql
declare cursor_name cursor for select_statement;
```

如：

```mysql
declare cursor_flower cursor for select fName, flowerID from flower;
```



打开：

```mysql
open cursor_name;
```

使用：

```mysql
fetch cursor_name into var_name [, var_name ...]
```

表示将光标中 select 查出来的信息存入到这个 `var_name` 里

关闭：

```mysql
close cursor_name;
```

只能在存储过程 / 函数使用。



#### 流程控制

if:

```sql
if expr_condition then statement_list
[elseif expr_condition then statment_list ...]
[else statement_list]
end if;
```

如：

```mysql
if val is null then select 'empty val'; -- 输出
else select 'ok';
end if;
```



case:

```mysql
case case_expr when when_value then statement_list 
[,when ...]
[else statement_list]
end case;
```

或：

```sql
case
[when expr_condition then statement_list] ...
[else statement_list]
end case;
```

> 存储程序与函数里略有不同。



loop:

```mysql
[loop_label:] loop
	statement_list
end loop [loop_label]
```

使用 `leave loop_label`  break ；使用 `iterate loop_label` continue;

如：

```mysql
delimiter $
create procedure fordemo()
begin
declare id int default 0;
add_loop: loop
	set `id` = `id` + 1;
	if `id` >= 10 then leave add_loop;
	elseif `id` = 5 then iterate add_loop; -- else if 暴毙 
	end if;
	select `id`;
end loop add_loop;
end$
delimiter ;
```



repeat:

```sql
[repeat_label:] repeat
	statement_list
until expr_condition
end repeat [repeat_label];
```



while:

```mysql
[while_label] while expr_condition do
	statement_list
end while [while_label];
```



#### 查询状态

可以直接从系统的 `information_schema` 数据库查询。也可以：

```mysql
show {procedure | function} status [like 'pattern']
```

返回子程序的特征，如数据库、名字、类型、创建者、创建日期、修改日期。一定要 like ，不然会输出一大堆乱七八糟的内容。如：

```mysql
show procedure status like 'fordemo%'\G;
```

也可以：

```sql
show create {procedure | function} sp_name;
```

如：

```mysql
show create procedure fordemo\G;
```

也可以查系统表：

```mysql
select * from information_schema.Routines where ROUTINE_NAME='sp_name' \G;
```

还可以只差函数或过程，限定： `and ROUTINE_TYPE = 'FUNCTION'` 。



#### 修改

```mysql
alter {procedure | function} sp_name [characteristic ...]
```

![image-20220520122056379](img/image-20220520122056379.png)

例如：

```mysql
alter procedure mypro modifies sql data sql security invoker;
alter procedure mypro comment 'QwQ';
```



#### 触发器

trigger ，特殊的存储过程。预定义事件（增删改）发生时，被 mysql 自动调用。通常而言很不推荐使用触发器，除非对需求有显著好处。

单行语句触发器语法：

```mysql
create trigger trigger_name trigger_time trigger_event
on tbl_name for each row trigger_stmt
```

`trigger_time` 为 `before` 或 `after` ，`trigger_event` 为触发事件，包括 `insert,update,delete` 。插入时临时新列是 new ，删除临时旧表示 old 。通过对这两张表操作可以实现 rollback 。

如：

```mysql
create trigger ins_sum before insert on account
for each row set @sum = @sum + NEW.value;
```

多行语句：

```mysql
create trigger trigger_name trigger_time trigger_event
on tbl_name for each row begin
...
end
```

查看： `show triggers` , 查看特定从 `information_schema` 数据库找 `trigger` 表，条件属性名 `TRIGGER_NAME` 。删除也是 `drop` 。

相同表相同事件只能有一个触发器。

如：

```mysql
create table if not exists ts (v int);
delimiter lr580
create trigger tst before insert on ts for each row begin
if new.v <= 0 then
signal sqlstate 'HY000' set message_text = '不允许插入';
end if;
end lr580
delimiter ;
insert into ts values (0); -- 输出报错
insert into ts values (10);
```



### 日志指令

分为：

- 错误日志：记录 MYSQL 服务启动、运行或停止 MYSQL 服务时出现的问题
- 查询日志：记录建立的客户端连接和执行的语句
- 二进制日志：记录所有更改数据的语句，可以用于数据复制
- 慢查询日志：记录所有执行时间超过 `long_query_time` 的所有查询或不使用索引的查询

日志创建在 MYSQL 数据目录。刷新日志可以强制 MYSQL 关闭。用指令 `flush logs`,或 cmd 语句 `mysqladmin flush-logs`, `mysqladmin refresh`。

复制功能，在复制服务器上维护更多日志文件，称为接替日志

查询和慢查询日志可能会降低性能和占用大量空间

日志跟数据库文件不建议放在同一个磁盘，若磁盘故障可能会一锅端

8.0 新版本添加了每条记录的错误信息编号如`[my-010311]`和错误所属子系统如`[server]`。

#### 二进制日志

事务安全。包含所有更新了数据或已经潜在更新了数据的语句，以事件形式保存，描述数据更改。包含每个更新数据库语句的执行时间信息。目的：最大可能地恢复数据库

修改配置 `my.ini`，来启动：

```ini
log-bin [=path/ [filename]]
```

定义路径和日志文件名称。会生成 `filename.000001` 等和 `filename.index`。`expire_logs_days` 定义了清除过期日志的时间，即自动删除的天数。默认为 0 即不删除。启动或刷新时可能删除。`max_binlog_size` 定义单个文件大小限制，不能大于 1GB 或小于 4096B，默认 1GB。但是大的事务会使得实际值超过该限制。

如：

```ini
[mysqld]
log-bin
expire_logs_days = 10
max_binlog_size = 100M
```

查询：

```mysql
show variables like 'log_%';
show binary logs;
```

也可以 cmd：

```shell
mysqlbinlog 文件路径
```

如：

```shell
mysqlbinlog D:/mysql/log/binlog.000001
```

删除全部：

```sql
reset master
```

删除指定文件名(比指定的编号小的所有(不包括这个指定的))或日期(该日期之前的所有(不包括当天))：

```mysql
purge {master | binary} logs to 'log_name';
purge {master | binary} logs before 'date';
```

如：

```mysql
purge master logs before '20190130';
purge master logs to "abc.000003";
```

使用日志恢复数据库：

```shell
mysqlbinlog [option] filename | mysql -uuser -ppass
```

选项有 `--start-date, --stop-date` 和 `--start-position, --stop-position`，指定时间和位置。时间如 `--stop-date="2019-01-30 15:27:48"`，其中 `|` 是管道运算符, windows 也可以管道

暂停/启动：

```mysql
set sql_log_bin = {0|1}
```



#### 错误日志

当启动和停止或运行时的严重错误相关信息。默认在数据库数据目录下，为 `hostname.err`。执行 `flush logs` 会重新加载。

配置：(修改后重启生效, `my.ini` 或 `my.cnf`)

```ini
[mysqld]
log-error=[path / [file_name]]
```

查看：

```mysql
show variables like 'log_error';
```

删除：直接找到文件删掉即可。5.5.7 以前版本 flush logs 可以重命名为 `filename.err_old` 并创建新的，之后只重新打开，不存在创建。运行时删除不会自动创建，需要的话：

```shell
mysqladmin -u root -p flush-logs
```

或：

```mysql
flush logs;
```



#### 通用查询日志

所有用户操作，含启动关闭服务、执行查询和更新。

默认不开启。查询：

```mysql
show variables like '%general%';
```

开启：(关闭设0)(调其他变量同理)

```mysql
set @@global.general_log=1;
```

查看可以直接到路径下翻。删除可以直接删，重建的话用：

```shell
mysqladmin [-u root -p] -flush logs
```



#### 慢查询日志

配置：

```ini
[mysqld]
log-slow-queries[=pat / [filename]]
long_query_time=n
```

n 是超过阈值，不填默认 10 秒。单位是秒。默认在数据目录，文件名 `hostname-slow.log`。查看直接打开。可以借助 mysql dump slow, mysql sla, mysql log ffilter, myprofi 等工具分析。删除同查询日志。



## 其他

### 性能优化

#### 性能查询

```mysql
show status like 'value';
```

value 如：

- `Connections` 连接服务器次数
- `uptime` 服务器上线时间
- `slow_queries` 慢查询次数
- `com_select` 查询次数
- `com_insert` 插入次数
- `com_update` 更新次数
- `com_delete` 删除次数



#### 查询分析

三者其一

```mysql
explain [extended] select select_option
describe select select_option
desc select select_option
```

输出里 `id` 是查询序列号。

`select_type` 有不含连接查询和子查询的简单查询 `simple`，主查询(最外层查询) `primary`，`union` 连接查询的非首个查询语句。`dependent union` 是连接查询非首个的 select；`union result` 是连接查询结果。`subquery` 是子查询第一个语句。同理 `dependent subquery`。`derived` 导出表的 select(from 子句的子查询)。

`table` 是要查询的表。

`type` 是连接类型。从最优到最差分别是 `system`, `const`(最多一个匹配行)，`eq_ref`(从前两者的组合里读取一行；当一个索引所有部分都在查询中使用且是 union/primary key索引时可以使用)；`ref` (前面的表读取所有匹配行)；`ref_or_null`；`index_merge` (索引合并优化)；`index_subquery`；`index_subquery`；`range`；`index`；`all`。

`rows` 遍历次数。

`extended` 会产生附加信息。

查询语句条件中只有 or 且前后两条件的列都是索引时才会使用索引，否则不使用。

子查询灵活但效率不高。会有临时表的创建和撤销。使用 join 代替子查询从而不需要建立临时表。连接效率更高只因为不需要再内存中创建临时表。

8.0 索引可以被隐藏，此时不被查询优化器使用。

```mysql
create table test1(a int, b int, index idx_a_b(a,b desc) invisible);
alter table test1 alter index idx_a_b visible;
show index from test1 \G
```



#### 数据库结构

字段多的表，对使用频率低的子段可以分离形成新表。

经常联合查询的表，可以建立中间表。

降低范式，添加冗余字段，减少连接操作。但是可能代价是空间和修改。

8.0 增加资源组用于调控线程优先级和绑定 CPU。mysql 用户权限为 resource\_group\_admin。进程要有 cap\_sys\_nice 权限如：

```shell
sudo setcap cap_sys_nice+ep /usr/local/mysql8.0/bin/mysqld
getcap /usr/local/mysql8.0/bin/mysqld # 输出
```

```mysql
create resource group my_re type=user vcpu=0,1 thread_priority=5;
set resource group my_re;
select * from performance_schema.threads where resource_group='my_re';
drop resource group my_re;
alter resource group my_re vcpu=2,3 thread_priority=8;
set resource group usr_default for 48;
set resource group my_re for thead_id;
select thread_id from performance_schema.threads;
set resource group my_reso for 20;
```





#### 数据插入

影响插入的主要因素是索引、唯一性校验、插入的数目。myisam可以插入前禁用索引，插入后再开启，如：

```mysql
alter table table_name disable keys;
alter table table_name enable keys;
```

同理禁用唯一性校验：

```mysql
set unique_checks=0;
set unique_checks=1;
```

用一条插入语句代替多条插入语句。

用 `load data infile` 代替 insert，更快。

对 innodb，可以：同理禁用唯一性，还可以禁用外键检查：

```mysql
set foreign_key_checks=0;
```

禁用自动提交：

```mysql
set autocommit=0;
```



#### 分析表

分析关键字的分布。

```mysql
analyze [local | no_write_to_binlog] table tbl_name [,tbl_name]...
```

local 与后者互为别名，都表示执行过程不写入二进制日志。

分析时加只读锁。能分析 innodb, bdb, myisam。

table 是表名。on 是执行的操作。msg\_type 是 status/info/note/warning/error, msg\_text 是显示信息



#### 检查表

检查 innodb, myisam 是否存在错误。后者还会更新关键字统计数据。也可以检查视图(如被引用的表不存在)

```mysql
check table tbl_name [,tbl_name] ... [option] ...
```

option 有 quick(不扫描行，不检查错误连接)；fast(只检查未被正确关闭的表)；changed(只检查上次检查后被更改和未正确关闭的)；medium(扫描行，验证删除的连接是有效的，计算各行关键字校验和)；extended(每行关键字做全面关键字查找，确保表 100% 一致)

option 只能 myisam。check 时加只读锁。



#### 优化表

对 innodb, myisam 有效，优化 varchar, blob, text。

```mysql
optimize [local | no_write_to_binlog] table tbl_name [,tbl_name] ...
```

可以消除删除和更新造成的文件碎片。加只读锁。一般只需要一周或一个月一次，只需要对特定的表运行。



#### 服务器

硬件：较大的内存。内存速度比磁盘 I/O 快。增加缓冲区容量使得在内存停留更久。高速磁盘。合理分布磁盘 I/O，分散到多个设备减少资源竞争，提高并行操作。配置多处理器，多线程。

参数：

- `key_buffer_size` 索引缓冲区大小。所有线程共享。值太大会操作系统频繁换页，降低系统性能
- `table_cache` 同时打开的表个数，太多影响系统性能
- `query_cache_size` 查询缓冲区大小。与 `query_cache_type` 配合，为 0 时都不使用，但不会导致释放所配置的内存；为 1 时都使用，除非查询语句指定 `select sql_no_cache * from` 这样的语法。而为 2 时，只有语句有 `sql_cache` 关键字才用。用缓冲区可以提高查询速度，只使用修改操作少和经常执行相同查询操作
- `sort_buffer_size` 排序缓冲区大小，越大排序速度越快。提高 order by 或 group by，默认约 2MB(2097144 byte)
- `read_buffer_size` 每个线程连续扫描时为扫描的每个表分配的缓冲区大小(字节)，从表连续读取记录时用到。可以 `set session read_buffer_size=n` 临时设置
- `read_rnd_buffer_size` 每个线程保留的缓冲区大小。主要用于存储按特定顺序读取出来的记录。也可以 set。频繁多次连续扫描可以增加。
- `innodb_buffer_pool_size` 该类型表和索引最大缓存。越大查询越快，太大影响操作系统性能
- `max_connections`。连接会浪费内存资源，过多会僵死
- `innodb_flush_log_at_fix_commit` 何时将缓冲区写入日志。0 是每隔一秒写入磁盘，1 是每次提交事务，2 是每次提交事务写日志，每隔 1 秒日志存盘。默认 1。0 更快但安全性差。
- `back_log` 暂时停止回答新请求的时间内，多少请求可以存在栈里。即对到来的 tcp/ip 连接侦听队列大小。高于操作系统无效。
- `interactive_timeout` 关闭连接前等待行动秒数
- `thread_cache_size` 复用线程数
- `wait_timeout` 关闭连接前等待秒数，默认 28800
- `innodb_log_buffer_size`
- `innodb_log_file_size`



#### 临时表

8.0 

可以把数据库和表归组到逻辑和物理表空间，提高资源利用率

去掉了临时表不必要持久化。增加 undo 日志额外的类型。临时表设置特别类型。

临时表元数据在 innodb\_temp\_table\_info 系统表

用 `create tablespace` 创建通用表空间。

```mysql
create tablespace dxy add datefile 'dxy.ibd' file_block_size=16k;
alter table t1 tablespace dxy;
drop table t1;
drop tablespace dxy;
```



#### 超时处理

限制语句时间。

```mysql
set global max_execution_time=2000; -- 毫秒,0无限
```

会话超时时间：

```mysql
set session max_execution_time=2000;
```



### 主从

Replication

数据库复制。从一个主服务器(master)将数据复制到另外若干台从服务器(slaves)的过程。将主数据库的 DDL 和 DML 操作通过二进制日志传到从服务器上然后执行，使得同步。复制异步进行。

从服务器一般用于处理查询，减少主服务器压力。

> 复制（replication）是MySQL数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用。总体来说，replication的工作原理分为以下3个步骤：
>
> 1. 主服务器（master）把数据更改记录到二进制日志（binlog）中。
> 2. 从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。
> 3. 从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。
>
> 复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上实时在进行中。这里特别需要注意的是，复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。复制的工作原理，其中从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，负责执行中继日志。

#### windows

查看数据路径：

```mysql
show variables like '%datadir%';
```

修改 `my.ini` 添加：

```ini
[mysqld]
log_bin="D:/MySQLlog/binlog"
expire_logs_days=10
max_binlog_size=100M
```

创建对应的文件。参数：删除的天数和最大的大小。

测试是否成功开启：

```mysql
show variables like '%log_bin%';
```

`log_bin=ON` 则开启。

配置一个复制用的账号 `repl`：

```mysql
grant replication slave on *.* to repl@'%' identified by '123';
flush privileges;
```

继续配置 ini：

```ini
server-id=1
binlog-do-db=test
binlog-ignore-db=mysql
```

放服务器标识 id，与 slave 不一样。要复制的数据库名和不需要复制的数据库名。

重启，查询信息：

```mysql
show master status \G;
```

导出数据，导入到从服务器：

```shell
mysqldump -u root -p -h localhost test > c:\a.txt
```

复制 txt 到从服务器，导入：

```shell
mysqldump -u root -p -h localhost test < c:\a.txt
```

继续配置从服务器：

```ini
[mysql]
default-character-set=utf8
log_bin="D:/MySQLlog/binlog"
expire_logs_days=10
max_binlog_size=100M

[mysqld]
server-id=2
```

可以注释掉 log\_bin 在 mysqld 的

重启从服务器，执行：

```mysql
stop slave;
change master to
master_host='192.168.0.208',
master_user='repl',
master_password='123',
master_log_file='binlog.000003',
master_log_pos=120;
start slave;
show slave status \G;
```

后两个表示要复制的日志文件和偏移量。

解决 fatal error 1236:

重启主机，执行：

```mysql
show master status \G;
```

记录 file 和 position 值。

重新设置从机，并把后两个参数调成这个值。

可以发现，主机每执行一次更改，就会同步到从机。



#### linux

安装 mysql

停止服务器：

```shell
service mysql stop
```

若 netstat 查询 330 无结果，则已经关闭

下略



#### 维护

查看从服务器：

```mysql
show slave status \G;
```

大文本复制出错：

```mysql
show variables like 'max_allowed_packet';
set @@global.max_allowed_packet=16777216;
```

或 `my.cnf` 设置。（16MB）

自增长冲突：主服务器设置 `auto_increment_increment=1,auto_increment_offfset=1`，从后者 0 前者 1。

切换服务器：

```mysql
stop slave IO_THREAD;
show processlist \G;
```

从：

```mysql
stop slave;
reset master;//从变f主
```



#### Proxy

mysql proxy 使得一个客户端的读写命令，写命令放到主数据库，读放到从数据库。只有一个 proxy 机器可能会出现单点失效，可以用多个 proxy 作为冗余。

```shell
mysql-proxy --help-all
```

[下载](downloads.mysql.com/archives/proxy)



### 锁

三种锁：行级、页级、表级。

#### 行级锁定

innodb 支持(row-level locking)和表级锁。默认前者。myisam memory两者表级。BDB 是页面和表。

颗粒度小，发生争用概率小。获取和释放消耗大，容易死锁。

如果一个事物请求的锁模式与当前模式兼容，就可以做，否则要等待。(考虑并发，多个会话)显然同一个会话自己不会冲突，加锁时其他会话可能会冲突。

共享锁 S，排他锁 X，意向共享锁 IX，意向排他锁 IX。

|      | S    | X    | IS   | IX   |
| ---- | ---- | ---- | ---- | ---- |
| S    | √    |      | √    |      |
| X    |      |      |      |      |
| IS   | √    |      | √    | √    |
| IX   |      |      | √    | √    |

意向锁自动添加。普通 select innodb 不加任何锁。增删改 innodb 自动加排他锁。

添加共享锁 S：

```mysql
select * from ... lock in share mode;
```

添加排他锁 X：

```c++
select * from ... for update;
```



#### 表级锁定

颗粒度大。系统开销小。较好避免死锁。冲突率高，并发度低。

包含读锁定和写锁定。

类型包括：

- ignore, unlock, read, write, `read_with_shared_locks`, `read_high_priority`, `read_no_insert`, `write_allow_write`, `write_allow_read`, `write_concurrent_insert`, `write_delayed`, `write_low_priority`, `write_only`

```mysql
lock table table_name read;
unlock tables;
```



#### 页级锁定

介于两者之间的颗粒度。因此性质也是介于两者之间。



#### myisam

有共享读锁 table read lock 和表独占写锁 table write lock

|      | None | 读锁 | 写锁 |
| ---- | ---- | ---- | ---- |
| 读锁 | √    | √    |      |
| 写锁 | √    |      |      |

如：

```mysql
lock table read_lock write;
unlock tables;
```

争用查看：

```mysql
show status like 'table%';
```

`table_locks_immediate` 产生表级锁定的次数

`table_locks_waited` 出现比较锁定争用而发生的等待次数

后者高争用明显。大量读写并发效率大大降低。读增加可能严重读写锁问题，实际上采用主从分离。

建议：将 `concurrent_insert` 设 2，文件碎片定期 `optimize table`；设置 `max_write_lock_count=1`；给读更高优先级 `low-priority-updates=1`

锁表语法：

```mysql
lock table tbl_name [as alias] {read[local] | [low_priority] write} [,tbl_name ...] ...
unlock tables;
```

用别名引用表就要用一样的别名锁定表，如：

```mysql
lock table cc as c read;
select * from cc as c; -- OK,直接select不OK
select * from cc; -- BAD
unlock tables;
lock table cc read;
select * from cc as c; -- BAD
select * from cc; -- OK
```

read local 允许锁定时执行非冲突性 insert 语句同时插入；若 low priority write，则等待特定的锁定，直到没有申请 read 锁定的线程为止，已经获得 write 时，其他线程会等待

系统变量 `concurrent_insert` 为 0 不允许并发插入，1 表没有被删除的行允许在一个进程读表时另一个进程表尾插入；2 无论如何都允许表尾并发插入

查询：

```mysql
show variables like '%concurrent%';
```



#### innodb

支持事务处理。但可能发生：

- 更新丢失：两个数据更新同一行数据，第二个进程中途退出，两个修改都失效
- 脏读：读了之后另一个事务马上更改了，使得所有操作被回滚可能
- 不可重复读：重复读两次，两次结果不一致
- 幻读：两次查询，第二次出现了第一次没有出现的数据

![image-20220829193406316](img/image-20220829193406316.png)

添加共享锁：

```mysql
select id,data from s_table where id=120 lock in share mode;
```

查询争用情况：

```mysql
show status like '%innodb_row_lock%'
```

`innodb_row_lock_current_waits` 当前等待锁定的数量，`innodb_row_lock_time` 从系统启动到现在锁定总时间长度，`innodb_row_lock_time_avg` 每次等待平均时间，`innodb_row_lock_time_max` 系统启动到现在最长的一次等待，`innodb_row_lock_waits` 启动后到现在一共等待了多少次

```mysql
show innodb status;
```



间隙锁

net-key 锁。存储一个区间数据时，会锁定这个区间的全部记录。即使某条记录不存在也会被锁定。

查看隔离级别：

```mysql
select @@tx_isolation;
```

```mysql
set session transaction isolation level repeatable read;
set session transaction isolation level serializable;
```



建议：控制事务大小；尽可能所有数据检索通过索引，避免表级锁定；减少基于范围的数据检索搜索条件；尽量用较低级别的事务隔离；尽可能按相同顺序访问；尽可能以此锁定所需所有资源；容易死锁可以放弃innodb行级使用表级；不要申请超过需求的锁级别。



#### 跳过锁等待

5.7 `select ... for update` 执行时若获取不到锁，会一直等待直到 `innodb_lock_wait_timeout` 超时

8.0 对其他会话，想要获取锁时，添加 nowait 和 skip locked 立即返回。若查询的加锁，前者返回报错，后者返回不包含锁定的行。

```mysql
select * from bbs1 where id=102 for update nowait;
select * from bbs1 where id=102 for update skip locked;
```





### 其他8.0特性

#### innodb

##### 在线

旧版本添加主键需要复制数据表。8.0 可以直接添加：

```mysql
create table tt(id int);
alter table tt add primary key(id);
```

8.0 在线更改 varchar：(增大到 255 内，且不支持在线介绍)

```mysql
alter table tm modify name varchar(255);
```

8.0 在线重命名索引：

```mysql
alter table bb rename index bs to newbs;
```



##### 缓冲池

可以动态修改大小

大小是 128mb 的倍数，否则会适当调大。

查看大小和个数：

```mysql
show variables like '%innodb_buffer_pool_size%';
show variables like '%innodb_buffer_pool_instances%';
```

设置：

```mysql
set global innodb_buffer_pool_size=1048576000;
```

查看设置进度：

```mysql
show global status like 'innodb_buffer_pool_resize_status';
```



##### 表空间数据加密

支持对独享表空间的 innodb 数据加密，使用 keyring plugin 管理，启动参数：

```ini
[mysqld]
early-plugin-load=keyring_file.so
```

检查是否支持加密：

```mysql
select plugin_name, plugin_status from information_schema.plugins where plugin_name like 'keyring%';
```

创建：

```mysql
create table t(id int, name varchar(10)) engine=innodb default charset utf8mb4 encryption='y';
```



#### json

传统存储为字符串，需要用户保证正确性，且在用户代码处理，只提取json一个字段也需要读取整个字符串，且无法建索引。

8.0 实现 json 支持。

```mysql
create table tb(data json)engine=innodb; -- or myisam
insert into tb values('{"key":"val"}');
```

实际存储是 blob。key 的长度用 2 字节(65535)保存，超过会错。内部会 key 排序。

```mysql
insert into tb values(json_object('key','val'));
```



#### 全文索引加强

支持外部分析器。实现标记优化器。实现支持 CJK(中日韩)全文检索。

检索(旧版本全部匹配到就算匹配到，新版本匹配到子串就行了)：

```mysql
select * from tft where match (name) against ('中文文本');
```



### 存储引擎

MySQL 8.0支持的存储引擎有InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE等。

比较：

![image-20220830230200957](img/image-20220830230200957.png)

![image-20220830230205825](img/image-20220830230205825.png)

存储的树上的叶子节点区别参见 `索引指令-原理-存储`

提供提交、回滚和崩溃恢复能力，事务安全，并发控制，innodb。

数据表主要用来插入和查询，效率 myisam 较高。

临时存放，数据量不大，不需要较高安全性，可以 memory。

只有 insert, select 可以 archive，高并发插入，但不事务安全。非常适合归档数据，如日志信息。

查看默认引擎：

```mysql
show variables like 'storage_engine';
```

#### InnoDB

InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5之后，InnoDB作为默认存储引擎，主要特性如下：

1. InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表与其他MySQL表的类型混合起来，甚至在同一个查询中也可以混合。
2. InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。
3. InnoDB存储引擎完全与MySQL服务器整合，为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引存在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。
4. InnoDB支持外键完整性约束（FOREIGN KEY）。存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6B的ROWID，并以此作为主键。
5. InnoDB被用在众多需要高性能的大型数据库站点上。InnoDB不创建目录，使用InnoDB时，MySQL将在数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件。

#### MyISAM

MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务。MyISAM的主要特性如下：

1. 在支持大文件（达63位文件长度）的文件系统和操作系统上被支持。
2. 当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块以及若下一个块被删除则扩展到下一块来自动完成。
3. 每个MyISAM表最大的索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16个。
4. 最大的键长度是1000B，这也可以通过编译来改变。对于键长度超过250B的情况，一个超过1024B的键将被用上。
5. BLOB和TEXT列可以被索引。
6. NULL值被允许在索引的列中，这个值占每个键的0~1个字节。
7. 所有数字键值以高字节优先被存储，以允许一个更高的索引压缩。
8. 每个表一个AUTO_INCREMENT列的内部处理。MyISAM为INSERT和UPDATE操作自动更新这一列，这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不能再利用。
9. 可以把数据文件和索引文件放在不同目录。
10. 每个字符列可以有不同的字符集。
11. 有VARCHAR的表可以固定或动态记录长度。
12. VARCHAR和CHAR列可以多达64KB。

### SQL注入

SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。

#### 登录

用户名设置为 `1' or '1='1` ，密码同理。使得通过 `where` 时， or 后边的判断总是成立，从而使得用户和密码总是正确，如：

```mysql
select * from _userlist where name = '?' and psw = '?';
```

如果我们使用 `' or 1=1 #` 作为用户名参数，那么服务端构建的SQL语句就如下：(注释掉后面条件)

```mysql
select * from user where username='' or 1=1 #' and password='123456'
```

在 java 里用 `mysql` ，statement 难以防御注入，建议使用 `preparestatement` ，可以防止注入，把特殊符号转义。

建议：

1. 严格的参数校验 在一些不该有特殊字符的参数中提前进行特殊字符校验即可。

2. SQL预编译

   在知道了SQL注入的原理之后，我们同样也了解到MySQL有预编译的功能，指的是在服务器启动时，MySQL Client把SQL语句的模板（变量采用占位符进行占位）发送给MySQL服务器，MySQL服务器对SQL语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给MySQL服务器，直接进行执行，节省了SQL查询时间，以及MySQL服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。

   具体是怎样防止SQL注入的呢？实际上当将绑定的参数传到MySQL服务器，MySQL服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。我们常用的JDBC就有预编译功能，不仅提升性能，而且防止SQL注入。

SQL 预编译的例子：(可以防止 SQL 注入)

```mysql
set @x=1;
prepare stmt from 'select * from user where id=?';
execute stmt using @x;
```



### 配置

#### 缓存池大小

```ini
[mysqld]
innodb_buffer_pool_size = 1G
```

调整完毕应当重启。

#### cli中文显示

```sh
mysql -uroot -pmy-secret-pw --default-character-set=utf8mb4
```

或者：

```mysql
show variables like "%char%";
SET character_set_client = utf8;
SET character_set_connection = utf8;
SET character_set_results = utf8;
```

应该可以显示。

# Docker

## 理论

[教程](https://yeasy.gitbook.io/docker_practice/basic_concept/image)

### 基本概念

docker类似于轻量虚拟机，可以用于将一台机子部署的东西快速迁移到别的机子



**镜像** Image 类似于 root 文件系统。是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 **不包含** 任何动态数据，其内容在构建之后也不会被改变。

镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。

> 因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。



**容器** Container 。容器是镜像的实例。镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 `root` 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样

> 容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更

一个 **Docker Registry** 中可以包含多个 **仓库**（`Repository`）；每个仓库可以包含多个 **标签**（`Tag`）；每个标签对应一个镜像。通过 `<仓库名>:<标签>` 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 `latest` 作为默认标签

> 仓库名经常以 *两段式路径* 形式出现，比如 `jwilder/nginx-proxy`，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名



## 使用

### 安装

#### windows 10

##### docker安装

建议先下载高速下载工具， winget [下载链接](https://www.microsoft.com/zh-cn/p/app-installer/9nblggh4nns1?rtc=1#activetab=pivot:overviewtab) 或者可以用我自己的备份[下载docker](https://cloud.socoding.cn/s/KZ1Tb)

然后在 cmd 键入指令：

```bash
winget install Docker.DockerDesktop
```

> 也可以 `-i` 指定交互界面安装，可以 `-l 路径` 指定安装目录，但是 docker 不支持
>
> 下载路径根据输出内容发现为： `C:\Users\lr580\AppData\Local\Temp\WinGet` ，装完好会自己删包

可能需要输入一次 `y` 

之后建议重启电脑一次



##### hyper-v安装

> 这一步可能是不需要的

然后安装 hyper-v，在管理员下执行该脚本：

```bat
pushd "%~dp0"

dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum >hyper-v.txt

for /f %%i in ('findstr /i . hyper-v.txt 2^>nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i"

del hyper-v.txt

Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL
```

然后重启电脑



##### 迁移到D盘

[教程对标](https://www.cnblogs.com/renguanyu/p/15201827.html) [备用对标教程](https://blog.csdn.net/jxl15680701016/article/details/106925002/)

因为默认安装在 C 盘，所以接下来考虑迁移走 C 盘：

首先在任务管理器关闭所有 Docker 前缀的进程

然后控制面板里搜索管理工具，点击Hyper-v管理器，点击仅有的一台，点停止服务，点 Hyper-v 设置



在管理员下，逐个剪切路径到另一个路径，然后执行下述命令：(后者路径仅供参考)

```sh
mklink /j "C:\ProgramData\Docker" "D:\Temps\docker\DockerData"
mklink /j "C:\ProgramData\DockerDesktop" "D:\Temps\docker\DockerDesktop"
mklink /j "C:\Program Files\Docker" "D:\Temps\docker\Docker"
mklink /j "C:\Users\lr580\AppData\Local\Docker" "D:\Users\lr580\AppData\Local\Docker"
```

> 如果重装时 `For security reasons C:\ProgramData\DockerDesktop cannot bea symlink`，则撤销：
>
> ```sh
> rmdir "C:\ProgramData\Docker"
> rmdir "C:\ProgramData\DockerDesktop"
> rmdir "C:\Program Files\Docker"
> rmdir "C:\Users\lr580\AppData\Local\Docker"
> ```

当且仅当在 C 盘对应位置能看到快捷图标然后点进去可以时，证明迁移成功，此时可以打开dockerdesktop。

验收标准：打开Docker Desktop正常，不会闪退(可能会要求安装WSL2)



##### WSL安装升级

安装 WSL(Windows Subsystem for Linux)：

win+r 运行 `winver` 查看版本号，确保内部版本号大于等于19041

打开 powershell ，列举可安装版本：

```bash
wsl -l -o
```

可以安装一个 Linux，如：

```bash
wsl --install -d Ubuntu-20.04
```

设置管理员密码：

```bash
sudo passwd root
```

关闭：

```bash
wsl --shutdown
```

然后迁移到D盘，使用类似的方法：

```bat
mklink /j  "C:\Users\lr580\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc" "D:\Temps\wsl\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc"
```

然后右击设置权限为完全控制。 [参考教程](https://www.cnblogs.com/itkingyw/p/12736358.html)

要卸载的话可以在菜单搜索 Ubuntu，直接右击卸载

检查安装的版本是 WSL 1还是2，输入：

```bash
wsl -l -v
```

关闭特定，如：

```bash
wsl -t Ubuntu-20.04
```

要启动的话，直接菜单搜索点击即可

管理员下 powershell 输入指令：[参考文献](https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package)

```bat
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
```

下载文献里的安装包 `.msi` ，大约16MB，安装，重启

对 WSL 1更新到 WSL 2： [参考文献](https://docs.microsoft.com/zh-cn/windows/wsl/install)

```bash
wsl --set-version Ubuntu-20.04 2
```

如果提示`转换完成。` 就成功了

设置默认版本：

```bash
wsl --set-default-version 2
```



验收标准：打开docker desktop，显示大约为：`Get started with Docker in a few easy steps!`



> 注意 docker 使用过程中疑似要一直开着那个虚拟机，所以不要关掉；此外 docker 还会创多两个虚拟机

#### linux

[参考](https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/)

ubuntu 为例：[参考](https://docs.docker.com/engine/install/ubuntu/)

删除旧的 docker：

```sh
for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do apt-get remove $pkg; done
```

安装依赖：

```
apt-get update
apt-get install ca-certificates curl gnupg
```

信任公钥，添加仓库：

```sh
install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \
  "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
  tee /etc/apt/sources.list.d/docker.list > /dev/null
```

安装：

```sh
apt-get update
apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

安装 compose:

```sh
sudo apt install docker-compose -y
```



### 配置

#### 镜像加速器

##### windows 10

菜单选择 `Settings`，打开配置窗口后在左侧导航菜单选择 `Docker Engine`，在右侧像下边一样编辑追加 json 文件，之后点击 `Apply & Restart` 保存后 Docker 就会重启并应用配置的镜像地址了。

```json
{
  "registry-mirrors": [
    "https://hub-mirror.c.163.com",
    "https://mirror.baidubce.com"
  ]
}
```

若输入指令：

```bash
docker info
```

后，能够查找到 `Registry Mirrors`有内容，即证明配置成功

##### linux

参考 [here](https://blog.csdn.net/qq_52712971/article/details/141862621?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7ECtr-3-141862621-blog-142520844.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7ECtr-3-141862621-blog-142520844.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=5)

修改 dns，保存自动生效：`/etc/resolv.conf`

```ini
nameserver 114.114.114.114
nameserver 8.8.8.8
```

修改 `/etc/docker/daemon.json`：

```json
{
     "max-concurrent-downloads": 10,
     "max-concurrent-uploads": 5,
     "default-shm-size": "1G",
     "debug": true,
     "experimental": false,
     "registry-mirrors":[
                "https://x9r52uz5.mirror.aliyuncs.com",
                "https://dockerhub.icu",
                "https://docker.chenby.cn",
                "https://docker.1panel.live",
                "https://docker.awsl9527.cn",
                "https://docker.anyhub.us.kg",
                "https://dhub.kubesre.xyz"
        ]
}
```

重启 docker:

```sh
sudo systemctl restart docker
```



#### 实验特性

一些 docker 命令或功能仅当 **实验特性** 开启时才能使用，在类似 `镜像加速器` 的方法里编辑 json：

```json
"expermental": true
```



### 使用

#### 官方hello-world

下载一个项目：

```bash
git clone git@github.com:docker/getting-started.git
```

cd 进入这个项目，在 docker 窗里跑：

```bash
docker run --name repo alpine
```

验收标准：不能再跑这个命令，输出`docker:Error response from daemon: Conflict.`

跑这个指令：

```bash
docker build -t docker101tutorial
```

等待完毕后，跑：

```bash
docker run -d -p 80:80 --name docker-tutorial docker101tutorial
```

注册一个账号，然后执行指令例如，上传分享：

```bash
docker tag docker101tutorial lr580/docker101tutorial
docker push lr580/docker101tutorial
```

可以点击查看 [自己上传的内容](https://hub.docker.com/repositories)

验收：发现端口是 80 ，猜测是 httpd ，所以直接在浏览器跑一下 [localhost](https://localhost) ，能看到网页就胜利了

#### 启动

windows wsl 为例，检查是否运行：

```sh
docker version
docker info
```

常见错误：

```
$ docker info
Server:
ERROR: Error response from daemon: open \\.\pipe\docker_engine_linux: The system cannot find the file specified.
errors pretty printing info
```

重装：windows 直接搜 ubuntu-20.04，右击设置，重置

#### 杂项

可以在任意 cmd 窗口，如 powershell 使用 docker，也可以用 Desktop

由于许多输出颜色跟 Powershell 背景颜色相似，建议右击标题栏修改 powershell 背景颜色



## 指令

### 镜像

#### 列举

```bash
docker image ls
```

列表包含了 `仓库名`、`标签`、`镜像 ID`、`创建时间` 以及 `所占用的空间`。

> 在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 `docker image ls` 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小
>
> 镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多

通过 `docker system df` 命令来便捷的查看镜像、容器、数据卷所占用的空间



> 列举出摘要 (即 SHA256)
>
> ```bash
> docker image ls --digests
> ```
>
> 按名字精准查询，如：
>
> ```bash
> docker image ls -q docker101tutorial
> ```
>
> 某版本之前的，如：
>
> ```bash
> docker image ls -q -f before=mongo:3.2
> ```



#### 获取

```bash
docker pull --help
```

命令格式：

```bash
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]
```

例如：

```bash
docker pull ubuntu:18.04
```



#### 删除

```bash
docker image rm [选项] <镜像1> [<镜像2> ...]
```

其中，`<镜像>` 可以是 `镜像短 ID`、`镜像长 ID`、`镜像名` 或者 `镜像摘要`。短 ID 一般取长为 3 的前缀，足以区分即可

如：

```bash
docker image rm centos # 若 docker rmi
```

更精确的是使用镜像摘要来删除，先列出摘要：

```bash
docker image ls --digests
```

然后删除用 `名字@摘要全文` ，如：

```bash
docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
```

> 镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。

> 删除的过程先把满足我们要求的所有镜像标签都取消，当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。直到没有任何层依赖当前层时，才会真实的删除当前层。

> 除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。



可以使用组合技 `docker image rm $(一条指令)` ，如：

```bash
docker image rm $(docker image ls -q -f before=mongo:3.2)
```



#### 对比

```bash
docker diff 镜像
```



#### 保存

**慎用该指令** ,因为这种方法所有对镜像的操作都是黑箱操作，生成的镜像也被称为 **黑箱镜像**

```bash
docker commit --author "作者" --message "更改内容" 名字 镜像:版本
```



#### 历史

```bash
docker history 镜像
```



#### mainfest

不懂，大概是跨平台用的



#### import

格式：`docker import [选项] <文件>|<URL>|- [<仓库名>[:<标签>]]`

压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 `/` 目录展开，并直接作为镜像第一层提交，如：

```bash
docker import http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz openvz/ubuntu:16.04
docker image ls openvz/ubuntu
```



#### save

> Docker 还提供了 `docker save` 和 `docker load` 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以

使用 `docker save` 命令可以将镜像保存为归档文件

```bash
docker save alpine -o filename
file filename
```

这里的 filename 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件

注意：如果同名则会覆盖（没有警告）

如：

```bash
docker save alpine | gzip > alpine-latest.tar.gz
```

在另一台机子加载：

```bash
docker load -i alpine-latest.tar.gz
```

```bash
docker save <镜像名> | bzip2 | pv | ssh <用户名>@<主机名> 'cat | docker load'
```





### Dockerfile

镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。

Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。

在一个空白目录中，建立一个文本文件，并命名为 `Dockerfile` 

#### 概述

在该文件里输入：

```dockerfile
FROM nginx
RUN echo '<h1>Nya haha, I am lr580~</h1>' > /usr/share/nginx/html/index.html
```

##### FROM

FROM 是必备指令和第一条指令；除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 `scratch`。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像

##### RUN

RUN 执行命令行，格式为：`RUN <命令>` 或 `RUN ["可执行文件", "参数1", "参数2"]`

> Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层

为了压缩层数，将多个 RUN 使用 `&&` 串联；为了美观，使用 `\` 换行，使用 `#` 行首注释；通常安装完环境后还需要删除掉安装包



##### 构建

接下来在有 `Dockerfile` 的目录下构建：

```bash
docker build -t nginx:v3 .
```

通用格式为：

```bash
docker build [选项] <上下文路径/URL/->
```

`docker build` 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的；指定构建镜像上下文的路径，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件



##### 上下文

context

> `COPY` 这类指令中的源文件的路径都是*相对路径* ， `COPY ../package.json /app` 或者 `COPY /opt/xxxx /app` 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去，一种复制如：
>
> ```dockerfile
> COPY ./package.json /app/
> ```

一般来说，应该会将 `Dockerfile` 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 `.gitignore` 一样的语法写一个 `.dockerignore`，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的

> 这只是默认行为，实际上 `Dockerfile` 的文件名并不要求必须为 `Dockerfile`，而且并不要求必须位于上下文目录中，比如可以用 `-f ../Dockerfile.php` 参数指定某个文件作为 `Dockerfile`



##### 远程

可以用 `-t` 参数从 URL 构建，如：

```bash
docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world
```

也可以是 tar 压缩包，那么会自动解包：

```bash
docker build http://server/context.tar.gz
```



##### 输入构建

```bash
docker build - < Dockerfile
```

或

```bash
cat Dockerfile | docker build -
```

如果标准输入传入的是文本文件，则将其视为 `Dockerfile`，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 `COPY` 进镜像之类的事情。

可以读取上下文压缩包：

```bash
docker build - < context.tar.gz
```



##### 运行

在窗口化里点击运行，输入参数端口，然后直接访问 [localhost](https://localhost) 即可



##### 阶段

另一种方式，就是我们事先在一个 `Dockerfile` 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 `Dockerfile` 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂

如：

```dockerfile
FROM golang:alpine as builder

RUN apk --no-cache add git

WORKDIR /go/src/github.com/go/helloworld/

RUN go get -d -v github.com/go-sql-driver/mysql

COPY app.go .

RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest as prod

RUN apk --no-cache add ca-certificates

WORKDIR /root/

COPY --from=0 /go/src/github.com/go/helloworld/app .

CMD ["./app"]
```

使用 as 后，若只想构建某一阶段的镜像，就可以`--target=as名字`，如：

```dockerfile
FROM golang:alpine as builder
```

```bash
docker build --target builder -t username/imagename:tag .
```

使用 `COPY --from=0 /go/src/github.com/go/helloworld/app .` 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件

```dockerfile
$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf
```





#### 指令

##### COPY

格式：

`COPY [--chown=<user>:<group>] <源路径>... <目标路径>`

`COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]`

`COPY` 指令将从构建上下文目录中 `<源路径>` 的文件/目录复制到新的一层的镜像内的 `<目标路径>` 位置。比如：

```dockerfile
COPY package.json /usr/src/app/
```

`<源路径>` 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 [`filepath.Match`](https://golang.org/pkg/path/filepath/#Match) 规则：

```
pattern:
	{ term }
term:
	'*'         matches any sequence of non-Separator characters
	'?'         matches any single non-Separator character
	'[' [ '^' ] { character-range } ']'
	            character class (must be non-empty)
	c           matches character c (c != '*', '?', '\\', '[')
	'\\' c      matches character c

character-range:
	c           matches character c (c != '\\', '-', ']')
	'\\' c      matches character c
	lo '-' hi   matches character c for lo <= c <= hi
```

目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录

使用 `COPY` 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等

在使用该指令的时候还可以加上 `--chown=<user>:<group>` 选项来改变文件的所属用户及所属组，如：

```dockerfile
COPY --chown=55:mygroup files* /mydir/
COPY --chown=bin files* /mydir/
COPY --chown=1 files* /mydir/
COPY --chown=10:11 files* /mydir/
```

如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径



##### ADD

是 COPY 的超集

 `<源路径>` 可以是一个 `URL`，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 `<目标路径>` 去。下载后的文件权限自动设置为 `600`，如果这并不是想要的权限，那么还需要增加额外的一层 `RUN` 进行权限调整

> 另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 `RUN` 指令进行解压缩。所以不如直接使用 `RUN` 指令，然后使用 `wget` 或者 `curl` 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用
>
> 真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 `ADD` 命令了
>
> `ADD` 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢

可以遵循这样的原则，所有的文件复制均使用 `COPY` 指令，仅在需要自动解压缩的场合使用 `ADD`



##### CMD

`shell` 格式：`CMD <命令>`

`exec` 格式：`CMD ["可执行文件", "参数1", "参数2"...]`

参数列表格式：`CMD ["参数1", "参数2"...]`。在指定了 `ENTRYPOINT` 指令后，用 `CMD` 指定具体的参数

在指令格式上，一般推荐使用 `exec` 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 `"`，而不要使用单引号



Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。`CMD` 指令就是用于指定默认的容器主进程的启动命令的

如果使用 `shell` 格式的话，实际的命令会被包装为 `sh -c` 的参数的形式进行执行。比如

```dockerfile
CMD echo $HOME
```

会变为：

```dockerfile
CMD [ "sh", "-c", "echo $HOME" ]
```

容器内没有后台服务的概念，例如 `service nginx start` 会挂掉

对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西

正确的做法是直接执行 `nginx` 可执行文件，并且要求以前台形式运行。比如：

```bash
CMD ["nginx", "-g", "daemon off;"]
```



只可以出现一次，如果写了多个，只有最后一个生效

运行时可以替换掉这个默认指令



##### ENTERPOINT

格式同 RUN

`ENTRYPOINT` 在运行时也可以替代，不过比 `CMD` 要略显繁琐，需要通过 `docker run` 的参数 `--entrypoint` 来指定。

当指定了 `ENTRYPOINT` 后，`CMD` 的含义就发生了改变，不再是直接的运行其命令，而是将 `CMD` 的内容作为参数传给 `ENTRYPOINT` 指令



场景一：让镜像像命令一样使用，如：

```dockerfile
FROM ubuntu:18.04
RUN apt-get update \
    && apt-get install -y curl \
    && rm -rf /var/lib/apt/lists/*
ENTRYPOINT [ "curl", "-s", "http://myip.ipip.net" ]
```

构建：

```bash
docker build -t myip
```

那么可以同时支持：

```bash
docker run myip
docker run myip -i
```

而不是后者需要：

```bash
docker run myip curl -s http://myip.ipip.net -i
```

> 若 `dockerfile` 的最后一行是 CMD 就要这么做



只可以出现一次，如果写了多个，只有最后一个生效



场景二：应用前的准备

通常用于一些初始化(特别是可能需要 root 的)

```dockerfile
FROM alpine:3.4
...
RUN addgroup -S redis && adduser -S -G redis redis
...
ENTRYPOINT ["docker-entrypoint.sh"]

EXPOSE 6379
CMD [ "redis-server" ]
```

其 `docker-entrypoint.sh` 为：

```bash
#!/bin/sh
...
# allow the container to be started with `--user`
if [ "$1" = 'redis-server' -a "$(id -u)" = '0' ]; then
    find . \! -user redis -exec chown redis '{}' +
    exec gosu redis "$0" "$@"
fi

exec "$@"
```

该脚本的内容就是根据 `CMD` 的内容来判断，如果是 `redis-server` 的话，则切换到 `redis` 用户身份启动服务器，否则依旧使用 `root` 身份执行，如：

```bash
docker run -it redis id
```



##### ENV

设置环境变量

```
ENV <key> <value>
```

```
ENV <key1>=<value1> <key2>=<value2>...
```

换行，以及对含有空格的值用双引号括起来的办法，如：

```dockerfile
ENV VERSION=1.0 DEBUG=on \
    NAME="Happy Feet"
```

环境变量可以被后文使用，如：

```dockerfile
ENV NODE_VERSION 7.2.0

RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz"
```

> 下列指令可以支持环境变量展开： `ADD`、`COPY`、`ENV`、`EXPOSE`、`FROM`、`LABEL`、`USER`、`WORKDIR`、`VOLUME`、`STOPSIGNAL`、`ONBUILD`、`RUN`。



##### ARG

构建参数和 `ENV` 的效果一样，都是设置环境变量。所不同的是，`ARG` 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的

`docker history` 还是可以看到所有值的(所以不可以存敏感信息)

该默认值可以在构建命令 `docker build` 中用 `--build-arg <参数名>=<值>` 来覆盖。

ARG 指令有生效范围，如果在 `FROM` 指令之前指定，那么只能用于 `FROM` 指令中



##### VOLUME

定义匿名卷

容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中

可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据，如：

```dockerfile
VOLUME /data
```

任何向 `/data` 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：

```bash
docker run -d -v mydata:/data xxxx
```



##### EXPOSE

格式为 `EXPOSE <端口1> [<端口2>...]`

声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 `docker run -P` 时，会自动随机映射 `EXPOSE` 的端口

要将 `EXPOSE` 和在运行时使用 `-p <宿主端口>:<容器端口>` 区分开来。`-p`，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 `EXPOSE` 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射



##### WORKDIR

使用 `WORKDIR` 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，`WORKDIR` 会帮你建立目录，如：

```dockerfile
WORKDIR /app

RUN echo "hello" > world.txt
```

```dockerfile
WORKDIR /a
WORKDIR b
WORKDIR c

RUN pwd
```

> pwd在 `/a/b/c`



##### USER

`USER <用户名>[:<用户组>]`

注意，`USER` 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换

如果以 `root` 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 `su` 或者 `sudo`，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 [`gosu`](https://github.com/tianon/gosu)

```dockerfile
# 建立 redis 用户，并使用 gosu 换另一个用户执行命令
RUN groupadd -r redis && useradd -r -g redis redis
# 下载 gosu
RUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64" \
    && chmod +x /usr/local/bin/gosu \
    && gosu nobody true
# 设置 CMD，并以另外的用户执行
CMD [ "exec", "gosu", "redis", "redis-server" ]
```



##### HEALTHCHECK

`HEALTHCHECK [选项] CMD <命令>`：设置检查容器健康状况的命令

`HEALTHCHECK NONE`：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令

当在一个镜像指定了 `HEALTHCHECK` 指令后，用其启动容器，初始状态会为 `starting`，在 `HEALTHCHECK` 指令检查成功后变为 `healthy`，如果连续一定次数失败，则会变为 `unhealthy`。

`HEALTHCHECK` 支持下列选项：

- `--interval=<间隔>`：两次健康检查的间隔，默认为 30 秒；
- `--timeout=<时长>`：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；
- `--retries=<次数>`：当连续失败指定次数后，则将容器状态视为 `unhealthy`，默认 3 次

和 `CMD`, `ENTRYPOINT` 一样，`HEALTHCHECK` 只可以出现一次，如果写了多个，只有最后一个生效。

如：

```dockerfile
FROM nginx
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
HEALTHCHECK --interval=5s --timeout=3s \
  CMD curl -fs http://localhost/ || exit 1
```

构建和启动、检查：

```bash
docker build -t myweb:v1 .
docker run -d --name web -p 80:80 myweb:v1
docker container ls
```

检查：

```bash
docker inspect --format '{{json .State.Health}}' web | python -m json.tool
```



##### ONBUILD

`ONBUILD` 是一个特殊的指令，它后面跟的是其它指令，比如 `RUN`, `COPY` 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行



##### LABEL

`LABEL` 指令用来给镜像以键值对的形式添加一些元数据（metadata）

```dockerfile
LABEL <key>=<value> <key>=<value> <key>=<value> ...
```

如：

```dockerfile
LABEL org.opencontainers.image.authors="yeasy"

LABEL org.opencontainers.image.documentation="https://yeasy.gitbooks.io"
```



##### SHELL

格式：`SHELL ["executable", "parameters"]`

`SHELL` 指令可以指定 `RUN` `ENTRYPOINT` `CMD` 指令的 shell，Linux 中默认为 `["/bin/sh", "-c"]`

```dockerfile
SHELL ["/bin/sh", "-c"]

RUN lll ; ls

SHELL ["/bin/sh", "-cex"]

RUN lll ; ls
```

两个 `RUN` 运行同一命令，第二个 `RUN` 运行的命令会打印出每条命令并当遇到错误时退出。



### 容器

容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用

#### 枚举

`docker container ls -a`

`docker ps`

#### 启动

`docker run 镜像`

`-t` 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， `-i` 则让容器的标准输入保持打开，如：

```bash
docker run -t -i ubuntu:18.04 /bin/bash
```

当利用 `docker run` 来创建容器时，Docker 在后台运行的标准操作包括：

- 检查本地是否存在指定的镜像，不存在就从 registry 下载
- 利用镜像创建并启动一个容器
- 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层
- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
- 从地址池配置一个 ip 地址给容器
- 执行用户指定的应用程序
- 执行完毕后容器被终止



可以利用 `docker container start` 命令，直接将一个已经终止（`exited`）的容器启动运行。

可以在伪终端中利用 `ps` 或 `top` 来查看进程信息



#### 守护态运行

更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 `-d` 参数来实现

如果不使用 `-d` 参数运行容器，容器会把输出的结果 (STDOUT) 打印到宿主机上面

如果使用了 `-d` 参数运行容器，输出结果可以用 `docker logs` 查看

容器是否会长久运行，是和 `docker run` 指定的命令有关，和 `-d` 参数无关

使用 `-d` 参数启动后会返回一个唯一的 id，也可以通过 `docker container ls` 命令来查看容器信息



#### 终止

可以使用 `docker container stop` 来终止一个运行中的容器。

此外，当 Docker 容器中指定的应用终结时，容器也自动终止

中只启动了一个终端的容器，用户通过 `exit` 命令或 `Ctrl+d` 来退出终端时，所创建的容器立刻终止

终止状态的容器可以用 `docker container ls -a` 命令看到

处于终止状态的容器，可以通过 `docker container start` 命令来重新启动。

此外，`docker container restart` 命令会将一个运行态的容器终止，然后再重新启动它



#### 进入

在使用 `-d` 参数时，容器启动后会进入后台。

> 不是持久化操作，如果需要装包等，重启后将消失

某些时候需要进入容器进行操作，包括使用 `docker attach` 命令或 `docker exec` 命令，如：

```bash
docker run -dit ubuntu
docker container ls
docker attach 243c  #CONTAINER ID的前缀
```

*注意：* 如果从这个 stdin 中 exit，会导致容器的停止



`docker exec` 后边可以跟多个参数，这里主要说明 `-i` `-t` 参数。

只用 `-i` 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。

当 `-i` `-t` 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符，如：

```bash
docker run -dit ubuntu
docker container ls
docker exec -i 69d1 bash
docker exec -it 69d1 bash
```

如果从这个 stdin 中 exit，不会导致容器的停止



```bash
docker exec --help
```



#### 导出导入

导出：`docker export CONTAINER_ID > 文件名.tar`

导入：

- `cat 文件名.tar | docker import 镜像名/镜像:版本`
- `docker import URL 镜像`

如：

```bash
docker export 7691a814370e > ubuntu.tar
cat ubuntu.tar | docker import - test/ubuntu:v1.0
docker import http://example.com/exampleimage.tgz example/imagerepo
```

*注：用户既可以使用* *`docker load`* *来导入镜像存储文件到本地镜像库，也可以使用* *`docker import`* *来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。*

> 有一个完整的，包含卷的，导出多个docker容器组合，到另一台服务器运行的完整例子，参见 `服务器维护记事-domjudge榜单导出`。该笔记暂未公开。详细描述了全面综合的指令使用。
>

#### 删除

`docker container rm` ，如：

```bash
docker container rm trusting_newton
```

如果要删除一个运行中的容器，可以添加 `-f` 参数。Docker 会发送 `SIGKILL` 信号给容器。

用下面的命令可以清理掉所有处于终止状态的容器：

```bash
docker container prune
```

#### 文件导出

```sh
docker cp 容器IMAGE名:文件路径 外部路径
```

如：

```sh
docker cp mysql:/var/lib/mysql-files/647.txt 647.txt
```

> 这里镜像名字是 `mysql: 8.0` 所以可以用 mysql。

### 仓库

仓库（`Repository`）是集中存放镜像的地方。

一个容易混淆的概念是注册服务器（`Registry`）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 `docker.io/ubuntu` 来说，`docker.io` 是注册服务器地址，`ubuntu` 是仓库名

docker hub 是官方公共仓库

基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字

比如 `ansible/centos7-ansible` 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 `username/` 来指定使用某个用户提供的镜像，比如 `ansible` 用户

私有仓库、Nexus3.x 略，有需要再看



#### 登录

可以通过执行 `docker login` 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。

你可以通过 `docker logout` 退出登录。



#### 搜索

通过 `docker search` 命令来查找官方仓库中的镜像，如：

```bash
docker search centos
```

描述包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（`OFFICIAL`）、是否自动构建 （`AUTOMATED`）

查找的时候通过 `--filter=stars=N` 参数可以指定仅显示收藏数量为 `N` 以上的镜像



#### 拉取

```bash
docker pull
```



#### 推送

```bash
docker tag 镜像:版本 用户名/镜像:版本
docker push 用户名/镜像:版本
```

验证：

```bash
docker search username
```



### 数据

![image-20220207124300680](img/image-20220207124300680.png)

在容器中管理数据主要有两种方式：

- 数据卷（Volumes）
- 挂载主机目录 (Bind mounts)

`数据卷` 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：

- `数据卷` 可以在容器之间共享和重用
- 对 `数据卷` 的修改会立马生效
- 对 `数据卷` 的更新，不会影响镜像
- `数据卷` 默认会一直存在，即使容器被删除

`数据卷` 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）



#### 数据卷

##### 创建

```bash
docker volume create my-vol
```



##### 查看

列出全部：

```bash
docker volume ls
```

查看某个卷：

```bash
docker volume inspect my-vol
```

或(可能其实是两个不同的指令)

```bash
docker inspect my-vol
```



##### 启动

在用 `docker run` 命令的时候，使用 `--mount` 标记来将 `数据卷` 挂载到容器里。在一次 `docker run` 中可以挂载多个 `数据卷` ，如：

```bash
docker run -d -P \
    --name web \
    # -v my-vol:/usr/share/nginx/html \
    --mount source=my-vol,target=/usr/share/nginx/html \
    nginx:alpine
```



##### 删除

```bash
docker volume rm my-vol
```

`数据卷` 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 `数据卷`，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 `数据卷`。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 `docker rm -v` 这个命令。

无主的数据卷可能会占据很多空间，要清理请使用以下命令

```bash
docker volume prune
```



#### 主机目录

本地目录的路径必须是绝对路径，以前使用 `-v` 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 `--mount` 参数时如果本地目录不存在，Docker 会报错。如：

```bash
docker run -d -P \
    --name web \
    # -v /src/webapp:/usr/share/nginx/html \
    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \
    nginx:alpine
```

Docker 挂载主机目录的默认权限是 `读写`，用户也可以通过增加 `readonly` 指定为 `只读`，如：

```bash
docker run -d -P \
    --name web \
    # -v /src/webapp:/usr/share/nginx/html:ro \
    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \
    nginx:alpine
```

`--mount` 标记也可以从主机挂载单个文件到容器中，如：

```bash
docker run --rm -it \
   # -v $HOME/.bash_history:/root/.bash_history \
   --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \
   ubuntu:18.04 \
   bash
```

这样就可以记录在容器输入过的命令了。



### 网络

#### 端口

容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 `-P` 或 `-p` 参数来指定端口映射

当使用 `-P` 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口

如：

```bash
docker run -d -P nginx:alpine
docker container ls -l #port处看端口
```

同样的，可以通过 `docker logs` 命令来查看访问记录，如：

```bash
docker logs sth
```

`-p` 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 `ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort`。

使用 `hostPort:containerPort` 格式本地的 80 端口映射到容器的 80 端口，可以执行，如：

```bash
docker run -d -p 80:80 nginx:alpine
```

可以使用 `ip:hostPort:containerPort` 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1，可以：

```bash
docker run -d -p 127.0.0.1:80:80 nginx:alpine
```

使用 `ip::containerPort` 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口

```bash
docker run -d -p 127.0.0.1::80 nginx:alpine
```

还可以使用 `udp` 标记来指定 `udp` 端口

```bash
docker run -d -p 127.0.0.1:80:80/udp nginx:alpine
```



使用 `docker port` 来查看当前映射的端口配置，也可以查看到绑定的地址，如：

```bash
docker port sth 80
```

容器有自己的内部网络和 ip 地址（使用 `docker inspect` 查看，Docker 还可以有一个可变的网络配置。）

`-p` 标记可以多次使用来绑定多个端口，如：

```bash
docker run -d \
    -p 80:80 \
    -p 443:443 \
    nginx:alpine
```



#### 互联

> 建议将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 `--link` 参数

创建网络：

```bash
docker network create -d bridge my-net
```

运行一个容器并连接到新建的 `my-net` 网络

```bash
docker run -it --rm --name busybox1 --network my-net busybox sh
```

打开新的终端，再运行一个容器并加入到 `my-net` 网络

```bash
docker run -it --rm --name busybox2 --network my-net busybox sh
```

再在第三个终端查看容器信息：

```bash
docker container ls
```

此时两个容器可以互相 ping 通，如：

```bash
ping busybox2
```



#### DNS

 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。

在容器中使用 `mount` 命令可以看到挂载信息：

这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 `/etc/resolv.conf` 文件立刻得到更新。

配置全部容器的 DNS ，也可以在 `/etc/docker/daemon.json` 文件中增加以下内容来设置。

```bash
{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}
```

检验生效：

```bash
docker run -it --rm ubuntu:18.04 cat etc/resolv.conf
```

如果用户想要手动指定容器的配置，可以在使用 `docker run` 命令启动容器时加入如下参数：

`-h HOSTNAME` 或者 `--hostname=HOSTNAME` 设定容器的主机名，它会被写到容器内的 `/etc/hostname` 和 `/etc/hosts`。但它在容器外部看不到，既不会在 `docker container ls` 中显示，也不会在其他的容器的 `/etc/hosts` 看到。

`--dns=IP_ADDRESS` 添加 DNS 服务器到容器的 `/etc/resolv.conf` 中，让容器用这个服务器来解析所有不在 `/etc/hosts` 中的主机名。

`--dns-search=DOMAIN` 设定容器的搜索域，当设定搜索域为 `.example.com` 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 `host.example.com`。

> 注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 `/etc/resolv.conf` 来配置容器。

### 其他

##### 清理缓存

1. **删除停止的容器**：
   - 使用 `docker container prune` 命令来删除所有停止的容器。
2. **删除未使用的镜像**：
   - 使用 `docker image prune` 来删除悬空（dangling）的镜像，即那些没有标签且不被任何容器引用的镜像。
   - 使用 `docker image prune -a` 来删除所有未被容器引用的镜像。
3. **删除未使用的网络**：
   - 使用 `docker network prune` 来删除未被任何容器使用的网络。
4. **删除构建缓存**：
   - 使用 `docker builder prune` 来删除 Docker 构建缓存，这可能包括过时的中间层镜像。
5. **删除未使用的卷**：
   - 使用 `docker volume prune` 来删除未被任何容器使用的卷。
6. **一键清理**：
   - 使用 `docker system prune` 命令来一次性清理未使用的容器、网络、悬空镜像。
   - 使用 `docker system prune -a` 将清理所有未使用的容器、网络、镜像（不仅仅是悬空的）和构建缓存。

## Compose

`Compose` 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 `OpenStack` 中的 `Heat` 十分类似

定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」

它允许用户通过一个单独的 `docker-compose.yml` 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）

`Compose` 中有两个重要的概念：

- 服务 (`service`)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。
- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元，在 `docker-compose.yml` 文件中定义。

> 原版本是 Python 写的，目前 Docker 官方用 GO 语言 [重写](https://github.com/docker/compose-cli) 了 Docker Compose，并将其作为了 docker cli 的子命令，称为 `Compose V2`。你可以参照官方文档安装，然后将熟悉的 `docker-compose` 命令替换为 `docker compose`，即可使用 Docker Compose。

`Docker Desktop for Mac/Windows` 自带 `docker-compose` 二进制文件，安装 Docker 之后可以直接使用(默认为v2)

使用如下命令查看是否装了：

```bash
docker-compose --version
```

Linux 有多种方法安装



### 使用

#### Hello world

在新的目录编写 `app.py` ：

```python
from flask import Flask
from redis import Redis

app = Flask(__name__)
redis = Redis(host='redis', port=6379)

@app.route('/')
def hello():
    count = redis.incr('hits')
    return 'Nya! lr580\'s here ovo <br/> 该页面已被访问 {} 次。\n'.format(count)

if __name__ == "__main__":
    app.run(host="0.0.0.0", debug=True)
```

> 每次重启 count 会被清零

编写 `Dockerfile` ，内容：

```dockerfile
FROM python:3.6-alpine
ADD . /code
WORKDIR /code
RUN pip install redis flask
CMD ["python", "app.py"]
```

编写 `docker-compose.yml` ，内容：

```yml
version: '3'
services:

  web:
    build: .
    ports:
     - "5000:5000"

  redis:
    image: "redis:alpine"
```

运行：

```bash
docker-compose up
```

在同一目录下执行以下指令结束：

```bash
docker-compose down
```



### 指令

通用格式：

```bash
docker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]
```

`-f, --file FILE` 指定使用的 Compose 模板文件，默认为 `docker-compose.yml`，可以多次指定。

`-p, --project-name NAME` 指定项目名称，默认将使用所在目录名称作为项目名。

`--verbose` 输出更多调试信息。

`-v, --version` 打印版本并退出。



#### help

```bash
docker-compose help
docker-compose 指令 --help
```



#### build

格式为 `docker-compose build [options] [SERVICE...]`。

构建（重新构建）项目中的服务容器。

服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。

可以随时在项目目录下运行 `docker-compose build` 来重新构建服务。

选项包括：

- `--force-rm` 删除构建过程中的临时容器。
- `--no-cache` 构建镜像过程中不使用 cache（这将加长构建过程）。
- `--pull` 始终尝试通过 pull 来获取更新版本的镜像。



#### config

验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。



#### down

此命令将会停止 `up` 命令所启动的容器，并移除网络



#### exec

进入指定的容器



#### images

列出 Compose 文件中包含的镜像。

`up` 时才能看到，如果全部关闭是看不到的



#### kill

格式为 `docker-compose kill [options] [SERVICE...]`。

通过发送 `SIGKILL` 信号来强制停止服务容器。

支持通过 `-s` 参数来指定发送的信号，例如通过如下指令发送 `SIGINT` 信号。

```bash
docker-compose kill -s SIGINT
```



#### logs

格式为 `docker-compose logs [options] [SERVICE...]`。

查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 `--no-color` 来关闭颜色。

该命令在调试问题的时候十分有用。



#### pause

格式为 `docker-compose pause [SERVICE...]`。

暂停一个服务容器。



#### port

格式为 `docker-compose port [options] SERVICE PRIVATE_PORT`。

打印某个容器端口所映射的公共端口。

选项：

- `--protocol=proto` 指定端口协议，tcp（默认值）或者 udp。
- `--index=index` 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。



#### ps

格式为 `docker-compose ps [options] [SERVICE...]`。

列出项目中目前的所有容器。

选项：

- `-q` 只打印容器的 ID 信息。



#### pull

格式为 `docker-compose pull [options] [SERVICE...]`。

拉取服务依赖的镜像。

选项：

- `--ignore-pull-failures` 忽略拉取镜像过程中的错误。



#### push

推送服务依赖的镜像到 Docker 镜像仓库。



#### restart

格式为 `docker-compose restart [options] [SERVICE...]`。

重启项目中的服务。

选项：

- `-t, --timeout TIMEOUT` 指定重启前停止容器的超时（默认为 10 秒）。



#### rm

格式为 `docker-compose rm [options] [SERVICE...]`。

删除所有（停止状态的）服务容器。推荐先执行 `docker-compose stop` 命令来停止容器。

选项：

- `-f, --force` 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。
- `-v` 删除容器所挂载的数据卷。



#### run

格式为 `docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]`。

在指定服务上执行一个命令。例如：

```bash
docker-compose run ubuntu ping docker.com
```

将会启动一个 ubuntu 服务容器，并执行 `ping docker.com` 命令。

默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。

该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。

两个不同点：

- 给定命令将会覆盖原有的自动运行命令；
- 不会自动创建端口，以避免冲突。

如果不希望自动启动关联的容器，可以使用 `--no-deps` 选项，例如

```bash
docker-compose run --no-deps web python manage.py shell
```

将不会启动 web 容器所关联的其它容器。

选项：

- `-d` 后台运行容器。
- `--name NAME` 为容器指定一个名字。
- `--entrypoint CMD` 覆盖默认的容器启动指令。
- `-e KEY=VAL` 设置环境变量值，可多次使用选项来设置多个环境变量。
- `-u, --user=""` 指定运行容器的用户名或者 uid。
- `--no-deps` 不自动启动关联的服务容器。
- `--rm` 运行命令后自动删除容器，`d` 模式下将忽略。
- `-p, --publish=[]` 映射容器端口到本地主机。
- `--service-ports` 配置服务端口并映射到本地主机。
- `-T` 不分配伪 tty，意味着依赖 tty 的指令将无法运行。



#### scale

格式为 `docker-compose scale [options] [SERVICE=NUM...]`。

设置指定服务运行的容器个数。

通过 `service=num` 的参数来设置数量。例如：

```bash
docker-compose scale web=3 db=2
```

一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器

选项：

- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）



#### start

格式为 `docker-compose start [SERVICE...]`。

启动已经存在的服务容器。



#### stop

格式为 `docker-compose stop [options] [SERVICE...]`。

停止已经处于运行状态的容器，但不删除它。通过 `docker-compose start` 可以再次启动这些容器。

选项：

- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。



#### top

查看各个服务容器内运行的进程。



#### unpause

格式为 `docker-compose unpause [SERVICE...]`。

恢复处于暂停状态中的服务。



#### up

格式为 `docker-compose up [options] [SERVICE...]`。

该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。

链接的服务都将会被自动启动，除非已经处于运行状态。

可以说，大部分时候都可以直接通过该命令来启动一个项目。

默认情况，`docker-compose up` 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。

当通过 `Ctrl-C` 停止命令时，所有容器将会停止。

如果使用 `docker-compose up -d`，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。

默认情况，如果服务容器已经存在，`docker-compose up` 将会尝试停止容器，然后重新创建（保持使用 `volumes-from` 挂载的卷），以保证新启动的服务匹配 `docker-compose.yml` 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 `docker-compose up --no-recreate`。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 `docker-compose up --no-deps -d <SERVICE_NAME>` 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。

选项：

- `-d` 在后台运行服务容器。
- `--no-color` 不使用颜色来区分不同的服务的控制台输出。
- `--no-deps` 不启动服务所链接的容器。
- `--force-recreate` 强制重新创建容器，不能与 `--no-recreate` 同时使用。
- `--no-recreate` 如果容器已经存在了，则不重新创建，不能与 `--force-recreate` 同时使用。
- `--no-build` 不自动构建缺失的服务镜像。
- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。



### compose文件

默认的模板文件名称为 `docker-compose.yml`，格式为 YAML 格式。

注意每个服务都必须通过 `image` 指令指定镜像或 `build` 指令（需要 Dockerfile）等来自动构建生成镜像。

如果使用 `build` 指令，在 `Dockerfile` 中设置的选项(例如：`CMD`, `EXPOSE`, `VOLUME`, `ENV` 等) 将会自动被获取，无需在 `docker-compose.yml` 中重复设置。



#### build

指定 `Dockerfile` 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 `Compose` 将会利用它自动构建这个镜像，然后使用这个镜像。如：

```yml
version: '3'
services:

  webapp:
    build: ./dir
```

你也可以使用 `context` 指令指定 `Dockerfile` 所在文件夹的路径。

使用 `dockerfile` 指令指定 `Dockerfile` 文件名。

使用 `arg` 指令指定构建镜像时的变量。

```yml
version: '3'
services:

  webapp:
    build:
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1
```

使用 `cache_from` 指定构建镜像的缓存

```yml
build:
  context: .
  cache_from:
    - alpine:latest
    - corp/web_app:3.14
```



#### cap_add,cap_drop

指定容器的内核能力（capacity）分配。

例如，让容器拥有所有能力可以指定为：

```yml
cap_add:
  - ALL
```

去掉 NET_ADMIN 能力可以指定为：

```yml
cap_drop:
  - NET_ADMIN
```



#### command

覆盖容器启动后默认执行的命令。

```yml
command: echo "hello world"
```



#### container_name

指定容器名称。默认将会使用 `项目名称_服务名称_序号` 这样的格式。

```yml
container_name: docker-web-container
```

> 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。



#### dns

自定义 `DNS` 服务器。可以是一个值，也可以是一个列表。

```yml
dns: 8.8.8.8

dns:
  - 8.8.8.8
  - 114.114.114.114
```

配置 `DNS` 搜索域。可以是一个值，也可以是一个列表。

```yml
dns_search: example.com

dns_search:
  - domain1.example.com
  - domain2.example.com
```



#### env_file

从文件中获取环境变量，可以为单独的文件路径或列表。

如果通过 `docker-compose -f FILE` 方式来指定 Compose 模板文件，则 `env_file` 中变量的路径会基于模板文件路径。

如果有变量名称与 `environment` 指令冲突，则按照惯例，以后者为准。

```yml
env_file: .env

env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env
```

环境变量文件中每一行必须符合格式，支持 `#` 开头的注释行。

设置环境变量。你可以使用数组或字典两种格式。

只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。

```yml
environment:
  RACK_ENV: development
  SESSION_SECRET:

environment:
  - RACK_ENV=development
  - SESSION_SECRET
```

如果变量名称或者值中用到 `true|false，yes|no` 等表达 [布尔](https://yaml.org/type/bool.html) 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括

```yml
y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF
```



Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 `.env` 文件中的变量。

例如，下面的 Compose 文件将从运行它的环境中读取变量 `${MONGO_VERSION}` 的值，并写入执行的指令中。

```yml
version: "3"
services:

db:
  image: "mongo:${MONGO_VERSION}"
```





#### image

指定为镜像名称或镜像 ID。如果镜像在本地不存在，`Compose` 将会尝试拉取这个镜像。

```yml
image: ubuntu
image: orchardup/postgresql
image: a4bc65fd
```



> 网络看文档吧，我不知道有什么用



#### secrets

存储敏感数据，例如 `mysql` 服务密码。

```yml
version: "3.1"
services:

mysql:
  image: mysql
  environment:
    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password
  secrets:
    - db_root_password
    - my_other_secret

secrets:
  my_secret:
    file: ./my_secret.txt
  my_other_secret:
    external: true
```



#### volumes

数据卷所挂载路径设置。可以设置为宿主机路径(`HOST:CONTAINER`)或者数据卷名称(`VOLUME:CONTAINER`)，并且可以设置访问模式 （`HOST:CONTAINER:ro`）。

该指令中路径支持相对路径。

```yml
volumes:
 - /var/lib/mysql
 - cache/:/tmp/cache
 - ~/configs:/etc/configs/:ro
```

如果路径为数据卷名称，必须在文件中配置数据卷。

```yml
version: "3"

services:
  my_src:
    image: mysql:8.0
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:
```



## 例子

### 模拟centos

```sh
docker run --network host --hostname localhost --dns 8.8.8.8 -it centos /bin/bash
#localhost是为了root@localhost好看，不然不好看；host是本机网络
docker run --hostname localhost -it centos /bin/bash
```

> 安装 httpd:
>
> ```sh
> curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo # 替换源
> ```

开启 clash, service 安装，开 TUN，使得 wsl 可翻墙

> Failed to set locale, defaulting to C.UTF-8

```sh
yum install -y glibc-langpack-en
```



### nginx hello world



# node.js

与前端相关的，如部署前端框架项目等，参见 `web.md-node`

## 概述

### 概念

简单的说 Node.js 就是运行在服务端的 JavaScript。

nodejs 构成：ECMAScript + node内置 api，没有 DOM 和 BOM。

> 由于语法与 js 相似度高，相同部分不再赘述，翻阅 `web.md`。
>
> 浏览器：js = ECMAScript + BOM + DOM，服务器：js = ECMAScript + node系统内置核心模块

可以实现：web 服务端、命令行工具、爬虫、桌面应用程序等

npm 是 Node.js 的包管理工具 (Node Package Manager)

npx 的作用是在本地安装并运行一个 Node.js 包 (Node Package Executor)

组成成分：

1. **引入 required 模块：**我们可以使用 **require** 指令来载入 Node.js 模块。
2. **创建服务器：**服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。
3. **接收请求与响应请求** 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。



### 安装使用

安装参见菜鸟教程。[nodejs官网](https://nodejs.org/zh-cn/)

查看是否已经安装：

```shell
node -v
```

交互式(类似python IDLE)命令行：(输入 `.exit` 或 ctrl+d 退出)

```shell
node
```

> 如，进入后可以输入 `console.log("Hell world!")`

运行代码 `js` 文件，如：

```js
//gishw.js
console.log('白茶。')
```

```shell
node gishw.js
```

vscode 插件对的话，可以直接 f5 或其他方法(code runner ctrl+shift+n)运行。



### npm

#### 基本

> 专门收集模块工具包的网站 [链接](https://www.npmjs.cn/)。

npm 可以用来获取第三方包，以及发布自己的包。不需要单独安装 npm，装 node 会附带。

> cnpm 是国内镜像的 npm

查看版本：

```shell
npm -v
```

升级 npm：(可以简写为 `-g`)

```shell
npm install npm --global
```

本地安装是：(全局安装加上 `-g`)(install 可以简写为 `i`)

```shell
npm install 包名
```

> 如：(特定版本用 `@` 如 `express@4.17.1`)(最新版本是 `@next`)
>
> ```shell
> npm install express -g
> ```

查看局部/全局已安装的包：(`-g` 全局)

```sh
npm list
```

卸载：

```shell
npm uninstall 模块名
```

更新：

```sh
npm update 模块名
```

创建模块：(不交互式创建，使用默认值就 `-y`；结果是生成 `package.json`)

```sh
npm init
```

> 模块包含的信息：
>
> - name 包名
> - version 版本号
> - description 描述
> - homepage 该包的官网url
> - author 作者
> - contribotors 其他贡献者
> - dependencies 依赖包列表(未安装自动装到 `node_module/`)
> - repository 代码仓库(git/svn)
> - main 主文件入口，使得 require 加载该文件，默认是 `index.js`
> - keywords 关键字



#### nodemon

```sh
npm i -g nodemon
```

传统运行方法 `node app.js` 代码被修改后要手动重启项目。

而 nodemon 在修改代码时会监听，然后自动重启项目。运行：`nodemon app.js`



#### nrm

npm registry manager 镜像源管理工具。

```sh
npm i -g nrm
```

查看源：

```sh
nrm ls
```

换源：

```sh
nrm use taobao
```



### yarn

Yet Another Resource Negotiator。JS 包管理工具。[官网](https://yarnpkg.com/en/docs)，[中文官网](https://yarn.bootcss.com/)



#### 基本

安装：

```sh
npm i -g yarn
```

检查安装完毕：

```sh
yarn --version
```

![image-20230105182243488](img/image-20230105182243488.png)



### 协同

一般项目共享前，把 `node_modules` 忽略，然后共享到代码仓库。因为有 `package.json`，对方执行

```sh
npm install
```

会根据该文件自动装包

可以在其下添加字段：

```js
"scripts":{
  "test":"echo \"Error: no test specified\" && exit 1",
  "start":"node app.js",
  "dev":"node test.js",
  "build":"node build.js"
},
```

然后执行 `npm run start` 即等于执行 `start` 对应的内容(当然不是单纯的，会加一些前后内容)



## 基本语法

### 模块

#### 基本

一个 js 文件就是一个模块，作用域私有，内部变量和函数只有当前文件可用。

别人要用模块，以对象形式用 `exports` 或 `module.exports` 导出；别人引入时用 `require` 来引入。

模块定义规范：

- AMD 规范。require.js (只在浏览器端)
- CMD 规范。 Sea.js (只在浏览器端)
- CommonJS 的 Modules 规范：NodeJS (只在服务器端)
- ES6 模块化规范 import \.\.\. from \.\.\. (node不支持)

以 CommonJS 为例，一个模块 `m1.js` 可以用下面两种方法之一定义要导出的内容：

```js
//导出方法一
exports.num = 580;
exports.fn = function () {
    console.log(1437);
}
```

```js
//导出方法二
var num2 = 582;
module.exports = {
    num: 581,
    fn: function () {
        console.log(1438)
    },
    num2
};
```

另一个调用模块的代码文件 `m2.js`：

```js
const m1 = require("./m1.js"); //同目录下
console.log(m1.num);
m1.fn();
```

运行 `m2.js` 即可看到效果。

其中，`exports` 是 `module.exports` 的引用。且 `this` 对象就是 `exports` 对象。不等于 `global` 全局对象。即：

```js
console.log(exports === module.exports); //T
console.log(this === exports); //T
console.log(this === global); //F
```

> global 是全局变量。如 console, setTimeout 是其成员
>
> ```js
> let b = 580;
> var c = 581;
> const d = 582;//下均undef
> console.log(global.b, global.c, global.d);
> global.a = 583;
> console.log(a);
> console.log(process.argv);//node命令所在位置,当前代码文件所在路径,(如果有)main参数
> console.log(process.arch);//系统位数，如 x64
> ```





#### babel+ES6

> Babel 是一个 JavaScript 编译器，它可以将 JavaScript 代码转换成向后兼容的版本。Babel 可以转换新的 JavaScript 语法，也可以将新的 JavaScript 语法转换成旧的语法，以便在不支持新语法的浏览器或运行环境中运行。(chatGPT)

安装：(会在当前目录下下载内容)

```shell
npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node
npm install --save @babel/polyfill
```

创建 `babel.config.js` 配置该插件：

```js
const presets = [
    ["@babel/env", {
        targets: {
            edge: "17",
            firefox: "60",
            chrome: "67",
            safari: "11.1"
        }
    }]
]
module.exports = { presets }
```

使用如下命令执行一般的 js 代码：

```shell
npx babel-node ./index.js
```

因此，可以用 ES6 语法了。即如 `m3.js` 如下：

```js
export const num = 581;
export function fn () {
    console.log(233);
}
```

`m4.js` 如下，并按上面格式运行 `m4.js`：

```js
import { num, fn } from "./m3.js";
console.log(num);
fn();
```

缺点是速度显然比常规跑代码(秒出)要慢(这个要几秒)。



#### 内置

三种模块：内置模块、自己写的模块、第三方模块(npm)

常用内置模块：[详见]()

- `fs` 文件操作
- `http` 网络操作
- `path` 路径操作
- `querystring` 查询参数解析
- `url` URL解析

导入方法，如：

```js
const fs = require('fs');
```



##### path

常见常量和函数：

```js
const path = require("path");
console.log(__dirname);//绝对路径(不含文件名)
console.log(__filename);//绝对路径(含文件名)
console.log(path.extname(__filename))//后缀('.xx')
console.log(path.basename(__filename))//文件名+后缀
console.log(path.parse(__filename))//对象
//root:, dir:, base:, ext:, name: (base=name+ext)
console.log(path.parse(__filename)['name'])
console.log(path.join(__dirname, 'm1.js'))
console.log(path.join(__dirname, 'a', 'm1.js'))
```



##### fs

###### 同步读取

等读完才执行后面的代码。

```js
const fs = require("fs");
const path = require("path");
let data1 = fs.readFileSync("1.txt");//Buffer
console.log(data1.toString());
let data2 = fs.readFileSync(path.join(__dirname, "2.txt"));//绝对路径
console.log(data2.toString());
console.log("Done");//同步表征
//可以填多一个参数'utf8',则返回字符串而不是buffer,下同or'utf-8'
```

###### 异步读取

```js
const fs = require("fs");
fs.readFile('1.txt', 'utf8', (err, data) => {
    if (err) {
        console.err(err);
        return;
    }
    console.log(data);
});
console.log('异步表征');
```

###### 写入

```js
const fs = require("fs");
fs.writeFileSync('10.txt', '你好小笼包谢谢再见');
console.log('Done1');
fs.writeFile('11.txt', '依托答辩', (err) => {
    console.log(err);//null
    console.log('Done2');
});//想加utf8的话插入到第二个参数位
console.log('异步表征');
```

###### 其他

重命名：

```js
fs.renameSync('11.txt', '12.txt');//旧,新
```

获取一个目录所有文件：

```js
let names = fs.readdirSync(__dirname);//数组
for (let i in names) {//文件和文件夹名字(文件就basename)
    console.log(names[i]);
}
```





###### 举例

实现文件 `c=a+b`，要求并发。

```js
const fs = require("fs");
//在保证并发的情况下同步
var d1 = undefined, d2 = undefined;
function write() {
    if (d1 && d2) {
        fs.writeFileSync('3.txt', d1 + d2);
    }
};
fs.readFile('1.txt', 'utf8', (err, data) => {
    console.log('read 1');
    d1 = data; write();
});
fs.readFile('2.txt', 'utf8', (err, data) => {
    console.log('read 2');
    d2 = data; write();
});
```



##### http

###### 基本

四个步骤：

1. 导入 http 模块
2. 定义服务器程序接口
3. 创建服务器对象
4. 调用服务器的监听方法，让服务器监听浏览器请求

搭建一个 hello world 服务器，凡是有请求都返回一句话

```js
const http = require('http');
//不要端口冲突如mysql3306 mongodb27017
const port = 15800;
//req:请求 res:响应
const server = http.createServer((req, res) => {
    res.setHeader('Content-type', 'text/html;charset=utf-8');
    res.write('不要回答！');
    res.end();
});
server.listen(port, () => {
    console.log('服务器已开启');
});
```

运行后，在浏览器输入 `localhost:15800` 得到不要回答的响应。

> end 表示最后一次写，上述代码等价于：
>
> ```js
> res.write('不要');
> res.write('回')
> res.end('答！');
> ```

> 如果想要浏览器可以 get，以 chrome 为例，需要解决跨域问题 CORS，一种方案是，对 chrome 快捷键右击属性，设起始位置为 x。则目标后面添加 ` --args --disable-web-security --user-data-dir=x`。左移 x 是字符串不需要引号，如目标 `"C:\Program Files\Google\Chrome\Application\chrome.exe" --args --disable-web-security --user-data-dir=C:\Program Files\Google\Chrome\Application`
>
> 一个更好的办法：添加 chrome 插件 CORS Unblock，[下载地址](https://chrome.google.com/webstore/detail/cors-unblock/lfhmikememgdcahcdlaciloancbhjino/related?hl=zh-CN)

一个 get 的例子：

```html
<script src="js/jquery.js"></script>
<script>
    $.ajax({
        url:'http://localhost:15800',
        type:'get',
        success:(data)=>{
            console.log(data);
        },
        error:(xhr,status,error)=>{console.log(error);}
    });
</script>
```



###### 获取请求信息

```js
const url = require('url');
const http = require('http');
const server = http.createServer((req, res) => {
    console.log('url:', req.url);
    console.log('method:', req.method);
    let obj = url.parse(req.url, true);
    //第二个参数是一个布尔值，表示是否将查询字符串解析为对象。默认为 true。(chatGPT)
    //第三个参数是一个布尔值，表示是否将不带协议的 URL 解析为相对路径。默认为 false。
    console.log('query:', obj.query);
    req.on('data', (postData) => {
        console.log('data:', postData.toString());
    });
    res.setHeader('Content-type', 'text/html;charset=utf-8');
    res.end('这一点都不好玩');
});
server.listen(15800, () => { console.log('pending'); });
```

例如传送：`http://localhost:15800/?a=1&b=32c`，得到输出：

```js
url: /?a=1&b=32c
method: GET
query: [Object: null prototype] { a: '1', b: '32c' }
```

假设写一个 post：

```html
<script src="js/jquery.js"></script>
<script>
    $.ajax({
    url:'http://localhost:15800',
    type:'post',
    data:{a:'c',b:4},
    success:(data)=>{
        console.log(data);
    },
    error:(xhr,status,error)=>{console.log(error);}
});
</script>
```

输出的 data 为 `data: a=c&b=4`, query 是 null



> ```js
> const http = require('http');
> const querystring = require('querystring');
> let server = http.createServer((req, res) => {
>     var str = '';
>     req.on('data', function (data) { str += data; })
>     req.on('end', function () {
>         console.log('str:', str);
>         let json = querystring.parse(str);
>         console.log('json:', json);
>     });
>     res.end('白茶');
> });
> server.listen(15800);
> ```
>
> 输出：
>
> ```js
> str: a=c&b=4
> json: [Object: null prototype] { a: 'c', b: '4' }
> ```



###### web服务器

返回 HTML 形式的数据即可。

```js
const http = require('http');
const fs = require('fs');
let server = http.createServer((req, res) => {
    res.setHeader('Content-type', 'text/html;charset=utf-8');
    if (req.url === '/' || req.url === '/index.html') {
        let ct = fs.readFileSync('index.html');
        res.end(ct);
    }//else if
    else {
        res.end("404 NOT FOUND");
    }
});
server.listen(15800);
```

则直接 `http://localhost:15800` 即可



##### util

###### promisify

将一个异步函数改造成一个 Promise。

```js
const util = require('util');
const fs = require('fs');
var f = util.promisify(fs.readFile);
f('./1.txt', 'utf8').then((data) => {
    console.log(data);
    return f('./2.txt', 'utf8');
}).then((data) => {
    console.log(data);
});
//或 Promise.all
Promise.all([
    f('./1.txt', 'utf8'), f('./2.txt', 'utf8')
]).then((data) => {
    console.log(data[0], data[1]);
});
```





#### 第三方

##### md5

```js
const md5 = require('md5');
console.log(md5('白茶'));
```



##### express

web 开发框架。[官网](http://www.expressjs.com.cn)。可以搭建：

- Web 网站服务器。对外提供 web 网页资源。
- API 接口服务器。对外提供 API 接口。

###### 基本

```js
const express = require('express');
const app = express();
app.get('/user', function (req, res) {
    res.send({ name: '白茶', id: 581 });
});
app.post('/user', function (req, res) {
    res.send('post');//建议返回obj
});
app.listen(15800, () => { console.log('Started'); });

```

获取 get URL 参数：

```js
app.get('/user', function (req, res) {
    console.log(req.query);//得到object,key:val
    res.send({ name: req.query.name, id: 581 });
});
```

获取层级参数(动态参数)：(如 `http://127.0.0.1:15800/user/1/baicha`)

```js
app.get('/user/:id/:name', function (req, res) {
    console.log(req.params);
    res.send({ name: req.params.name, id: req.params.id });
});
```

托管若干个静态资源：取一个文件夹作为根目录，可以访问该目录下的所有文件(按URL路径)

```js
app.use(express.static('resource'));
```

> 设该目录下(即当前运行目录下的 `resource/index.html`, `resources/sub/another.html`)，则可以输入 `http://127.0.0.1:15800/index.html`, `http://127.0.0.1:15800/sub/another.html`
>
> 当前目录用 `__dirname` 绝对
>
> 可以挂载路径前缀，`app.use("/res", express.static('resource'));`



###### 路由

路由即映射关系，路径对应页面。指客户端请求与服务器处理函数的映射关系。分为请求的类型、请求的 URL 地址、处理函数：

```js
app.methods(path, handle)
```

上文的 get 和 post 实际上就是路由。其中 methods 就是请求的类型。将路由直接挂载在 app 上。

为了方便管理众多模块，建议将路由分模块，即：

1. 创建路由模块对应的 `.js` 文件
2. 调用 `express.Router()` 创建路由对象
3. 将路由对象挂载具体路由
4. 调用 `module.exports` 向外共享路由对象
5. 用 `app.use()` 注册路由模块

例如创建模块如下：(`expuser.js`)

```js
const express = require('express')
const router = express.Router()
router.get('/user/list', function (req, res) {
    res.send('假装是列表');
});
module.exports = router;
```

```js
const express = require('express');
const app = express();
const userRouter = require('./expuser.js');
app.use(userRouter);
app.listen(15800);
```

如果要给模块加前缀，可以：`app.use('/a1',userRouter)`，则需要访问 `a1/user/list`。



###### 中间件

middleware。业务处理的中间处理环节。可以认为时预处理。中间件的实现形式：

```js
app.get("/",function(req,res,next)){next();}
```

如：

```js
const express = require('express');
const app = express();
app.use(function (req, res, next) {
    console.log('预处理');
    next();
});
app.get("/", (req, res) => {console.log(1); res.send('这是①个首页'); })
app.listen(15800);
```

可以通过中间件往 req 里塞东西(新属性)来达到数据流传递的作用

如果想要中间件局部生效，可以 `app.get(路径,中间件函数,处理函数本体)`

多个中间件，就 `函数1,函数2` 或 `[函数1,函数2]` 去替换上述中间件函数位置。注意：

1. 一定要在路由之前注册中间件
2. 客户端发来的请求可以连续调用多个中间件，执行完记得 next
3. 调用 next 后不要再写别的东西
4. 多个中间件共享 res, req

中间件的分类：

1. 应用级别 `app.use, app.get, app.post` (全局中间件，局部中间件)

2. 路由级别 `router.use`。绑定的主体对象不同

3. 错误级别 `(err,req,res,next)` 函数参数。捕获错误和主动的 throw。必须在所有路由之后，listen之前

   ```js
   const express = require('express');
   const app = express();
   app.get("/", (req, res) => { throw new Error('QwQ'); });
   app.get("/user", (req, res) => { res.send("哈哈"); });
   app.use((err, req, res, next) => { res.send(`错误:${err.message}`); });
   app.listen(15800);
   ```

4. Express 内置

   1. `express.static`
   2. `express.json` 解析请求的数据(4.16.0+)
   3. `express.urlencoded` 解析 URL-encoded 格式请求体(4.16.0+)

   ```js
   const express = require('express');
   const app = express();
   app.use(express.json());//至少要后者才可输出body
   app.use(express.urlencoded({ extended: false }));
   app.post("/", (req, res) => {
       console.log(req.body);
       res.send('ok');
   });
   app.listen(15800);
   //如输出 [Object: null prototype] { a: 'c', b: '4' }
   ```

5. 第三方

   如 body-parser，是 urlencoded 的封装来源，有：

   ```js
   const parser = require('body-parser');
   app.use(parser.urlencoded({ extended: false }));
   ```



###### 监听

数据量比较大，客户端会分批发送。则会触发多次 `data` 事件，最后一次发送触发 `end` 事件。需要对 `data` 拼接。即在处理函数里，对 `req` 绑定两个函数：

```js
let str='';
req.on('data',(chunk)=>{str+=chunk;});
req.on('end',()=>{console.log('处理str');});
```

通常，可以在中间件实现，并将 end 结果挂载到 req 的新属性里



###### 跨域

CORS cross-origin resource sharing

只有支持 XMLHttpRequest Level2 的浏览器才能正常访问开启了 CORS 服务端接口，如 IE10+， Chrome4+, FireFox3.5+

安装 `cors` 模块后，可：

```js
const cors = require('cors');
app.use(cors());
```

可以添加头：

```js
res.setHeader('Access-Control-Allow-Origin','*');//*可以换成完整url,表示只允许来自该url的请求
```

这是因为默认 CORS 只支持客户端向服务端发送 9 种请求头，而其不在生命力。可以添加：

```js
res.setHeader('Access-Control-Allow-Methods','POST, GET, DELETE, HEAD')
//默认没有delete,三大简单请求外需要预检
res.setHeader('Access-Control-Allow-Methods', '*');//简单省事
res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-Custom-Header');
```

> 简单请求：只发送一次请求。
>
> 预检请求：option 预检请求一次，然后再请求一次

jsonp 是通过 script src 属性请求服务器数据，服务器返回函数调用。不属于 Ajax，没有 XMLHttprequest，只支持 get。防止冲突配置 jsonp：

```js
app.geet('/api/jsonp', (req,res)=>{});//不视为jsp接口的接口
app.use(cors())
app.geet('/api/get', (req,res)=>{});
```

通常而言 jsonp 的函数为：

```js
const funcName = req.query.callback;
const data = {}; //...
const scriptStr = `${funcName}(${JSON.stringify(data)})`;
res.send(scriptStr);
```

网页请求：

```js
$.ajax({
    method:'GET',
    url:'http:127.0.0.1:15800/api/jsonp',
    dataType:'jsonp',
    success:function(res){console.log(res);}
})
```



###### template

模板引擎。对 html 字符串用一种快捷方式填充数据。要填充的部分起止是 `{{}}`，里面可以是任意表达式(取属性、三元、逻辑、算术等)

含 html 标签结构的内容，用 `{{@ value}}`

`{{if value}} 如果需要输出 {{else if value2}} 如果 {{/if}}`

`{{each arr}} {{$index}} {{$value}} {{/each}}`

`{{value | filtername}}` 管道操作符，上一个输出作下一个输入，过滤器：

```js
template.default.imports.filterName =  function(value){return 结果;}
```

```html
<script type="text/html" id="tmp">放模板HTML的内容</script>
<script src="template-web.js"></script>
<script>
    var obj = {}; //可以填进去的变量名及其值
    var str = template('tmp', obj);
    document.body.innerHTML = str;
</script>
```



##### moment

```js
const moment = require('moment');
for (let i = 0; i < 3; ++i) {
    let d = +new Date();//正号强转时间戳
    // console.log(d);
    let d2 = moment(d);
    // console.log(d2);//Obj
    let res = d2.format('YYYY-MM-DD HH:mm:ss SSSS');
    console.log(res);//string
}
```



##### mysql

###### 查

```js
const mysql = require('mysql');
const db = mysql.createPool({
    host: '127.0.0.1',
    user: 'root',
    password: psw,
    database: 'easydb',
});//db.querySQL内有没有分号都行
db.query('select * from t_user;', (err, data) => {
    if (err) {
        console.log(err.message); return;
    }
    for (let i of data) {//取某一列
        console.log(i.user_id);
    }
    db.end();//断开连接
});
```

填参版本：

```js
async function f() {
    await new Promise((reso) => {
        db.query('insert into tb values (?)', 580, (err, res) => {
            console.log(res.affectedRows);
            reso();
        });
    });
    await new Promise((reso) => {
        db.query('select count(*) as num from tb where id>=? and id<=?', [10, 1000], (err, res) => {
            console.log(res[0].num);
            reso();
        });
    });
    db.end();
}
f();
```



###### 改

回调地狱：

```js
const outiferr = err => { if (err) { console.log(err); } };
//注意异步关系，使用回调地狱或异步处理
db.query('create table if not exists tb (id int);', (err, res) => {
    outiferr(err);
    db.query('insert into tb values (4),(5)', (err, res) => {
        outiferr(err);
        console.log(res.affectedRows);
    });
});
```

不要地狱：

```js
db.query('delete from tb where id>=4', async function (err, res) {
    await new Promise((reso) => {
        db.query('insert into tb values (4),(5)', (err, res) => {
            console.log('ins', res.affectedRows);
            reso();
        });
    });
    await new Promise((reso) => {
        db.query('update tb set id=6 where id=5;', (err, res) => {
            console.log('upd', res.affectedRows);
            reso();
        });
    });
    console.log('del', res.affectedRows);
    db.end();
});//可以判affectedRows测试是否修改成功
```



##### js-cookie

因为 HTTP 无状态，而 Cookie 是存在浏览器不超过 4KB 的字符串，由名称、值、有效期安全性适用范围属性等组成，各域名独立，每次发起请求时，会自动把当前域名所有未过期 Cookie 发送。即特点为：自动发送、域名独立、过期时限、大小限制。

```js
const Cookies = require('js-cookie');
Cookies.set('key', val);
Cookies.set('key', val, {expires:7});//7天
Cookies.set('key', val, {expires:7/24/24/60*1});//1min
Cookies.set('key', val, {expires:7,path:''});//当前页面
Cookies.get('name');
Cookies.get();//全部
Cookies.remove（'key',{path:''});//不存在的删除不会报错也不返回
```

![image-20230103174837035](img/image-20230103174837035.png)



##### express-session

###### 基本

web 的开发模式有前后端分离、服务器渲染两种方式。

服务器渲染：前端耗时少、有利于SEO(Search Engine Optimization 的缩写，意思是搜索引擎优化。SEO 是指对网站进行优化，以便获得更高的搜索引擎排名，从而使网站在搜索引擎结果页中更容易被用户发现)(chatGPT)；但占用服务器资源，开发效率低。

前后端分离依赖 Ajax，后端只提供 API 接口。开发体验、用户体验好、减轻服务器渲染压力，但不利于 SEO(因为爬虫难爬，但可以用 Vue, React 等前端框架的 SSR(server sided render)解决)

可以复合，如首屏服务器渲染，其他页面前后端分离。

服务器渲染使用 Session 认证机制，前后端分离推荐使用 JWT 认证机制。

session 是存在服务端的，且通常每次关闭服务器就消失；cookie 是存在客户端的。session 需要配合 cookie，即客户端用 cookie 存 session 的值。cookie 不支持跨域访问。所以涉及跨域时不能用。

一个简单例子：

```js
const express = require('express');
const app = express();
const session = require('express-session');
app.use(session({
    secret: 'anything',
    resave: false,
    saveUninitialized: true,
}));
app.get("/", (req, res) => {
    // console.log(req.session);
    console.log(req.session.val);
    req.session.val = Math.random();
    console.log(req.session.val);
    res.send('这是一个网页');
});
app.listen(15800);
```

清空：

```js
res.session.destroy();
```

![image-20230103174910240](img/image-20230103174910240.png)



##### jsonwebtoken

JWT json web token。适合处理跨域+身份认证。

![image-20230103175248702](img/image-20230103175248702.png)

JWT 的组成：头部、有效载荷、签名(通常都是加密字符串)，以 `.` 分隔，即 `Header.Payload.Signature`。载荷是真正要传送的内容。加密是为了保证客户端无法伪造。

一个验证 JWT 的例子，服务端：

```js
const jwt = require('jsonwebtoken');
const { expressjwt } = require('express-jwt');
const express = require('express');
const cors = require('cors');
const app = express();
const secretKey = '114514'
app.use(cors());
//api不需要鉴权
app.use(expressjwt({ secret: secretKey, algorithms: ["HS256"] }).unless({ path: [/^\/api\//] }));
app.use((err, req, res, next) => {
    if (err.name === 'UnauthorizedError') {
        return res.send({ status: 401, message: '无效的token' });
    }
    res.send({ status: 500, message: '未知错误' });
});
app.post("/api/login", function (req, res) {
    res.send({
        status: 200,
        message: '登陆成功',
        token: jwt.sign({ name: '白茶' }, secretKey, { expiresIn: "1h" })
    });
});
app.post('/oth/info', (req, res) => {
    res.send({
        status: 200,
        message: '获取成功',
        
    });
});
app.listen(15800);
```

客户端：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <script src="js/jquery.js"></script>
        <script>
        function next(token){
            $.ajax({
                url:'http://localhost:15800/oth/info',            
                type:'post',
                data:{a:'你好',b:4},
                success:(data)=>{
                    console.log(data);
                },
                // beforeSend:function(xhr){
                //     console.log(token);
                //     xhr.setRequestHeader('Authorization', 'Bearer 114514');  
                // },
                error:(xhr,status,error)=>{console.log(error);},
                headers:{
                    'Authorization': 'Bearer '+token,
                }
            });
        }
        $.ajax({
            url:'http://localhost:15800/api/login',            
            type:'post',
            data:{a:'你好',b:4},
            success:(data)=>{
                console.log(data);
                next(data.token);
            },
            error:(xhr,status,error)=>{console.log(error);}
        });
        </script>
    </head>
    <body></body>
</html>
```



##### bcryptjs

随机盐加密。

```js
const bcrypt = require('bcryptjs');
//8是随机盐长度,每次结果不一样(默认10)
console.log(bcrypt.hashSync('白茶', 8));
console.log(bcrypt.hashSync('白茶', 8));
console.log(bcrypt.compareSync(
    bcrypt.hashSync('白茶'),bcrypt.hashSync('白茶')
));//false
```



##### joi

```sh
yarn add joi@17.4.2
yarn add '@escook/express-joi'
```

表单拦截和合法性验证，如：

```js
let a = joi.string().alphanum().min(1).max(10).required() //用户名
let b = joi.string().pattern(/^[\S]{3,12}$/).required()
router.post('/reg',expressJoi({body:{a,b}}), 主处理函数)
```



##### axios

promise 风格的 get 和 post

```js
const axios = require('axios');
axios.get('http:localhost:15800/user?name=白茶').then((res) => {
    console.log('get', res.data);
});
axios.post('http:localhost:15800/user', { name: 1 }).then((res) => {
    console.log('post', res.data);
});
axios.get('http:localhost:15800/userr').then((res) => {
    console.log('ok');
}).catch((err) => { console.log('err'); });
async function getUser() {
    try {
        let { data: data1 } = await axios.get('http:localhost:15800/user?name=果冻');
        console.log('get2', data1);
        let { data: data2 } = await axios.get('http:localhost:15800/userr');//err
    } catch (err) { console.error('err2'); }
}
getUser();
```





### 数据类型

#### Buffer

专门存放二进制数据缓冲区。

```js
let buf1 = Buffer.from([97, 98, 99]);//abc
console.log(buf1);
console.log(buf1.toString());

let buf2 = Buffer.from("白茶果冻");
console.log(buf2);
console.log(buf2.toString());

let buf3 = Buffer.alloc(10);//10字符
buf3.write("禾枫");
console.log(buf3);//用了6个(3*2)
console.log(buf3.toString());
```



> # 运维
>
> ## windows shell
>
> ### 指令
>
> ##### dir
>
> ##### cd
>
> 不输入路径就是 `pwd`。
>





# Nginx

请参考 `java.md-语法-Spring-Nginx`。

## 安装使用

### 使用

查看运行状态：

```sh
systemctl status nginx
```

默认配置文件，通常位于 `/etc/nginx/sites-available/default`。

检查 Nginx 配置文件的语法是否正确：

```sh
nginx -t
```

重启：

```sh
systemctl restart nginx
```



## 语法

### 例子

#### SCNUOJ

```nginx
server {
    listen 80;
    listen [::]:80;

    root /var/www/scnuoj/web;
    client_max_body_size 0;
    index index.php;
    server_name scnuoj;

    location / {
        try_files $uri $uri/ /index.php?$args;
    }

    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
    }
}
```

#### 子域名指向端口

以 `game.young-oj.cn` 指代 `young-oj.cn:5801` 为例。

> 找到服务器的云解析 DNS，点我的解析，找到自己的域名，点添加记录，主机类型是 game (即子域名的名字)，记录类型是 A (ipv4)，线路类型默认，记录值写自己的主机 IP，其他不用改。可能需要等待生效。(参考 `linux.md-云服务器`)

在现有 server 块的前或后添加：

```nginx
server {
    listen 80;
    listen [::]:80; # 为 IPv6 配置监听
    server_name game.young-oj.cn;

    location / {
        proxy_pass http://localhost:5801; # 将请求转发到本地的 5801 端口
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

重启 nginx 即可。
