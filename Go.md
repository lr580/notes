# åŸºç¡€

## åŸºæœ¬æ¦‚å¿µ

### ä½¿ç”¨

#### å®‰è£…

éšæœºå‚è€ƒå®˜æ–¹æ–‡æ¡£äº†ã€‚

[å®˜æ–¹ä»£ç ä»“åº“](https://github.com/golang/go) [å®˜æ–¹æ–‡æ¡£](https://go.dev/doc/tutorial/getting-started) [ä¸‹è½½](https://go.dev/dl/)

å®‰è£…ï¼Œå¯¹ windows è€Œè¨€ç›´æ¥ä¸‹å®‰è£…åŒ…æ— è„‘ next å³å¯ã€‚æ£€æŸ¥å®‰è£…ï¼š

```sh
go version
go env
```

> linux, ubuntu ä¸ºä¾‹
>
> ```sh
> sudo apt update
> sudo apt install golang-go
> ```

#### å¸¸ç”¨æŒ‡ä»¤

##### ä»£ç†

```sh
go env -w GOPROXY=https://goproxy.io/
go env -w GOPROXY=https://goproxy.cn,direct # æˆ‘ç”¨çš„
```

##### å®‰è£…

`go install` æ˜¯ Go è¯­è¨€çš„ä¸€ä¸ªå¸¸ç”¨å‘½ä»¤ï¼Œç”¨äºç¼–è¯‘å¹¶å®‰è£… Go åŒ…æˆ–å¯æ‰§è¡Œç¨‹åºã€‚å®ƒä¼šå°†ç¼–è¯‘åçš„äºŒè¿›åˆ¶æ–‡ä»¶å®‰è£…åˆ° `$GOPATH/bin` ç›®å½•ï¼ˆæˆ– `$GOBIN` ç›®å½•ï¼‰ä¸­ï¼Œæ–¹ä¾¿å…¨å±€ä½¿ç”¨ã€‚

- å®‰è£…ç¬¬ä¸‰æ–¹å·¥å…·æˆ–å‘½ä»¤è¡Œç¨‹åºï¼ˆå¦‚ `goimports`ã€`gopls` ç­‰ï¼‰ã€‚
- å®‰è£…æœ¬åœ°å¼€å‘çš„ Go ç¨‹åºã€‚

```sh
go install [package]@[version]
```

å¦‚

```sh
go install golang.org/x/tools/cmd/goimports@latest
go install ./cmd/myapp
```

é»˜è®¤æƒ…å†µä¸‹ï¼Œ`go install` ä¼šå°†äºŒè¿›åˆ¶æ–‡ä»¶å®‰è£…åˆ° `$GOPATH/bin` ç›®å½•ã€‚

å¦‚æœè®¾ç½®äº† `$GOBIN`ï¼Œåˆ™ä¼šå®‰è£…åˆ° `$GOBIN` ç›®å½•ã€‚

å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤æŸ¥çœ‹å®‰è£…è·¯å¾„ï¼š

```sh
go env GOPATH
go env GOBIN
```

##### æ ¼å¼åŒ–

go fmt ä¸»è¦ç”¨äºæ ¼å¼åŒ–æ–‡æ¡£ï¼Œ è®©æ‰€æœ‰äººçš„ä»£ç é£æ ¼ä¿æŒä¸€è‡´  

```sh
go fmt main.go
```

#### åŒ…ç®¡ç†

go mod

> åœ¨ Golang1.11 ç‰ˆæœ¬ä¹‹å‰å¦‚æœæˆ‘ä»¬è¦è‡ªå®šä¹‰åŒ…çš„è¯å¿…é¡»æŠŠé¡¹ç›®æ”¾åœ¨ GOPATH ç›®å½•ã€‚ Go1.11 ç‰ˆæœ¬ä¹‹åæ— éœ€æ‰‹åŠ¨é…ç½®ç¯å¢ƒå˜é‡ï¼Œ ä½¿ç”¨ go mod ç®¡ç†é¡¹ç›®ï¼Œ ä¹Ÿä¸éœ€è¦éå¾—æŠŠé¡¹ç›®æ”¾åˆ° GOPATHæŒ‡å®šç›®å½•ä¸‹ï¼Œ ä½ å¯ä»¥åœ¨ä½ ç£ç›˜çš„ä»»ä½•ä½ç½®æ–°å»ºä¸€ä¸ªé¡¹ç›® , Go1.13 ä»¥åå¯ä»¥å½»åº•ä¸è¦ GOPATH  

##### init

åœ¨æˆ‘ä»¬é¡¹ç›®ç›®å½•ä¸­ç”¨ go mod å‘½ä»¤ç”Ÿæˆä¸€ä¸ª go.mod æ–‡ä»¶ç®¡ç†æˆ‘ä»¬é¡¹ç›®çš„ä¾èµ–

```sh
go mod init é¡¹ç›®åå­—
```

ä¼šåœ¨å½“å‰ç›®å½•ç”Ÿæˆ `go.mod`ï¼Œå†…å®¹å¦‚ä¸‹ (ç¬¬ä¸€è¡Œmodule é¡¹ç›®åå­—)

```go
module golearn

go 1.24.0
```

å¦‚æœæœ‰åŒ…ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š

```go
require github.com/shopspring/decimal v1.4.0
```

> è¿˜æœ‰ `go.sum` æ–‡ä»¶ï¼Œæ˜¯è‡ªåŠ¨ç”Ÿæˆçš„æ–‡ä»¶ï¼Œç”¨äºæ ¡éªŒä¾èµ–çš„å®Œæ•´æ€§å’Œä¸€è‡´æ€§ï¼Œå®ƒè®°å½•äº†ä¾èµ–æ¨¡å—çš„ç‰ˆæœ¬ã€å“ˆå¸Œå€¼
>

##### get

å®‰è£…åŒ…

cd åˆ°é¡¹ç›®ç›®å½•ï¼Œå‡è®¾æœ‰åŒ… `https://github.com/shopspring/decimal`

```go
go get github.com/shopspring/decimal
```

`-u` æ ‡å¿—çš„ä½œç”¨æ˜¯ï¼š

- æ›´æ–°ä¾èµ–ï¼šå®ƒä¼šå¼ºåˆ¶æ›´æ–°æŒ‡å®šçš„åŒ…åŠå…¶ä¾èµ–é¡¹åˆ°æœ€æ–°çš„ç‰ˆæœ¬ï¼ˆéµå¾ª `go.mod` æ–‡ä»¶ä¸­å®šä¹‰çš„ç‰ˆæœ¬çº¦æŸï¼‰ã€‚
- ä¸‹è½½ç¼ºå¤±çš„ä¾èµ–ï¼šå¦‚æœæœ¬åœ°ç¼ºå°‘æŸäº›ä¾èµ–åŒ…ï¼Œ`-u` ä¼šè‡ªåŠ¨ä¸‹è½½å®ƒä»¬ã€‚

```go
go get -u github.com/gin-gonic/gin
```

##### install

ç¼–è¯‘å¹¶å®‰è£…å½“å‰é¡¹ç›®æˆ–æŒ‡å®šçš„åŒ…ï¼Œç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œä½¿ç”¨ `go install`

ä¹Ÿå¯ä»¥è£…åŒ…

##### tidy

å¼•å…¥åŒ…ä»¥åå¯ä»¥ä½¿ç”¨ go mod tidy å¢åŠ ä¸¢å¤±çš„ module å»æ‰æœªç”¨çš„ module  

```go
go mod tidy
```

ä¼šåˆ æ‰ä»£ç é‡Œä»æœªç”¨è¿‡çš„åŒ…ã€‚æ¸…ç† `go.sum`

##### å…¶ä»–

- downloadï¼š download modules to local cache (ä¸‹è½½ä¾èµ–çš„ module åˆ°æœ¬åœ° cache))
- editï¼š edit go.mod from tools or scripts (ç¼–è¾‘ go.mod æ–‡ä»¶)
- graphï¼š print module requirement graph (æ‰“å°æ¨¡å—ä¾èµ–å›¾))
- initï¼š initialize new module in current directory (å†å½“å‰æ–‡ä»¶å¤¹ä¸‹åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„module, åˆ›å»º go.mod æ–‡ä»¶))
- tidyï¼š add missing and remove unused modules (å¢åŠ ä¸¢å¤±çš„ moduleï¼Œ å»æ‰æœªç”¨çš„module)
- vendorï¼š make vendored copy of dependencies (å°†ä¾èµ–å¤åˆ¶åˆ° vendor ä¸‹)
- verifyï¼š verify dependencies have expected content (æ ¡éªŒä¾èµ– æ£€æŸ¥ä¸‹è½½çš„ç¬¬ä¸‰æ–¹åº“æœ‰æ²¡æœ‰æœ¬åœ°ä¿®æ”¹ï¼Œ å¦‚æœæœ‰ä¿®æ”¹ï¼Œ åˆ™ä¼šè¿”å›é 0ï¼Œ å¦åˆ™éªŒè¯æˆåŠŸã€‚ )
- whyï¼š explain why packages or modules are needed (è§£é‡Šä¸ºä»€ä¹ˆéœ€è¦ä¾èµ–)

#### æµ‹è¯•

æµ‹è¯•æ–‡ä»¶æ˜¯ä»¥  `_test.go` ç»“å°¾çš„æ–‡ä»¶ï¼Œæµ‹è¯•å‡½æ•°ä»¥ `Test` å¼€å¤´ï¼Œå¹¶æ¥æ”¶ä¸€ä¸ª `*testing.T`å‚æ•°ã€‚å…¶ä¸­ `testing` æ˜¯ä¸€ä¸ªåŒ…ã€‚

```go
func TestAdd(t *testing.T) { // ...
```

`go test`ã€‚è¿™ä¼šè¿è¡Œå½“å‰CLIè·¯å¾„åŒ…ä¸­çš„æ‰€æœ‰æµ‹è¯•æ–‡ä»¶ï¼ˆä»¥ `_test.go`ç»“å°¾çš„æ–‡ä»¶ï¼‰ä¸­çš„æ‰€æœ‰æµ‹è¯•å‡½æ•°ï¼šä»¥ Test å¼€å¤´çš„å‡½æ•°å’Œä»¥ Example å¼€å¤´çš„ç¤ºä¾‹å‡½æ•°ã€‚

`go test -v` æ˜¾ç¤ºæ¯ä¸ªæµ‹è¯•å‡½æ•°çš„åç§°å’Œè¿è¡ŒçŠ¶æ€ï¼Œä»¥åŠæ‰“å°çš„æ—¥å¿—ä¿¡æ¯ã€‚

`go test -bench=.`ï¼Œ

> `go test -v -run TestName` å‚æ•°åé¢è·Ÿä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼Œåªè¿è¡Œåç§°åŒ¹é…çš„æµ‹è¯•å‡½æ•°
>
> `go test -v -run TestName/SubtestName` 1.17 å­æµ‹è¯•
>
> `go test -cover` æ˜¾ç¤ºä»£ç çš„æµ‹è¯•è¦†ç›–ç‡ç»Ÿè®¡

> ```sh
> go test -coverprofile=coverage.out
> go tool cover -html=coverage.out
> ```

è¿™é‡Œåªè®²è¿è¡Œæ–¹æ³•ã€‚å…·ä½“æµ‹è¯•ä»£ç è¯¦è§ `å¸¸ç”¨å†…ç½®åŒ…/è¯­æ³•å¢å¼º/testing`ã€‚

### å¸¸è¯†

#### ç‰¹ç‚¹

[å‚è€ƒ:å¤§åœ°(æœ¬ç¬”è®°å…¨éƒ¨å…¥é—¨éƒ¨åˆ†å¤šæœ‰å‚è€ƒ)](https://www.bilibili.com/video/BV1Rm421N7Jy/) 

> Go è¯­è¨€ä¸ä»…æ‹¥æœ‰é™æ€ç¼–è¯‘è¯­è¨€çš„å®‰å…¨å’Œé«˜æ€§èƒ½ï¼Œ è€Œä¸”åˆè¾¾åˆ°äº†åŠ¨æ€è¯­è¨€å¼€å‘é€Ÿåº¦å’Œæ˜“ç»´æŠ¤æ€§ã€‚ æœ‰äººå½¢å®¹ Go è¯­è¨€ï¼š Go = C + Python , è¯´æ˜ Go è¯­è¨€æ—¢æœ‰ C è¯­è¨€ç¨‹åºçš„è¿è¡Œé€Ÿåº¦ï¼Œ åˆèƒ½è¾¾åˆ° Python è¯­è¨€çš„å¿«é€Ÿå¼€å‘  
>
> å®ƒçš„åº”ç”¨åœºæ™¯æ˜¯ç›®å‰äº’è”ç½‘éå¸¸çƒ­é—¨çš„å‡ ä¸ªé¢†åŸŸï¼Œæ¯”å¦‚ WEB å¼€å‘ã€ åŒºå—é“¾å¼€å‘ã€ å¤§å‹æ¸¸æˆæœåŠ¡ç«¯å¼€å‘ã€ åˆ†å¸ƒå¼/äº‘è®¡ç®—å¼€å‘  

ç¼–è¯‘å‹è¯­è¨€

#### ç‰ˆæœ¬

> Go1.11 ç‰ˆæœ¬ä¹‹åæ— éœ€æ‰‹åŠ¨é…ç½®ç¯å¢ƒå˜é‡ï¼Œ ä½¿ç”¨ go mod ç®¡ç†é¡¹ç›®ï¼Œ ä¹Ÿä¸éœ€è¦éå¾—æŠŠé¡¹ç›®æ”¾åˆ° GOPATH 
>
> æŒ‡å®šç›®å½•ä¸‹ï¼Œ ä½ å¯ä»¥åœ¨ä½ ç£ç›˜çš„ä»»ä½•ä½ç½®æ–°å»ºä¸€ä¸ªé¡¹ç›®ã€‚
>
> Go1.13 ä»¥åå¯ä»¥å½»åº•ä¸è¦ GOPATH äº†

#### vscode

vscode çš„è¯ï¼Œç›´æ¥å®‰è£…åä¸º go çš„æ’ä»¶ã€‚[å‚è€ƒ](https://blog.csdn.net/sanqima/article/details/132030537)ã€‚GOPATH ç¯å¢ƒå˜é‡ä¼šè‡ªå·±å¥½ï¼Œä¸ç”¨ç®¡ã€‚

è®¾ç½® GOROOT ç¯å¢ƒå˜é‡

é…ç½®æ’ä»¶ï¼šå³å‡»æ’ä»¶-æ‰©å±•è®¾ç½®ã€‚

æµ‹è¯•ä»£ç ï¼š(`hello.go`)

```go
package main
import "fmt"
func main() {
	fmt.Println("hello world!")
}
```

å‘½ä»¤è¡Œï¼š`go run hello.go` ç›´æ¥è¿è¡Œã€‚

ç¼–è¯‘æˆ exe ç„¶åè¿è¡Œï¼š`go build hello.go`ï¼Œ`./hello`ã€‚[èœé¸Ÿ](https://m.runoob.com/go/go-tutorial.html)

#### è¯­æ³•å¸¸è¯†

åç¼€ `.go`

ä¸ä½¿ç”¨åˆ†å·

æ³¨é‡Š C é£æ ¼

é€šè¿‡é¦–å­—æ¯å¤§å°å†™å†³å®šæƒé™å¯è§æ€§ï¼Œæ¨èé©¼å³°è€Œä¸æ˜¯ä¸‹åˆ’çº¿

## æ•°æ®ç»“æ„

### å˜é‡

#### å®šä¹‰

##### å‘½åè§„èŒƒ

è¦æ±‚ï¼š

1. æ•°å­—ã€ å­—æ¯ã€ ä¸‹åˆ’çº¿ç»„æˆ  
2. æ ‡è¯†ç¬¦å¼€å¤´ä¸èƒ½æ˜¯æ•°å­—  
3. æ ‡è¯†ç¬¦ä¸èƒ½æ˜¯ä¿ç•™å­—å’Œå…³é”®å­—  
4. åŒºåˆ†å¤§å°å†™

> å®é™…ä¸Šå¯ä»¥ä¸­æ–‡å‘½åå˜é‡å

å»ºè®®ï¼š

1. å˜é‡åç§°å»ºè®®ç”¨åè¯ï¼Œ æ–¹æ³•åç§°å»ºè®®ç”¨åŠ¨è¯  
2. å˜é‡å‘½åä¸€èˆ¬é‡‡ç”¨é©¼å³°å¼ï¼Œ å½“é‡åˆ°ç‰¹æœ‰åè¯ï¼ˆç¼©å†™æˆ–ç®€ç§°ï¼Œ å¦‚ DNSï¼‰ çš„æ—¶å€™ï¼Œ ç‰¹æœ‰åè¯æ ¹æ®æ˜¯å¦ç§æœ‰å…¨éƒ¨å¤§å†™æˆ–å°å†™

ä»£ç é£æ ¼ï¼š

1. ä»£ç æ¯ä¸€è¡Œç»“æŸåä¸ç”¨å†™åˆ†å·ï¼ˆ ;ï¼‰  

2. å·¦æ‹¬å·ç´§æ¥ç€è¯­å¥ä¸æ¢è¡Œ

3. è¿ç®—ç¬¦å·¦å³å»ºè®®å„åŠ ä¸€ä¸ªç©ºæ ¼  ` a = b + c`

4. go fmt ä¸»è¦ç”¨äºæ ¼å¼åŒ–æ–‡æ¡£ï¼Œ è®©æ‰€æœ‰äººçš„ä»£ç é£æ ¼ä¿æŒä¸€è‡´  

   ```sh
   go fmt main.go
   ```


##### var

```go
var å˜é‡å ç±»å‹ = è¡¨è¾¾å¼
```

å¦‚

```go
var name string = "lr580 ä¸­æ–‡"
var name2 = "è‡ªåŠ¨ç±»å‹æ¨æ–­æ‰€ä»¥name2=string"
```

ä¸€æ¬¡å¤šä¸ª

```go
var name1, name2 string
name1 = "å¼ 3"
name2 = "æ4"
```

å¤šä¸ªå®šä¹‰+èµ‹å€¼ (ç±»å‹æ¨å¯¼äº†ï¼Œæ ¹æ®ç­‰å¼å³è¾¹æ¨æ–­äº† a çš„ç±»å‹)ï¼Œé€»è¾‘ç±»ä¼¼ python

```go
var a, b, c = 1/3, 1.0/3, false
```

å¤šä¸ªå£°æ˜+æŒ‡å®š

```go
var (a string
    b int
    c bool) // æ‹¬å·å¯ä»¥å•ç‹¬ä¸€è¡Œï¼Œä½† a,b,cè¦ä¸åŒè¡Œ
a = "å¼ 3"
b = 10
c = true
```

ä¸Šé¢çš„æ‹¬å·ä¹Ÿå¯ä»¥å†™æˆï¼š

```go
var (
    a string
    b int
    c bool
)
```

æ‰¹é‡+èµ‹å€¼

```go
var (
    a string = "å¼ 3"
    b int    = 10
    c bool   = true
)
```

**ä¸èµ‹å€¼ä¼šæœ‰é»˜è®¤å€¼**ï¼Œä½†**å£°æ˜äº†å˜é‡ä½†ä¸ä½¿ç”¨ä¼šæŠ¥é”™**ã€‚Go ç¼–è¯‘å™¨è¦æ±‚æ‰€æœ‰å£°æ˜çš„å˜é‡éƒ½å¿…é¡»è¢«ä½¿ç”¨

```go
var x int
fmt.Println(x) // 0
```

> æ•´å‹å’Œæµ®ç‚¹å‹å˜é‡çš„é»˜è®¤å€¼ä¸º 0ã€‚ å­—ç¬¦ä¸²å˜é‡çš„é»˜è®¤å€¼ä¸ºç©ºå­—ç¬¦ä¸²ã€‚ å¸ƒå°”å‹å˜é‡é»˜è®¤ä¸º falseã€‚ åˆ‡ç‰‡ã€ å‡½æ•°ã€ æŒ‡é’ˆå˜é‡çš„é»˜è®¤ä¸º nil  

ç”Ÿå‘½å‘¨æœŸï¼šå‡½æ•°è°ƒç”¨æœŸé—´(ä¸é€ƒé€¸çš„è¯)

##### :=

åœ¨å‡½æ•°å†…éƒ¨ï¼Œ å¯ä»¥ä½¿ç”¨æ›´ç®€ç•¥çš„ := æ–¹å¼å£°æ˜å¹¶åˆå§‹åŒ–å˜é‡ã€‚

è¿™æ˜¯å£°æ˜å˜é‡+åˆå§‹åŒ–ã€‚å¦‚æœè¦å¯¹å·²å£°æ˜å˜é‡èµ‹å€¼ï¼Œç›´æ¥ = å³å¯ã€‚

æ³¨æ„ï¼š çŸ­å˜é‡åªèƒ½ç”¨äºå£°æ˜å±€éƒ¨å˜é‡ï¼Œ ä¸èƒ½ç”¨äºå…¨å±€å˜é‡çš„å£°æ˜  

```go
n := 10
```

ä¾‹å¦‚ï¼š

```go
package main
import "fmt"
func main() {
	var name string = "lr580 æ˜¯ç¬¨è›‹"
	name2 := "lr581 ä¸æ˜¯ç¬¨è›‹"
	fmt.Println(name)
	fmt.Println(name2)
}
```

```go
m1, m2, m3 := 10, 20, 30
fmt.Println(m1, m2, m3)
```

å¯¹å¤šå˜é‡çš„ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªæ˜¯æ–°å˜é‡ï¼Œå°±å¯ä»¥ `:=`

```go
a, b := 1, 2
a, c := 3, 4 
```



##### åŒ¿åå˜é‡

```go
func getInfo() (int, string) {
    return 10, "å¼ ä¸‰"
}
func main() {
    _, username := getInfo()
    fmt.Println(username)
}
```

åŒ¿åå˜é‡ä¸å ç”¨å‘½åç©ºé—´ï¼Œ ä¸ä¼šåˆ†é…å†…å­˜ï¼Œ æ‰€ä»¥åŒ¿åå˜é‡ä¹‹é—´ä¸å­˜åœ¨é‡å¤å£°æ˜  

_å¤šç”¨äºå ä½ï¼Œ è¡¨ç¤ºå¿½ç•¥å€¼ã€‚  

##### å…¨å±€å˜é‡

å…¨å±€å˜é‡æ˜¯å®šä¹‰åœ¨å‡½æ•°å¤–éƒ¨çš„å˜é‡ï¼Œ å®ƒåœ¨ç¨‹åºæ•´ä¸ªè¿è¡Œå‘¨æœŸå†…éƒ½æœ‰æ•ˆã€‚ åœ¨å‡½æ•°ä¸­å¯ä»¥è®¿é—®åˆ°å…¨å±€å˜é‡  

```go
package main
import "fmt"
var lr = 58
func main() {
	lr *= 10
	fmt.Println(lr)
}
```

å¦‚æœå±€éƒ¨å˜é‡å’Œå…¨å±€å˜é‡é‡åï¼Œ ä¼˜å…ˆè®¿é—®å±€éƒ¨å˜é‡ï¼Œä¹Ÿå°±æ˜¯å¤§æ‹¬å·ä½œç”¨åŸŸã€‚å’Œ C ä¸€æ ·ï¼Œå¯ä»¥å‡­ç©ºåŠ å¤§æ‹¬å·åŒºåˆ†ä½œç”¨åŸŸ

> å…¨å±€å˜é‡ï¼Œç¼ºçœæ˜¯ 0 å€¼ï¼Œç©ºä¸²ï¼Œfalseï¼Œnil (æŒ‡é’ˆã€sliceã€mapã€chanã€æ¥å£ç­‰)ï¼Œä¹Ÿå°±æ˜¯äº”ä¸ªå¼•ç”¨ç±»å‹çš„ç¼ºçœéƒ½æ˜¯nil

ç”Ÿå‘½å‘¨æœŸæ˜¯æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´ã€‚

å…¨å±€å˜é‡å£°æ˜åœ¨å‡½æ•°å¤–ï¼Œåœ¨æ•´ä¸ªåŒ…å†…ç”šè‡³è·¨åŒ…éƒ½å¯ä»¥è®¿é—®ï¼ˆå¦‚æœé¦–å­—æ¯å¤§å†™åˆ™å¯ä»¥è·¨åŒ…è®¿é—®ï¼‰ã€‚å±€éƒ¨å˜é‡å£°æ˜åœ¨å‡½æ•°å†…ï¼Œåªåœ¨å…¶æ‰€åœ¨çš„å‡½æ•°å†…æœ‰æ•ˆ

#### å¸¸é‡

constant åœ¨ç¨‹åºè¿è¡Œæ—¶ä¸å¯ä¿®æ”¹çš„å€¼

##### å­—é¢é‡

> å­—é¢é‡ï¼ˆliteralï¼‰æ˜¯æŒ‡ç¨‹åºä¸­ç›´æ¥è¡¨ç¤ºå¸¸é‡å€¼çš„å½¢å¼ï¼Œä¹Ÿå°±æ˜¯åœ¨ä»£ç ä¸­ç›´æ¥å†™å‡ºæ¥çš„å€¼ï¼Œæ¯”å¦‚æ•°å­—ã€å­—ç¬¦ä¸²ã€å¸ƒå°”å€¼ç­‰ç­‰ã€‚
>
> ç»„åˆå­—é¢é‡æ˜¯æŒ‡é€šè¿‡å†…è”ï¼ˆin-lineï¼‰å½¢å¼å®šä¹‰å¤æ‚æ•°æ®ç»“æ„çš„å­—é¢é‡ï¼Œæ¯”å¦‚æ•°ç»„ã€åˆ‡ç‰‡ã€æ˜ å°„ï¼ˆmapï¼‰ã€ç»“æ„ä½“ç­‰ã€‚å¯ä»¥éå¸¸ç›´è§‚åœ°å®šä¹‰å’Œåˆå§‹åŒ–å¤æ‚çš„æ•°æ®ç»“æ„ã€‚

##### ä½¿ç”¨

å¸¸é‡çš„å£°æ˜å’Œå˜é‡å£°æ˜éå¸¸ç±»ä¼¼ï¼Œ åªæ˜¯æŠŠ var æ¢æˆäº† constï¼Œ å¸¸é‡åœ¨å®šä¹‰çš„æ—¶å€™å¿…é¡»èµ‹å€¼  

```go
const lr = 580
const (
    pi = 3.1415
    e = 2.7182
)
```

const åŒæ—¶å£°æ˜å¤šä¸ªå¸¸é‡æ—¶ï¼Œ å¦‚æœçœç•¥äº†å€¼åˆ™è¡¨ç¤ºå’Œä¸Šé¢ä¸€è¡Œçš„å€¼ç›¸åŒ  

```go
const (
    n1 = 100
    n2
    n3
)
fmt.Println(n1, n2, n3)
```

å¸¸é‡å£°æ˜äº†å¯ä»¥ä¸ä½¿ç”¨

`const`åªèƒ½ç”¨äºåŸºæœ¬ç±»å‹ï¼ˆå¦‚ `string`ã€`int`ã€`bool`ç­‰ï¼‰æˆ–ç®€å•è¡¨è¾¾å¼ï¼Œä¸èƒ½ç”¨äºæ•°ç»„ã€åˆ‡ç‰‡ã€map ç­‰å¤åˆç±»å‹ã€‚

> å¯ä»¥å®šä¹‰æ—¶ä½¿ç”¨ç±»å‹ï¼Œå¦‚ `const pi float64 = 3.14`ï¼Œä¹Ÿå¯ä»¥è®©ç¼–è¯‘å™¨è‡ªå·±æ¨æ–­ã€‚å³æ‰€è°“æœ‰ç±»å‹å¸¸é‡ï¼Œæ— ç±»å‹å¸¸é‡

##### iota

iota æ˜¯ golang è¯­è¨€çš„å¸¸é‡è®¡æ•°å™¨,å¯ä»¥ç”¨æ¥å®ç° enums æšä¸¾å€¼ã€‚

åªèƒ½åœ¨å¸¸é‡çš„è¡¨è¾¾å¼ä¸­ä½¿ç”¨ã€‚

iota åœ¨ const å…³é”®å­—å‡ºç°æ—¶å°†è¢«é‡ç½®ä¸º 0(const å†…éƒ¨çš„ç¬¬ä¸€è¡Œä¹‹å‰)ï¼Œ const ä¸­æ¯æ–°å¢ä¸€è¡Œå¸¸é‡å£°æ˜å°†ä½¿ iota è®¡æ•°ä¸€æ¬¡(iota å¯ç†è§£ä¸º const è¯­å¥å—ä¸­çš„è¡Œç´¢å¼•)

1. iota åªèƒ½åœ¨å¸¸é‡çš„è¡¨è¾¾å¼ä¸­ä½¿ç”¨  

  ```go
  // fmt.Println(iota) ä¸å¯ä»¥
  ```

2. æ¯æ¬¡ const å‡ºç°æ—¶ï¼Œ éƒ½ä¼šè®© iota åˆå§‹åŒ–ä¸º 0.  

  ```go
  const a = iota // a=0
  const (
      b = iota //b=0
      c //c=1
  )
  ```

3. const iota ä½¿ç”¨_è·³è¿‡æŸäº›å€¼ 

  ```go
  const (
      n1 = iota //0
      n2 //1
      _
      n4 //3
  )
  ```

4. iota å£°æ˜ä¸­é—´æ’é˜Ÿ 

  ```go
  const (
      n1 = iota //0
      n2 = 100 //100
      n3 = iota //2
      n4 //3
  )
  const n5 = iota //0
  ```

5. å¤šä¸ª iota å®šä¹‰åœ¨ä¸€è¡Œ  

   ```go
   const (
       a, b = iota + 1, iota + 2 //1,2
       c, d //2,3
       e, f //3,4
   )
   ```

> å¹¶æ²¡æœ‰è‡ªåŠ¨æä¾›å°†æšä¸¾å€¼è½¬æ¢ä¸ºå­—ç¬¦ä¸²çš„åŠŸèƒ½ï¼Œå¯ä»¥è‡ªå·±è®¾è®¡ã€‚

ä¸èƒ½ç»™ bool èµ‹å€¼ã€‚

### è¿ç®—

#### è®¡ç®—

##### ç®—æœ¯

æ•´æ•°é™¤æ³•æ•´é™¤

å–ä½™ï¼š`ä½™æ•°=è¢«é™¤æ•°-(è¢«é™¤æ•°/é™¤æ•°)*é™¤æ•°`ï¼Œä¸ C ä¸€æ ·ï¼Œä¸å…è®¸å°æ•°å–ä½™

```go
fmt.Println(10%3, -10%3, 10%-3, -10%-3) // 1 -1 1 -1
```

`++ --` ä¸æ˜¯è¿ç®—ç¬¦ï¼Œæ˜¯è¯­å¥ï¼Œæ‰€ä»¥ä¸èƒ½ `a = b++`ï¼Œä¸”åªæœ‰ `a++` æ²¡æœ‰ `++a`ã€‚æ”¯æŒå°æ•°(è¿™ç‚¹åŒ C)ã€‚

```go
i := 1.2
i++
fmt.Println(i) // 2.2
```

##### é€»è¾‘

å…³ç³»ï¼š`== != >= > <= <` 

```go
fmt.Println(3 > 2.9) // true
```

é€»è¾‘ï¼š`&& || !`ï¼ŒçŸ­è·¯ã€‚`&&` ä¼˜å…ˆçº§é«˜(åŒå¸¸è§„è¯­è¨€)

```go
func f1() bool {
	fmt.Println("f1")
	return false //è‹¥trueï¼Œä¸æ‰§è¡Œf2,f3
}
func f2() bool {
	fmt.Println("f2")
	return false // çŸ­è·¯ï¼Œä¸æ‰§è¡Œf3
}
func f3() bool {
	fmt.Println("f3")
	return true
}
// ...
if f1() || f2() && f3() { // è¾“å‡º f1, f2ï¼Œä¸è¾“å‡º f3, ok
    fmt.Println("ok")
}
```

> å¯ä»¥æ¯”è¾ƒ == != çš„ç±»å‹ï¼šåŸºæœ¬ç±»å‹ã€æŒ‡é’ˆã€é€šé“ã€æ¥å£ã€å­—æ®µæ˜¯å¯æ¯”è¾ƒçš„æ•°ç»„å’Œç»“æ„ä½“ã€‚ä¸å¯æ¯”è¾ƒï¼šslice, map, function, å«ä¸å¯æ¯”è¾ƒå­—æ®µçš„æ•°ç»„ï¼Œç»“æ„ä½“ã€‚1.18 æ–°å¢ comparableï¼Œç”¨äºå®šä¹‰è¿™äº›ã€‚ä½†å®ƒä¸å¯æ’åºä¸ä¸€æ ·ã€‚

##### èµ‹å€¼

`= += -= *= /= %=`

`a, b = 5, 80` å¯ä»¥è¿™æ ·ä¸€è¡Œå¤šä¸ªèµ‹å€¼ï¼Œå¤šé‡èµ‹å€¼ï¼Œç±»ä¼¼ pythonï¼Œå…ˆç®—å®Œå³è¾¹çš„

##### ä½è¿ç®—

`& | ^ << >>` åˆ†åˆ«æ˜¯å·¦ç§»ï¼Œå³ç§» å³ `001 -> 010` å’Œ `001 -> 000`ã€‚`>` æ˜¯ `->` ç®­å¤´æ–¹å‘ã€‚

#### è¿ç®—

##### åˆ†ç±»

è¯­è¨€ä¸­æ•°æ®ç±»å‹åˆ†ä¸ºï¼š åŸºæœ¬æ•°æ®ç±»å‹å’Œå¤åˆæ•°æ®ç±»å‹

åŸºæœ¬æ•°æ®ç±»å‹æœ‰ï¼šæ•´å‹ã€ æµ®ç‚¹å‹ã€ å¸ƒå°”å‹ã€ å­—ç¬¦ä¸²

å¤åˆæ•°æ®ç±»å‹æœ‰ï¼šæ•°ç»„ã€ åˆ‡ç‰‡ã€ ç»“æ„ä½“ã€ å‡½æ•°ã€ mapã€ é€šé“ï¼ˆchannelï¼‰ ã€ æ¥å£ç­‰

##### ç±»å‹

è¾“å‡ºç±»å‹ï¼š

```go
var num int64 = 580
fmt.Printf("å€¼:%v ç±»å‹%T", num, num) // å€¼:580 ç±»å‹int64
```

> å¼•ç”¨ç±»å‹ï¼šå†…å­˜ä¸­å­˜å‚¨æ•°æ®çš„å¼•ç”¨ï¼ˆåœ°å€ï¼‰ï¼Œè€Œéç›´æ¥å­˜å‚¨æ•°æ®ã€‚å¦‚sliceã€mapã€chan

##### å ç”¨å­—èŠ‚æ•°

unsafe.Sizeof(n1) æ˜¯ unsafe åŒ…çš„ä¸€ä¸ªå‡½æ•°ï¼Œ å¯ä»¥è¿”å› n1 å˜é‡å ç”¨çš„å­—èŠ‚æ•°  

```go
import (
    "fmt"
    "unsafe"
)
// ...
fmt.Println(unsafe.Sizeof(num))  // 8
fmt.Println(unsafe.Sizeof(true)) // 1
```

##### ç±»å‹è½¬æ¢

å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œ æ²¡æœ‰éšå¼ç±»å‹è½¬æ¢  

```go
var num1 int8
num1 = 127
num2 := int32(num1)
fmt.Printf("å€¼:%v ç±»å‹%T", num2, num2) //å€¼:127 ç±»å‹ int32
```

```go
var a int16 = 580
var b int32 = 1437
var c = int32(a) + b*1000 // ä¸è½¬æŠ¥é”™
fmt.Println(c)
```

##### åˆå§‹å€¼

å½“ä½ å£°æ˜äº†ä¸€ä¸ªå˜é‡ , ä½†å´è¿˜å¹¶æ²¡æœ‰èµ‹å€¼æ—¶ , golang ä¸­ä¼šè‡ªåŠ¨ç»™ä½ çš„å˜é‡èµ‹å€¼ä¸€ä¸ªé»˜è®¤é›¶å€¼ã€‚ è¿™æ˜¯æ¯ç§ç±»å‹å¯¹åº”çš„é›¶å€¼  

```go
bool -> false
numbers -> 0
string-> ""
pointers -> nil
slices -> nil
maps -> nil
channels -> nil
functions -> nil
interfaces -> nil
```

array ä¸èƒ½å’Œ nil æ¯”è¾ƒï¼Œåˆ‡ç‰‡å¯ä»¥

##### type

ç±»ä¼¼ C/C++ typedef, using

```go
type i32 int32 // è‡ªå®šä¹‰ç±»å‹
type dbFunc func(int, int) int
type integer = int // 1.9 ç‰ˆæœ¬ï¼šåˆ«å
```

```go
var vv i32 = 666
fmt.Println(vv)
var a integer = 6
```

è‡ªå®šä¹‰ç±»å‹å’Œåˆ«åçš„åŒºåˆ«ï¼šåˆ«åç­‰ä»·åŸæœ¬ï¼Œè‡ªå®šä¹‰ä¸ç­‰

```go
var a integer = 6
var b i32 = 6
fmt.Printf("%T %T\n", a, b) // int main.i32
```

type å¯ä»¥æ”¾å‡½æ•°å†…æˆ–å¤–ï¼Œtype å®šä¹‰ç»“æ„ä½“ä¹Ÿæ˜¯

##### æ‹·è´

Go è¯­è¨€çš„ç±»å‹ä¸­ï¼Œé»˜è®¤ä¸ºæ·±æ‹·è´çš„ç±»å‹æœ‰boolã€intã€floatã€stringã€arrayã€structç­‰å€¼ç±»å‹ã€‚æ³¨æ„å¦‚æœæ˜¯ struct ç±»å‹ï¼Œéœ€è¦ä¿è¯å…¶åµŒå¥—çš„æ‰€æœ‰å­—æ®µéƒ½æ˜¯å€¼ç±»å‹ã€‚

Go è¯­è¨€çš„ç±»å‹ä¸­ï¼Œé»˜è®¤ä¸ºæµ…æ‹·è´çš„ç±»å‹æœ‰ sliceã€mapã€æŒ‡é’ˆ ptrã€å‡½æ•° funcã€é€šé“ chanã€æ¥å£ interface ç­‰å¼•ç”¨ç±»å‹ã€‚

åµŒå¥—ç±»å‹ï¼Œæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨å®ç°æ·±æ‹·è´ã€‚





### æ•°æ®ç±»å‹

#### æ•´å‹

æ•´å‹åˆ†ä¸ºä»¥ä¸‹ä¸¤ä¸ªå¤§ç±»ï¼š

æœ‰ç¬¦å·æ•´å½¢æŒ‰é•¿åº¦åˆ†ä¸ºï¼š int8ã€ int16ã€ int32ã€ int64

å¯¹åº”çš„æ— ç¬¦å·æ•´å‹ï¼š uint8ã€ uint16ã€ uint32ã€ uint64

é»˜è®¤ int æ˜¯å¤šå°‘å–å†³äºæ“ä½œç³»ç»Ÿä½æ•°æ˜¯å¤šå°‘ï¼Œå¦‚ 64 ä½ int = int64ï¼Œuint åŒç†

> åœ¨ä½¿ç”¨ int å’Œ uint ç±»å‹æ—¶ï¼Œ ä¸èƒ½å‡å®šå®ƒæ˜¯ 32 ä½æˆ– 64 ä½çš„æ•´å‹ï¼Œ è€Œæ˜¯è€ƒè™‘ int å’Œ uintå¯èƒ½åœ¨ä¸åŒå¹³å°ä¸Šçš„å·®å¼‚  
>
> å®é™…é¡¹ç›®ä¸­æ•´æ•°ç±»å‹ã€ åˆ‡ç‰‡ã€ map çš„å…ƒç´ æ•°é‡ç­‰éƒ½å¯ä»¥ç”¨ int æ¥è¡¨ç¤ºã€‚ åœ¨æ¶‰åŠåˆ°äºŒè¿›åˆ¶ä¼ è¾“ã€ ä¸ºäº†ä¿æŒæ–‡ä»¶çš„ç»“æ„ä¸ä¼šå—åˆ°ä¸åŒç¼–è¯‘ç›®æ ‡å¹³å°å­—èŠ‚é•¿åº¦çš„å½±å“ï¼Œ ä¸è¦ä½¿ç”¨ int å’Œ uint  ï¼šä¸ºäº†ç¡®ä¿è·¨å¹³å°çš„ä¸€è‡´æ€§ï¼Œå»ºè®®ä½¿ç”¨å…·æœ‰æ˜ç¡®é•¿åº¦çš„æ•´æ•°ç±»å‹

uintptr æ˜¯æ— ç¬¦å·æ•´å‹ï¼Œ ç”¨äºå­˜æ”¾ä¸€ä¸ªæŒ‡é’ˆ

```go
var num int64
num = 580
fmt.Printf("å€¼:%v ç±»å‹%T", num, num) // å€¼:580 ç±»å‹int64
```

ç±»å‹è½¬æ¢å¯ä»¥ç›´æ¥è½¬ï¼Œå¦‚ `num2 := int32(num1)`

æ›´å¤šæ ¼å¼

```go
x4 := 1_000_000_007
fmt.Printf("%b %o %x %d\n", x4, x4, x4, x4) // ä¸åŒè¿›åˆ¶
// 111011100110101100101000000111 7346545007 3b9aca07 1000000007
x5 := 0x1p31 //å¯ä»¥ç”¨æŒ‡æ•°ï¼Œç­‰ä»·äº 1 * 2^31, ä¹Ÿå¯ä»¥ 1p-31,é»˜è®¤ float
x5--
fmt.Printf("%v %b %x\n", int(x5), int(x5), x5+1) // ä¸è¿‡å°æ•°ä¹Ÿå¯ä»¥ %xï¼Œè¿™é‡Œå°±æ˜¯åŸæ±¤åŒ–åŸé£Ÿè¾“å‡º 0x1p31
```

#### æµ®ç‚¹å‹

æ”¯æŒä¸¤ç§æµ®ç‚¹å‹æ•°ï¼š float32 å’Œ float64ã€‚ è¿™ä¸¤ç§æµ®ç‚¹å‹æ•°æ®æ ¼å¼éµå¾ª IEEE 754 æ ‡å‡†ï¼š float32 çš„æµ®ç‚¹æ•°çš„æœ€å¤§èŒƒå›´çº¦ä¸º 3.4e38ï¼Œ å¯ä»¥ä½¿ç”¨å¸¸é‡å®šä¹‰ï¼š math.MaxFloat32ã€‚ float64 çš„æµ®ç‚¹æ•°çš„æœ€å¤§èŒƒå›´çº¦ä¸º 1.8e308ï¼Œ å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå¸¸é‡å®šä¹‰ï¼š math.MaxFloat64ã€‚  

æµ®ç‚¹æ•°é»˜è®¤æ˜¯ float64  

```go
num := 2. / (2.5 + .5)
fmt.Printf("%f, %.2f, %T\n", num, num, num)
// 0.666667, 0.67, float64
```

#### å¸ƒå°”å€¼

bool true / false

å¸ƒå°”ç±»å‹å˜é‡çš„é»˜è®¤å€¼ä¸º false

Go è¯­è¨€ä¸­ä¸å…è®¸å°†æ•´å‹å¼ºåˆ¶è½¬æ¢ä¸ºå¸ƒå°”å‹ï¼›åœ¨ go è¯­è¨€ä¸­æ•°å€¼ç±»å‹æ²¡æ³•ç›´æ¥è½¬æ¢æˆ bool ç±»å‹ bool ç±»å‹ä¹Ÿæ²¡æ³•ç›´æ¥è½¬æ¢æˆæ•°å€¼ç±»å‹  

å¸ƒå°”å‹æ— æ³•å‚ä¸æ•°å€¼è¿ç®—ï¼Œ ä¹Ÿæ— æ³•ä¸å…¶ä»–ç±»å‹è¿›è¡Œè½¬æ¢ã€‚

```go
fmt.Println(unsafe.Sizeof(true)) // 1
```

#### å­—ç¬¦ä¸²

##### åŸºç¡€

åŒå¼•å·/åå¼•å·ï¼›stringï¼›len æ±‚é•¿åº¦

```go
var s = `å³å¾—æ˜“è§å¹³å‡¡
ä»¿ç…§ä¸Šä¾‹æ˜¾ç„¶` // ä¸è¦å¯¹é½ä¸ç„¶ä¼šæœ‰å¤šä½™ç©ºæ ¼
fmt.Println(s, len(s)) //ä¸€ä¸ªä¸­æ–‡3ä¸ªé•¿åº¦
fmt.Println(len([]rune(s))) //å¸¦ä¸­æ–‡å­—ç¬¦ä¸²é•¿åº¦
// åŒç†ï¼Œå–ä¸­æ–‡å­ä¸²ï¼Œåº”è¯¥å– rune å­æ•°ç»„è½¬å› string
```

åå¼•å·å¯ä»¥å¤šè¡Œï¼Œä¸è½¬ä¹‰å­—ç¬¦ï¼Œæœ¬èº«ä¸èƒ½åŒ…å«åå¼•å·

è¦ä¿®æ”¹å­—ç¬¦ä¸²ï¼Œ éœ€è¦å…ˆå°†å…¶è½¬æ¢æˆ[]rune æˆ–[]byteï¼Œ å®Œæˆåå†è½¬æ¢ä¸º stringã€‚ æ— è®ºå“ªç§è½¬æ¢ï¼Œéƒ½ä¼šé‡æ–°åˆ†é…å†…å­˜ï¼Œ å¹¶å¤åˆ¶å­—èŠ‚æ•°ç»„  

```go
s := "abcè“è“ç†Š"
fmt.Println(s[0], s[3]) // 97 232ï¼›ä¸­æ–‡ä¸èƒ½å–ä¸‹æ ‡ï¼Œè§å­—ç¬¦ä¸€èŠ‚
// å–[]å‡ºæ¥æ˜¯ byte ç±»å‹
```

ä¸åŒC/C++ï¼ŒåŒPython/Javaï¼Œgoä¸ä½¿ç”¨\0æˆªæ–­å’Œæœ«å°¾å ä½(å¤šä¸€ä¸ªé•¿åº¦)

```go
fmt.Println(len("abc")) // 3
```

å¯ä»¥åˆ‡ç‰‡ï¼Œåˆ‡ç‰‡ç»“æœä¹Ÿæ˜¯ stringï¼Œä¸ä¼šå¤åˆ¶ã€‚

##### å¸¸ç”¨å‡½æ•°

å­—ç¬¦ä¸²æ‹¼æ¥ï¼š+ æˆ– `fmt.Sprintf` (åè€…å¸¸ç”¨å…¶ä»–ç±»å‹è½¬ str)

```go
var str1 = "ä¸»å¸­æ ‘"
var str2 = "å¯æŒä¹…åŒ–æƒå€¼çº¿æ®µæ ‘"
fmt.Println(str1 + str2)
var str3 = fmt.Sprintf("%v=%v", str1, str2)
fmt.Println(str3)
```

strings åŒ…æœ‰å¸¸ç”¨åº“å‡½æ•°ï¼š

```go
var str4 = "020--5800---5800"
fmt.Println(strings.Split(str4, "--")) // [020 5800 -5800]
fmt.Println(strings.Contains(str4, "5800"))
fmt.Println(strings.ContainsRune(str4, 'A'))
fmt.Println(strings.HasPrefix(str4, "020"))
fmt.Println(strings.HasSuffix(str4, "0")) // all true
fmt.Println(strings.Index(str4, "20"))    // 1
fmt.Println(strings.Index(str4, "3"))     // -1
fmt.Println(strings.LastIndex(str4, "0"))
// æŸ¥æ‰¾å­—ç¬¦xï¼šstrings.IndexByte(s, x)
fmt.Println(strings.Join([]string{"020", "5800", "5800"}, "-"))
fmt.Println(strings.Repeat("A", k-1))
```

æŒ‰ç‰¹å®šè§„åˆ™å®šä¹‰åˆ†éš”ç¬¦ï¼Œåˆ†å‰²å­—ç¬¦ä¸²ï¼š

```go
ff := func(r rune) bool { return !unicode.IsLetter(r) }
fmt.Println(strings.FieldsFunc("abc123def4g5", ff)) // [abc def g]
```



##### ç±»å‹è½¬æ¢

###### å…¶ä»–->å­—ç¬¦ä¸²

- `strconv.Itoa` æ˜¯ Go è¯­è¨€æ ‡å‡†åº“ `strconv` åŒ…ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºå°†æ•´æ•°(int)è½¬æ¢ä¸ºå­—ç¬¦ä¸²(string)ï¼Œå¯¹äºå…¶ä»–æ•´æ•°ç±»å‹(int8, int16, int32, int64, uintç­‰)ï¼Œéœ€è¦ä½¿ç”¨ `FormatInt` æˆ– `FormatUint`

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// é€šè¿‡strconv  æŠŠå…¶ä»–ç±»å‹è½¬æ¢æˆstringç±»å‹
	/* FormatInt
	å‚æ•°1ï¼šint64 çš„æ•°å€¼
	å‚æ•°2ï¼šä¼ å€¼intç±»å‹çš„è¿›åˆ¶*/
	var i int = 20
	str1 := strconv.FormatInt(int64(i), 10)
	fmt.Printf("å€¼ï¼š%v ç±»å‹ï¼š%T\n", str1, str1)

	/* å‚æ•° 1ï¼šè¦è½¬æ¢çš„å€¼
	å‚æ•° 2ï¼šæ ¼å¼åŒ–ç±»å‹ 'f'ï¼ˆ-ddd.ddddï¼‰ã€
		 'b'ï¼ˆ-ddddpÂ±dddï¼ŒæŒ‡æ•°ä¸ºäºŒè¿›åˆ¶ï¼‰ã€
		 'e'ï¼ˆ-d.ddddeÂ±ddï¼Œåè¿›åˆ¶æŒ‡æ•°ï¼‰ã€
		 'E'ï¼ˆ-d.ddddEÂ±ddï¼Œåè¿›åˆ¶æŒ‡æ•°ï¼‰ã€
		 'g'ï¼ˆæŒ‡æ•°å¾ˆå¤§æ—¶ç”¨'e'æ ¼å¼ï¼Œå¦åˆ™'f'æ ¼å¼ï¼‰ã€
		 'G'ï¼ˆæŒ‡æ•°å¾ˆå¤§æ—¶ç”¨'E'æ ¼å¼ï¼Œå¦åˆ™'f'æ ¼å¼ï¼‰ã€‚
	 å‚æ•° 3: ä¿ç•™çš„å°æ•°ç‚¹ -1ï¼ˆä¸å¯¹å°æ•°ç‚¹æ ¼å¼åŒ–ï¼‰
	 å‚æ•° 4ï¼šæ ¼å¼åŒ–çš„ç±»å‹ ä¼ å…¥ 64  32*/
	var f float32 = 20.231363
	str2 := strconv.FormatFloat(float64(f), 'f', 4, 32)
	fmt.Printf("å€¼ï¼š%v ç±»å‹ï¼š%T\n", str2, str2) // å››èˆäº”å…¥

	str3 := strconv.FormatBool(true) //æ²¡æœ‰ä»»ä½•æ„ä¹‰
	fmt.Printf("å€¼ï¼š%v ç±»å‹ï¼š%T\n", str3, str3)

	a := 'b' //æ²¡æœ‰ä»»ä½•æ„ä¹‰
	str4 := strconv.FormatUint(uint64(a), 10)
	fmt.Printf("å€¼ï¼š%v ç±»å‹ï¼š%T\n", str4, str4) //å€¼ï¼š98 ç±»å‹ï¼šstring
}
```

###### å­—ç¬¦ä¸²->å…¶ä»–

```go
x, _ := strconv.ParseInt("580", 10, 64) // è½¬ 10è¿›åˆ¶int64
fmt.Printf("å€¼ï¼š%v ç±»å‹ï¼š%T\n", x, x)
x, _ := strconv.Atoi("580") // ascii to int (ä¸æ˜¯int64)
f, _ := strconv.ParseFloat("580.1437", 64)
fmt.Printf("å€¼ï¼š%v ç±»å‹ï¼š%T\n", f, f)
b, _ := strconv.ParseBool("true")
fmt.Printf("å€¼ï¼š%v ç±»å‹ï¼š%T\n", b, b)
```

###### byte[]

```go
fmt.Println([]byte("aä½ å¥½")) // [97 228 189 160 229 165 189]
fmt.Println(string([]byte{97, 228, 189, 160, 229, 165, 189}))
// "aä½ å¥½"
```

> ä¼šå‘ç”Ÿæ‹·è´ï¼Œä½¿å…¶ä»ä¸å¯ä¿®æ”¹å˜æˆå¯ä¿®æ”¹ã€‚ä½¿ç”¨ `unsafe.Pointer` é¿å…æ‹·è´ã€‚
>
> ```go
> str := "Hello, mianshiya!"
> byteArray := *(*[]byte)(unsafe.Pointer(&str)) // ä½¿ç”¨ unsafe.Pointer é¿å…æ‹·è´ï¼›å¾—åˆ°[]byte
> // æˆ–
> return unsafe.Slice(unsafe.StringData(s), len(s))
> // byte[] è½¬ string
> return unsafe.String(&b[0], len(b))
> ```
>
> Go 1.22 ç‰ˆæœ¬ç¼–è¯‘å™¨å¯¹å­—ç¬¦ä¸²å’Œ `[]byte` ä¹‹é—´çš„è½¬æ¢è¿›è¡Œäº†ä¼˜åŒ–ï¼Œåœ¨æŸäº›ç‰¹å®šåœºæ™¯ä¸‹å®ç°äº†é›¶æ‹·è´ã€‚ç„¶è€Œï¼Œè¿™ç§ä¼˜åŒ–ä¸»è¦ä¾èµ–äºç¼–è¯‘å™¨çš„å†…è”å’Œé€ƒé€¸åˆ†æï¼Œåªæœ‰åœ¨æœªå‘ç”Ÿé€ƒé€¸çš„æƒ…å†µä¸‹æ‰èƒ½ç”Ÿæ•ˆã€‚å› æ­¤ï¼Œå¹¶éæ‰€æœ‰åœºæ™¯ä¸‹éƒ½èƒ½å®ç°é›¶æ‹·è´è½¬æ¢

ç©ºæ•°ç»„è½¬å›å»ä¹Ÿæœ‰é•¿åº¦ï¼Œ\0 æ˜¯æ™®é€šå­—ç¬¦ã€‚

```go
s := make([]byte, 5)
t := string(s)
fmt.Println(len(t), t) // 5
s[2] = '6'
t = string(s)
fmt.Println(len(t), t) // 5 6
s[4] = '7'
t = string(s)
fmt.Println(len(t), t) // 5 67
```

###### rune[]

è½¬è¿‡æ¥è½¬å›å»ï¼Œå¦‚å­—ç¬¦ä¸²åè½¬

```go
rs := []rune(s)
for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
    rs[i], rs[j] = rs[j], rs[i]
}
return string(rs)
```

##### stringbuilder

åªå®ç°äº† `io.Writer` æ¥å£

```go
package main
import (
	"fmt"
	"strings"
)
func main() {
	var builder strings.Builder
	builder.WriteString("Hello, ")
	builder.WriteString("World!")
	builder.Write([]byte(" Welcome to Go."))
	builder.WriteByte(' ')
	builder.WriteRune('ğŸš€')

	result := builder.String()
	fmt.Println(result)//è¾“å‡º: Hello, World! Welcome to Go. ğŸš€
	builder.Reset()
	builder.WriteString("New content")
	fmt.Println(builder.String()) // è¾“å‡º: New content
}
```

##### Buffer

`bytes.Buffer` åˆ™æ›´é€‚åˆäºŒè¿›åˆ¶æ•°æ®ã€‚å®ç°äº† `io.Reader` å’Œ `io.Writer` æ¥å£ã€‚å†™çš„ç”¨æ³•å’Œä¸Šé¢ Builder ä¸€æ ·ã€‚è¯»å’Œå†™ä¸€æ ·ï¼Œä¼šæ”¹å˜ offsetï¼Œæ˜¾ç„¶æ˜¯æµæ“ä½œã€‚

```go
var buf bytes.Buffer
buf.WriteString("Hello, World!")
p := make([]byte, 5)
buf.Read(p)            // è¯»å–5ä¸ªå­—èŠ‚ ï¼›è¿”å› n, err
fmt.Println(string(p)) // Hello
buf.Read(p)
fmt.Println(string(p)) // , Wor
```

å¯ä»¥å°ç«¯è¯»å†™ï¼š(å¯ä»¥ä»»æ„æ•°æ®ç±»å‹ value)

```go
buf2 := new(bytes.Buffer) // *bytes.Buffer
binary.Write(buf, binary.LittleEndian, value)
buf3 := bytes.NewReader(bytearray) // *bytes.Reader åªè¯»
binary.Read(buf, binary.LittleEndian, &value)
```



#### å­—ç¬¦

##### å¸¸è§„

å•å¼•å·ï¼Œå¯ä»¥æ˜¯æ±‰å­—

byte å‹ï¼Œ æœ¬è´¨æ˜¯ uint8 ç±»å‹ï¼Œ ä»£è¡¨äº† ASCII ç çš„ä¸€ä¸ªå­—ç¬¦ã€‚

rune ç±»å‹ï¼Œ ä»£è¡¨ä¸€ä¸ª UTF-8 å­—ç¬¦ã€‚

> Unicode ä¸ºæ‰€æœ‰å­—ç¬¦è®¾ç½®å”¯ä¸€æ•°å­—ç¼–ç ï¼Œæ¯ä¸ªç ç‚¹(code point)ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ï¼›UTF-8 æ˜¯ Unicode çš„ä¸€ç§å­˜å‚¨å®ç°ï¼Œå®ƒç”¨äº†å˜é•¿æ¥å‹ç¼©ç ç‚¹

å½“éœ€è¦å¤„ç†ä¸­æ–‡ã€ æ—¥æ–‡æˆ–è€…å…¶ä»–å¤åˆå­—ç¬¦æ—¶ï¼Œ åˆ™éœ€è¦ç”¨åˆ° rune ç±»å‹ã€‚ rune ç±»å‹å®é™…æ˜¯ä¸€ä¸ªint32

Go ä½¿ç”¨äº†ç‰¹æ®Šçš„ rune ç±»å‹æ¥å¤„ç† Unicodeï¼Œ è®©åŸºäº Unicode çš„æ–‡æœ¬å¤„ç†æ›´ä¸ºæ–¹ä¾¿ï¼Œ ä¹Ÿå¯ä»¥ä½¿ç”¨ byte å‹è¿›è¡Œé»˜è®¤å­—ç¬¦ä¸²å¤„ç†ï¼Œ æ€§èƒ½å’Œæ‰©å±•æ€§éƒ½æœ‰ç…§é¡¾

```go
a := 'c'  //rune
a := 'å¼ ' //rune
fmt.Println(a) // 24352è€Œä¸æ˜¯å­—ç¬¦ï¼Œä¸”sizeof=4ï¼Œæ— æ³•len
fmt.Printf("%T %c\n", a, a) // int32 å¼ 
```

```go
s := "12345 ä¸‹æµ·æ‰“é²¸é±¼"
for i := 0; i < len(s); i++ { // byte
    fmt.Printf("%v(%c)", s[i], s[i])
}
fmt.Println()
for _, c := range s { // rune
    fmt.Printf("%v(%c)", c, c)
}
fmt.Println()
/* 49(1)50(2)51(3)52(4)53(5)32( )228(Ã¤)184(Â¸)139(Â‹)230(Ã¦)181(Âµ)183(Â·)230(Ã¦)137(Â‰)147(Â“)233(Ã©)178(Â²)184(Â¸)233(Ã©)177(Â±)188(Â¼)
49(1)50(2)51(3)52(4)53(5)32( )19979(ä¸‹)28023(æµ·)25171(æ‰“)40120(é²¸)40060(é±¼)*/
```

##### å¸¸ç”¨æ–¹æ³•

åå‘ä½¿ç”¨å­—ç¬¦ä¸² containsï¼Œå¯ä»¥æ±‚å½“å‰å­—ç¬¦æ˜¯å¦æ˜¯æŸå‡ ä¸ªå­—ç¬¦çš„ä¸€ä¸ª

```go
if strings.ContainsRune("aeiou", b) { // ...
```

#### å¤æ•°

`complex64` è¡¨ç¤ºä¸€ä¸ªç”±ä¸¤ä¸ª `float32` ç±»å‹çš„æµ®ç‚¹æ•°ç»„æˆçš„å¤æ•°ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªæµ®ç‚¹æ•°è¡¨ç¤ºå®éƒ¨ï¼Œç¬¬äºŒä¸ªæµ®ç‚¹æ•°è¡¨ç¤ºè™šéƒ¨ï¼›è¿˜æœ‰ `complex128` (ä¿©float64)ï¼Œæœ‰å†…ç½®æ–¹æ³• `real(), imag()`ï¼Œæœ‰å››åˆ™è¿ç®—ã€‚æ„é€ ï¼š`c1 := complex(1.0, 2.0)` ä¸º 1+2i

> ä½¿ç”¨ä¾‹å­è§`leetcode2.md`é¢˜ç›®611ã€‚

#### nil

ä¸€ä¸ªç‰¹æ®Šå€¼ï¼Œè¡¨ç¤º"æ— "æˆ–"é›¶å€¼"ã€‚ä»£è¡¨æŒ‡é’ˆã€é€šé“ã€å‡½æ•°ã€æ¥å£ã€æ˜ å°„æˆ–åˆ‡ç‰‡çš„é›¶å€¼ã€‚ä¸æ˜¯å…³é”®å­—ï¼Œå¯ä»¥è¢«é‡æ–°å®šä¹‰ã€‚

> - æŒ‡é’ˆï¼šä¸æŒ‡å‘ä»»ä½•æœ‰æ•ˆçš„å†…å­˜åœ°å€ã€‚è§£å¼•ç”¨ä¼š panic
> - åˆ‡ç‰‡ï¼šé•¿åº¦å®¹é‡å‡ 0ï¼Œå¯ä»¥ len, cap, append
> - æ˜ å°„(map)ï¼šä¸èƒ½å­˜å‚¨é”®å€¼å¯¹ï¼Œå¿…é¡»å…ˆ make
> - é€šé“ï¼šä¸èƒ½ç”¨äºå‘é€æˆ–æ¥æ”¶æ•°æ®ï¼Œæ“ä½œä¼šæ°¸è¿œé˜»å¡
> - å‡½æ•°ï¼šå˜é‡æœªèµ‹å€¼ï¼Œè°ƒç”¨ panic
> - æ¥å£ï¼šç±»å‹å’Œå€¼éƒ½æ˜¯ nil

### æ•°ç»„å‹

#### array

##### åˆå§‹åŒ–

æ•°ç»„çš„é•¿åº¦æ˜¯ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œ ä¹Ÿå°±æ˜¯è¯´ [5]int å’Œ [10]int æ˜¯ä¸¤ä¸ªä¸åŒçš„ç±»å‹  

> æ•°ç»„å¯¹åº”çš„ç±»å‹æ˜¯ Sliceï¼ˆåˆ‡ç‰‡ï¼‰ ï¼Œ Slice æ˜¯å¯ä»¥å¢é•¿å’Œæ”¶ç¼©çš„åŠ¨æ€åºåˆ—  

0-indexedï¼Œè¶Šç•Œpanic

æŒ‡å®š**å¸¸æ•°**é•¿åº¦ã€åˆå§‹å€¼æ¥åˆå§‹åŒ–ï¼šæ•°ç»„é•¿åº¦æ˜¯æ•°ç»„ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œä¾‹å¦‚ `[3]int` å’Œ `[4]int` æ˜¯ä¸åŒç±»å‹

```go
var a [3]int
var b = [3]int{5, 8}
for i := 0; i < 3; i++ {
    fmt.Println(a[i] + b[i]) // 5 8 0
}
var c = []string{"ç™½èŒ¶", "ç»¿èŒ¶", "é˜¿å¸•èŒ¶"}
fmt.Println(c) // å¯ä»¥ç›´æ¥è¾“å‡ºæ•°ç»„ [ç™½èŒ¶ ç»¿èŒ¶ é˜¿å¸•èŒ¶]
var intArr2 [5]int = [...]int{1, -1, 9, 90, 12}
// var a, b [3]int ä¸¤ä¸ªä¸€æ ·å½¢çŠ¶çš„æ•°ç»„
```

å¯ä»¥çœç•¥é•¿åº¦ï¼Œç”¨...æ¥è‡ªå·±è®¡ç®—é•¿åº¦

```go
var d = [...]int{1437, 580} //å¤§æ‹¬å·èµ‹å€¼ }å•ç‹¬ä¸€è¡Œçš„è¯æœ€åä¸€ä¸ªå…ƒç´ è¦,
fmt.Printf("%T\n", d) // [2]int
arr := [...]int{1, 3, 5, 7, 8}
```

å¯ä»¥ç¦»æ•£åœ°èµ‹å€¼

```go
var e = [...]int{1: 10, 5: 80}
var f = [8]int{7: 9}
fmt.Println(e, f) // [0 10 0 0 0 80] [0 0 0 0 0 0 0 9]
```

##### ä½¿ç”¨

è¾“å‡º `%T` å¯ä»¥å¾—åˆ°é•¿åº¦ä¿¡æ¯ï¼Œ`len` å‡½æ•°ä¹Ÿå¯ä»¥å¾—åˆ°é•¿åº¦ï¼Œä¸‹é¢æ˜¯ä¸¤ç§éå†

```go
a := [3]int{1, 2, 3}
b := a // å¤åˆ¶
b[0] = 100
fmt.Println(a, b)   // [1 2 3] [100 2 3]
fmt.Println(a != b) // ä½†æ˜¯ä¸æ”¯æŒ >, <
b[0] = a[0]
fmt.Println(a == b)
for i := 0; i < len(a); i++ {
    fmt.Println(a[i])
}
for i, v := range a {
    fmt.Println(i, v)
}
```

æ³¨æ„æ•°ç»„ä¼ å…¥å‡½æ•°æ˜¯ä¼ å€¼å¤åˆ¶ã€‚

##### å¤šç»´

åªæœ‰ç¬¬ä¸€æ¬¡å±‚å¯ä»¥æ¨å¯¼é•¿åº¦ï¼Œä¸å¯ä»¥ç”¨åˆ°å…¶ä»–ç»´åº¦

```go
s := [...][2]string{
    {"å¼ ä¸‰", "å¼ é‡"},
    {"æå››", "ææ€§æ€ç»´"},
    {"ç‹èˆ", "é…’å§èˆ"},//éœ€è¦é€—å·è¿™ä¸€è¡Œï¼Œæ— è®º[3][2]è¿˜æ˜¯[...][2]éƒ½éœ€è¦
}
fmt.Println(len(s), s) // 3 [[å¼ ä¸‰ å¼ é‡] [æå›› ææ€§æ€ç»´] [ç‹èˆ é…’å§èˆ]]
```

å¤šç»´æ•°ç»„ for i, v çš„éå† v æ˜¯ä¸€ç»´æ•°ç»„ï¼Œå¤åˆ¶ã€‚

```go
a := [...][3]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}
for _, row := range a {
    row[0] *= 2 // a ä¸å˜
}
fmt.Println(a)
```



##### ä¼ å€¼

ä¸ç®¡å‡ ç»´ï¼Œå‡½æ•°ä¼šå¤åˆ¶æ•´ä¸ªæ•°ç»„

```go
func t2(x [3]int) { // ä¸€å®šè¦å†™å›ºå®šçš„é•¿åº¦ï¼Œä¸èƒ½å†™[]intï¼Œå¤šç»´åŒç†
	for i := 0; i < len(x); i++ {
		x[i] *= 2
	}
	fmt.Println(x)
}
// ...
t2(a) // [2 4 6]
fmt.Println(a) // [1 2 3]
```

#### slice

åˆ‡ç‰‡ slice æ˜¯ä¸€ä¸ªæ‹¥æœ‰ç›¸åŒç±»å‹å…ƒç´ çš„å¯å˜é•¿åº¦çš„åºåˆ—ã€‚ å®ƒæ˜¯åŸºäºæ•°ç»„ç±»å‹åšçš„ä¸€å±‚å°è£…ã€‚å®ƒéå¸¸çµæ´»ï¼Œ æ”¯æŒè‡ªåŠ¨æ‰©å®¹ã€‚

åˆ‡ç‰‡æ˜¯ä¸€ä¸ªå¼•ç”¨ç±»å‹ï¼Œ å®ƒçš„å†…éƒ¨ç»“æ„åŒ…å«åœ°å€ã€ é•¿åº¦å’Œå®¹é‡

åˆ‡ç‰‡çš„æœ¬è´¨å°±æ˜¯å¯¹åº•å±‚æ•°ç»„çš„å°è£…ï¼Œ å®ƒåŒ…å«äº†ä¸‰ä¸ªä¿¡æ¯ï¼š åº•å±‚æ•°ç»„çš„æŒ‡é’ˆã€ åˆ‡ç‰‡çš„é•¿åº¦ï¼ˆlenï¼‰å’Œåˆ‡ç‰‡çš„å®¹é‡ï¼ˆcapï¼‰  

##### å®šä¹‰

å¦‚æœä¸åˆå§‹åŒ–æ˜¯ç©ºï¼Œåˆå§‹åŒ–ä¸€ä¸ªç©ºå°±ä¸æ˜¯

```go
var a []string
var b = []int{}
var c = []bool{false, true}
fmt.Println(a, b, c)              // [] [] [false true]
fmt.Println(a == nil, b == nil)   // true false
fmt.Printf("%T %T %T\n", a, b, c) // []string []int []bool
```

å®šä¹‰å¤šç»´ï¼Œå˜é‡çš„ï¼Œå¦‚ï¼šm+1, n+1, 3

```go
f := make([][][3]int, m+1)
for i := range f {
    f[i] = make([][3]int, n+1)
}
// æˆ– n+1, m+1, 3
dp := make([][][]int, n+1)
for i := range dp {
    dp[i] = make([][]int, m+1)
    for j := range dp[i] {
        dp[i][j] = make([]int, 3)
    }
}
```

å¸¦åˆå§‹å€¼ï¼š(ä¸Šé¢çš„ f)

```go
for j := range f[0] {
    f[0][j] = [3]int{math.MinInt / 2, math.MinInt / 2, math.MinInt / 2}
}
f[0][1] = [3]int{}
```

æ•°ç»„å¥— sliceï¼š(ç¬¬ä¸€ç»´å›ºå®šï¼Œç¬¬äºŒä½ slice)

```go
vis := [1024][]int
```

æ•°ç»„è½¬ sliceï¼Œ`a := arr[:]`ï¼ŒO1ï¼Œè½¬äº†å°±èƒ½å½“åˆ‡ç‰‡å‡½æ•°å‚æ•°

> å£°æ˜ä¸åˆå§‹åŒ–å°±æ˜¯ nilï¼Œ`s==nil` ä¸º trueï¼Œlen, cap ä¸º0ã€‚å®ƒä¸ç­‰äºç©ºåˆ‡ç‰‡(æœ‰åœ°å€)ã€‚ç”¨ Json Encode å¾—åˆ°ç»“æœä¸€ä¸ªæ˜¯ null ä¸€ä¸ªæ˜¯ []ã€‚nil åˆ‡ç‰‡å’Œç©ºåˆ‡ç‰‡çš„å¯¹æ¯”æ˜¯ false çš„ã€‚nil å¯ä»¥ appendã€‚

##### make

ä¸åŸºäºæ•°ç»„ï¼ŒåŠ¨æ€åˆ›å»ºåˆ‡ç‰‡ï¼Œä¼ å…¥ T, size (å…ƒç´ æ•°), cap (å®¹é‡) ä¸‰ä¸ªå‚æ•°

make å‚æ•°åˆ†åˆ«ï¼šç±»å‹ã€é€»è¾‘å¤§å°(length)ã€å®é™…åˆ†é…å†…å­˜å¤§å°(capacity)

```go
d := make([]int, 3, 5)
d[2] = 580
fmt.Println(d, len(d), cap(d)) // [0 0 580] 3 5
```

å¯ä»¥é€šè¿‡é¢„å…ˆåˆ†é…åˆé€‚çš„å®¹é‡æ¥å‡å°‘æ‰©å®¹çš„æ¬¡æ•°ã€‚

##### è¿ç®—

éå†ä¸æ•°ç»„ä¸€æ ·ã€‚ä¸æ”¯æŒsliceä¹‹é—´æ¯”è¾ƒ `==, !=`ï¼Œä½†å¯ä»¥ä¸ nil æ¯”è¾ƒ(è§ä¸Šé¢ä»£ç )ã€‚è¶Šç•Œpanic

ä¸€ä¸ª nil å€¼çš„åˆ‡ç‰‡å¹¶æ²¡æœ‰åº•å±‚æ•°ç»„ï¼›ä¸€ä¸ª nil å€¼çš„åˆ‡ç‰‡é•¿åº¦å’Œå®¹é‡éƒ½æ˜¯ 0ã€‚ ä½†ä¸èƒ½è¯´ä¸€ä¸ªé•¿åº¦å’Œå®¹é‡éƒ½æ˜¯ 0 çš„åˆ‡ç‰‡ä¸€å®šæ˜¯ nilã€‚æ‰€ä»¥è¦åˆ¤æ–­ä¸€ä¸ªåˆ‡ç‰‡æ˜¯å¦æ˜¯ç©ºçš„ï¼Œ è¦æ˜¯ç”¨ len(s) == 0 æ¥åˆ¤æ–­ï¼Œ ä¸åº”è¯¥ä½¿ç”¨ s == nil æ¥åˆ¤æ–­ã€‚  

```go
var s1 []int //len(s1)=0;cap(s1)=0;s1==nil
s2 := []int{} //len(s2)=0;cap(s2)=0;s2!=nil
s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
```

å¯ä»¥ç”¨ç±»ä¼¼ python ä»£ç çš„æ–¹æ³•ç”¨æ•°ç»„è½¬åˆ‡ç‰‡ï¼Œä¿®æ”¹æ•°ç»„çš„åˆ‡ç‰‡å½±å“æ•°ç»„æœ¬èº«

```go
ar := [5]int{99, 82, 44, 35, 3}
ar1 := ar[1:4]
ar1[0] *= 10 // ä¿®æ”¹åŸæ•°ç»„ï¼Œå¯¹ ar, ar1-4 éƒ½å½±å“
ar2 := ar[1:]
ar3 := ar[:4]
ar4 := ar[:]
fmt.Println(ar1, ar2, ar3, ar4)
// [820 44 35] [820 44 35 3] [99 820 44 35] [99 820 44 35 3]
```

åˆ‡ç‰‡çš„é•¿åº¦å°±æ˜¯å®ƒæ‰€åŒ…å«çš„å…ƒç´ ä¸ªæ•°ã€‚

åˆ‡ç‰‡çš„å®¹é‡æ˜¯ä»å®ƒçš„ç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹æ•°ï¼Œ åˆ°å…¶åº•å±‚æ•°ç»„å…ƒç´ æœ«å°¾çš„ä¸ªæ•°ã€‚åˆ‡ç‰‡ s çš„é•¿åº¦å’Œå®¹é‡å¯é€šè¿‡è¡¨è¾¾å¼ len(s) å’Œ cap(s) æ¥è·å–

åˆ‡ç‰‡å¯ä»¥å†åˆ‡ï¼ŒåŸºäºåˆ‡ç‰‡ä¸‹æ ‡ç»§ç»­ç´¢å¼•

åˆ‡ç‰‡æ˜¯å¼•ç”¨æ•°æ®ç±»å‹ï¼Œä¿®æ”¹åˆ‡ç‰‡ä¼šä¿®æ”¹å®ƒçš„åº•å±‚æ•°ç»„

```go
a := [...]string{"åŒ—äº¬", "ä¸Šæµ·", "å¹¿å·", "æ·±åœ³", "æˆéƒ½", "é‡åº†"}
fmt.Printf("a:%v type:%T len:%d cap:%d\n", a, a, len(a), cap(a))
b := a[1:3]
fmt.Printf("b:%v type:%T len:%d cap:%d\n", b, b, len(b), cap(b))
c := b[1:5]
fmt.Printf("c:%v type:%T len:%d cap:%d\n", c, c, len(c), cap(c))
//a:[åŒ—äº¬ ä¸Šæµ· å¹¿å· æ·±åœ³ æˆéƒ½ é‡åº†] type:[6]string len:6 cap:6
//b:[ä¸Šæµ· å¹¿å·] type:[]string len:2 cap:5
//c:[å¹¿å· æ·±åœ³ æˆéƒ½ é‡åº†] type:[]string len:4 cap:4
//ç¬¬ä¸€ä¸ªåˆ‡ç‰‡æ˜¾ç„¶ï¼Œä»èµ·ç‚¹å¼€å§‹è¿˜æœ‰5ä¸ªå…ƒç´ ï¼›ç¬¬äºŒä¸ªå°±æ˜¯è¿˜æœ‰4ä¸ª(cap)
// fmt.Println(b[2]) ä¸å¯ä»¥ï¼šè¶Šç•Œ
fmt.Println(c[0]) // å¹¿å·
c[0] = "æ˜Ÿç¯åŸ"
fmt.Println(a) // [åŒ—äº¬ ä¸Šæµ· æ˜Ÿç¯åŸ æ·±åœ³ æˆéƒ½ é‡åº†]
```

##### append

å†…å»ºå‡½æ•° append()å¯ä»¥ä¸ºåˆ‡ç‰‡åŠ¨æ€æ·»åŠ å…ƒç´ ï¼Œæ¯ä¸ªåˆ‡ç‰‡ä¼šæŒ‡å‘ä¸€ä¸ªåº•å±‚æ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„çš„å®¹é‡å¤Ÿç”¨å°±æ·»åŠ æ–°å¢å…ƒç´ ã€‚

å½“åº•å±‚æ•°ç»„ä¸èƒ½å®¹çº³æ–°å¢çš„å…ƒç´ æ—¶ï¼Œåˆ‡ç‰‡å°±ä¼šè‡ªåŠ¨æ‰©å®¹ï¼Œæ‰©å®Œäº†å† append (`append` å‡½æ•°ä¸­ä¼šæ£€æŸ¥åˆ‡ç‰‡çš„å½“å‰å®¹é‡ï¼Œè‹¥ä¸è¶³åˆ™è°ƒç”¨ `grow` å‡½æ•°æ‰©å±•å®¹é‡)ï¼Œæ‰€ä»¥æˆ‘ä»¬é€šå¸¸éƒ½éœ€è¦ç”¨åŸå˜é‡æ¥æ”¶ append å‡½æ•°çš„è¿”å›å€¼ï¼Œ

```go
a := make([]int, 3, 5)
for i := 1; i <= 10; i++ {
    a = append(a, i)
    fmt.Printf("%v %d %d %p\n", a, len(a), cap(a), a)
}
```

append()å‡½æ•°è¿˜æ”¯æŒä¸€æ¬¡æ€§è¿½åŠ å¤šä¸ªå…ƒç´  ï¼Œä»¥åŠè¿½åŠ åˆ‡ç‰‡

```go
var b []int
b = append(b, 12, 34, 56)
fmt.Println(b)
c := []int{44, 888}
b = append(b, c...)
fmt.Println(b)
```

å¿…é¡»æ¥æ”¶ append çš„è¿”å›å€¼ï¼Œå¦åˆ™å®ƒä¼šè¡¨ç¤ºè¿”å›å€¼æœªè¢«ä½¿ç”¨

##### åˆ é™¤

æ²¡æœ‰åˆ é™¤åˆ‡ç‰‡å…ƒç´ çš„ä¸“ç”¨æ–¹æ³•ï¼Œ ä½¿ç”¨åˆ‡ç‰‡æœ¬èº«çš„ç‰¹æ€§æ¥åˆ é™¤å…ƒç´   

```go
a := []int{30, 31, 32, 33, 34, 35, 36, 37}
// è¦åˆ é™¤ç´¢å¼•ä¸º 2 çš„å…ƒç´ 
a = append(a[:2], a[3:]...)
fmt.Println(a) //[30 31 33 34 35 36 37]
```

åˆ é™¤æ˜¯ O1 çš„ï¼Œä»»æ„ `a = a[l:r]` éƒ½æ˜¯å¦‚æ­¤ã€‚å¦‚ `a=a[1:]` æ˜¯åˆ é™¤ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

##### copy

c å¿…é¡»å·²ç»ç”³è¯·å†…å­˜ï¼Œcopy ä¸ä¼šç”³è¯·å†…å­˜

```go
b := []int{1, 4, 3, 7}
c := make([]int, 4, 4)
copy(c, b)
c[0] *= 2
fmt.Println(b, c)
```

è‰¯å¥½ç¤ºèŒƒï¼š

```go
if vis[v] == nil {
    vis[v] = make([]int, len(vis[u]))  // å…ˆåˆ†é…ä¸€æ ·å¤§çš„ç©ºé—´
    copy(vis[v], vis[u])   // å†å¤åˆ¶æ•°æ®
}
vis[v] = append(vis[v], i)             // æœ€åè¿½åŠ æ–°å…ƒç´ 
```

æ–¹æ³•äºŒï¼šä¸ç®¡ nil ä¸å¦éƒ½å¯ä»¥

```go
vis[v] = append(vis[v], vis[u]...)  // å…ˆå¤åˆ¶ vis[u] çš„æ‰€æœ‰å…ƒç´ 
vis[v] = append(vis[v], i)          // å†è¿½åŠ æ–°å…ƒç´ 
```

##### ä¼ å‚

> ä¸€èˆ¬ä¼ æ•°ç»„éƒ½ç”¨sliceè€Œä¸æ˜¯æ•°ç»„ï¼Œé™¤éï¼šå›ºå®šå¤§å°ç¼“å†²åŒºã€é¿å…ä¿®æ”¹åŸå§‹æ•°æ®ã€‚

å¦‚æœå®ƒä¼ å…¥å‡½æ•°ï¼Œå¯¹åº”çš„sliceæŒ‡é’ˆç­‰ä¿¡æ¯ä¼šå¤åˆ¶ï¼Œä½†å®ƒçš„åº•å±‚æ•°ç»„ä¸ä¼šã€‚æ‰€ä»¥åŒèŒƒå›´å†…ä¿®æ”¹å€’æ˜¯å¯ä»¥ï¼Œä½†æ˜¯å¦‚æœå¢åˆ å°±ä¸ä¸€è‡´äº†ï¼Œä½†å®ƒèƒŒåçš„æ•°ç»„æ˜¯ä¸€è‡´çš„ã€‚

```go
a := make([]int, 3, 4)
a[0], a[1], a[2] = -1, 4, 7
f := func(b []int) []int {
    b = append(b, 10)
    b[0] = 1
    fmt.Println(b) // 1, 4, 7, 10
    return b
}
b := f(a)
fmt.Println(a, b) // [1 4 7] [1 4 7 10]
a = a[:4]
fmt.Println(a) // [1 4 7 10]
g := func(b *[]int) {
    *b = append(*b, 20)
}
g(&a)
fmt.Println(a) // [1 4 7 10 20]
```

##### å€¼å¯»å€

ä¸èƒ½ç›´æ¥è·å– map ä¸­æŸä¸ªå…ƒç´ çš„åœ°å€ï¼Œå› ä¸ºåŠ¨æ€å¢é•¿(èµ‹å€¼åæ‰©å®¹ï¼Œå¾—åˆ°çš„åœ°å€å°†æ— æ•ˆ)ã€å¹¶å‘å®‰å…¨(mapå¹¶å‘ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå¯èƒ½æ•°æ®ç«äº‰)ã€ä¸€è‡´æ€§(map çš„å®ç°ä¸ä¿è¯å…ƒç´ çš„è¿ç»­å­˜å‚¨ï¼Œå–å€æ“ä½œæ²¡æœ‰æ˜ç¡®çš„æ„ä¹‰)ã€‚

å› æ­¤ï¼Œè‹¥å€¼æ˜¯ç»“æ„ä½“ï¼Œæ— æ³•ç›´æ¥èµ‹å€¼ï¼Œéœ€è¦å…ˆå–å…¨éƒ¨ä¸ºä¸´æ—¶å˜é‡ï¼Œå†æ”¾å›å»ã€‚æˆ–è€…ç”¨ç»“æ„ä½“æŒ‡é’ˆ

```go
type Point struct{ X, Y int }
m := make(map[string]Point)
m["a"] = Point{1, 2}
// m["a"].X = 3 // é”™è¯¯
p := m["a"]
p.X = 3
m["a"] = p
// æ–¹æ¡ˆäºŒï¼šm := make(map[string]*Point)
```

> å®ƒé€šè¿‡é™åˆ¶æŸäº›æ“ä½œæ¥é¿å…æ›´ä¸¥é‡çš„æ½œåœ¨é—®é¢˜ï¼Œæ˜¯ä¸€ç§é˜²å¾¡æ€§è®¾è®¡

##### æ‰©å®¹

åˆ‡ç‰‡æ˜¯å¼•ç”¨ç±»å‹ï¼Œå­˜å‚¨çš„æ˜¯å¯¹åº•å±‚æ•°ç»„çš„å¼•ç”¨ã€‚å½“åˆ‡ç‰‡æ‰©å®¹æ—¶ï¼Œä¼šåˆ›å»ºæ–°çš„åº•å±‚æ•°ç»„ï¼Œå¹¶å°†æ•°æ®å¤åˆ¶åˆ°æ–°æ•°ç»„ä¸­ã€‚æ‰€ä»¥æ”¯æŒ O1 ä¸‹æ ‡ç´¢å¼•ã€‚æ‰€ä»¥æ‰©å®¹åæ–°æ—§åˆ‡ç‰‡ä¸åœ¨å…±äº«åº•å±‚æ•°ç»„ã€‚

æ‰©å®¹ç­–ç•¥ï¼šå¯æŸ¥çœ‹ $GOROOT/src/runtime/slice.go æºç 

- åœ¨ 1.18 ä»¥å‰ï¼šå®¹é‡å°äº 1024 æ—¶ä¸º 2 å€æ‰©å®¹ï¼Œå¤§äºç­‰äº 1024 æ—¶ä¸º 1.25 å€æ‰©å®¹ã€‚

- åœ¨ 1.18 åŠä»¥åï¼šå®¹é‡å°äº 256 æ—¶ä¸º 2 å€æ‰©å®¹ï¼Œå¤§äºç­‰äº 256 æ—¶çš„æ‰©å®¹å› å­é€æ¸ä» 2 å‡ä½ä¸º 1.25ã€‚

  > æ¯æ¬¡å¢åŠ  `(newcap + 3*threshold)/4`çš„å®¹é‡ï¼Œç›´åˆ°æ–°å®¹é‡å¤§äºæœŸæœ›å®¹é‡ã€‚å…¶ä¸­thresholdæ˜¯256ã€‚

> åœ¨æ‰©å®¹ä¹‹åè¿˜ä¼šè¿›è¡Œä¸€æ­¥`roundupsize`ï¼Œè¿™ä¸€æ­¥ä¸»è¦æ˜¯é å†…å­˜å¯¹é½çš„ä¼˜åŒ–ï¼Œæ¥è®¡ç®—å‡ºæœ€ç»ˆçš„å®¹é‡

> | starting cap | growth factor |
> | ------------ | ------------- |
> | 256          | 2.0           |
> | 512          | 1.63          |
> | 1024         | 1.44          |
> | 2048         | 1.35          |
> | 4096         | 1.30          |

> ```go
> newcap := old.cap
> doublecap := newcap + newcap
> if cap > doublecap {
>  newcap = cap
> } else {
>  if old.len < 1024 {
>      newcap = doublecap
>  } else {
>      // Check 0 < newcap to detect overflow
>      // and prevent an infinite loop.
>      for 0 < newcap && newcap < cap {
>          newcap += newcap / 4
>      }
>      // Set newcap to the requested cap when
>      // the newcap calculation overflowed.
>      if newcap <= 0 {
>          newcap = cap
>      }
>  }
> }
> ```
>
> 1. å¦‚æœæ–°ç”³è¯·å®¹é‡ï¼ˆcapï¼‰ å¤§äº 2 å€çš„æ—§å®¹é‡ï¼ˆold.capï¼‰ ï¼Œ æœ€ç»ˆå®¹é‡ï¼ˆnewcapï¼‰å°±æ˜¯æ–°ç”³è¯·çš„å®¹é‡ï¼ˆcapï¼‰  
> 2. å¦åˆ™åˆ¤æ–­ï¼Œ å¦‚æœæ—§åˆ‡ç‰‡çš„é•¿åº¦å°äº 1024ï¼Œ åˆ™æœ€ç»ˆå®¹é‡(newcap)å°±æ˜¯æ—§å®¹é‡(old.cap)çš„ä¸¤å€
> 3. å¦åˆ™åˆ¤æ–­ï¼Œ å¦‚æœæ—§åˆ‡ç‰‡é•¿åº¦å¤§äºç­‰äº 1024ï¼Œ åˆ™æœ€ç»ˆå®¹é‡ï¼ˆnewcapï¼‰ ä»æ—§å®¹é‡ï¼ˆold.capï¼‰å¼€å§‹å¾ªç¯å¢åŠ åŸæ¥çš„ 1/4ï¼Œ ç›´åˆ°æœ€ç»ˆå®¹é‡ï¼ˆnewcapï¼‰ å¤§äºç­‰äºæ–°ç”³è¯·çš„å®¹é‡(cap)
> 4. å¦‚æœæœ€ç»ˆå®¹é‡ï¼ˆcapï¼‰ è®¡ç®—å€¼æº¢å‡ºï¼Œ åˆ™æœ€ç»ˆå®¹é‡ï¼ˆcapï¼‰ å°±æ˜¯æ–°ç”³è¯·å®¹é‡ï¼ˆcapï¼‰ 
>
> åˆ‡ç‰‡æ‰©å®¹è¿˜ä¼šæ ¹æ®åˆ‡ç‰‡ä¸­å…ƒç´ çš„ç±»å‹ä¸åŒè€Œåšä¸åŒçš„å¤„ç†ï¼Œ æ¯”å¦‚ int å’Œ stringç±»å‹çš„å¤„ç†æ–¹å¼å°±ä¸ä¸€æ ·ã€‚  
>
> ```go
> // 1.18 åŠä¹‹åç‰ˆæœ¬
> // nextslicecap è®¡ç®—ä¸‹ä¸€ä¸ªåˆé€‚çš„åˆ‡ç‰‡å®¹é‡ã€‚
> // å‚æ•° newLen æ˜¯ç›®æ ‡åˆ‡ç‰‡çš„é•¿åº¦ï¼ŒoldCap æ˜¯å½“å‰åˆ‡ç‰‡çš„å®¹é‡ã€‚
> // è¿”å›å€¼æ˜¯æ ¹æ®æ–°çš„é•¿åº¦å’Œå½“å‰å®¹é‡è®¡ç®—å‡ºçš„æœ€é€‚åˆçš„å®¹é‡ã€‚
> func nextslicecap(newLen, oldCap int) int {
> 	newcap := oldCap                   // åˆå§‹åŒ–æ–°çš„å®¹é‡ä¸ºå½“å‰å®¹é‡
> 	doublecap := newcap + newcap       // è®¡ç®—å½“å‰å®¹é‡çš„ä¸¤å€
> 	if newLen > doublecap {            // å¦‚æœç›®æ ‡é•¿åº¦å¤§äºä¸¤å€å½“å‰å®¹é‡ï¼Œåˆ™è¿”å›ç›®æ ‡é•¿åº¦
> 		return newLen
> 	}
> 
> 	const threshold = 256              // å®šä¹‰ä¸€ä¸ªé˜ˆå€¼ï¼Œå½“å®¹é‡å°äºé˜ˆå€¼æ—¶ï¼Œé‡‡ç”¨2å€å¢é•¿
> 	if oldCap < threshold {            // å¦‚æœå½“å‰å®¹é‡å°äºé˜ˆå€¼ï¼Œåˆ™è¿”å›å½“å‰å®¹é‡çš„2å€
> 		return doublecap
> 	}
> 
> 	for {
> 		// å¯¹äºè¾ƒå°çš„åˆ‡ç‰‡ï¼Œå®¹é‡å¢é•¿ä¸º2å€ï¼›å¯¹äºè¾ƒå¤§çš„åˆ‡ç‰‡ï¼Œå®¹é‡å¢é•¿ä¸º1.25å€ã€‚
> 		// è¿™ä¸ªå…¬å¼å®ç°äº†åœ¨ä¸¤è€…ä¹‹é—´çš„å¹³æ»‘è¿‡æ¸¡ã€‚
> 		newcap += (newcap + 3*threshold) >> 2 // å¢é•¿1.25å€
> 
> 		// éœ€è¦æ£€æŸ¥ newcap æ˜¯å¦å¤§äºç­‰äº newLenï¼Œå¹¶ä¸”æ£€æŸ¥ newcap æ˜¯å¦æº¢å‡ºã€‚
> 		// å› ä¸º newLen ä¿è¯å¤§äºé›¶ï¼Œå› æ­¤å½“ newcap æº¢å‡ºæ—¶ï¼Œuint(newcap) ä¼šå¤§äº uint(newLen)ã€‚
> 		// è¿™æ ·æˆ‘ä»¬å¯ä»¥é€šè¿‡ç›¸åŒçš„æ¯”è¾ƒæ¥æ£€æŸ¥è¿™ä¸¤ä¸ªæ¡ä»¶ã€‚
> 		if uint(newcap) >= uint(newLen) {
> 			break // å¦‚æœæ–°å®¹é‡å¤§äºç­‰äºç›®æ ‡é•¿åº¦ï¼Œè·³å‡ºå¾ªç¯
> 		}
> 	}
> 
> 	// å¦‚æœ newcap è®¡ç®—æº¢å‡ºï¼Œè®¾ç½® newcap ä¸ºç›®æ ‡é•¿åº¦ã€‚
> 	// å› ä¸ºå®¹é‡æº¢å‡ºæ—¶ï¼Œnewcap å¯èƒ½å˜ä¸ºè´Ÿæ•°æˆ– 0ï¼Œå› æ­¤è¿”å›ç›®æ ‡é•¿åº¦ã€‚
> 	if newcap <= 0 {
> 		return newLen
> 	}
> 
> 	return newcap // è¿”å›è®¡ç®—å‡ºçš„åˆé€‚å®¹é‡
> }
> ```

#### map

##### å®šä¹‰

æ˜ å°„ mapã€‚æ— åºçš„åŸºäº key-value çš„æ•°æ®ç»“æ„ï¼Œå¼•ç”¨ç±»å‹ï¼Œåˆå§‹åŒ–æ‰èƒ½ä½¿ç”¨

map ç±»å‹çš„å˜é‡é»˜è®¤åˆå§‹å€¼ä¸º nilï¼Œ éœ€è¦ä½¿ç”¨ make()å‡½æ•°æ¥åˆ†é…å†…å­˜ï¼Œå¯ä»¥æŒ‡å®šå®¹é‡capä¹Ÿå¯ä»¥ä¸æŒ‡å®šã€‚æ²¡æœ‰ cap æœ‰ len

key å¯ä»¥æ˜¯ï¼šé•¿åº¦å›ºå®šæ•°ç»„ã€stringã€int ç­‰å€¼å¯æ¯”è¾ƒç±»å‹ï¼Œç»“æ„ä½“å„å­—æ®µå¯æ¯”è¾ƒå¯ä»¥åš keyï¼Œåˆ‡ç‰‡å¯ä»¥è½¬ string / å›ºå®šæ•°ç»„ã€‚

```go
score := make(map[string]int, 8)
score["lr"] = 580
score["ac"] = 100
fmt.Printf("%v %T", score, score)
//map[ac:100 lr:580] map[string]int
occur := map[byte]bool{}
```

set çš„æ€è·¯ï¼šbool ä¸º valï¼Œæˆ–ï¼š

```go
set := map[int]struct{}{}
// èµ‹å€¼ï¼šset[x] = struct{}{}
```

å¸¦åˆå§‹å€¼ï¼š

```go
score2 := map[string]string{
    "lr":    "580@ac.com",
    "lr580": "https://github.com/lr580",
}
fmt.Println(score2)
vowels := map[byte]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true}
```

è¿™ä¸ªæ— åºä¼šä½¿å¾—æ¯æ¬¡éå†æ—¶ï¼Œè¾“å‡ºçš„é¡ºåºéƒ½å¯èƒ½ä¸åŒã€‚

> æ— åºè®¾è®¡ä¸ºäº†é¿å…é¡ºåºä¾èµ–ï¼Œä½†æ˜¯æ‰©å®¹åé¡ºåºä¼šæ”¹å˜ã€‚è¦æœ‰åºå¯ä»¥ç”¨ slice å­˜é¡ºåºã€‚

##### ä½¿ç”¨

###### å–å€¼

å–ä¸‹æ ‡è¿”å›ä¸¤ä¸ªå€¼(å¤šé‡èµ‹å€¼)ï¼Œåˆ†åˆ«ä»£è¡¨å€¼ï¼Œæ˜¯å¦å­˜åœ¨(ä¸å­˜åœ¨å€¼å˜æˆè¯¥ç±»å‹é›¶å€¼)

```go
v, ok := score2["lr"]
fmt.Println(v, ok) // 580@ac.com true
v, ok = score2["LR"]
fmt.Println(v, ok) //  false
```

ä¹Ÿå¯ä»¥å•è¿”å›å€¼ï¼Œè¿”å›é›¶å€¼å¦‚æœkeyä¸å­˜åœ¨ (ä¸ä¼šæ’å…¥è¯¥ key)

```go
value := m["key"]
```

å¯ä»¥ç›´æ¥æ‹¿æ¥ if (å¦‚æœ value æ˜¯ bool)

```go
if vowels[word[j]] {
    occur[word[j]] = true
}
```

> å¦‚æœ map æ˜¯ nilï¼Œé‚£ä¹ˆæ— è®ºä½¿ç”¨å“ªç§ get æ“ä½œï¼ŒæŸ¥è¯¢éƒ½ä¼šè¿”å›è¯¥ç±»å‹çš„é›¶å€¼ï¼Œå¹¶ä¸” ok ä¸º falseã€‚åœ¨ Go ä¸­ï¼Œæœªåˆå§‹åŒ–çš„ map é»˜è®¤ä¸º nilï¼Œè¿™ç§æƒ…å†µä¸‹ç›´æ¥è®¿é—®è¯¥ map ä¹Ÿä¸ä¼šå¯¼è‡´ panicï¼Œè€Œæ˜¯è¿”å›é›¶å€¼ã€‚ä½†nil mapä¸å¯ä»¥èµ‹å€¼ã€‚

###### éå†

éå†ï¼š(æ— åº) å…ƒç´ é¡ºåºä¸æ·»åŠ é”®å€¼å¯¹çš„é¡ºåºæ— å…³  

```go
for k, v := range score2 {
    fmt.Println(k, v)
} // è‹¥ for k := range scoreMapï¼Œåªéå†é”®
```

###### åˆ é™¤

åˆ é™¤ï¼šå­˜åœ¨å°±åˆ é™¤ï¼Œä¸å­˜åœ¨å°±ä¸æ“ä½œã€‚map ä¸º nil ä¸æ“ä½œã€‚

```go
delete(score2, "lr")
```

ç±»ä¼¼ C++ï¼Œä¸å­˜åœ¨æ—¶è¦èµ‹å€¼ä¼šæœ‰é»˜è®¤å€¼

```go
score["AA"]++
fmt.Println(score) // AA é¡¹æ˜¯ 1
```

å…¨åˆ äº†ï¼š`clear(score)`ã€‚Go 1.21 ç‰ˆæœ¬å¼•å…¥çš„æ–°å†…ç½®å‡½æ•°

> æ³¨æ„åˆå§‹åŒ–ï¼Œå¦åˆ™ç©ºæŒ‡é’ˆé”™è¯¯ï¼Œå¦‚ `var m map[int]int` ç›´æ¥ `m[1]=2`ã€‚

##### åµŒå¥—ç»“æ„

å¦‚ slice çš„å…ƒç´ æ˜¯ map

```go
var mapSlice = make([]map[string]string, 3)
for index, value := range mapSlice {
    fmt.Printf("index:%d value:%v\n", index, value)
}
fmt.Println("after init")
// å¯¹åˆ‡ç‰‡ä¸­çš„ map å…ƒç´ è¿›è¡Œåˆå§‹åŒ–
mapSlice[0] = make(map[string]string, 10)
mapSlice[0]["name"] = "å°ç‹å­"
mapSlice[0]["password"] = "123456"
mapSlice[0]["address"] = "æµ·æ·€åŒº"
for index, value := range mapSlice {
    fmt.Printf("index:%d value:%v\n", index, value)
}
// index:0 value:map[address:æµ·æ·€åŒº name:å°ç‹å­ password:123456]
// index:1 value:map[]
// index:2 value:map[]
```

map çš„å…ƒç´ æ˜¯ slice

```go
var sliceMap = make(map[string][]string, 3)
fmt.Println(sliceMap)
fmt.Println("after init")
key := "ä¸­å›½"
value, ok := sliceMap[key]
if !ok { // æ‰§è¡Œ
    value = make([]string, 0, 2)
    fmt.Println("init")
}
value = append(value, "åŒ—äº¬", "ä¸Šæµ·")
sliceMap[key] = value
fmt.Println(sliceMap) // map[ä¸­å›½:[åŒ—äº¬ ä¸Šæµ·]]
```

##### è‡ªå®šä¹‰ç±»å‹key

struct åš go çš„ key æ—¶ï¼Œè‡ªåŠ¨æŒ‰å£°æ˜é¡ºåºæˆå‘˜å±æ€§æ’åºã€‚

éœ€è¦å®ç°å“ˆå¸ŒHash()ï¼Œå¦‚ pair<int,int> (ä¹Ÿå¯ä»¥ç”¨ string å®ç°)

```go
type IntPair [2]int
func (ip IntPair) Hash() uint64 {
    return uint64(ip[0])<<32 | uint64(ip[1])
}
var m map[IntPair]int
```

##### æ‰©å®¹

ä¸»æ¡¶regular bucketï¼šåˆå§‹æ•°é‡å›ºå®šï¼Œé€šå¸¸8ä¸ªé”®å€¼å¯¹ã€‚æº¢å‡ºæ¡¶overflow bucketï¼Œé“¾è¡¨æ–¹å¼è¿æ¥åˆ°ä¸»æ¡¶ã€‚

å¢é‡æ‰©å®¹å’Œç­‰é‡æ‰©å®¹ã€‚

- å¢é‡æ‰©å®¹ï¼šå½“é”®å€¼å¯¹çš„æ•°é‡å¤§äº 8 ä¸”å¤§äºæ¡¶æ•°ç»„çš„ 6.5 å€æ—¶ï¼Œæ­¤æ—¶æ¡¶éƒ½å¿«æ»¡äº†ï¼Œéœ€è¦è§¦å‘å¢é‡æ‰©å®¹ï¼Œæ¡¶æ•°é‡ç¿»å€ã€‚

- ç­‰é‡æ‰©å®¹ï¼šå½“æº¢å‡ºæ¡¶è¶…è¿‡ä¸€å®šæ•°é‡ï¼Œåˆ™ä¼šè§¦å‘ç­‰é‡æ‰©å®¹ã€‚è¿™ç§æƒ…å†µæ˜¯å› ä¸ºé¢‘ç¹æ’å…¥å…ƒç´ ååˆåˆ é™¤å…ƒç´ ï¼Œå¯¼è‡´æº¢å‡ºæ¡¶å¢å¤šï¼Œä½†æ˜¯é”®å€¼å¯¹çš„æ€»æ•°ä¸€ç›´ä¸é«˜ï¼Œæ­¤æ—¶ key çš„å­˜å‚¨æ¯”è¾ƒåˆ†æ•£ï¼ŒæŸ¥è¯¢çš„æ•ˆç‡å˜ä½ã€‚ç”±äºæœ¬èº«é”®å€¼å¯¹ä¸å¤šï¼Œæ‰€ä»¥ç­‰é‡æ‰©å®¹ï¼Œæ¡¶æ•°é‡ä¸å˜ã€‚

  ä»¤ Bï¼šå½“å‰ map çš„æ¡¶æ•°é‡çš„å¯¹æ•°ï¼ˆæ¡¶æ•°é‡ = 2^Bï¼‰ã€‚

  ç­‰é‡æ‰©å®¹æº¢å‡ºæ¡¶çš„é˜ˆå€¼ï¼š

  - å¦‚æœæ¡¶æ•°é‡è¾ƒå°‘ï¼ˆB < 16ï¼‰ï¼šæº¢å‡ºæ¡¶çš„æœ€å¤§æ•°é‡é™åˆ¶ä¸º 2^Bã€‚å³ï¼Œå¦‚æœæº¢å‡ºæ¡¶æ•°é‡ noverflow >= 2^Bï¼Œè§¦å‘æ‰©å®¹ã€‚
  - å¦‚æœæ¡¶æ•°é‡è¾ƒå¤šï¼ˆB >= 16ï¼‰ï¼šä¸ºé¿å…æº¢å‡ºæ¡¶çš„æ•°é‡æ— é™å¢é•¿ï¼Œè®¾å®šä¸Šé™ä¸º 2^15ã€‚å³ï¼Œå½“ noverflow >= 2^15 æ—¶ï¼Œè§¦å‘æ‰©å®¹ã€‚

  æ“ä½œå†…å®¹ï¼šé‡æ•´æ•°æ®åˆ†å¸ƒã€å‹ç¼©æº¢å‡ºæ¡¶ã€ä¼˜åŒ–å†…å­˜å¸ƒå±€ã€‚

ç¡®å®šéœ€è¦æ‰©å®¹åï¼Œä¼šè¿›å…¥æ¸è¿›å¼æ‰©å®¹è¿ç§»çŠ¶æ€ã€‚å³åŸæœ‰çš„é”®å€¼å¯¹ä¸ä¼šä¸€æ¬¡æ€§æ¬è¿åˆ°æ–°çš„æ¡¶ä¸­ï¼Œæ¯æ¬¡æœ€å¤šåªä¼šæ¬è¿ 2 ä¸ªæ§½ï¼Œè¿™ä¸ªè¿ç§»å·¥ä½œåˆ†æ‘Šåˆ°åç»­çš„ map æ“ä½œï¼ˆæ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ï¼‰ä¸­ï¼Œä»¥å‡å°‘æ‰©å®¹å¯¹æ€§èƒ½çš„å½±å“ã€‚

> map ä¸­ä¼šæœ‰ä¸€ä¸ª `nevacuate` è®°å½•å·²ç»è¿ç§»çš„æ—§æ¡¶æ•°é‡ï¼Œæ¯æ¬¡è¿ç§»ä¸€ä¸ªæ—§æ¡¶åï¼Œ`nevacuate` ä¼šé€’å¢ã€‚å½“ `nevacuate` ç­‰äºæ—§æ¡¶æ€»æ•°æ—¶ï¼Œè¡¨ç¤ºæ‰€æœ‰æ—§æ¡¶è¿ç§»å®Œæˆï¼Œæ­¤æ—¶ä¼šå°† `oldbuckets` è®¾ç½®ä¸º nilï¼Œè¡¨ç¤ºæ‰©å®¹å®Œæˆã€‚
>
> æ‰©å®¹æ—¶å†™å…¥ï¼šå°šæœªè¿ç§»çš„æ•°æ®ä»å­˜å‚¨åœ¨æ—§æ¡¶ä¸­ï¼›å·²è¿ç§»çš„æ•°æ®å­˜å‚¨åœ¨æ–°æ¡¶ä¸­ã€‚æ£€æŸ¥æ˜¯å¦æ‰©å®¹ï¼Œå³ `oldbuckets != nil`

### æŒ‡é’ˆ

##### åŸºæœ¬

è·Ÿ C ä¸€æ ·ï¼Œ& å–åœ°å€ï¼Œ* å–å˜é‡å€¼ï¼›ç±»å‹æ˜¯ *int ç­‰ã€‚ç©ºæŒ‡é’ˆæ˜¯ `nil`ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯ç©ºå°± `== nil`ã€‚

```go
a := 10
var b *int = &a // å¯ä»¥ä¸å†™ç±»å‹
c := &a         // ç­‰ä»·
*b *= 2
fmt.Printf("%p %v %T\n", a, c, c)
fmt.Println(b, *b, &b)
// %!p(int=20) 0xc0001060a8 *int
// 0xc0001060a8 20 0xc000108058
```

æŒ‡é’ˆåœ¨ Go ä¸­ä¸æ”¯æŒæŒ‡é’ˆç®—æœ¯ï¼ˆå³ä¸èƒ½ç›´æ¥é€šè¿‡æŒ‡é’ˆè¿›è¡ŒåŠ å‡æ“ä½œï¼‰

å…è®¸æŒ‡é’ˆçš„å†…å®¹ï¼š

1. åŸºç¡€ç±»å‹ã€è‡ªå®šä¹‰ç±»å‹ã€ç»“æ„ä½“ã€åˆ‡ç‰‡ã€æ˜ å°„mapã€é€šé“ç­‰
2. æ•°ç»„ï¼šæ•°ç»„çš„æŒ‡é’ˆç±»å‹ `*[N]int`ï¼ˆä¾‹å¦‚ `*[5]int`ï¼‰è¡¨ç¤ºä¸€ä¸ªå›ºå®šå¤§å°ä¸º `N` çš„æ•°ç»„çš„æŒ‡é’ˆã€‚
3. å‡½æ•°ï¼šå¦‚ `func() int` å‡½æ•°å¯ä»¥æœ‰ä¸€ä¸ª `*func() int` ç±»å‹çš„æŒ‡é’ˆ

æ— éœ€æŒ‡é’ˆï¼šæ¥å£ã€‚å®ƒæ˜¯å¼•ç”¨ç±»å‹ï¼Œå®ƒä»¬æœ¬èº«å°±å¯ä»¥ç›´æ¥å¼•ç”¨å…¶ä»–å¯¹è±¡ï¼Œæ²¡æœ‰å¿…è¦ä½¿ç”¨æŒ‡é’ˆç±»å‹ã€‚

C/C++è¿”å›å±€éƒ¨å˜é‡çš„æŒ‡é’ˆä¸å®‰å…¨ï¼Œå› ä¸ºå‡½æ•°è¿”å›åä¼šé‡Šæ”¾ç©ºé—´ã€‚ç”±äºé€ƒé€¸åˆ†æçš„å­˜åœ¨ï¼Œgoé‡Œæ˜¯å®‰å…¨çš„ã€‚

> æŒ‡é’ˆï¼Œå¯ä»¥å…±äº«æ•°æ®ï¼Œå‡å°‘å†…å­˜ä½¿ç”¨ï¼Œä½œä¸ºç»“æ„ä½“æ–¹æ³•æ¥å—è€…ï¼Œå®ç°é“¾å¼è°ƒç”¨(ç±»æ¯”cout)

> æ”¯æŒå¤šçº§æŒ‡é’ˆï¼ˆå³æŒ‡å‘æŒ‡é’ˆçš„æŒ‡é’ˆï¼‰
>
> ```go
> var a int = 100
> var p *int = &a
> var pp **int = &p
> fmt.Println(**pp) // è¾“å‡º 100
> ```

> ç”±äº GC çš„ç¼˜æ•…ï¼Œgo å‡ ä¹é‡ä¸åˆ°æ‚¬æŒ‚æŒ‡é’ˆ(æŒ‡å‘é‡Šæ”¾äº†çš„å†…å­˜ä½ç½®)

##### å‡½æ•°

```go
func modify(a *int) {
	*a *= 2
}
// ...
a := 580
modify(&a)
fmt.Println(a) // 1160
```

##### new

```go
var a *int
a = new(int) // é»˜è®¤å€¼0
b := new(int)
*b = 100
fmt.Println(*a, *b)
```

> new åˆ†é…çš„å†…å­˜å—é»˜è®¤å€¼æ˜¯0ï¼Œè¿”å›æŒ‡é’ˆï¼›ä¸makeä¸åŒï¼Œmakeåªé€‚ç”¨äºslice, map, channelï¼Œè¿”å›åˆå§‹åŒ–åçš„å¯¹è±¡ã€‚

##### æ•°ç»„æŒ‡é’ˆ

æŒ‡é’ˆæ•°ç»„

```go
var p [3]*int
a, b, c := 10, 20, 30
p[0], p[1], p[2] = &a, &b, &c
fmt.Println(*p[0], *p[1], *p[2])
```

æ•°ç»„æŒ‡é’ˆ

```go
a := [3]int{5, 8}
var p *[3]int = &a
fmt.Println(p[0], p[1], p[2]) // ä¸¤ä¸ªå–å€¼ç­‰æ•ˆ
fmt.Println((*p)[0], (*p)[1], (*p)[2])
```

äºŒç»´

```go
arr := [2][3]int{{1, 2, 3}, {7, 8, 9}}
p := &arr
for i := 0; i < len(p); i++ {
    for j := 0; j < len(p[i]); j++ {
        p[i][j] *= 10
        fmt.Printf("%d ", p[i][j])
    }
}
```

å¯¹ slice ä½¿ç”¨æŒ‡é’ˆï¼Œè¿™æ ·æ‰èƒ½ä¿®æ”¹ sliceï¼Œä¸ç„¶æ˜¯å¤åˆ¶äº† slice çš„æŒ‡é’ˆã€‚

```go
a := []int{1,2,3}
tasks := &a
for i, _ := range *tasks {
	tasks[i]
}
```



##### ç»“æ„ä½“æŒ‡é’ˆ

åœ¨ Golang ä¸­æ”¯æŒå¯¹ç»“æ„ä½“æŒ‡é’ˆç›´æ¥ä½¿ç”¨.æ¥è®¿é—®ç»“æ„ä½“çš„æˆå‘˜ï¼›ä¹Ÿå°±æ˜¯å¯¹è±¡é€‰æ‹©å™¨è‡ªåŠ¨è§£å¼•ç”¨

`p2.name` å¯¹æŒ‡é’ˆ `p2` ç­‰ä»·äº `(*p2).name`

æ•°ç»„æŒ‡é’ˆåŒç†ï¼Œ`p2[0].name`ã€‚ç»“æ„ä½“åµŒå¥—åŒç†ã€‚

å¯¹ç©ºæŒ‡é’ˆä¼šè¿è¡Œæ—¶é”™è¯¯panicã€‚

> å¯ä»¥æœ‰ç©ºç»“æ„ä½“æŒ‡é’ˆï¼ŒæŒ‡é’ˆå å†…å­˜ã€‚

##### unsafe.Pointer

unsafe åŒ…çš„æŒ‡é’ˆï¼Œå¯ä»¥æŒ‡å‘ä»»ä½•ç±»å‹å˜é‡çš„é€šç”¨æŒ‡é’ˆã€‚å¯ä»¥ä¸æŒ‡é’ˆäº’è½¬ã€‚

```go
package main
import (
	"fmt"
	"unsafe"
)
func main() {
	var x float64 = 3.1415
	p := unsafe.Pointer(&x)
	ui64p := (*uint64)(p)
	bits := *ui64p
	fmt.Printf("æµ®ç‚¹æ•° %f çš„äºŒè¿›åˆ¶è¡¨ç¤º: %016x\n", x, bits)
}
```

Go çš„åƒåœ¾å›æ”¶å™¨ä¾èµ–äºç±»å‹å®‰å…¨ï¼Œä½¿ç”¨ `unsafe.Pointer` å¯èƒ½å¯¼è‡´åƒåœ¾å›æ”¶å™¨æ— æ³•æ­£ç¡®è¿½è¸ªå¯¹è±¡ï¼Œä»è€Œå¼•å‘å†…å­˜æ³„æ¼ã€‚è€Œä¸”å¦‚æœå†…å­˜è¶Šç•Œå’Œç±»å‹ä¸åŒ¹é…ä¼šå¯¼è‡´é”™è¯¯ã€‚

##### uintptr

æ ¹æ®æ“ä½œç³»ç»Ÿä¸åŒï¼Œå­—èŠ‚æ•°ä¸ä¸€æ ·ã€‚åªæ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œå¯ä»¥ç”¨ unsafe è¿›è¡ŒåŠ å‡æ“ä½œã€‚

### ç»“æ„ä½“

> #### åŸºæœ¬
>

Golang ä¸­æ²¡æœ‰â€œç±»â€çš„æ¦‚å¿µï¼Œä¸é¢å‘å¯¹è±¡ï¼›ä¸æ”¯æŒé‡è½½è¿ç®—ç¬¦

##### å®šä¹‰

```go
type itab struct {
    hash  uint32    
    _     [4]byte // å¯ä»¥å®šä¹‰ç”¨äºå­—èŠ‚å¯¹é½çš„å˜é‡/ä¿ç•™ä»¥åç”¨
    fun   [1]uintptr 
}
```

å…è®¸å®šä¹‰å’Œä½¿ç”¨ç©ºç»“æ„ä½“ï¼Œå®ƒ0å†…å­˜å ç”¨ï¼Œåœ°å€å”¯ä¸€ï¼Œå¯ä½œä¸ºæ— æ•°æ®æ ‡è®°ã€‚

```go
set := make(map[string]struct{})
```

> ä½œç”¨ï¼šå ä½ç¬¦ã€ä¿¡å·é‡(å¹¶å‘)ã€ç©ºç»“æ„ä½“é€šé“ã€é›†åˆå€¼(å®ç°set)ã€æ¥å£å®ç°(æ–¹æ³•onlyï¼Œæ— æˆå‘˜å±æ€§ï¼Œ`type sth struct{}`)

##### èµ‹å€¼

```go
var p1 node
p1.x, p1.y = 5, 80
fmt.Println(p1) // {5 80}
fmt.Printf("%v %#v %T\n", p1, p1, p1)
// {5 80} main.node{x:5, y:80} main.node
```

å¸¦åˆå§‹åŒ–ï¼š

```go
p5 := node{58, 1437}
p6 := node{
    58,
    1437,
} // æ³¨æ„åŒºåˆ«ï¼šé€—å·ä¸å¦
fmt.Println(p5, p6)
```

æˆ–è€… newï¼Œä½†æ³¨æ„è¿™æ—¶å€™ç±»å‹æ˜¯æŒ‡é’ˆ

```go
var p2 = new(node)
p2.x, p2.y = 5, 80
fmt.Println(p2) // &{5 80}
fmt.Printf("%v %#v %T %T\n", p2, p2, p2, *p2)
// &{5 80} &main.node{x:5, y:80} *main.node main.node
```

æˆ–è€…æœ¬è´¨ newï¼š

```go
p3 := &node{}
p4 := &node{5, 80}
fmt.Println(p3, p4) // &{0 0} &{5 80}
```

ä¸æŒ‰é¡ºåº / partial èµ‹å€¼çš„è¯ï¼Œå¯ä»¥é™„ keyï¼›æŒ‡é’ˆæˆ–ä¸€èˆ¬éƒ½è¿™æ ·

```go
p7 := node{y: 6}
p8 := node{x: 7} // åª7ä¸è¡Œ
fmt.Println(p7, p8)
```

ç©ºç»“æ„ä½“ï¼šå¦‚ç”¨äº map value åš set

```go
a := struct{}{}
```

##### æƒé™

ç»“æ„ä½“ï¼ˆstructï¼‰çš„å­—æ®µå’Œæ–¹æ³•çš„è®¿é—®æ§åˆ¶æ˜¯é€šè¿‡å‘½åè§„åˆ™æ¥å®ç°çš„ï¼Œè€Œä¸æ˜¯é€šè¿‡å…³é”®å­—

ç»“æ„ä½“åç§°å•è¯é¦–å­—æ¯å¯ä»¥å¤§å†™ä¹Ÿå¯ä»¥å°å†™ï¼Œ å¤§å†™è¡¨ç¤ºè¿™ä¸ªç»“æ„ä½“æ˜¯å…¬æœ‰çš„ï¼Œ åœ¨å…¶ä»–çš„åŒ…é‡Œé¢å¯ä»¥ä½¿ç”¨ã€‚ å°å†™è¡¨ç¤ºè¿™ä¸ªç»“æ„ä½“æ˜¯ç§æœ‰çš„ï¼Œ åªæœ‰è¿™ä¸ªåŒ…é‡Œé¢æ‰èƒ½ä½¿ç”¨ (ä¹Ÿå¯ä»¥é—´æ¥è®¿é—®æˆ–åå°„)

å¯¹ç»“æ„ä½“çš„å­—æ®µï¼ŒåŒæ ·å¦‚æ­¤ã€‚å¦‚æœç»“æ„ä½“æœ¬èº«æ˜¯å°å†™å­—æ¯å¼€å¤´çš„ï¼Œé‚£ä¹ˆå³ä½¿å®ƒçš„å­—æ®µæˆ–æ–¹æ³•æ˜¯å¤§å†™å­—æ¯å¼€å¤´çš„ï¼Œä¹Ÿæ— æ³•åœ¨åŒ…å¤–éƒ¨è®¿é—®ï¼Œå› ä¸ºç»“æ„ä½“æœ¬èº«æ˜¯ç§æœ‰çš„

```go
// å®šä¹‰ä¸€ä¸ªå…¬æœ‰ç»“æ„ä½“
type Person struct {
    Name string // å…¬æœ‰å­—æ®µ
    age  int    // ç§æœ‰å­—æ®µ
}
```

å‡½æ•°å’Œå…¨å±€å˜é‡çš„å‘½ååŒæ ·éµå¾ªé¦–å­—æ¯å¤§å°å†™å†³å®šå¯è§æ€§çš„è§„åˆ™ï¼Œè¿™ä¸ç»“æ„ä½“çš„è§„åˆ™ä¸€è‡´ã€‚

##### æ–¹æ³•

ç»™ç±»å‹ï¼ˆç»“æ„ä½“ï¼Œ è‡ªå®šä¹‰ç±»å‹ï¼‰ å®šä¹‰æ–¹æ³•ã€‚ æ‰€è°“æ–¹æ³•å°±æ˜¯å®šä¹‰äº†æ¥æ”¶è€…çš„å‡½æ•°  

å®šä¹‰æ–¹æ³•ï¼šåœ¨å‚æ•°åˆ—è¡¨å‰ï¼Œæ·»åŠ  `(å˜é‡å ç»“æ„ä½“ç±»å‹)`ï¼Œå¯ä»¥æ˜¯æŒ‡é’ˆä¹Ÿå¯ä»¥ä¸æ˜¯ï¼ŒåŒºåˆ«åœ¨äºå¤åˆ¶ä¸å¦(ä¼ å€¼ä¼ å€)

é€šè¿‡è¿™ä¸ªåŠæ³•ï¼Œå…è®¸ç»•è¿‡ï¼šGo è¯­è¨€ä¸å…è®¸ç›´æ¥ä¸ºå†…ç½®ç±»å‹ï¼ˆå¦‚ `[]int`ï¼‰æˆ–æœªå‘½åçš„ç±»å‹ï¼ˆå¦‚ `[]int`ï¼‰å®šä¹‰æ–¹æ³•ã€‚ä½¿å¾—å¯ä»¥ä¸ºåŸºç¡€ç±»å‹å®šä¹‰æ–¹æ³•ï¼Œè§ä¸‹é¢çš„ä¾‹å­

éæœ¬åœ°ç±»å‹ä¸èƒ½å®šä¹‰æ–¹æ³•ï¼Œ ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬ä¸èƒ½ç»™åˆ«çš„åŒ…çš„ç±»å‹å®šä¹‰æ–¹æ³•  

> æ¥æ”¶è€…ä¸­çš„å‚æ•°å˜é‡ååœ¨å‘½åæ—¶ï¼Œ å®˜æ–¹å»ºè®®ä½¿ç”¨æ¥æ”¶è€…ç±»å‹åçš„ç¬¬ä¸€ä¸ªå°å†™å­—æ¯ï¼Œ è€Œä¸æ˜¯ selfã€ this ä¹‹ç±»çš„å‘½å(å°½ç®¡åŠŸèƒ½ä¸Šæ˜¯ this)ã€‚ ä¾‹å¦‚ï¼Œ Person ç±»å‹çš„æ¥æ”¶è€…å˜é‡åº”è¯¥å‘½åä¸º pï¼ŒConnector ç±»å‹çš„æ¥æ”¶è€…å˜é‡åº”è¯¥å‘½åä¸º c ç­‰

```go
type mint int
func (i mint) lowbit() mint {
	return i & -i
}
func (i *mint) double() {
	*i *= 2
}
func (i *mint) set(v int) {
	*i = mint(v)
}
// ...
var x mint = 10
fmt.Println(x.lowbit())
x.double()
x.set(580)
```

> åˆ†åˆ«å«åšå€¼æ¥å—è€…å’ŒæŒ‡é’ˆæ¥æ”¶è€…ã€‚

æ²¡æœ‰æ„é€ å‡½æ•°ï¼Œå¯ä»¥é€šè¿‡è¿”å›ç»“æ„ä½“çš„å‡½æ•°å®ç°ï¼š

```go
type unionFind struct {
    fa []int
}
func newUnionFind(n int) unionFind {
    fa := make([]int, n)
    for i := range fa {
        fa[i] = i
    }
    return unionFind{fa}
}
// ...
indices := newUnionFind(n + 2)
```

éœ€è¦åœ¨æ„é€ å‡½æ•°è°ƒç”¨æˆå‘˜æ–¹æ³•ï¼Œç­‰åŒäºåœ¨å‡½æ•°å¤–è°ƒç”¨å˜é‡çš„æ–¹æ³• (åŠ›æ‰£3408)

```go
func Constructor(tasks [][]int) TaskManager {
	task2user := make(map[int]int)
	prio2task := redblacktree.New[int, int]()
	this := TaskManager{task2user: task2user, prio2task: prio2task}
	for _, task := range tasks {
		userId, taskId, priority := task[0], task[1], task[2]
		this.Add(userId, taskId, priority)
	}
	return this
}
```

å› ä¸ºå¯ä»¥éšå¼ç±»å‹è½¬æ¢ï¼Œæ‰€ä»¥å¯¹ç»“æ„ä½“æŒ‡é’ˆå’Œå˜é‡éƒ½å¯ä»¥ç›¸äº’è°ƒç”¨å¯¹æ–¹çš„æ–¹æ³•ã€‚

> å¯¹æ¯ä¸ªç±»å‹ï¼Œéƒ½æœ‰æ–¹æ³•é›†ã€‚ç±»å‹æœ¬èº«æœ‰ä¸€ä¸ªæ–¹æ³•é›†ï¼Œå®ƒçš„æŒ‡é’ˆçš„æ–¹æ³•é›†æ˜¯å®ƒç‹¬æœ‰çš„åŠ ä¸Šç±»å‹æœ¬èº«çš„ã€‚

##### æ•°ç»„

```go
p := []Node{Node{13, 31}, Node{3, 0}, Node{0, 1}}
```

##### åŒ¿åå­—æ®µ

åªæœ‰æ•°æ®ç±»å‹ï¼Œæ— æˆå‘˜å±æ€§åç§°

åŒ¿åå­—æ®µé»˜è®¤é‡‡ç”¨ç±»å‹åä½œä¸ºå­—æ®µåï¼Œ ç»“æ„ä½“è¦æ±‚å­—æ®µåç§°å¿…é¡»å”¯ä¸€ï¼Œ å› æ­¤ä¸€ä¸ªç»“æ„ä½“ä¸­åŒç§ç±»å‹çš„åŒ¿åå­—æ®µåªèƒ½æœ‰ä¸€ä¸ª  

```go
type student struct {
	no string
	string
	int
}
s := student{"lr580", "AC", 580}
fmt.Println(s.no, s.string, s.int)
```

##### åµŒå¥—ç»“æ„ä½“

ä¸€ä¸ªç»“æ„ä½“ä¸­å¯ä»¥åµŒå¥—åŒ…å«å¦ä¸€ä¸ªç»“æ„ä½“æˆ–ç»“æ„ä½“æŒ‡é’ˆï¼Œå½“ç„¶ä¹Ÿå¯ä»¥æ˜¯åŒ¿åçš„

åµŒå¥—çš„å­—æ®µå”¯ä¸€çš„æ—¶å€™ï¼Œå¯ä»¥ç›´æ¥ç”¨å­—æ®µ

```go
type ns_pair struct {
	node
	student
}
// ...
ns := ns_pair{node{5, 80}, student{"lr580", "AC", 580}}
fmt.Println(ns, ns.x, ns.no, ns.node.x)
```

è®¿é—®ç»“æ„ä½“æˆå‘˜æ—¶ä¼šå…ˆåœ¨ç»“æ„ä½“ä¸­æŸ¥æ‰¾è¯¥å­—æ®µï¼Œ æ‰¾ä¸åˆ°å†å»åŒ¿åç»“æ„ä½“ä¸­æŸ¥æ‰¾

  ```go
  type xnode struct {
  	x int
  	node
  }
  // ...
  xn := xnode{580, node{5, 80}}
  fmt.Println(xn.x, xn.node.x) // 580 5
  ```

```go
type nodepair struct {
	p1 node
	p2 node
}
// ...
pr := nodepair{node{5, 80}, node{6, 91}}
fmt.Println(pr.p1.x, pr.p2.y)
```

##### ç»§æ‰¿

> æ”¯æŒç±»å‹åµŒå…¥ï¼Œè¿™æ˜¯ä¸€ç§å°†ä¸€ä¸ªç±»å‹åµŒå…¥åˆ°å¦ä¸€ä¸ªç±»å‹ä¸­ï¼Œä½¿å¾—è¢«åµŒå…¥ç±»å‹çš„æ–¹æ³•æˆä¸ºå¤–éƒ¨ç±»å‹çš„æ–¹æ³•çš„æœºåˆ¶ã€‚è¿™æä¾›äº†ä¸€ç§ç±»ä¼¼äºç»§æ‰¿çš„ä»£ç é‡ç”¨æ–¹å¼

åµŒå¥—åŒ¿åç»“æ„ä½“æŒ‡é’ˆï¼Œæ ¹æ®ä¸Šè¿°åµŒå¥—çš„ç©¿é€è§„åˆ™ï¼Œå¯ä»¥å®ç°ç»§æ‰¿çš„åŠŸèƒ½ã€‚æŒ‡é’ˆé¿å…ä¸å¿…è¦çš„å¤åˆ¶ã€‚

```go
type monster struct {
	name string
}

func (m *monster) enter() {
	fmt.Println(m.name, "comming!")
}

type goblin struct {
	weapon string
	*monster
}

func (g *goblin) attack() {
	fmt.Printf("goblin %s attack with %s\n", g.name, g.weapon)
}
// ...
m := &monster{"Gin"}
m.enter()
g := &goblin{"404 Not Found", &monster{"goroutine"}}
g.enter()
g.attack()
```

##### æ¯”è¾ƒ

æŒ‰å­—æ®µå£°æ˜é¡ºåºæ¯”è¾ƒå„å…³é”®å­—ã€‚æ‰€æœ‰å±æ€§å¯æ¯”è¾ƒï¼Œåˆ™ç»“æ„ä½“è‡ªåŠ¨å¯æ¯”è¾ƒã€‚

ä¸å¯æ¯”è¾ƒçš„å±æ€§ï¼šslice, map, function å’ŒåŒ…å«å®ƒä»¬çš„åµŒå¥—ç»“æ„ã€‚

æœ‰ä¸å¯æ¯”è¾ƒï¼Œå°±è¦è‡ªå·±å†™å‡½æ•°å»æ¯”è¾ƒ(ä¸å¯æ¯”è¾ƒçš„å¯ä»¥å€Ÿç”¨ `reflect.DeepEqual`)ï¼Œä¼ å…¥ä¿©æ¶æ„ä½“ï¼Œè¿”å› boolã€‚æˆ–è€…åºåˆ—åŒ–åæ¯”è¾ƒã€‚

##### Tag

Tag æ˜¯ç»“æ„ä½“çš„å…ƒä¿¡æ¯ï¼Œ å¯ä»¥åœ¨è¿è¡Œçš„æ—¶å€™é€šè¿‡åå°„çš„æœºåˆ¶è¯»å–å‡ºæ¥ã€‚ Tag 

åœ¨ç»“æ„ä½“å­—æ®µçš„åæ–¹å®šä¹‰ï¼Œ ç”±ä¸€å¯¹åå¼•å·åŒ…è£¹èµ·æ¥ï¼Œ å…·ä½“çš„æ ¼å¼å¦‚ä¸‹ï¼š

```
key1:"value1" key2:"value2"
```

ç»“æ„ä½“ tag ç”±ä¸€ä¸ªæˆ–å¤šä¸ªé”®å€¼å¯¹ç»„æˆã€‚ é”®ä¸å€¼ä½¿ç”¨å†’å·åˆ†éš”ï¼Œ å€¼ç”¨åŒå¼•å·æ‹¬èµ·æ¥ã€‚ åŒä¸€ä¸ªç»“æ„ä½“å­—æ®µå¯ä»¥è®¾ç½®å¤šä¸ªé”®å€¼å¯¹ tagï¼Œ ä¸åŒçš„é”®å€¼å¯¹ä¹‹é—´ä½¿ç”¨ç©ºæ ¼åˆ†éš”

ä¸ºç»“æ„ä½“ç¼–å†™ Tag æ—¶ï¼Œ å¿…é¡»ä¸¥æ ¼éµå®ˆé”®å€¼å¯¹çš„è§„åˆ™ã€‚ ç»“æ„ä½“æ ‡ç­¾çš„è§£æä»£ç çš„å®¹é”™èƒ½åŠ›å¾ˆå·®ï¼Œ ä¸€æ—¦æ ¼å¼å†™é”™ï¼Œ ç¼–è¯‘å’Œè¿è¡Œæ—¶éƒ½ä¸ä¼šæç¤ºä»»ä½•é”™è¯¯ï¼Œ é€šè¿‡åå°„ä¹Ÿæ— æ³•æ­£ç¡®å–å€¼ã€‚ ä¾‹å¦‚ä¸è¦åœ¨ key å’Œ value ä¹‹é—´æ·»åŠ ç©ºæ ¼ã€‚  

```go
type Person struct {
    Name    string `json:"name" validate:"required"`
    Address string `json:"address,omitempty"` // å­—æ®µå€¼ä¸ºç©ºæ—¶ä¸åŒ…å«è¯¥å­—æ®µ
}
```

> ç”¨é€”ï¼šç»™ç¬¬ä¸‰æ–¹åº“æŒ‡ç¤ºè¡Œä¸ºã€‚å¦‚ web, xmlã€‚

### æ¥å£

##### æ¦‚å¿µ

ä¸€ç§æŠ½è±¡æ•°æ®ç±»å‹ï¼Œ Golang ä¸­æ¥å£å®šä¹‰äº†å¯¹è±¡çš„è¡Œä¸ºè§„èŒƒï¼Œ åªå®šä¹‰è§„èŒƒä¸å®ç°ã€‚ æ¥å£ä¸­å®šä¹‰çš„è§„èŒƒç”±å…·ä½“çš„å¯¹è±¡æ¥å®ç°  

æ¥å£ï¼ˆinterfaceï¼‰ æ˜¯ä¸€ç»„å‡½æ•° method çš„é›†åˆï¼Œ Golang ä¸­çš„æ¥å£ä¸èƒ½åŒ…å«ä»»ä½•å˜é‡ï¼Œæ¥å£ä¸­çš„æ‰€æœ‰æ–¹æ³•éƒ½æ²¡æœ‰æ–¹æ³•ä½“ï¼Œå‚æ•°åˆ—è¡¨å’Œè¿”å›å€¼åˆ—è¡¨ä¸­çš„å‚æ•°å˜é‡åå¯ä»¥çœç•¥  

> æ¥å£åœ¨å‘½åæ—¶ï¼Œ ä¸€èˆ¬ä¼šå•è¯åé¢æ·»åŠ  erï¼Œ å¦‚æœ‰å†™æ“ä½œçš„æ¥å£å« Writerï¼Œ æœ‰å­—ç¬¦ä¸²åŠŸèƒ½çš„æ¥å£å« Stringer ç­‰
>

é‡‡ç”¨é¸­å­ç±»å‹çš„è®¾è®¡å“²å­¦ï¼šåªéœ€è¦ä¸€ä¸ªå˜é‡å«æœ‰æ¥å£ç±»å‹ä¸­çš„æ‰€æœ‰æ–¹æ³•ï¼Œ é‚£ä¹ˆè¿™ä¸ªå˜é‡å°±å®ç°äº†è¿™ä¸ªæ¥å£ï¼›ä¸€ä¸ªç»“æ„ä½“ä¹Ÿå¯ä»¥å®ç°å¤šä¸ªæ¥å£  

> æ¥å£å­˜å‚¨äº†ç±»å‹Typeå’Œå€¼Valueã€‚[åº•å±‚å®ç°](https://www.mianshiya.com/bank/1810641215871569922/question/1810649484082831361#heading-2)ï¼Œéç©ºæ¥å£ifaceå®ç°æ˜¯â‘ ä¸€ä¸ªæ–¹æ³•æŒ‡é’ˆè¡¨itabæŒ‡é’ˆ(å­˜å‚¨å®ç°çš„åœ°å€)å’Œå®é™…æ•°æ®unsafe.Pointerã€‚è‹¥ç©ºæ¥å£æ˜¯efaceï¼ŒæŒ‡é’ˆæ˜¯ `_type` ç±»å‹ã€‚å…¶ä¸­ï¼Œ`itab` æœ‰æ¥å£ç±»å‹ä¿¡æ¯(ç»“æ„ä½“)ï¼Œå®ç°æ¥å£çš„å…·ä½“ç±»å‹ä¿¡æ¯(`_type`)ï¼Œç±»å‹hashå€¼ï¼Œå®ç°æ¥å£æ–¹æ³•çš„å‡½æ•°åœ°å€ã€‚

> æ¥å£çš„é›¶å€¼ä¸º `nil`ï¼Œå½“ä¸”ä»…å½“æ¥å£çš„ `Type` å’Œ `Value` éƒ½ä¸º `nil` æ—¶ï¼Œæ¥å£æœ¬èº«æ‰æ˜¯ `nil`ã€‚
> å¦‚æœä¸€ä¸ªæ¥å£çš„ `Type` ä¸ä¸º `nil` è€Œ `Value` ä¸º `nil`ï¼Œåˆ™æ¥å£å¹¶ä¸ç­‰äº `nil`ã€‚ï¼ˆè¿™ç§æƒ…å†µå¸¸å‡ºç°åœ¨æ¥å£èµ‹å€¼æ—¶ï¼Œä¾‹å¦‚å°†ä¸€ä¸ªæŒ‡é’ˆå€¼ä¸º `nil` çš„ç»“æ„ä½“èµ‹å€¼ç»™æ¥å£å˜é‡æ—¶ï¼‰

> é€šè¿‡æ¥å£å®ç°äº†å¤šæ€Polymorphism,

##### å®šä¹‰

åŸºæœ¬ä½¿ç”¨ï¼š

- å¦‚æœç»“æ„ä½“ä¸­çš„æ–¹æ³•æ˜¯å€¼æ¥æ”¶è€…ï¼Œ é‚£ä¹ˆå®ä¾‹åŒ–åçš„ç»“æ„ä½“å€¼ç±»å‹å’Œç»“æ„ä½“æŒ‡é’ˆç±»å‹éƒ½å¯ä»¥èµ‹å€¼ç»™æ¥å£å˜é‡  
- å¦‚æœç»“æ„ä½“ä¸­çš„æ–¹æ³•æ˜¯æŒ‡é’ˆæ¥æ”¶è€…ï¼Œ é‚£ä¹ˆå®ä¾‹åŒ–åç»“æ„ä½“æŒ‡é’ˆç±»å‹éƒ½å¯ä»¥èµ‹å€¼ç»™æ¥å£å˜é‡ï¼Œç»“æ„ä½“å€¼ç±»å‹æ²¡æ³•èµ‹å€¼ç»™æ¥å£å˜é‡  

```go
type Bar interface {
	Test()
	FryRice()
}
type TesterBar struct{}
func (t TesterBar) Test() { // ä¸èƒ½ * å‚æ•°ï¼Œä¸ç„¶åªèƒ½æŒ‡é’ˆæ˜¯æ¥å£
	fmt.Println("ä¸€ä½æµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›äº†é…’å§")
}
func (t TesterBar) FryRice() {
	fmt.Println("æµ‹è¯•å·¥ç¨‹å¸ˆç‚¹äº†ä¸€ä»½ç‚’é¥­\næœåŠ¡å™¨å´©æºƒ")
}
func main() {
	var b Bar = TesterBar{}
	b.Test()
	b.FryRice()
}
```

ç”¨ä½œå‡½æ•°ï¼š

```go
func goTest(b Bar) {
	b.Test()
	b.FryRice()
}
// ...
var t TesterBar = TesterBar{}
goTest(t) // goTest(TesterBar{})
```

æ¥å£ç±»å‹ä¸èƒ½ç”¨æŒ‡é’ˆï¼Œæ¥å£æœ¬èº«å°±æ˜¯å¼•ç”¨ç±»å‹ã€‚

##### ç©ºæ¥å£

golang ä¸­çš„æ¥å£å¯ä»¥ä¸å®šä¹‰ä»»ä½•æ–¹æ³•ï¼Œ æ²¡æœ‰å®šä¹‰ä»»ä½•æ–¹æ³•çš„æ¥å£å°±æ˜¯ç©ºæ¥å£ã€‚ 

ç©ºæ¥å£è¡¨ç¤ºæ²¡æœ‰ä»»ä½•çº¦æŸï¼Œ å› æ­¤ä»»ä½•ç±»å‹å˜é‡éƒ½å¯ä»¥å®ç°ç©ºæ¥å£ã€‚

ç©ºæ¥å£åœ¨å®é™…é¡¹ç›®ä¸­ç”¨çš„æ˜¯éå¸¸å¤šçš„ï¼Œ ç”¨ç©ºæ¥å£å¯ä»¥è¡¨ç¤ºä»»æ„æ•°æ®ç±»å‹

```go
var x interface{}
x = "ç°åœ¨æ˜¯å­—ç¬¦ä¸²"
fmt.Println(x)
fmt.Printf("%T %v\n", x, x) // string ç°åœ¨æ˜¯å­—ç¬¦ä¸²
v := 580
x = v
fmt.Println(x)              // ä½†æ˜¯æ— æ³• x * 10
fmt.Printf("%T %v\n", x, x) // int 580
```

ä½¿ç”¨ç©ºæ¥å£å®ç°å¯ä»¥æ¥æ”¶ä»»æ„ç±»å‹çš„å‡½æ•°å‚æ•°  

```go
func print(x interface{}) {
	fmt.Println(x)
}
// ...
print(1. / 3)
```

ä½¿ç”¨ç©ºæ¥å£å®ç°å¯ä»¥ä¿å­˜ä»»æ„å€¼çš„å­—å…¸ï¼Œåˆ‡ç‰‡ï¼Œæ•°ç»„

```go
var lrInfo = map[string]interface{}{}
lrInfo["name"] = "lr580"
lrInfo["age"] = -580
lrInfo["alive"] = false
fmt.Println(lrInfo)
var slice = []interface{}{1 / 3, 1. / 3, false, "å¼ ä¸‰"}
fmt.Println(slice)
var arr = [3]interface{}{1 / 3, 1. / 3, false}
fmt.Println(arr)
fmt.Printf("%T %T %T", lrInfo, slice, arr)
// map[string]interface {} []interface {} [3]interface {}
```

##### ç±»å‹æ–­è¨€

ä¸€ä¸ªæ¥å£çš„å€¼ï¼ˆç®€ç§°æ¥å£å€¼ï¼‰ æ˜¯ç”±ä¸€ä¸ªå…·ä½“ç±»å‹å’Œå…·ä½“ç±»å‹çš„å€¼ä¸¤éƒ¨åˆ†ç»„æˆçš„ã€‚ è¿™ä¸¤éƒ¨åˆ†åˆ†åˆ«ç§°ä¸ºæ¥å£çš„åŠ¨æ€ç±»å‹å’ŒåŠ¨æ€å€¼  

ä½¿ç”¨ç±»å‹æ–­è¨€ï¼Œå¯¹å€¼ç±»å‹(int, struct)ä¼šå‘ç”Ÿæ‹·è´ï¼Œå¼•ç”¨ç±»å‹ä¸æ‹·è´ã€‚

å¯¹ `x.(T)`ï¼Œéæ¥å£ç±»å‹çš„xä¸èƒ½åšç±»å‹æ–­è¨€ã€‚T æ˜¯æ¥å£æˆ–(å®ç°xçš„)éæ¥å£

ä½¿ç”¨ç±»å‹æ–­è¨€ï¼Œè¿”å›å˜é‡å’Œæ–­è¨€å¸ƒå°”å€¼ã€‚

```go
var x interface{}
x = "è®©æˆ‘ä»¬è¯´ä¸­æ–‡"
v, ok := x.(string) // åˆ¤æ–­å¤±è´¥ä¸è¡Œï¼Œè¿™é‡Œåªèƒ½ stringï¼Œä¼šç¼–è¯‘é”™è¯¯
fmt.Println(v, ok)
fmt.Printf("%T %T", v, ok) // string bool
```

å¯ä»¥å•è¿”å›å€¼ï¼Œå¯èƒ½panic

```go
v := x.(string)
```



å¦‚æœæœªçŸ¥ï¼Œå¯ä»¥ç”¨ switch

```go
func typeof(x interface{}) {
	switch v := x.(type) {
	case int:
		fmt.Println("int")
	case string:
		fmt.Println("string")
	default:
		fmt.Println("unknown", v) // ä¸€å®šè¦ç”¨åˆ°vä¸ç„¶æŠ¥é”™
	}
}
// ...
typeof(int64(2))
```

##### æ¥å£åµŒå¥—

```go
type fooer interface {
	foo()
}
type barer interface {
	bar()
}
type foobarer interface {
	fooer
	barer
}
type foobar struct{}
func (f foobar) foo() {
	fmt.Println("foo")
}
func (f foobar) bar() {
	fmt.Println("bar")
}
// ...
var fb foobarer
fb = foobar{}
fb.foo()
fb.bar()
```

### æ³›å‹

##### ç»“æ„ä½“

```go
package main

import "fmt"

type Set[T comparable] struct {
	data map[T]struct{}
}

func NewSet[T comparable]() *Set[T] { // æ„é€ å‡½æ•°
	return &Set[T]{data: make(map[T]struct{})}
}
func (s *Set[T]) Add(value T) {
	s.data[value] = struct{}{}
}
func (s *Set[T]) Remove(value T) {
	delete(s.data, value)
}
func (s *Set[T]) Contains(value T) bool {
	_, exists := s.data[value]
	return exists
}
func (s *Set[T]) Size() int {
	return len(s.data)
}
func (s *Set[T]) Elements() []T {
	elements := make([]T, 0, len(s.data))
	for key := range s.data {
		elements = append(elements, key)
	}
	return elements
}

func main() {
	s := NewSet[int]()
	s.Add(1)
	s.Add(2)
	s.Add(1)                   // é‡å¤å…ƒç´ 
	fmt.Println(s.Contains(1)) // true
	fmt.Println(s.Contains(3)) // false
	fmt.Println(s.Elements())  // [1 2]
	s.Remove(1)
	fmt.Println(s.Contains(1)) // false
}
```



##### å‡½æ•°

```go
package main

import "fmt"

// æ³›å‹å‡½æ•°ï¼šæ‰“å°ä»»æ„ç±»å‹çš„åˆ‡ç‰‡
func PrintSlice[T any](s []T) {
    for _, v := range s {
        fmt.Print(v, " ")
    }
    fmt.Println()
}

func main() {
    // å¯ä»¥ç”¨äºå­—ç¬¦ä¸²åˆ‡ç‰‡
    strSlice := []string{"Hello", "World"}
    PrintSlice(strSlice) // è¾“å‡º: Hello World 
    // è¿˜å¯ä»¥ç”¨äºæµ®ç‚¹æ•°åˆ‡ç‰‡
    floatSlice := []float64{1.1, 2.2, 3.3}
    PrintSlice(floatSlice) // è¾“å‡º: 1.1 2.2 3.3 
}
```

```go
func permuteFunc[T comparable](nums []T, f func([]T)) 
```

## æµç¨‹æ§åˆ¶

### æ¡ä»¶åˆ¤æ–­/å¾ªç¯

#### if

`if` ç­‰è¯­å¥çš„ä»£ç å—å¿…é¡»ä½¿ç”¨å¤§æ‹¬å· `{}` åŒ…è£¹ï¼Œå³ä½¿ä»£ç å—ä¸­åªæœ‰ä¸€è¡Œä»£ç 

```go
score := 30
if score%2 == 0 {
    fmt.Println("even")
} else if score%2 == 1 {
    fmt.Println("odd")
} else {
    fmt.Println("inPossible")
}
```

å¯ä»¥æ·»åŠ èµ‹å€¼è¯­å¥ï¼Œå˜é‡å±€éƒ¨ä½œç”¨åŸŸï¼Œif å¤–ä¸å¯ç”¨

```go
score := 30
if score := 31; score%2 == 1 { // æ³¨æ„ä½œç”¨åŸŸï¼Œè¯¥ score æ˜¯ifå¤–å¤±æ•ˆ=
    fmt.Println("no even")
}
fmt.Println(score) // 30
```

#### for

##### åŸºæœ¬

ä¸‰ç§åŸºæœ¬å†™æ³•

```go
for i := 0; i < 5; i++ {
    fmt.Println(i)
}
i := 0
for ; i < 3; i++ {
    fmt.Println(i)
}
for i < 5 {
    fmt.Println("i=", i)
    i++
}
```

Go è¯­è¨€ä¸­**æ²¡æœ‰ while è¯­å¥**ï¼Œå¯ä»¥ç”¨ for ä»£æ›¿

æ­»å¾ªç¯ï¼Œcontinue break

```go
j := 0
for { // æˆ– for ;; {
    j++
    if j%2 == 0 {
        continue
    }
    if j >= 5 {
        break
    }
    fmt.Println(j)
}
```

##### range

for range éå†æ•°ç»„ã€ åˆ‡ç‰‡ã€ å­—ç¬¦ä¸²ã€ map åŠé€šé“ï¼ˆchannelï¼‰  

è¿”å›å€¼ï¼š

- æ•°ç»„ã€ åˆ‡ç‰‡ã€ å­—ç¬¦ä¸²è¿”å›ç´¢å¼•å’Œå€¼ã€‚
- è¿”å›é”®å’Œå€¼ã€‚
- é€šé“ï¼ˆchannelï¼‰ åªè¿”å›é€šé“å†…çš„å€¼

ä»0æšä¸¾åˆ°n-1ï¼š(Go 1.22)

```go
for i := range n {
    fmt.Println(i)
}
```

```go
s := "Goä¹°å–" // ä¸­æ–‡å­—ç¬¦æ­£å¸¸è¾“å‡º
for i, v := range s {
    fmt.Printf("index:%d, value:%c\n", i, v)
} // index = 0, 1, 2, 5 (ä¸€ä¸ªä¸­æ–‡3ä¸ªå­—ç¬¦)
```

Go 1.4+ (s æ˜¯æ•°ç»„/sliceï¼Œvå–ä¸‹æ ‡ï¼›æ˜¯ map éšæœºåºvå– key)

```go
for v := range s {
    fmt.Printf("value:%c\n", v)
}
```

æ˜¯å¤åˆ¶ä¸€ä»½ï¼Œå¯¹åˆ‡ç‰‡ä¿®æ”¹vè¿™æ ·æ— æ³•ä¿®æ”¹æœ¬èº«ã€‚

range åœ¨ for å¼€å§‹æ—¶è®¡ç®—ä¸€æ¬¡ï¼Œæ‰€ä»¥å¦‚æœ for é‡Œå¢åˆ sliceï¼Œä¸ä¼šå½±å“å¾ªç¯ã€‚ä½†æ˜¯ mapä¼šå½±å“ã€‚

å¯ä»¥ä¸æ¥æ”¶å˜é‡

```go
m := []int{1, 1}
for range m {
    fmt.Println("Hello, World!")
}
```



##### å¤šé‡å¾ªç¯è·³å‡º

break

```go
label1:
	for i := 0; i < 5; i++ {
		for j := 0; j < 5; j++ {
			if i*j >= 8 {
				break label1
			}
			fmt.Println(i, j, i*j)
		}
	}
```

continueï¼šå¯¹æ ‡ç­¾æ‰€åœ¨çš„å¾ªç¯å¼€å¯ä¸‹ä¸€è½®

```go
label2:
for i := 0; i < 5; i++ {
    for j := 0; j < 5; j++ {
        for k := 0; k < 5; k++ {
            if i+j+k > 8 {
                fmt.Println(i, j, k, i+j+k)
                continue label2 // è¿›å…¥ i++ çš„æœ€å¤–å±‚
            }
        }
    }
}
```

switch é‡Œè·³å‡º for éœ€è¦ç”¨è¿™ç§åŠæ³•ã€‚

#### switch

`switch` è¯­å¥ä¸éœ€è¦æ˜¾å¼ä½¿ç”¨ `break`ï¼Œå› ä¸º Go çš„ `switch` é»˜è®¤åªä¼šæ‰§è¡ŒåŒ¹é…çš„ `case` å—ï¼Œç„¶åè‡ªåŠ¨è·³å‡º `switch` è¯­å¥

```go
s := "å“ˆå“ˆ"
switch s { // è¾“å‡ºhahaï¼Œä¸ç”¨break
case "å“ˆ":
    fmt.Println("ha") // æ— éœ€å¤§æ‹¬å·ï¼Œä¸€è¡Œåˆ°å¤šè¡Œéƒ½è¡Œ
case "å“ˆå“ˆ":
    fmt.Println("haha")
case "å“ˆå“ˆå“ˆ":
    fmt.Println("hahaha")
default:
    fmt.Println("Everything is set.")
}
```

å¤šå€¼ï¼š

```go
switch m := 3; m { // å¯ä»¥ç¼©å†™è·Ÿ if ä¸€æ ·
case 1, 3, 5, 7, 8, 10, 12:
    fmt.Println("31 days")
case 4, 6, 9, 11:
    fmt.Println("30 days")
default:
    fmt.Println("28/29 days")
}
```

åˆ†æ”¯è¿˜å¯ä»¥ä½¿ç”¨è¡¨è¾¾å¼ï¼Œ è¿™æ—¶å€™ switch è¯­å¥åé¢ä¸éœ€è¦å†è·Ÿåˆ¤æ–­å˜é‡  

```go
a := 1
b := 2
switch {
case a < b || a > b:
    fmt.Println("a != b")
case a == b:
    fmt.Println("a == b")
}
```

fallthrough è¯­æ³•å¯ä»¥æ‰§è¡Œæ»¡è¶³æ¡ä»¶çš„ case çš„ä¸‹ä¸€ä¸ª caseï¼Œ æ˜¯ä¸ºäº†å…¼å®¹ C è¯­è¨€ä¸­çš„ case  (å¯ä»¥ä¸€ç›´ fallï¼Œfall ä¸€æ¬¡è·³ä¸€æ¬¡)

```go
s = "a"
switch {
case s == "a":
    fmt.Println("a")
    fallthrough
case s == "b":
    fmt.Println("b")
case s == "c":
    fmt.Println("c")
default:
    fmt.Println("...")
} // è¾“å‡º a,b
```

break ç”¨äºè·³å‡ºå½“å‰ case å‰©ä¸‹è¿˜æ²¡èµ°å®Œçš„éƒ¨åˆ†

```go
for num := 0; num < 5; num++ { // è¾“å‡ºä¸€äºŒä¸‰ï¼Œ break ä¸è·³å‡º for
    switch num {
    case 1:
        fmt.Println("ä¸€")
    case 2:
        fmt.Println("äºŒ")
        break // æå‰é€€å‡º switch
        fmt.Println("è¿™è¡Œä¸ä¼šæ‰§è¡Œ")
    case 3:
        fmt.Println("ä¸‰")
    }
}
```



#### goto

```go
	n := 10
	if n > 5 {
		goto label3
	}
	fmt.Println("No going here")
label3:
	fmt.Println("ends here")
```

### å‡½æ•°

Go è¯­è¨€ä¸­æ”¯æŒï¼š å‡½æ•°ã€ åŒ¿åå‡½æ•°å’Œé—­åŒ…  

#### å¸¸è§„

##### å®šä¹‰

å‡½æ•°å¤–è¾¹çš„æ¯ä¸ªè¯­å¥éƒ½å¿…é¡»ä»¥å…³é”®å­—å¼€å§‹ï¼ˆvarã€ constã€ func ç­‰ï¼‰  

å‡½æ•°å¯ä»¥ä¸æŒ‰é¡ºåºï¼Œå³ä¸Šé¢çš„å‡½æ•°è°ƒç”¨ä¸‹é¢çš„å‡½æ•°

> æ¨èæŒ‰å¤§é©¼å³°å‘½åï¼Œè¡¨è¾¾åŠ¨è¯(çŸ­è¯­)ï¼Œé¿å…ä¸‹åˆ’çº¿

**ä¸æ”¯æŒé»˜è®¤å‚æ•°**

> ç†ç”±ï¼šç¼–è¯‘æ—¶å›ºå®šï¼Œå‡å°‘é¢å¤–æ£€æŸ¥ã€‚

å‡½æ•°åï¼š ç”±å­—æ¯ã€ æ•°å­—ã€ ä¸‹åˆ’çº¿ç»„æˆã€‚ ä½†å‡½æ•°åçš„ç¬¬ä¸€ä¸ªå­—æ¯ä¸èƒ½æ˜¯æ•°å­—ã€‚ åœ¨åŒä¸€ä¸ªåŒ…å†…ï¼Œ å‡½æ•°åä¹Ÿç§°ä¸èƒ½é‡åã€‚

å‚æ•°åä¸å¯çœç•¥ã€‚å¯ä»¥ä¸º `_`ã€‚

è¿”å›å€¼ï¼šè¿”å›å€¼ç”±è¿”å›å€¼å˜é‡å’Œå…¶å˜é‡ç±»å‹ç»„æˆï¼Œ ä¹Ÿå¯ä»¥åªå†™è¿”å›å€¼çš„ç±»å‹ï¼Œ å¤šä¸ªè¿”å›å€¼å¿…é¡»ç”¨()åŒ…è£¹ï¼Œ å¹¶ç”¨,åˆ†éš”ï¼Œæ²¡æœ‰å¯ä»¥ä¸å†™

```go
func f0() {
	fmt.Println("è®©æˆ‘æŒ£å¼€ è®©æˆ‘æ˜ç™½ æ”¾æ‰‹ä½ çš„DL")
}
```

```go
func add(x int, y int) int {
	return x + y
}
```

```go
func swap(x int, y int) (int, int) {
	return y, x
}
```

å‡½æ•°çš„å‚æ•°ä¸­å¦‚æœç›¸é‚»å˜é‡çš„ç±»å‹ç›¸åŒï¼Œ åˆ™å¯ä»¥çœç•¥ç±»å‹ï¼Œ   

```go
func intSum(x, y int) int {
	return x + y
}
```

> æ³¨æ„æ•°ç»„ä¼ å…¥å‡½æ•°æ˜¯ä¼ å€¼å¤åˆ¶ã€‚åˆ‡ç‰‡ä¸æ˜¯ã€‚

##### è°ƒç”¨

```go
func main() {
	f0()
	fmt.Println(add(1437, 581))
	a, b := 5, 80
	a, b = swap(a, b)
	fmt.Println(a, b)
}
```

è¿”å›ä¸¤ä¸ªå€¼ï¼Œå¯ä»¥ç›´æ¥ä¼ å…¥éœ€è¦ä¸¤ä¸ªå€¼çš„å‡½æ•°ï¼Œå…¶ä»–åŒç†

```go
fmt.Println(intSum(calc(5, 3))) //ä¸¤ä¸ªè‡ªå®šä¹‰å‡½æ•°éƒ½ä¼ å…¥ä¸¤ä¸ªintå‚æ•°
```

##### å¯å˜å‚æ•°

å¯å˜å‚æ•°é€šå¸¸è¦ä½œä¸ºå‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°ï¼Œä½œä¸ºä¸€ä¸ªåˆ‡ç‰‡ä½¿ç”¨

```go
func powSum(p int, x ...int) int64 {
	var ans int64
	for _, v := range x {
		var vp int64 = 1
		for i := 1; i <= p; i++ {
			vp *= int64(v)
		}
		ans += vp
	}
	return ans
} // fmt.Println(powSum(2, 3, 4)) // 3^2+4^2
```

å¯ä»¥å®ç°ç»“æ„ä½“é€‰é¡¹æ¨¡å¼ã€‚(è§åæ–‡)

å¯¹ slice ç­‰ä¹Ÿå¯ä»¥ä¼ å…¥å¯å˜å‚ï¼Œå¦‚ `powSum(arr...)`ã€‚è¯¥`...`å±•å¼€è¯­æ³•åªèƒ½ç”¨äºå¯å˜å‚æ•°å‡½æ•°

##### è¿”å›å€¼

å¯ä»¥æœ‰å¤šä¸ªè¿”å›å€¼ã€‚

é™¤äº†è·Ÿä¸Šæ–‡ä¸€æ ·ç›´æ¥å¸¸è§„çš„è¿”å›å€¼ï¼Œè¿˜å¯ä»¥å‡½æ•°å®šä¹‰æ—¶å¯ä»¥ç»™è¿”å›å€¼å‘½åï¼Œ å¹¶åœ¨å‡½æ•°ä½“ä¸­ç›´æ¥ä½¿ç”¨è¿™äº›å˜é‡ï¼Œ æœ€åé€šè¿‡ return å…³é”®å­—è¿”å›  

```go
func calc(x, y int) (sum, sub int) {
    sum = x + y
    sub = x - y
    return
}
/*æ­¤æ—¶å¦‚æœ return æœ‰å€¼ï¼Œè¿™ä¸ªå€¼ä¼šèµ‹å€¼ç»™è¿”å›å€¼å˜é‡
func a() (x int) {
	return 3
}ï¼Œè°ƒç”¨å¾—åˆ°è¿˜æ˜¯3*/
```

```go
fmt.Println(calc(5, 3))
```

å¯ä»¥æ˜¯åˆ‡ç‰‡ï¼Œå¤šä¸ªåˆ‡ç‰‡

```go
func f(s string) ([]int64, []int64) {
    n := len(s)
    to0 := make([]int64, n)
    to1 := make([]int64, n)
    // ...
    return to0, to1
}
```



#### é«˜é˜¶

å‚æ•°æˆ–è¿”å›å€¼æ˜¯å‡½æ•°çš„å‡½æ•°ã€‚

##### å‡½æ•°å˜é‡

```go
type dbFunc func(int, int) int
func add(x, y int) int {
	return x + y
}
func sub(x, y int) int {
	return x - y
}
```

```go
var f dbFunc
f = add
fmt.Println(f(5, 3))
f = sub
fmt.Println(f(5, 3))
```

```go
fmt.Printf("%T -- %T\n", add, f) 
//func(int, int) int -- main.dbFunc
```

##### é«˜é˜¶å‡½æ•°

å‡½æ•°ä½œä¸ºå‚æ•°ï¼š

```go
func add(x, y int) int {
	return x + y
}
//type dbFunc func(int, int) int
//func f2(x, y int, f dbFunc) int {
func f2(x, y int, f func(int, int) int) int {
	return f(x, y)
}
```

```go
fmt.Println(f2(5, 3, add))
```

å‡½æ•°åšè¿”å›å€¼ï¼š

```go
func getOp(op string) func(int, int) int { // æˆ– dbFunc
	if op == "+" {
		return add
	}
	return sub
}
```

```go
var op = getOp("+")
fmt.Println(op(5, 3))
```

##### åŒ¿åå‡½æ•°

```go
ff := func(x, y int) int {
    return x * y
}
fmt.Println(ff(8, 9))
func(x, y int) {
    fmt.Println(x * y)
}(10, 11)
```

é€’å½’å‡½æ•°ï¼šå…ˆå£°æ˜å†å®šä¹‰

```go
var dfs func(u int)
dfs = func(u int) {
    // ...
    dfs(v)
}
```

#### é—­åŒ…

é—­åŒ…Closureæ˜¯å¯ä»¥å¼•ç”¨å¤–éƒ¨ä½œç”¨åŸŸå˜é‡çš„å‡½æ•°ã€‚

> å¯ä»¥ç†è§£æˆâ€œå®šä¹‰åœ¨ä¸€ä¸ªå‡½æ•°å†…éƒ¨çš„å‡½æ•°â€œã€‚ åœ¨æœ¬è´¨ä¸Šï¼Œ é—­åŒ…æ˜¯å°†å‡½æ•°å†…éƒ¨å’Œå‡½æ•°å¤–éƒ¨è¿æ¥èµ·æ¥çš„æ¡¥æ¢ã€‚ æˆ–è€…è¯´æ˜¯å‡½æ•°å’Œå…¶å¼•ç”¨ç¯å¢ƒçš„ç»„åˆä½“  

```go
package main

import "fmt"

func adder() func(int) int {
	var x int
	return func(y int) int {
		x += y
		return x
	}
}
func main() {
	var f = adder()
	fmt.Println(f(10)) //10
	fmt.Println(f(20)) //30
	f1 := adder()
	fmt.Println(f1(40)) //40
}
```

> åŠŸèƒ½ï¼šä¼ªå…¨å±€å˜é‡ã€å‡½æ•°å·¥å‚ã€è£…é¥°å™¨æ¨¡å¼ã€å›è°ƒå‡½æ•°ã€å¹¶å‘ã€ä¿å­˜ä¸­é—´çŠ¶æ€(è®¡æ•°å™¨)ã€‚

å˜é‡ f æ˜¯ä¸€ä¸ªå‡½æ•°å¹¶ä¸”å®ƒå¼•ç”¨äº†å…¶å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„ x å˜é‡ï¼Œ æ­¤æ—¶ f å°±æ˜¯ä¸€ä¸ªé—­åŒ…ã€‚ åœ¨ f çš„ç”Ÿå‘½å‘¨æœŸå†…ï¼Œ å˜é‡ x ä¹Ÿä¸€ç›´æœ‰æ•ˆ  

ç®€åŒ–ï¼š

```go
func adder2(x int) func(int) int {
	return func(y int) int {
		x += y
		return x
	}
}
func t2() {
	var f = adder2(10)
	fmt.Println(f(10)) //20
	fmt.Println(f(20)) //40
	fmt.Println(f(30)) //70
	f1 := adder2(20)
	fmt.Println(f1(40)) //60
	fmt.Println(f1(50)) //110
}
```

ä¾‹å­2ï¼š

```go
func makeSuffixFunc(suffix string) func(string) string {
	return func(name string) string {
		if !strings.HasSuffix(name, suffix) {
			return name + suffix
		}
		return name
	}
}
```

```go
jpgFunc := makeSuffixFunc(".jpg")
txtFunc := makeSuffixFunc(".txt")
fmt.Println(jpgFunc("test")) //test.jpg
fmt.Println(txtFunc("test")) //test.txt
```

##### é€‰é¡¹æ¨¡å¼

ä¸€ç§è®¾è®¡æ¨¡å¼ã€‚Option Patternï¼Œé€‰é¡¹æ¨¡å¼ï¼ˆä¹Ÿç§°ä¸ºåŠŸèƒ½é€‰é¡¹æ¨¡å¼ï¼‰æ˜¯ä¸€ç§åˆ›å»ºå‹è®¾è®¡æ¨¡å¼ã€‚è¿™æ˜¯ç”±äº go æ²¡æœ‰é»˜è®¤å‚æ•°å’Œå‡½æ•°é‡è½½ï¼Œè€Œé‡‡å–çš„ä¸€ç§æ›¿ä»£æ–¹æ³•ã€‚

1. é¦–å…ˆæ„é€ ä¸€ä¸ªç»“æ„ä½“ï¼Œå­˜å‚¨æ‰€æœ‰å‡½æ•°é»˜è®¤å‚æ•°ã€‚
2. å®šä¹‰ä¼ å…¥è¯¥ç»“æ„ä½“æŒ‡é’ˆä½œä¸ºå‚æ•°çš„å‡½æ•°æŒ‡é’ˆä¸ºé€‰é¡¹(Option)ã€‚
3. å¯¹æ¯ä¸ªå‚æ•°(ç»“æ„ä½“æˆå‘˜å±æ€§)ï¼Œè®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒè¿”å›ä¸€ä¸ªé—­åŒ…ï¼Œå³ Optionï¼Œå®ƒçš„ä½œç”¨æ˜¯ï¼Œä¼ å…¥å‡½æ•°å‚æ•°ï¼Œè¯¥å‚æ•°èµ‹å€¼ç»™é—­åŒ…é‡Œçš„ç»“æ„ä½“æŒ‡é’ˆæˆå‘˜å±æ€§ã€‚
4. ç°åœ¨è®¾è®¡å‡½æ•°æœ¬ä½“ï¼Œå®ƒä¼ å…¥å¯å˜å‚æ•°ï¼Œæ¯ä¸ªå‚æ•°æ˜¯ Optionï¼Œè¿”å›ç»“æ„ä½“æŒ‡é’ˆã€‚å‡½æ•°ä½“å†…é¦–å…ˆåˆ›å»ºä¸€ä¸ªç»“æ„ä½“ï¼Œèµ‹å€¼æ‰€æœ‰æˆå‘˜å±æ€§ä¸ºé»˜è®¤å€¼ã€‚æ¥ä¸‹æ¥æ‰§è¡Œæ¯ä¸ªé—­åŒ…ï¼Œä¿®æ”¹è¯¥ç»“æ„ä½“ï¼Œæœ€åè¿”å›è¯¥ç»“æ„ä½“ã€‚
5. è°ƒç”¨æ—¶ï¼Œå¦‚æœæˆ‘éœ€è¦æ”¹å˜æŸä¸ªé»˜è®¤å‚æ•°ï¼Œæˆ‘å°±ä¼ å…¥è¯¥é—­åŒ…(åˆ©ç”¨ç¬¬ä¸‰æ­¥è®¾è®¡çš„å‡½æ•°ä½œä¸ºä¼ å…¥å‡½æ•°çš„å‚æ•°)

```go
package main

import (
	"fmt"
	"time"
)

// 1. å®šä¹‰æˆ‘ä»¬è¦é…ç½®çš„å¯¹è±¡ - ç®€å•çš„HTTPå®¢æˆ·ç«¯é…ç½®
type HTTPClientConfig struct {
	Timeout    time.Duration // è¯·æ±‚è¶…æ—¶æ—¶é—´
	UserAgent  string        // ç”¨æˆ·ä»£ç†å­—ç¬¦ä¸²
	MaxRetries int           // æœ€å¤§é‡è¯•æ¬¡æ•°
}

// 2. å®šä¹‰é€‰é¡¹å‡½æ•°ç±»å‹
type Option func(*HTTPClientConfig)

// 3. åˆ›å»ºé€‰é¡¹å‡½æ•°

// WithTimeout è®¾ç½®è¯·æ±‚è¶…æ—¶æ—¶é—´
func WithTimeout(timeout time.Duration) Option {
	return func(c *HTTPClientConfig) {
		c.Timeout = timeout
	}
}

// WithUserAgent è®¾ç½®ç”¨æˆ·ä»£ç†
func WithUserAgent(ua string) Option {
	return func(c *HTTPClientConfig) {
		c.UserAgent = ua
	}
}

// WithMaxRetries è®¾ç½®æœ€å¤§é‡è¯•æ¬¡æ•°
func WithMaxRetries(retries int) Option {
	return func(c *HTTPClientConfig) {
		c.MaxRetries = retries
	}
}

// 4. æ„é€ å‡½æ•°
func NewHTTPClientConfig(options ...Option) *HTTPClientConfig {
	// è®¾ç½®é»˜è®¤å€¼
	config := &HTTPClientConfig{
		Timeout:    10 * time.Second, // é»˜è®¤è¶…æ—¶10ç§’
		UserAgent: "Go-HTTP-Client", // é»˜è®¤ç”¨æˆ·ä»£ç†
		MaxRetries: 3,               // é»˜è®¤é‡è¯•3æ¬¡
	}

	// åº”ç”¨æ‰€æœ‰ä¼ å…¥çš„é€‰é¡¹
	for _, option := range options {
		option(config)
	}

	return config
}

// 5. æ‰“å°é…ç½®çš„è¾…åŠ©å‡½æ•°
func printConfig(c *HTTPClientConfig) {
	fmt.Println("HTTPå®¢æˆ·ç«¯é…ç½®:")
	fmt.Printf("è¶…æ—¶æ—¶é—´: %v\n", c.Timeout)
	fmt.Printf("ç”¨æˆ·ä»£ç†: %s\n", c.UserAgent)
	fmt.Printf("æœ€å¤§é‡è¯•æ¬¡æ•°: %d\n", c.MaxRetries)
	fmt.Println("----------------------")
}

func main() {
	// åœºæ™¯1: ä½¿ç”¨å…¨éƒ¨é»˜è®¤é…ç½®
	fmt.Println("åœºæ™¯1: é»˜è®¤é…ç½®")
	defaultConfig := NewHTTPClientConfig()
	printConfig(defaultConfig)

	// åœºæ™¯2: è‡ªå®šä¹‰è¶…æ—¶æ—¶é—´
	fmt.Println("åœºæ™¯2: è‡ªå®šä¹‰è¶…æ—¶æ—¶é—´")
	customTimeout := NewHTTPClientConfig(
		WithTimeout(30 * time.Second),
	)
	printConfig(customTimeout)

	// åœºæ™¯5: ç»„åˆå¤šä¸ªé…ç½®
	fmt.Println("åœºæ™¯5: ç»„åˆå¤šä¸ªé…ç½®")
	combinedConfig := NewHTTPClientConfig(
		WithTimeout(5 * time.Second),
		WithUserAgent("API-Client/2.0"),
		WithMaxRetries(2),
	)
	printConfig(combinedConfig)
}
```



#### defer

##### åŸºæœ¬ä½¿ç”¨

defer è¯­å¥ä¼šå°†å…¶åé¢è·Ÿéšçš„è¯­å¥è¿›è¡Œå»¶è¿Ÿå¤„ç†ã€‚ åœ¨ defer å½’å±çš„å‡½æ•°å³å°†è¿”å›æ—¶ï¼Œ å°†å»¶è¿Ÿå¤„ç†çš„è¯­å¥æŒ‰ defer å®šä¹‰çš„é€†åºè¿›è¡Œæ‰§è¡Œï¼Œ ä¹Ÿå°±æ˜¯è¯´ï¼Œ å…ˆè¢« defer çš„è¯­å¥æœ€åè¢«æ‰§è¡Œï¼Œ æœ€åè¢« defer çš„è¯­å¥ï¼Œ æœ€å…ˆè¢«æ‰§è¡Œã€‚  

èƒ½éå¸¸æ–¹ä¾¿çš„å¤„ç†èµ„æºé‡Šæ”¾é—®é¢˜ã€‚ æ¯”å¦‚ï¼šèµ„æºæ¸…ç†ã€ æ–‡ä»¶å…³é—­ã€ è§£é”åŠè®°å½•æ—¶é—´  

```go
fmt.Println("start")
defer fmt.Println(1)
defer fmt.Println(2)
defer fmt.Println(3)
fmt.Println("end") // è¾“å‡º start end 3 2 1
```

> defer å¯ä»¥åœ¨åµŒå¥—å‡½æ•°ä¸­ä½¿ç”¨ï¼Œç”šè‡³åœ¨åµŒå¥—çš„ defer ä¸­ï¼ŒåŒç†åè¿›å…ˆå‡º

##### å˜é‡å¿«ç…§

`defer` çš„å˜é‡å¿«ç…§æ˜¯æŒ‡åœ¨ `defer` è¯­å¥å®šä¹‰æ—¶æ‰€æ•è·çš„å˜é‡çš„çŠ¶æ€ã€‚ä½†æœ‰äº›æƒ…å†µä¸‹ï¼Œ`defer` è¯­å¥ä¸­çš„å˜é‡å¿«ç…§å¯èƒ½ä¼šå¤±æ•ˆï¼Œå¯¼è‡´ä¸å¦‚é¢„æœŸé‚£æ ·è¡Œä¸ºï¼Œå¦‚ä¸‹

- åŒ¿åå‡½æ•°é—­åŒ…ï¼Œå½“ `defer` è¯­å¥ä¸­ä½¿ç”¨çš„åŒ¿åå‡½æ•°æ•è·äº†å¤–éƒ¨å˜é‡æ—¶ã€‚å¦‚æœå˜é‡çš„å€¼åœ¨ `defer` è¯­å¥å®šä¹‰åå‘ç”Ÿå˜åŒ–ï¼Œ`defer` æ‰§è¡Œæ—¶ä¼šä½¿ç”¨å˜åŒ–åçš„å€¼ã€‚
- å¼•ç”¨ç±»å‹ï¼Œå½“ `defer` å¼•ç”¨æŒæœ‰å¼•ç”¨ç±»å‹çš„å˜é‡ï¼ˆå¦‚æŒ‡é’ˆã€åˆ‡ç‰‡ã€æ˜ å°„ã€é€šé“å’Œå‡½æ•°ï¼‰æ—¶ï¼Œè™½ç„¶å¼•ç”¨æœ¬èº«çš„åœ°å€ä¸ä¼šå˜ï¼Œä½†æŒ‡å‘çš„å†…å®¹å¯èƒ½å˜åŒ–ï¼Œè¿™ä¹Ÿä¼šå¯¼è‡´æœ€ç»ˆçš„ç»“æœå’Œé¢„æœŸçš„å¿«ç…§ç»“æœä¸åŒã€‚

```go
x := 0
defer fmt.Println("deferred x:", x) // è¿™é‡Œæ•è·çš„ä¸æ˜¯xçš„å¼•ç”¨
x = 1
fmt.Println("Normal x:", x) // è¾“å‡º Normal 1; deferred 0
```

```go
x := 0
defer func() { fmt.Println("deferred x:", x) }() // è¿™é‡Œæ•è·çš„æ˜¯xçš„å¼•ç”¨, åŒ¿åå‡½æ•°é—­åŒ…
x = 1
fmt.Println("Normal x:", x) // éƒ½è¾“å‡º1
```

```go
x := []int64{0}
defer fmt.Println("deferred x:", x) // è¿™é‡Œæ•è·çš„æ˜¯xçš„å¼•ç”¨
x[0] = 1
fmt.Println("Normal x:", x)
```



##### æ‰§è¡Œé¡ºåº

return è¯­å¥åœ¨åº•å±‚å¹¶ä¸æ˜¯åŸå­æ“ä½œï¼Œè¿”å›æ“ä½œåˆ†ä¸‰æ­¥ï¼šâ‘ èµ‹å€¼è¿”å›å€¼ã€â‘¡æ‰§è¡Œdeferã€â‘¢æ‰§è¡Œè¿”å›(RETæŒ‡ä»¤)

å¦‚ï¼š

```go
func f1() int {
	x := 5
	defer func() {
		x++
	}()
	return x
}
func f2() (x int) {
	defer func() {
		x++
	}()
	return 5
}
func f3() (y int) {
	x := 5
	defer func() {
		x++
	}()
	return x
}
func f4() (x int) {
	defer func(x int) {
		x++
	}(x)
	return 5
}
func t4() {
	fmt.Println(f1()) //5
	fmt.Println(f2()) //6
	fmt.Println(f3()) //5
	fmt.Println(f4()) //5
}
```

ä¸Šé¢ä¾‹å­ï¼Œ

1. è¿”å›å€¼=xï¼Œx++ï¼Œè¿”å›è¿”å›å€¼
2. è¿”å›å€¼å‘½åä¸ºxï¼Œx=5ï¼Œx++ï¼Œè¿”å›x
3. è¿”å›å€¼å‘½åä¸ºyï¼Œy=xï¼Œx++ï¼Œè¿”å›y
4. è¿”å›å€¼å‘½åä¸ºxï¼Œx=5ï¼ŒåŒåå‚æ•°x(x2)=5ï¼Œx2++ï¼Œè¿”å›x

```go
func cal(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}
func t5() {
	x := 1
	y := 2
	defer cal("AA", x, cal("A", x, y))
	fmt.Println("=X")
	x = 10
	defer cal("BB", x, cal("B", x, y))
	fmt.Println("=Y")
	y = 20
}
```

è¾“å‡ºï¼š(defer è®¡ç®—æ˜¯é¡ºåºçš„ï¼Œè¿”å›æ˜¯é€†åºçš„ï¼Œå‚æ•°å€¼å°±æ˜¯å½“æ—¶é¡ºåºçš„å€¼)

```
A 1 2 3
=X
B 10 2 12
=Y
BB 10 12 22
AA 1 3 4
```

##### åŸç†è§£æ

çš„`_defer`å¯¹è±¡åº•å±‚æ˜¯é“¾è¡¨å®ç°çš„ï¼Œæ–°åˆ†é…çš„ `_defer` ç»“æ„ä½“ä¼šæŒ‚è½½åˆ°é“¾è¡¨å¤´éƒ¨ï¼Œå› æ­¤æ‰§è¡Œé¡ºåºæ˜¯åè¿›å…ˆå‡ºçš„æ‰§è¡Œé¡ºåºã€‚

> ```go
> type _defer struct {
>     started   bool    // defer è¯­å¥æ˜¯å¦å·²ç»æ‰§è¡Œ
>     heap      bool    // åŒºåˆ†å¯¹è±¡æ˜¯åœ¨å †ä¸Šåˆ†é…è¿˜æ˜¯æ ˆä¸Šåˆ†é…
>     sp        uintptr // è°ƒç”¨æ–¹çš„ sp (æ ˆåº•) å¯„å­˜å™¨
>     pc        uintptr // è°ƒç”¨æ–¹çš„ pc (ç¨‹åºè®¡æ•°å™¨) å¯„å­˜å™¨ï¼Œä¸‹ä¸€æ¡æ±‡ç¼–æŒ‡ä»¤çš„åœ°å€
>     fn        func()  // ä¼ å…¥ defer çš„å‡½æ•°ï¼ŒåŒ…æ‹¬å‡½æ•°åœ°å€åŠå‚æ•°
>     _panic    *_panic // æ­£åœ¨æ‰§è¡Œ defer çš„ panic å¯¹è±¡
>     link      *_defer // next defer, é“¾è¡¨æŒ‡é’ˆï¼Œå¯ä»¥æŒ‡å‘æ ˆæˆ–è€…å †
> }
> ```



#### å†…ç½®å‡½æ•°

- closeï¼šå…³é—­ channel
- lenï¼šæ±‚é•¿åº¦ï¼Œ æ¯”å¦‚ stringã€ arrayã€ sliceã€ mapã€ channel
- newï¼šåˆ†é…å†…å­˜ï¼Œ ä¸»è¦ç”¨æ¥åˆ†é…å€¼ç±»å‹ï¼Œ æ¯”å¦‚ intã€ structã€‚ è¿”å›çš„æ˜¯æŒ‡é’ˆ
- makeï¼šåˆ†é…å†…å­˜ï¼Œ ä¸»è¦ç”¨æ¥åˆ†é…å¼•ç”¨ç±»å‹ï¼Œ æ¯”å¦‚ chanã€ mapã€ slice
- appendï¼šç”¨æ¥è¿½åŠ å…ƒç´ åˆ°æ•°ç»„ã€ slice ä¸­
- panicã€recoverï¼šé”™è¯¯å¤„ç†

- min, max å‡½æ•° 1.21.0 å¼€å§‹

  ```go
  fmt.Println(max(2, 3))
  fmt.Println(min(1, 1, 4, 0.5))
  ```

#### ç‰¹æ®Šå‡½æ•°

##### initå‡½æ•°

æ²¡æœ‰å‚æ•°ä¹Ÿæ²¡æœ‰è¿”å›å€¼ã€‚ init()å‡½æ•°åœ¨ç¨‹åºè¿è¡Œæ—¶è‡ªåŠ¨è¢«è°ƒç”¨æ‰§è¡Œï¼Œ ä¸èƒ½åœ¨ä»£ç ä¸­ä¸»åŠ¨è°ƒç”¨å®ƒã€‚ç­‰ä»·äº java `static {}` æˆ– c++ `auto f = [](){}()`

æ‰§è¡Œé¡ºåºï¼šå…¨å±€å£°æ˜ã€initã€mainã€‚ä¸ç®¡å£°æ˜åœ¨initå‰åï¼Œéƒ½æ˜¯å…ˆå£°æ˜

```go
func init() {
	fmt.Println(x)
}
var x = 1
```

å…·ä½“æ‰§è¡Œé¡ºåºï¼š

- åŒ…çš„åˆå§‹åŒ–é¡ºåºï¼šå¦‚æœä¸€ä¸ªåŒ…è¢«å¤šä¸ªåŒ…ä¾èµ–ï¼ŒGo ä¼šé¦–å…ˆæ‰§è¡Œæ‰€æœ‰å¯¼å…¥çš„åŒ…çš„ `init()` å‡½æ•°ï¼Œä¾èµ–çš„åŒ… `init()` å‡½æ•°ä¼šå…ˆæ‰§è¡Œã€‚
- åŒä¸€ä¸ªåŒ…å¤šæ–‡ä»¶å¤š initï¼ŒæŒ‰æ–‡ä»¶åé¡ºåºã€‚
- åŒä¸€ä¸ªæ–‡ä»¶å†…å¤šä¸ª initï¼ŒæŒ‰å‡ºç°é¡ºåºã€‚å¤šä¸ªåŒåå‡½æ•° init æ˜¯ç‰¹ä¾‹ã€‚

> åœºæ™¯ä¾‹å­ï¼šsql initï¼Œæ—¥å¿—è®°å½•æ³¨å†Œ

##### mainå‡½æ•°

æ‰€åœ¨çš„åŒ…å¿…é¡»ä¸ºmainåŒ…ï¼Œå¯ä»¥ä½¿ç”¨flagåŒ…æ¥è·å–å’Œè§£æå‘½ä»¤è¡Œå‚æ•°

å‚æ•°ï¼š`func main()` æˆ– `func main(args []string)`

å¯ä»¥å®šä¹‰è¿”å›å€¼å¦‚ `func main() int`ï¼Œä½†æ¨èé€€å‡ºçŠ¶æ€é€šè¿‡ `os.Exit()` æ¥æ§åˆ¶

> åœ¨ `main.main` å‡½æ•°æ‰§è¡Œä¹‹å‰æ‰€æœ‰ä»£ç éƒ½è¿è¡Œåœ¨åŒä¸€ä¸ª `Goroutine` ä¸­ï¼Œå³ä¸»ç³»ç»Ÿçº¿ç¨‹ä¸­ã€‚
>
> ä½†æ˜¯å¦‚æœæŸä¸ª `init()` å‡½æ•°å†…éƒ¨ç”¨å¯åŠ¨äº†æ–°çš„ `Goroutine` ï¼Œé‚£ä¹ˆæ–°çš„ `Goroutine` å’Œ `main.main` å‡½æ•°æ˜¯å¹¶å‘æ‰§è¡Œçš„ã€‚

è§£æmainå‡½æ•°CLIå‚æ•°ï¼Œå¦‚ï¼š

```go
// os.Args[0] æ˜¯ç¨‹åºå
// os.Args[1:] æ˜¯å®é™…å‚æ•°
for i, arg := range os.Args {
    fmt.Printf("å‚æ•° %d: %s\n", i, arg)
}
```

> shell èƒ½å¤Ÿè‡ªåŠ¨æ‰©å±•é€šé…ç¬¦ï¼Œå¦‚ï¼š`go run xx.go ..src/main/pg*.txt` å¯ä»¥è¾“å‡ºä¸‹é¢è¿™æ ·ï¼Œåœ¨ shell é‡Œè‡ªå·± lsã€‚
>
> ```
> å‚æ•° 0: /tmp/go-build3836890561/b001/exe/shellFile
> å‚æ•° 1: ../src/main/pg-being_ernest.txt
> å‚æ•° 2: ../src/main/pg-dorian_gray.txt
> ...
> ```

è§£æä½ç½®å‚æ•°ï¼š

```go
package main

import (
	"flag"
	"fmt"
)

func main() {
	// å®šä¹‰å‘½ä»¤è¡Œå‚æ•°
	var (
		name    = flag.String("name", "é»˜è®¤å", "ç”¨æˆ·å")
		age     = flag.Int("age", 0, "ç”¨æˆ·å¹´é¾„")
		married = flag.Bool("married", false, "å©šå§»çŠ¶å†µ")
	)
	
	// è§£æå‘½ä»¤è¡Œå‚æ•°
	flag.Parse()
	
	// ä½¿ç”¨å‚æ•°
	fmt.Printf("å§“å: %s\n", *name)
	fmt.Printf("å¹´é¾„: %d\n", *age)
	fmt.Printf("å·²å©š: %t\n", *married)
	
	// è®¿é—®éæ ‡å¿—å‚æ•°
	fmt.Println("å…¶ä»–å‚æ•°:", flag.Args())
}
// go run main.go -name=å¼ ä¸‰ -age=30 -married=true é¢å¤–å‚æ•°1 é¢å¤–å‚æ•°2
```



### å¼‚å¸¸

##### error

errorç±»å‹å¤„ç†é”™è¯¯ã€‚

> å¸¸è§é”™è¯¯æœ‰ï¼šè¶Šç•Œã€ç©ºæŒ‡é’ˆè§£å¼•ç”¨ã€éæ³•ç±»å‹æ–­è¨€ã€æ•°å­—é”™è¯¯(1/0)ã€è°ƒç”¨panicã€å†…å­˜è¶Šç•Œ/éæ³•æ“ä½œã€è¿è¡Œæ—¶é”™è¯¯ã€ä¸å®‰å…¨çš„åº“/ä»£ç 
>
> Go æ›´æ¨èä½¿ç”¨æ˜¾å¼é”™è¯¯å¤„ç†ï¼Œè€Œä¸æ˜¯é€šè¿‡ panic å’Œ recover æ¥å¤„ç†å¸¸è§„çš„é”™è¯¯æƒ…å†µ

ç”¨ errors åŒ…ï¼Œå¯ä»¥ä¸»åŠ¨æ–°å»ºé”™è¯¯ã€‚ä½†å®ƒåªæ˜¯åˆ›å»ºé”™è¯¯å¯¹è±¡ï¼Œä¸ä¼šåƒ panic ä¸€æ ·ä¸­æ–­ç¨‹åºæ‰§è¡Œã€‚

```go
package main
import (
    "errors"
    "fmt"
)
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
        // ä¹Ÿå¯ä»¥ç”¨ fmt.Errorf è¿”å› error
    }
    return a / b, nil
}
func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Result:", result)
}
```

å…¶ä¸­ï¼Œerror æ˜¯å†…ç½®æ¥å£ç±»å‹

```go
type error interface {
    Error() string
}
```

åˆ¤æ–­é”™è¯¯ç±»å‹ï¼š

```go
if err != nil && err.Error() != "å·²å®Œæˆ" {
    fmt.Println(err)
}
```



##### panic

panicè¡¨ç¤ºä¸¥é‡é”™è¯¯ã€‚panicå¯ä»¥åœ¨ä»»ä½•åœ°æ–¹å¼•å‘ã€‚é€šå¸¸ç”¨äºå¤„ç†ä¸€äº›å¼‚å¸¸æƒ…å†µï¼Œè€Œä¸æ˜¯å¸¸è§„çš„é”™è¯¯å¤„ç†

> è°ƒç”¨ `panic` ä¼šå¯¼è‡´ç¨‹åºçš„æ§åˆ¶æµä¸­æ–­ï¼Œå¹¶å¼€å§‹é€å±‚å‘ä¸Šä¼ æ’­ï¼Œç›´åˆ°ç¨‹åºå´©æºƒæˆ–è¢« `recover` æ•è·ã€‚å¸¸ä½¿ç”¨äºç¨‹åºå¯åŠ¨åˆå§‹åŒ–é”™è¯¯å¤„ç†

```go
panic("ç›´æ¥æŠ¥é”™ï¼Œå¹¶ä¸”è¿™ä¸€è¡Œä¸‹é¢çš„ä¸ä¼šæ‰§è¡Œï¼Œå‚æ•°æ˜¯æŠ¥é”™ä¿¡æ¯")
```

```
panic: ç›´æ¥æŠ¥é”™ï¼Œå¹¶ä¸”è¿™ä¸€è¡Œä¸‹é¢çš„ä¸ä¼šæ‰§è¡Œï¼Œå‚æ•°æ˜¯æŠ¥é”™ä¿¡æ¯

goroutine 1 [running]:
main.main()
	d:/_lr580_desktop/codes/golang/lgo-013.go:111 +0x3d
exit status 2
```

##### recover

é€šè¿‡recover å°†ç¨‹åºæ¢å¤å›æ¥ï¼Œ ç»§ç»­å¾€åæ‰§è¡Œã€‚ recover åªèƒ½åœ¨ defer è°ƒç”¨çš„å‡½æ•°é‡Œã€‚

```go
func funcA() {
	fmt.Println("func A")
}
func funcB() {
	defer func() {
		err := recover() // æœ‰é”™è¯¯çš„è¯ï¼Œerr å°±æ˜¯ panic å­—ç¬¦ä¸²
		//å¦‚æœç¨‹åºå‡ºå‡ºç°äº† panic é”™è¯¯,å¯ä»¥é€šè¿‡ recover æ¢å¤è¿‡æ¥
		if err != nil {
			fmt.Println("recover in B")
		}
        // æˆ–ï¼š if err := recover(); err != nil {
	}()
	panic("panic in B")
}
func funcC() {
	fmt.Println("func C")
}
func t6() {
	funcA()
	funcB()
	funcC()
}
```

è¾“å‡º

```
func A
recover in B
func C
```

> `recover` åªèƒ½æ•è·ç›¸åŒè°ƒç”¨æ ˆå±‚æ¬¡å†…çš„ `panic`ã€‚å¦‚æœ `panic` è·¯å¾„è·¨è¶Šå‡½æ•°è°ƒç”¨è¾¹ç•Œï¼Œæ•è·å°±éœ€è¦åœ¨æ¯ä¸ªå±‚æ¬¡éƒ½æ·»åŠ  `recover`ã€‚å¦‚ä¸åŒçš„ go routineã€‚

##### æ•è·å¼‚å¸¸

æ•…å¯ä»¥æ•è·å¼‚å¸¸ï¼ŒåŒ…æ‹¬é panic è§¦å‘çš„å¼‚å¸¸ï¼š

```go
func fn2() {
	defer func() {
		err := recover()
		if err != nil {
			fmt.Println("æŠ›å‡ºå¼‚å¸¸ç»™ç®¡ç†å‘˜å‘é€é‚®ä»¶")
			fmt.Println(err)
		}
	}()
	num1 := 10
	num2 := 0
	res := num1 / num2
	fmt.Println("res=", res)
}
//æŠ›å‡ºå¼‚å¸¸ç»™ç®¡ç†å‘˜å‘é€é‚®ä»¶
//runtime error: integer divide by zero
```

##### ä¼ é€’å¼‚å¸¸

ä¸€å±‚å±‚åœ°ä¼ é€’å¼‚å¸¸ï¼š

```go
func readFile(fileName string) error { // error æ˜¯ä¸€ç§ç±»å‹
	if fileName == "main.go" {
		return nil // æ— å¼‚å¸¸
	} //import "errors"
	return errors.New("è¯»å–æ–‡ä»¶å¤±è´¥") // æœ‰å¼‚å¸¸
}
func fn3() {
	defer func() {
		err := recover()
		if err != nil {
			fmt.Println("ç¨‹åºå‡ºç°å¼‚å¸¸ï¼Œå‘é€æŠ¥è­¦é‚®ä»¶ç»™ç®¡ç†å‘˜")
			fmt.Println(err)
		}
	}()
	err := readFile("mian.go")
	if err != nil {
		panic(err) // æŠ›å‡ºå¼‚å¸¸
	}
	fmt.Println("æ— äº‹å‘ç”Ÿ")
}
```

### åŒ…

#### åŸºæœ¬ç”¨æ³•

##### æ¦‚å¿µ

###### åŒ…çš„åˆ†ç±»

åŒ…å¯ä»¥åˆ†ä¸ºä¸‰ç§ï¼š 1ã€ ç³»ç»Ÿå†…ç½®åŒ… 2ã€ è‡ªå®šä¹‰åŒ… 3ã€ ç¬¬ä¸‰æ–¹åŒ…  

- ç³»ç»Ÿå†…ç½®åŒ…: Golang è¯­è¨€ç»™æˆ‘ä»¬æä¾›çš„å†…ç½®åŒ…ï¼Œ å¼•å…¥åå¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œ å¦‚ fmtã€ strconvã€ stringsã€sortã€ errorsã€ timeã€ encoding/jsonã€ osã€ io ç­‰ã€‚
- è‡ªå®šä¹‰åŒ…ï¼š å¼€å‘è€…è‡ªå·±å†™çš„åŒ…
- ç¬¬ä¸‰æ–¹åŒ…ï¼š å±äºè‡ªå®šä¹‰åŒ…çš„ä¸€ç§ï¼Œ éœ€è¦ä¸‹è½½å®‰è£…åˆ°æœ¬åœ°åæ‰å¯ä»¥ä½¿ç”¨ï¼Œ å¦‚"github.com/shopspring/decimal"åŒ…è§£å†³ float ç²¾åº¦ä¸¢å¤±é—®é¢˜

###### åŒ…

åŒ…ï¼ˆpackageï¼‰ æ˜¯å¤šä¸ª Go æºç çš„é›†åˆï¼Œ ä¸€ä¸ªåŒ…å¯ä»¥ç®€å•ç†è§£ä¸ºä¸€ä¸ªå­˜æ”¾å¤šä¸ª.go æ–‡ä»¶çš„æ–‡ä»¶å¤¹ã€‚ è¯¥æ–‡ä»¶å¤¹ä¸‹é¢çš„æ‰€æœ‰ go æ–‡ä»¶éƒ½è¦åœ¨ä»£ç çš„ç¬¬ä¸€è¡Œæ·»åŠ å¦‚ä¸‹ä»£ç ï¼Œ å£°æ˜è¯¥æ–‡ä»¶å½’å±çš„åŒ…  

```go
package åŒ…å
```

ä¸€ä¸ªæ–‡ä»¶å¤¹ä¸‹é¢ç›´æ¥åŒ…å«çš„æ–‡ä»¶åªèƒ½å½’å±ä¸€ä¸ª packageï¼Œ åŒæ ·ä¸€ä¸ª package çš„æ–‡ä»¶ä¸èƒ½åœ¨å¤šä¸ªæ–‡ä»¶å¤¹ä¸‹ã€‚

åŒ…åå¯ä»¥ä¸å’Œæ–‡ä»¶å¤¹çš„åå­—ä¸€æ ·ï¼Œ åŒ…åä¸èƒ½åŒ…å« - ç¬¦å·ã€‚

åŒ…åä¸º main çš„åŒ…ä¸ºåº”ç”¨ç¨‹åºçš„å…¥å£åŒ…ï¼Œ è¿™ç§åŒ…ç¼–è¯‘åä¼šå¾—åˆ°ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œ è€Œç¼–è¯‘ä¸åŒ…å« main åŒ…çš„æºä»£ç åˆ™ä¸ä¼šå¾—åˆ°å¯æ‰§è¡Œæ–‡ä»¶

###### é¡ºåº

ä» main åŒ…å¼€å§‹æ£€æŸ¥å…¶å¯¼å…¥çš„æ‰€æœ‰åŒ…ï¼Œ æ¯ä¸ªåŒ…ä¸­åˆå¯èƒ½å¯¼å…¥äº†å…¶ä»–çš„åŒ…ã€‚ Go ç¼–è¯‘å™¨ç”±æ­¤æ„å»ºå‡ºä¸€ä¸ªæ ‘çŠ¶çš„åŒ…å¼•ç”¨å…³ç³»ï¼Œ å†æ ¹æ®å¼•ç”¨é¡ºåºå†³å®šç¼–è¯‘é¡ºåºï¼Œ ä¾æ¬¡ç¼–è¯‘è¿™äº›åŒ…çš„ä»£ç ï¼Œç‰¹åˆ«å¯¹ init è€Œè¨€ï¼Œé¡ºåºéµå¾ªï¼š

- import çš„åŒ…ï¼ŒæŒ‰å­—å…¸åºæ’åˆ—ï¼Œå…ˆåå¼•å…¥
- åŒä¸€ä¸ªåŒ…æœ‰å¤šä¸ªä»£ç æ–‡ä»¶ï¼Œå­—å…¸åº
- ä¸€ä¸ªåŒ… import äº†å¦ä¸€ä¸ªåŒ…ï¼Œå…ˆæ‰§è¡Œè¢«å¼•ç”¨çš„ï¼Œæ„æˆæ ‘çŠ¶

é main åŒ…çš„ main å‡½æ•°ä¸ä¼šè¢«æ‰§è¡Œï¼Œä¼š warning

```go
// lgo-018.go
package main
import (
	"fmt"
	_ "golearn/testpa"       // fun3.go æ–‡ä»¶
	alias "golearn/testpack" // fun1, gun1 æ–‡ä»¶ä¸¤ä¸ª init å‡½æ•°
	"golearn/testpack2"      // fun2, è€Œå¤–å¼•ç”¨äº†å…¶ä»–åŒ…çš„ fun4
)
```

è¾“å‡º

```
init fun3
init fun1
init gun1
init fun4
init fun2
```

##### å¯¼åŒ…

import åªèƒ½å†™åœ¨å‡½æ•°å¤–ï¼Œå‡½æ•°å£°æ˜å‰

```go
import "fmt"
import "os"
```

```go
import (
    "fmt"
    "math"
)
```

ç¬¬ä¸‰æ–¹åŒ…å’Œå…¶ä»–åŒ…ä¹‹é—´ï¼Œä¼šé»˜è®¤åŠ ä¸€ä¸ªç©ºè¡Œ

##### è‡ªå®šä¹‰åŒ…

åœ¨ä¸€ä¸ªåŒ…ä¸­å¼•ç”¨å¦å¤–ä¸€ä¸ªåŒ…é‡Œçš„æ ‡è¯†ç¬¦ï¼ˆå¦‚å˜é‡ã€ å¸¸é‡ã€ ç±»å‹ã€ å‡½æ•°ç­‰ï¼‰ æ—¶ï¼Œ è¯¥æ ‡è¯†ç¬¦å¿…é¡»æ˜¯å¯¹å¤–å¯è§çš„ï¼ˆpublicï¼‰ ã€‚ åœ¨ Go è¯­è¨€ä¸­åªéœ€è¦å°†æ ‡è¯†ç¬¦çš„é¦–å­—æ¯å¤§å†™å°±å¯ä»¥è®©æ ‡è¯†ç¬¦å¯¹å¤–å¯è§äº†  

å¦‚åœ¨å½“å‰ç›®å½•ä¸‹æ–°å»º `testpack/` ç›®å½•ï¼Œå½“å‰ `go.mod` çš„é¡¹ç›®åå­—æ˜¯ `golearn`ï¼ŒåŒ…åå« `tpack`ï¼Œä»£ç ä¸º `testpack/fun1.go`

```go
package tpack
var pwd = 1437 // ç§æœ‰
var Lr = 580   // å…¬æœ‰
func PrintLR() int {
	return pwd*1000 + Lr
}
```

åœ¨æ ¹ç›®å½•ä¸‹çš„ `lgo-018.go` è°ƒç”¨ä¸Šé¢çš„åŒ…ï¼š

```go
package main
import (
	"fmt"
	"golearn/testpack"
)
func main() {
	fmt.Println(tpack.Lr)
}
```

å¯ä»¥å®šä¹‰åˆ«åï¼šé€šå¸¸ç”¨äºå¯¼å…¥çš„åŒ…åå¤ªé•¿æˆ–è€…å¯¼å…¥çš„åŒ…åå†²çªçš„æƒ…å†µ  

```go
package main
import (
	"fmt"
	alias "golearn/testpack" // é»˜è®¤ä¼šåˆ«å tpackï¼Œè·Ÿä¸Šé¢ä¸€æ ·
)
func main() {
	fmt.Println(alias.PrintLR())
}
```

å¦‚æœç°åœ¨æœ‰ä¸æ–‡ä»¶å¤¹åŒåçš„ï¼Œå¦‚ `testpack2/` ç›®å½•ä¸‹ï¼Œ`fun2.go` å¦‚ä¸‹ï¼š

```go
package testpack2
var AC = 100
```

é‚£ä¹ˆå°±ä¸ä¼šè‡ªåŠ¨å®šä¹‰åˆ«åï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ï¼š

```go
import "golearn/testpack2" // éƒ¨åˆ†ä»£ç 
fmt.Println(testpack2.AC)
```

##### åŒ¿åå¯¼å…¥

åªå¸Œæœ›å¯¼å…¥åŒ…ï¼Œ è€Œä¸ä½¿ç”¨åŒ…å†…éƒ¨çš„æ•°æ®æ—¶ï¼Œ å¯ä»¥ä½¿ç”¨åŒ¿åå¯¼å…¥åŒ…ï¼Œè¿™æ ·æ— æ³•ä½¿ç”¨ä»»ä½•å˜é‡å’Œå‡½æ•°ï¼Œé‚£ä¹ˆå°±ç”¨ `_` åšåˆ«åï¼Œä¸€èˆ¬æ˜¯å¸Œæœ›æ‰§è¡Œ init å‡½æ•°

```go
import _ "golearn/testpack2"
```

å¯ä»¥é¿å…ä¸ä½¿ç”¨å®ƒçš„å˜é‡å’Œå‡½æ•°è€Œè¢«è‡ªåŠ¨åˆ æ‰ import

### å¤šçº¿ç¨‹

#### ç†è®º

> å¹¶å‘ï¼š å¤šä¸ªçº¿ç¨‹åŒæ—¶ç«äº‰ä¸€ä¸ªä½ç½®ï¼Œ ç«äº‰åˆ°çš„æ‰å¯ä»¥æ‰§è¡Œï¼Œ æ¯ä¸€ä¸ªæ—¶é—´æ®µåªæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œã€‚
>
> å¹¶è¡Œï¼š å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶æ‰§è¡Œï¼Œ æ¯ä¸€ä¸ªæ—¶é—´æ®µï¼Œ å¯ä»¥æœ‰å¤šä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œã€‚é€šä¿—çš„è®²å¤šçº¿ç¨‹ç¨‹åºåœ¨å•æ ¸ 
>
> CPU ä¸Šé¢è¿è¡Œå°±æ˜¯å¹¶å‘ï¼Œ å¤šçº¿ç¨‹ç¨‹åºåœ¨å¤šæ ¸ CUP ä¸Šè¿è¡Œå°±æ˜¯å¹¶è¡Œï¼Œ å¦‚æœçº¿ç¨‹æ•°å¤§äº CPU æ ¸æ•°ï¼Œ åˆ™å¤šçº¿ç¨‹ç¨‹åºåœ¨å¤šä¸ª CPU ä¸Šé¢è¿è¡Œæ—¢æœ‰å¹¶è¡Œåˆæœ‰å¹¶å‘

##### åç¨‹

åç¨‹ï¼š å¯ä»¥ç†è§£ä¸ºç”¨æˆ·çº§çº¿ç¨‹ï¼Œ è¿™æ˜¯å¯¹å†…æ ¸é€æ˜çš„ï¼Œ ä¹Ÿå°±æ˜¯ç³»ç»Ÿå¹¶ä¸çŸ¥é“æœ‰åç¨‹çš„å­˜åœ¨ï¼Œ æ˜¯å®Œå…¨ç”±ç”¨æˆ·è‡ªå·±çš„ç¨‹åºè¿›è¡Œè°ƒåº¦çš„ã€‚ Golang çš„ä¸€å¤§ç‰¹è‰²å°±æ˜¯ä»è¯­è¨€å±‚é¢åŸç”Ÿæ”¯æŒåç¨‹ï¼Œ åœ¨å‡½æ•°æˆ–è€…æ–¹æ³•å‰é¢åŠ  go å…³é”®å­—å°±å¯åˆ›å»ºä¸€ä¸ªåç¨‹ã€‚ å¯ä»¥è¯´ Golang ä¸­çš„åç¨‹å°±æ˜¯goroutine   

å¤šåç¨‹å’Œå¤šçº¿ç¨‹ï¼š Golang ä¸­æ¯ä¸ª goroutine (åç¨‹) é»˜è®¤å ç”¨å†…å­˜è¿œæ¯” Java ã€ C çš„çº¿ç¨‹å°‘ã€‚OS çº¿ç¨‹ï¼ˆ æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼‰ ä¸€èˆ¬éƒ½æœ‰å›ºå®šçš„æ ˆå†…å­˜ï¼ˆé€šå¸¸ä¸º 2MB å·¦å³ï¼‰ ,ä¸€ä¸ª goroutine (åç¨‹) å ç”¨å†…å­˜éå¸¸å°ï¼Œ åªæœ‰ 2KB å·¦å³ï¼Œ å¤šåç¨‹ goroutine åˆ‡æ¢è°ƒåº¦å¼€é”€æ–¹é¢è¿œæ¯”çº¿ç¨‹è¦å°‘ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¶Šæ¥è¶Šå¤šçš„å¤§å…¬å¸ä½¿ç”¨ Golang çš„åŸå› ä¹‹ä¸€  

##### ä¸»çº¿ç¨‹

golang ä¸­çš„ä¸»çº¿ç¨‹ï¼š ï¼ˆå¯ä»¥ç†è§£ä¸ºçº¿ç¨‹/ä¹Ÿå¯ä»¥ç†è§£ä¸ºè¿›ç¨‹ï¼‰ ï¼Œ åœ¨ä¸€ä¸ª Golang ç¨‹åºçš„ä¸»çº¿ç¨‹ä¸Šå¯ä»¥èµ·å¤šä¸ªåç¨‹ã€‚ Golang ä¸­å¤šåç¨‹å¯ä»¥å®ç°å¹¶è¡Œæˆ–è€…å¹¶å‘

ä¸»çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œä¸ç®¡åç¨‹æ˜¯å¦æ‰§è¡Œå®Œæ¯•ï¼Œéƒ½ä¼šç»ˆæ­¢ç¨‹åºï¼Œå‚è§ä¸‹é¢ `go` ä¸€èŠ‚ä»£ç ä¾‹å­ 

##### ç®¡é“

ç®¡é“æ˜¯ Golang åœ¨è¯­è¨€çº§åˆ«ä¸Šæä¾›çš„ goroutine é—´çš„é€šè®¯æ–¹å¼ï¼Œ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ channel åœ¨å¤šä¸ª goroutine ä¹‹é—´ä¼ é€’æ¶ˆæ¯ã€‚ å¦‚æœè¯´ goroutine æ˜¯ Go ç¨‹åºå¹¶å‘çš„æ‰§è¡Œä½“ï¼Œ channel å°±æ˜¯å®ƒä»¬ä¹‹é—´çš„è¿æ¥ã€‚ channel æ˜¯å¯ä»¥è®©ä¸€ä¸ª goroutine å‘é€ç‰¹å®šå€¼åˆ°å¦ä¸€ä¸ª goroutine çš„é€šä¿¡æœºåˆ¶  

Golang çš„å¹¶å‘æ¨¡å‹æ˜¯ CSPï¼ˆCommunicating Sequential Processesï¼‰ ï¼Œ æå€¡é€šè¿‡é€šä¿¡å…±äº«å†…å­˜è€Œä¸æ˜¯é€šè¿‡å…±äº«å†…å­˜è€Œå®ç°é€šä¿¡  

Go è¯­è¨€ä¸­çš„ç®¡é“ï¼ˆchannelï¼‰ æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç±»å‹ï¼Œéµå¾ª FIFOï¼Œæ¯ä¸€ä¸ªç®¡é“éƒ½æ˜¯ä¸€ä¸ªå…·ä½“ç±»å‹çš„å¯¼ç®¡ï¼Œ ä¹Ÿå°±æ˜¯å£°æ˜ channel çš„æ—¶å€™éœ€è¦ä¸ºå…¶æŒ‡å®šå…ƒç´ ç±»å‹  

##### æ­»é”

å¦‚ï¼Œå½“æ‰€æœ‰æ´»è·ƒçš„goroutineï¼ˆä¸»goroutine + 4ä¸ªæ¶ˆè´¹è€…ï¼‰å‡å¤„äºé˜»å¡çŠ¶æ€ï¼Œä¸”æ— å…¶ä»–goroutineå¯æ¨è¿›ä»»åŠ¡æ—¶ï¼ŒGoè¿è¡Œæ—¶ä¼šæ£€æµ‹åˆ°**æ­»é”**ï¼ŒæŠ›å‡ºé”™è¯¯ï¼š

```
fatal error: all goroutines are asleep - deadlock!
```

è¿™æ˜¯æ˜ç¡®çš„è¿è¡Œæ—¶é”™è¯¯ï¼Œè€Œéæ¶ˆè´¹è€…é™·å…¥â€œæ­»å¾ªç¯â€ï¼ˆæ­»å¾ªç¯æŒ‡æŒç»­å ç”¨CPUçš„å¾ªç¯ï¼Œè€Œæ­¤å¤„æ˜¯é˜»å¡ç­‰å¾…ï¼‰

#### goroutine

> Goroutine æ˜¯ä¸€ç§æ¯”æ“ä½œç³»ç»Ÿçº¿ç¨‹æ›´è½»é‡çº§çš„çº¿ç¨‹ã€‚é€šè¿‡ Goroutine å’Œ Channelï¼ŒGo å®ç°äº†è½»é‡çº§çš„å¹¶å‘å¤„ç†ï¼Œå¹¶ç®€åŒ–äº†çº¿ç¨‹é—´çš„é€šä¿¡å’ŒåŒæ­¥

##### go

go æŒ‡ä»¤æ‰§è¡Œä¸€ä¸ªå‡½æ•°ï¼Œ`go f()`ï¼Œä»¥åç¨‹æ–¹å¼æ‰§è¡Œå®ƒ

```go
package main
import (
	"fmt"
	"time"
)
func test() {
	for i := 1; i <= 10; i++ {
		fmt.Println("test in", i)
		time.Sleep(100 * time.Millisecond)
	}
}
func main() {
	go test()
	for i := 1; i <= 3; i++ {
		fmt.Println("main in", i)
		time.Sleep(100 * time.Millisecond)
	}
}
```

main æ‰§è¡Œå®Œæ¯•ï¼Œæ‰€æœ‰åç¨‹å¼ºåˆ¶ç»ˆæ­¢ã€‚å¯èƒ½çš„è¾“å‡ºï¼š

```go
main in 1
test in 1
test in 2
main in 2
main in 3
test in 3
test in 4
```

##### waitgroup

`sync` åŒ…çš„ `Waitgroup`ï¼Œæœ‰å¸¸ç”¨æ–¹æ³•ï¼š

1. `wg.Add(x)` æ·»åŠ xä¸ªä¿¡å·é‡
2. `wg.Done()` å‡å°‘ä¸€ä¸ªä¿¡å·é‡
3. `wg.Wait()` ç›´åˆ°ä¿¡å·é‡ä¸º0æ—¶ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œå¦åˆ™é˜»å¡

ä¸»ç¨‹åºä¸ test å¹¶å‘ï¼Œå¹¶ç­‰å¾… test æ‰§è¡Œå®Œæ¯•ï¼š

```go
package main
import (
	"fmt"
	"sync"
	"time"
)
var wg sync.WaitGroup
func test() {
	for i := 1; i <= 10; i++ {
		fmt.Println("test in", i)
		time.Sleep(100 * time.Millisecond)
	}
	wg.Done()
}
func main() {
	wg.Add(1)
	go test()
	for i := 1; i <= 3; i++ {
		fmt.Println("main in", i)
		time.Sleep(100 * time.Millisecond)
	}
	wg.Wait()
}
```

å¦ä¸€ç§æ€è·¯ï¼šç›´æ¥åœ¨ `test()` å‡½æ•°ç¬¬ä¸€è¡Œï¼š

```go
defer wg.Done()
```

åŒç†ï¼Œå¯ä»¥æ‰©å±•åˆ°å¤šä¸ª goroutine å¹¶å‘

##### GOMAXPROCS

`runtime` åŒ…ï¼Œå¯ä»¥æ±‚å‡ºå½“å‰è®¡ç®—æœº CPU æ•°ã€‚(å¤šå°‘æ ¸)

```go
cpuNum := runtime.NumCPU()
fmt.Println(cpuNum) // å¦‚ 16
runtime.GOMAXPROCS(cpuNum - 1) // è®¾ç½®
```

#### chan

##### å®šä¹‰

channel æ˜¯ä¸€ç§ç±»å‹ï¼Œ ä¸€ç§å¼•ç”¨ç±»å‹ã€‚ å£°æ˜ç®¡é“ç±»å‹çš„æ ¼å¼å¦‚ä¸‹  

```go
// å£°æ˜
var ch1 chan int
var ch2 chan bool
var ch3 chan []int
```

æˆ–ï¼š

```go
// å£°æ˜å¹¶åˆ›å»º
ch1 := make(chan int, 10) // å®¹é‡ä¸º10
ch2 := make(chan bool, 4)
ch3 := make(chan []int, 3)
// å¦‚æœå·²ç»å£°æ˜
```

æ— å®¹é‡(æ— ç¼“å†²)

```go
h := make(chan int)
```

> æ— ç¼“å†²ç”¨äºåŒæ­¥æœºåˆ¶ï¼Œæ”¶å‘åŒæ—¶å‘ç”Ÿï¼›æœ‰ç¼“å†²åœ¨æ»¡ä¹‹å‰ä¸é˜»å¡ï¼Œä½¿ç”¨ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ã€‚

##### ä½¿ç”¨

ç®¡é“æœ‰å‘é€ï¼ˆsendï¼‰ ã€ æ¥æ”¶(receiveï¼‰ å’Œå…³é—­ï¼ˆcloseï¼‰ ä¸‰ç§æ“ä½œã€‚å‘é€å’Œæ¥æ”¶éƒ½ä½¿ç”¨<-ç¬¦å·  

```go
ch1 <- 580   // å‘é€æ•°æ®
num := <-ch1 // æ¥æ”¶æ•°æ®
fmt.Println(num)
// fmt.Println(<-ch1) // æ²¡æœ‰æ•°æ®ï¼Œä¼šæŠ¥é”™
// <-ch1 // æ¥æ”¶æ•°æ®ï¼ŒåŸåœ°ä¸¢å¼ƒå¿½ç•¥
```

##### å…³é—­

```go
close(ch1) // å…³é—­é€šé“
```

å…³äºå…³é—­ç®¡é“éœ€è¦æ³¨æ„çš„äº‹æƒ…æ˜¯ï¼Œ åªæœ‰åœ¨é€šçŸ¥æ¥æ”¶æ–¹ goroutine æ‰€æœ‰çš„æ•°æ®éƒ½å‘é€å®Œæ¯•çš„æ—¶å€™æ‰éœ€è¦å…³é—­ç®¡é“ã€‚ ç®¡é“æ˜¯å¯ä»¥è¢«åƒåœ¾å›æ”¶æœºåˆ¶å›æ”¶çš„ï¼Œ å®ƒå’Œå…³é—­æ–‡ä»¶æ˜¯ä¸ä¸€æ ·çš„ï¼Œ åœ¨ç»“æŸæ“ä½œä¹‹åå…³é—­æ–‡ä»¶æ˜¯å¿…é¡»è¦åšçš„ï¼Œ ä½†å…³é—­ç®¡é“ä¸æ˜¯å¿…é¡»çš„  

å¯¹ä¸€ä¸ªå…³é—­çš„ç®¡é“å†å‘é€å€¼å°±ä¼šå¯¼è‡´ panic

å¯¹ä¸€ä¸ªå…³é—­çš„ç®¡é“è¿›è¡Œæ¥æ”¶ä¼šä¸€ç›´è·å–å€¼ç›´åˆ°ç®¡é“ä¸ºç©ºã€‚

å¯¹ä¸€ä¸ªå…³é—­çš„å¹¶ä¸”æ²¡æœ‰å€¼çš„ç®¡é“æ‰§è¡Œæ¥æ”¶æ“ä½œä¼šå¾—åˆ°å¯¹åº”ç±»å‹çš„é›¶å€¼  

å…³é—­ä¸€ä¸ªå·²ç»å…³é—­çš„ç®¡é“ä¼šå¯¼è‡´ panic

##### é˜»å¡

å¦‚æœåˆ›å»ºç®¡é“çš„æ—¶å€™æ²¡æœ‰æŒ‡å®šå®¹é‡ï¼Œ é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å«è¿™ä¸ªç®¡é“ä¸ºæ— ç¼“å†²çš„ç®¡é“  

å½“è¦å‘é€æ•°æ®ï¼Œè€Œè¶…è¿‡ç®¡é“å®¹é‡æ—¶(å¦‚æ²¡æœ‰ä»»ä½•å®¹é‡çš„ç®¡é“)ï¼Œä¼šæŠ¥é”™ï¼›åªè¦ç®¡é“çš„å®¹é‡å¤§äºé›¶ï¼Œ é‚£ä¹ˆè¯¥ç®¡é“å°±æ˜¯æœ‰ç¼“å†²çš„ç®¡é“ï¼Œ ç®¡é“çš„å®¹é‡è¡¨ç¤ºç®¡é“ä¸­èƒ½å­˜æ”¾å…ƒç´ çš„æ•°é‡  

##### éå†

åœ¨éå†ä¹‹å‰ï¼Œå¿…é¡»å…³é—­ç®¡é“ã€‚

```go
ch := make(chan int, 10)
ch <- 10
ch <- 40
close(ch)
for val := range ch {
    fmt.Println(val)
}
```

##### å•å‘ç®¡é“

æ¯”å¦‚é™åˆ¶ç®¡é“åœ¨å‡½æ•°ä¸­åªèƒ½å‘é€æˆ–åªèƒ½æ¥æ”¶  

```go
var ch2 chan<- int // åªå†™
ch2 = make(chan int, 3)
ch2 <- 580
var ch3 <-chan int // åªè¯» (åªè¯»æ— æ³•è¢«å…³é—­)
fmt.Printf("%T %v %v", ch3, ch3, ch2)
// <-chan int <nil> 0xc0000a6080
```

ä½¿ç”¨åœºæ™¯ï¼šä½œç”¨äºå‡½æ•°å‚æ•°ï¼Œä½¿å¾—è™½ç„¶æ˜¯åŒä¸€ä¸ªç®¡é“ï¼Œä½†åœ¨æŸäº›å‡½æ•°åªèƒ½è¯»ï¼Œåœ¨æŸäº›å‡½æ•°åªèƒ½å†™ï¼Œè§ä¸‹æ–‡è´¨æ•°ä¾‹å­ã€‚

##### å¤šè·¯å¤ç”¨

select çš„ä½¿ç”¨ç±»ä¼¼äº switch è¯­å¥ï¼Œ å®ƒæœ‰ä¸€ç³»åˆ— case åˆ†æ”¯å’Œä¸€ä¸ªé»˜è®¤çš„åˆ†æ”¯ã€‚ æ¯ä¸ª case ä¼šå¯¹åº”ä¸€ä¸ªç®¡é“çš„é€šä¿¡ï¼ˆæ¥æ”¶æˆ–å‘é€ï¼‰ è¿‡ç¨‹ã€‚ select ä¼šä¸€ç›´ç­‰å¾…ï¼Œ ç›´åˆ°æŸä¸ª case çš„é€šä¿¡æ“ä½œå®Œæˆæ—¶ï¼Œ å°±ä¼šæ‰§è¡Œ case åˆ†æ”¯å¯¹åº”çš„è¯­å¥  

```go
ic := make(chan int, 10)
for i := 1; i <= 10; i++ {
    ic <- i * 580
}
sc := make(chan string, 5)
for i := 1; i <= 5; i++ {
    sc <- fmt.Sprintf("string %d", i)
}
for { // æ‰§è¡Œç»“æœï¼šéšæœºè¯»å–ä¸€ä¸ªï¼Œç„¶åè¯»å®Œäº†no receive
    select {
    case v := <-ic:
        fmt.Println("ic", v)
    case v := <-sc:
        fmt.Println("sc", v)
    default:
        fmt.Println("No receive")
        // break æ— æ³•è·³å‡º
        return
    }
}
```

##### å¤šçº¿ç¨‹

å®ä¾‹

> ##### è¾¹ç”Ÿäº§è¾¹æ¶ˆè´¹

ä¸€ä¸ªç”Ÿäº§è€…ï¼Œ4ä¸ªæ¶ˆè´¹è€…æŠ¢ï¼š

```go
var wg sync.WaitGroup
thing := make(chan string, 2)
wg.Add(5)
go func() { // ä¸€ä¸ªç”Ÿäº§è€…
    defer wg.Done()
    for i := 1; i <= 20; i++ {
        fmt.Println("producer produce thing", i)
        thing <- fmt.Sprintf("thing %d", i)
        time.Sleep(200 * time.Millisecond)
    }
    close(thing)
}()
for i := 0; i < 4; i++ { // å¤šä¸ªæ¶ˆè´¹è€…
    go func(i int) {
        defer wg.Done()
        for x := range thing {
            fmt.Printf("consumer %d got %s\n", i, x)
        }
    }(i) // è§‚å¯Ÿåˆ°æŒ‰ç…§ 0,1,2,3,...çš„é¡ºåºæ¶ˆè´¹
}
wg.Wait()
fmt.Println("All done")
```

> ##### ä¾‹ï¼šè´¨æ•°è®¡ç®—

å¤šçº¿ç¨‹è®¡ç®—è´¨æ•°å¹¶ä½¿ç”¨ç®¡é“è¾“å‡º

```go
import (
	"fmt"
	"runtime"
	"sync"
	"time"
)
// å¯ä»¥è¯æ˜æ˜¯è¾¹ç”Ÿäº§è¾¹æ¶ˆè´¹çš„
var wg sync.WaitGroup

func producer(n int, a chan<- int) {
	defer wg.Done()
	fmt.Println("ç”Ÿäº§è€…å¼€å§‹ç”Ÿäº§")
	for i := 2; i <= n; i++ {
		a <- i
	}
	close(a)
	fmt.Println("ç”Ÿäº§è€…ç”Ÿäº§å®Œæ¯•")
}
func consumer(a <-chan int, p chan<- int) {
	started := false
	for x := range a {
		if !started {
			fmt.Println("æ¶ˆè´¹è€…å¼€å§‹æ¶ˆè´¹")
			started = true
		}
		isPrime := true
		for i := 2; i*i <= x; i++ {
			if x%i == 0 {
				isPrime = false
				break
			}
		}
		if isPrime {
			p <- x
		}
	}
	fmt.Println("æ¶ˆè´¹è€…æ¶ˆè´¹å®Œæ¯•")
	wg.Done()
}
func main() {
	start := time.Now()
	n := int(1e7)
	a := make(chan int, n)
	p := make(chan int, n)
	m := 4 // çº¿ç¨‹æ•°
	wg.Add(m + 1)
	go producer(n, a)
	for i := 0; i < m; i++ {
		go consumer(a, p)
	}
	wg.Wait()
	// å•çº¿ç¨‹ 3.95ms, 4çº¿ç¨‹ 1.3ms
	fmt.Println("æ‰§è¡Œå®Œæ¯•ï¼Œéœ€è¦ï¼š", time.Since(start))
	fmt.Println("ç´ æ•°ä¸ªæ•°ï¼š", len(p))
	close(p) // å¿…é¡»è¦å…³é—­
	// æ˜¯æœ‰åºçš„
	// for x := range p {
	// 	fmt.Println(x)
	// }
}
```

#### å¹¶å‘å®‰å…¨

##### race

é¦–å…ˆçœ‹ä¸€ä¸ªç»å…¸å¤šçº¿ç¨‹++é—®é¢˜ï¼š

```go
// lgo-020.go
var wg sync.WaitGroup
cnt := 0
wg.Add(100)
for i := 0; i < 100; i++ {
    go func() {
        for j := 0; j < 100; j++ {
            cnt++
            time.Sleep(time.Millisecond)
        }
        wg.Done()
    }()
}
wg.Wait()
fmt.Println(cnt) // å¦‚ 9961
```

å‘½ä»¤ `go build -race lgo-020.go` ç”¨äºç¼–è¯‘ Go æºä»£ç æ–‡ä»¶ `lgo-020.go`ï¼Œå¹¶ä¸”åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­å¯ç”¨æ•°æ®ç«äº‰æ£€æµ‹ï¼ˆrace detectionï¼‰

ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶åœ¨è¿è¡Œæ—¶ï¼Œå¦‚æœæ£€æµ‹åˆ°æ•°æ®ç«äº‰ï¼Œä¼šåœ¨æ§åˆ¶å°è¾“å‡ºç›¸å…³çš„è­¦å‘Šä¿¡æ¯ï¼Œå¸®åŠ©ä½ å®šä½å’Œä¿®å¤å¹¶å‘é—®é¢˜

```go
go build -race lgo-020.go
./lgo-020
```

å¦‚å‘Šè¯‰ä»£ç è¡Œæ•°ï¼š

```
==================
WARNING: DATA RACE
Read at 0x00c00000a1b8 by goroutine 8:
  main.main.func1()
      D:/_lr580_desktop/codes/golang/lgo-020.go:178 +0x37
```

##### äº’æ–¥é”

sync ä¸­çš„ Mutexç»“æ„ä½“ç±»å‹è¡¨ç¤ºã€‚ sync.Mutex ç±»å‹åªæœ‰ä¸¤ä¸ªå…¬å¼€çš„æŒ‡é’ˆæ–¹æ³•ï¼Œ Lock å’Œ Unlockã€‚ Lock é”å®šå½“å‰çš„å…±äº«èµ„æºï¼Œ Unlock è¿›è¡Œè§£é”  

ä½¿ç”¨äº’æ–¥é”èƒ½å¤Ÿä¿è¯åŒä¸€æ—¶é—´æœ‰ä¸”åªæœ‰ä¸€ä¸ª goroutine è¿›å…¥ä¸´ç•ŒåŒºï¼Œ å…¶ä»–çš„ goroutine åˆ™åœ¨ç­‰å¾…é”ï¼› å½“äº’æ–¥é”é‡Šæ”¾åï¼Œ ç­‰å¾…çš„ goroutine æ‰å¯ä»¥è·å–é”è¿›å…¥ä¸´ç•ŒåŒºï¼Œ å¤šä¸ª goroutine åŒæ—¶ç­‰å¾…ä¸€ä¸ªé”æ—¶ï¼Œ å”¤é†’çš„ç­–ç•¥æ˜¯éšæœºçš„  

```go
fmt.Println("begin")
cnt := 0
var wg sync.WaitGroup
wg.Add(100)
var mutex sync.Mutex
t := time.Now()
for i := 0; i < 100; i++ {
    go func() {
        for j := 0; j < 100; j++ {
            mutex.Lock()
            cnt++
            mutex.Unlock()
            time.Sleep(time.Millisecond)
        }
        wg.Done()
    }()
}
wg.Wait()
fmt.Println("æ‰§è¡Œå®Œæ¯•ï¼Œéœ€è¦ï¼š", time.Since(t)) // 158ms
fmt.Println(cnt) // 10000
```

ç¼ºç‚¹ï¼šé”ä½çš„ä»£ç ä¸å¹¶è¡Œï¼Œè€Œæ˜¯ä¸²è¡Œäº†

##### è¯»å†™é”

ä¿®æ”¹çš„æ•°æ®è¦åŒæ­¥ï¼Œ è¿™æ ·å…¶ä»–goroutine æ‰å¯ä»¥æ„ŸçŸ¥åˆ°ã€‚ æ‰€ä»¥çœŸæ­£çš„äº’æ–¥åº”è¯¥æ˜¯è¯»å–å’Œä¿®æ”¹ã€ ä¿®æ”¹å’Œä¿®æ”¹ä¹‹é—´ï¼Œ è¯»å’Œè¯»æ˜¯æ²¡æœ‰äº’æ–¥æ“ä½œçš„å¿…è¦

å†™é”å¯ä»¥è®©å¤šä¸ªè¯»æ“ä½œå¹¶å‘ï¼Œ åŒæ—¶è¯»å–ï¼Œ ä½†æ˜¯å¯¹äºå†™æ“ä½œæ˜¯å®Œå…¨äº’æ–¥çš„ã€‚ å½“ä¸€ä¸ª goroutine è¿›è¡Œå†™æ“ä½œçš„æ—¶å€™ï¼Œ å…¶ä»– goroutine æ—¢ä¸èƒ½è¿›è¡Œè¯»æ“ä½œï¼Œ ä¹Ÿä¸èƒ½è¿›è¡Œå†™æ“ä½œ  

```go
var mutex sync.RWMutex
var wg sync.WaitGroup
cnt := 0
wg.Add(13)
t := time.Now()
for i := 0; i < 3; i++ {
    go func() {
        defer wg.Done()
        for j := 0; j < 100; j++ {
            mutex.Lock() // å†™é”
            cnt++
            mutex.Unlock()
            time.Sleep(time.Millisecond)
        }
    }()
}
for i := 0; i < 10; i++ {
    go func() {
        defer wg.Done()
        for j := 0; j < 100; j++ {
            mutex.RLock() // è¯»é”
            fmt.Println(cnt)
            mutex.RUnlock()
            time.Sleep(time.Millisecond)
        }
    }()
}
wg.Wait()
fmt.Println("æ‰§è¡Œå®Œæ¯•ï¼Œéœ€è¦ï¼š", time.Since(t))
fmt.Println(cnt)
```

##### å…¨å±€é”

mutex é”åªå¯¹è‡ªå·±æœ‰ç”¨ï¼Œå¦‚æœæ˜¯å¤šä¸ªè¿›ç¨‹

> ##### å¼‚å¸¸å¤„ç†

### ç¼–è¯‘

> å¯èƒ½æ¢æˆä¸€äºŒçº§æ ‡é¢˜åç»­

#### æ„å»ºçº¦æŸ

æ„å»ºçº¦æŸï¼ˆBuild Constraintsï¼‰ã€‚ä¹Ÿå«æ„å»ºæ ‡ç­¾ï¼ˆBuild Tagsï¼‰ã€‚å…è®¸ä½ æ§åˆ¶å“ªäº› `.go` æ–‡ä»¶åº”è¯¥è¢«åŒ…å«åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ã€‚è¿™ä½¿å¾—ä½ å¯ä»¥æ ¹æ®ä¸åŒçš„ç›®æ ‡æ“ä½œç³»ç»Ÿã€æ¶æ„ã€ç¯å¢ƒæˆ–è‡ªå®šä¹‰æ¡ä»¶æ¥ç¼–è¯‘ä¸åŒç‰ˆæœ¬çš„ä»£ç ã€‚

æ–‡ä»¶çº§çº¦æŸï¼šåœ¨æ–‡ä»¶å¼€å¤´ä½¿ç”¨ `//go:build` + ç©ºè¡Œï¼ŒåŠ ä¸€ä¸ªå¸ƒå°”å€¼è¡¨è¾¾å¼æ¡ä»¶ï¼Œå¦‚ï¼š

å¿½ç•¥å…¶ä»–åŒæ–‡ä»¶ä¸‹çš„ `.go` æ–‡ä»¶ï¼Œåªè€ƒè™‘è¯¥æ–‡ä»¶è‡ªå·±ã€‚

```go
//go:build ignore

package main
var s [2201]byte
func longestPalindrome(c string) string { // ...
```

æ¡ä»¶ä½¿ç”¨æ ‡å‡†çš„å¸ƒå°”è¿ç®—ç¬¦ï¼Œå¦‚ `&&` (ä¸), `||` (æˆ–), `!` (é)

```
//go:build dev && !test
```

## åº•å±‚

### å†…å­˜

##### å †æ ˆ

æ ˆåˆ†é…ï¼š

- æ ˆæ˜¯çº¿ç¨‹ç§æœ‰çš„ï¼Œåˆ†é…å’Œé‡Šæ”¾å†…å­˜ç”±ç¼–è¯‘å™¨ç®¡ç†ã€‚
- åˆ†é…é€Ÿåº¦å¿«ï¼Œé€šå¸¸ç”¨äºå‡½æ•°çš„å±€éƒ¨å˜é‡ã€‚

å †åˆ†é…ï¼š

- å †æ˜¯å…¨å±€å…±äº«çš„ï¼Œå†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾ç”±åƒåœ¾å›æ”¶å™¨ï¼ˆGCï¼‰ç®¡ç†ã€‚
- é€‚ç”¨äºåŠ¨æ€åˆ†é…å’Œé•¿ç”Ÿå‘½å‘¨æœŸçš„å†…å­˜ï¼Œä½†æ€§èƒ½è¾ƒæ…¢ã€‚

##### å˜é‡åˆ†é…

å¦‚æœå˜é‡çš„ç”Ÿå‘½å‘¨æœŸå±€é™äºå‡½æ•°ä½œç”¨åŸŸï¼Œå¹¶ä¸”ä¸ä¼šé€ƒé€¸åˆ°å‡½æ•°å¤–ï¼Œåˆ™åˆ†é…åœ¨æ ˆä¸Šã€‚

å¦‚æœå±€éƒ¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸè¶…å‡ºå‡½æ•°ä½œç”¨åŸŸï¼ˆå¦‚é€šè¿‡æŒ‡é’ˆè¿”å›ç»™å¤–éƒ¨ä½¿ç”¨ï¼‰ï¼Œç¼–è¯‘å™¨ä¼šå°†å˜é‡åˆ†é…åœ¨å †ä¸Šï¼Œç¡®ä¿å˜é‡åœ¨ä½œç”¨åŸŸå¤–ä»ç„¶æœ‰æ•ˆï¼Œè¿™ç§æœºåˆ¶ç§°ä¸ºâ€œé€ƒé€¸åˆ†æâ€ï¼Œè§¦å‘åœºæ™¯ï¼š

- æœå±€éƒ¨å˜é‡çš„åœ°å€è¢«è¿”å›
- å±€éƒ¨å˜é‡è¢«é—­åŒ…æ•è·
- å±€éƒ¨å˜é‡è¢«ä¼ é€’åˆ°å¦ä¸€ä¸ª Goroutineï¼Œåˆ™æ— æ³•ä¿è¯å…¶å®‰å…¨å­˜å‚¨åœ¨æ ˆ

é€ƒé€¸æŸ¥è¯¢ï¼š

> ä½¿ç”¨ `go build` æˆ– `go run` çš„ `-gcflags="-m"` å‚æ•°å¯ä»¥æŸ¥çœ‹é€ƒé€¸åˆ†æç»“æœï¼š
>
> ```sh
> go build -gcflags="-m" escape.go
> ```
>
> ```go
> //go:build ignore
> 
> package main // escape.go
> 
> func closure() func() int {
> 	x := 10
> 	return func() int {
> 		return x
> 	} 
> }// è¾“å‡ºæœ‰ä¸€è¡Œï¼š ./escape.go:7:9: func literal escapes to heap
> 
> func main() {}
> ```



> åƒåœ¾å›æ”¶ï¼Œä½†è®¾è®¡ä¸Šæ›´åŠ ç®€æ´ï¼Œä¸“æ³¨äºå‡å°‘ GC å¯¹åº”ç”¨æ€§èƒ½çš„å½±å“ã€‚Go çš„ GC æ›´é€‚åˆå¤„ç†å¤§é‡å¹¶å‘è¯·æ±‚ï¼Œå…·æœ‰è¾ƒä½çš„æš‚åœæ—¶é—´
>

## å¸¸ç”¨å†…ç½®åŒ…

### I/O

fmt åŒ…é‡Œé¢ç»™æˆ‘ä»¬æä¾›äº†ä¸€äº›å¸¸è§çš„æ‰“å°æ•°æ®çš„æ–¹æ³•ï¼Œ æ¯”å¦‚ï¼š Print ã€ Printlnã€ Printfï¼Œ åœ¨æˆ‘ä»¬å®é™…å¼€å‘ä¸­ Printlnã€ Printf ç”¨çš„éå¸¸å¤š  

#### æ ‡å‡†I/O

##### è¾“å‡º

ä¼ å…¥å¤šä¸ªå‚æ•°ï¼Œé€—å·åˆ†éš”ã€‚è¾“å‡ºåˆ° stdout

- `Println` åœ¨ä¸åŒå‚æ•°åŠ ç©ºæ ¼æœ«å°¾åŠ æ¢è¡Œï¼Œ
- `Print` ä¸åŠ ç©ºæ ¼ï¼Œæœ«å°¾æ— æ¢è¡Œ

```go
package main
import "fmt"
func main() {
	fmt.Println("ä¸€äºŒ", 2, 1/3)
	fmt.Println("æˆ‘ä»æ¥æœ‰", "è§‰å¾—", "å­¦GO", "å¼€å¿ƒè¿‡")
	fmt.Print("æˆ‘ä»æ¥æ²¡æœ‰", "è§‰å¾—", "åšç§‘ç ”")
	fmt.Print("å¼€å¿ƒè¿‡")
}
```

è¾“å‡ºï¼š

```
ä¸€äºŒ 2 0
æˆ‘ä»æ¥æœ‰ è§‰å¾— å­¦GO å¼€å¿ƒè¿‡
æˆ‘ä»æ¥æ²¡æœ‰è§‰å¾—åšç§‘ç ”å¼€å¿ƒè¿‡
```

##### æ ¼å¼åŒ–

æ ¼å¼åŒ–è¾“å‡º `Printf` [å‚è€ƒ](https://www.cnblogs.com/jasmine456/p/18338866)

> - `%v`ï¼šå€¼çš„é»˜è®¤æ ¼å¼è¡¨ç¤ºã€‚å¯ä»¥è¾“å‡ºæ•°ç»„ã€åˆ‡ç‰‡ç­‰ã€‚
> - `%+v`ï¼šç»“æ„ä½“å­—æ®µåå’Œå€¼çš„æ ¼å¼è¡¨ç¤ºã€‚
> - `%#v`ï¼šGo è¯­æ³•è¡¨ç¤ºçš„å€¼ã€‚
> - `%T`ï¼šå€¼çš„ç±»å‹ã€‚
> - `%%`ï¼šç™¾åˆ†å·å­—é¢é‡ã€‚
>
> å¯¹äºç‰¹å®šç±»å‹ï¼š
>
> - `%d`ï¼šæ•´æ•° (åè¿›åˆ¶)ã€‚
> - `%b`ï¼šæ•´æ•° (äºŒè¿›åˆ¶)ã€‚
> - `%o`ï¼šæ•´æ•° (å…«è¿›åˆ¶)ã€‚
> - `%x`ï¼Œ`%X`ï¼šæ•´æ•° (åå…­è¿›åˆ¶)ã€‚
> - `%f`ï¼šæµ®ç‚¹æ•°ã€‚
> - `%e`ï¼Œ`%E`ï¼šç§‘å­¦è®¡æ•°æ³•æ ¼å¼çš„æµ®ç‚¹æ•°ã€‚
> - `%s`ï¼šå­—ç¬¦ä¸²ã€‚
> - `%q`ï¼šåŒå¼•å·å›´ç»•çš„å­—ç¬¦ä¸²ã€‚
> - `%t`ï¼šå¸ƒå°”å€¼ã€‚
> - `%p`ï¼šåœ°å€
> - `%U`ï¼šUnicode æ ¼å¼ï¼Œå¦‚ U+4F60
> - `%q`ï¼šå¸¦å¼•å·çš„å­—ç¬¦(ä¸²)

```go
i := 580
s := "hello"
fmt.Printf("æ•´æ•°: %d ", i)
fmt.Printf("å­—ç¬¦ä¸²: %s ", s)
fmt.Printf("å¸ƒå°”å€¼: %t\n", true)
```

è¾“å‡º

```
123 å­—ç¬¦ä¸²: hello å¸ƒå°”å€¼: true
```

å ä½ç¬¦å˜é‡ç¼ºå¤±ä¸ä¼šæŠ¥é”™ï¼Œå ä½åœ°æ–¹å˜æˆå¦‚ `%!s(MISSING)` çš„å­—ç¬¦ä¸²ã€‚

æ•´æ•°æŒ‡æ•°ä¼šæŠ¥é”™ï¼š

```go
x4 := 1_000_000_007
fmt.Printf("%e %e\n", x4, float32(x4))
// %!e(int=1000000007) 1.000000e+09
```

å°æ•°ä¹Ÿå¯ä»¥äºŒè¿›åˆ¶è¾“å‡ºï¼Œå³ %x

```go
x := 1.0 / 4
fmt.Printf("%b %o %x", x, x, x)
// 4503599627370496p-54 %!o(float64=0.25) 0x1p-02
```

æµ®ç‚¹é»˜è®¤ 6 ä½ï¼š

```go
num := 2. / (2.5 + .5)
fmt.Printf("%f, %.2f, %T\n", num, num, num)
// 0.666667, 0.67, float64
```

é«˜ç²¾åº¦ç¬¬ä¸‰æ–¹åŒ…ï¼š[decimal](https://github.com/shopspring/decimal)

ç§‘å­¦è®¡æ•°æ³• 

```go
fmt.Printf("%f\n", 1e9+7) // å¤§å°å†™eéƒ½è¡Œ
```

åœ°å€ç›´æ¥ä¼ å…¥å˜é‡åå³å¯ï¼Œæ²¡æœ‰å–åœ°å€ç¬¦ä¹‹ç±»çš„ã€‚è¾“å‡ºå¦‚ `0xc0000200a0`

```go
fmt.Printf("%v %d %d %p\n", a, len(a), cap(a), a)
// [0 0 0 1] 4 5 0xc00000c420
```

##### è¾“å…¥

- `fmt.Scanf`ï¼Œç±»ä¼¼ C è¯­è¨€ï¼Œå ä½ç¬¦ä¹Ÿå·®ä¸å¤š

  ```go
  fmt.Scanf("%s %d", &name, &age)
  ```

- `fmt.Scan`ï¼Œè¯»å–å¤šä¸ªå˜é‡ï¼Œç›´åˆ°é‡åˆ°ç©ºç™½å­—ç¬¦

  ```go
  var name string
  var age int
  fmt.Print("Enter your name and age: ")
  fmt.Scan(&name, &age) // å¦‚è¾“å…¥ lr580 ç©ºæ ¼æˆ–å›è½¦ 580 å›è½¦
  fmt.Printf("Hello, %s! You are %d years old.\n", name, age)
  ```

- `fmt.Scanln`ï¼ŒåŒ Scanï¼Œé‡åˆ°æ¢è¡Œç»“æŸ

#### æ–‡ä»¶I/O

å¯èƒ½ä¼šç”¨åˆ°ï¼š`os` åŒ…å’Œ `io` åŒ…ã€‚ç¼“å†² `bufio` åŒ…

##### æ‰“å¼€

è®°å¾—å…³é—­ã€‚go é£æ ¼ç”³è¯·èµ„æºçš„æ—¶å€™ä¸‹ä¸€è¡Œå°±å¯ä»¥ defer å…³é—­ï¼Œè¿™æ ·å¯ä»¥æŒ‰ç…§ç”³è¯·é¡ºåºå…³é—­

```go
file, err := os.Open("lgo-022.go") // è¯»å–è‡ªå·±ï¼Œæˆ– ./lgo-022.go
defer file.Close()
if err != nil {
    fmt.Println("Error", err)
    return
}
fmt.Println(file) // åœ°å€å¦‚ &{0xc0000a06c8}
```

Open åå¾—åˆ° `*os.File`ï¼Œè¯¥ç±»å‹å®ç°äº† `os.Reader` æ–¹æ³•

> æ³¨æ„æ–‡ä»¶è¯»å†™ä¸æ˜¯äº’æ–¥çš„ï¼Œå­˜åœ¨è¯»çš„æ—¶å€™è¢«å†™çš„å¯èƒ½æ€§

##### è¯»å–

åˆ†å—è¯»ï¼š

```go
package main
import (
	"fmt"
	"io"
	"os"
)
func main() {
	file, err := os.Open("lgo-022.go")
	defer file.Close()
	if err != nil {
		fmt.Println("Error", err)
		return
	}
    
	var content []byte
	var tmp = make([]byte, 128)
	for {
		n, err := file.Read(tmp)
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Println("Error", err)
			return
		}
		content = append(content, tmp[:n]...)
	}
	fmt.Println(string(content)) // è¶³ä»¥å¤„ç†ä¸­æ–‡
}
```

ä¸€æ¬¡è¯»ï¼š

```go
content, err := os.ReadFile("filename.txt")
if err != nil {
    log.Fatal(err)
}
fmt.Println(string(content))
```

##### ç¼“å†²è¯»

Reader é€è¡Œè¯»ï¼Œå¦‚è¾“å‡ºè¡Œå·

```go
func testfile2(file *os.File) {
	reader := bufio.NewReader(file)
	for i := 1; ; i++ {
		line, err := reader.ReadString('\n')
		if len(line) != 0 {
			fmt.Printf("[%v] %v", i, line)
		}
		if err != nil {
			if err != io.EOF {
				fmt.Println("Error", err)
			}
			break
		}
	}
}
```

##### æ•´è¯»

åªéœ€è¦æ–‡ä»¶è·¯å¾„ï¼Œéå¸¸æ–¹ä¾¿çš„å°è£…æ–¹æ³•ã€‚

```go
func testfile3(path string) {
	content, err := os.ReadFile(path) // []byte
	if err != nil {
		fmt.Println("Error", err)
		return
	}
	fmt.Println(string(content))
}
// testfile3("lgo-022.go")
```

ä¹Ÿå¯ä»¥æ‹¿åˆ° `os.Reader` åè¯»ï¼š

```go
content, err2 := io.ReadAll(file)
if err2 != nil {
    fmt.Println("Error", err2)
    return
}
fmt.Println(string(content))
```

##### å†™å…¥

flag int æ¨¡å¼ï¼Œæˆ–èµ·æ¥ï¼Œå¸¸è§çš„æœ‰ï¼š

- `os.O_WRONLY` åªå†™
- `os.O_CREATE` åˆ›å»º (å·²å­˜åœ¨è¦†ç›–)
- `os.O_RDONLY` åªè¯»
- `os.O_RDWR` è¯»å†™
- `os.O_TRUNC` æ¸…ç©º
- `os.O_APPEND` è¿½åŠ 

perm æƒé™ï¼šå…«è¿›åˆ¶æ•° r è¯»04ï¼Œw å†™02ï¼Œx æ‰§è¡Œ01ï¼Œä¸‰ä¸ªå…«è¿›åˆ¶åˆ†åˆ«å¯¹åº”ä»é«˜åˆ°ä½æ˜¯æ–‡ä»¶æ‰€æœ‰è€…ã€ç»„ç”¨æˆ·ã€å…¶ä»–ç”¨æˆ·ã€‚`perm` å‚æ•°ç”¨äºæŒ‡å®šæ–°åˆ›å»ºæ–‡ä»¶çš„æƒé™ã€‚å¦‚æœæ–‡ä»¶å·²ç»å­˜åœ¨ï¼Œ`perm` å‚æ•°ä¼šè¢«å¿½ç•¥ã€‚

ç„¶åç”¨ `.WriteString` æˆ– `.Write` æ¥å†™ä¸œè¥¿ã€‚

```go
file, err := os.OpenFile("a.txt", os.O_CREATE|os.O_WRONLY, 0666)
if err != nil {
    fmt.Println("Error", err)
    return
}
defer file.Close()
str := "éšä¾¿\nå†™ç‚¹ä»€ä¹ˆ"
file.Write([]byte(str))
file.WriteString("å†å†™ç‚¹ä¸œè¥¿ï¼Œç¬¬äºŒç§å†™å…¥æ–¹æ³•")
```

##### ç¼“å†²å†™

å¯¹å¯å†™ flag æ–‡ä»¶ï¼š

```go
writer := bufio.NewWriter(file)
for i := 0; i < 10; i++ {
    writer.WriteString(fmt.Sprintf("ç¬¬%vè¡Œ\n", i+1))
}
writer.Flush()
```

##### ç›´æ¥å†™

```go
str := "Company Dream: It's My Go!!!!"
err := os.WriteFile("a.txt", []byte(str), 0666)
if err != nil {
    fmt.Println("Error", err)
    return
}
```

##### ioutil

> `ioutil` åŒ…ä¸­çš„ä¸€äº›å‡½æ•°å·²ç»è¢«ç§»åˆ°äº† `os` å’Œ `io` åŒ…ä¸­ï¼Œåœ¨æ–°ç‰ˆæœ¬æ˜¾ç¤º depreciated
>
> - `ioutil.WriteFile` â†’ `os.WriteFile`
> - `ioutil.ReadAll` â†’ `io.ReadAll`
> - `ioutil.ReadDir` â†’ `os.ReadDir`
> - `ioutil.TempFile` â†’ `os.CreateTemp`
> - `ioutil.TempDir` â†’ `os.MkdirTemp`

##### ä¸´æ—¶æ–‡ä»¶

å­˜æ”¾åœ¨ç³»ç»Ÿä¸´æ—¶ç›®å½•ï¼Œç³»ç»Ÿæœ‰å¯èƒ½ä¼šæ¸…ç†ï¼Œç”Ÿæˆå”¯ä¸€åå­—ã€‚

1.16+ åæ¨èçš„å†™æ³•ï¼š

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// åœ¨æŒ‡å®šç›®å½•åˆ›å»ºä¸´æ—¶æ–‡ä»¶, * è¡¨ç¤ºéšæœº
    // /tmp/sample.2116853806.tmp
	tmpFile, err := os.CreateTemp("/tmp", "sample.*.tmp")
    // os.CreateTemp(dir, "abc-") åˆ™åœ¨ abc- åè¾¹åŠ éšæœºæ•°å­—
	if err != nil {
		fmt.Println("åˆ›å»ºä¸´æ—¶æ–‡ä»¶å¤±è´¥:", err)
		return
	}
	defer os.Remove(tmpFile.Name())

	fmt.Printf("ä¸´æ—¶æ–‡ä»¶è·¯å¾„: %s\n", tmpFile.Name())

	// å†™å…¥å†…å®¹
	if _, err := tmpFile.Write([]byte{65, 66, 67}); err != nil {
		fmt.Println("å†™å…¥ä¸´æ—¶æ–‡ä»¶å¤±è´¥:", err)
		return
	}
}
```



#### æ—¥å¿—I/O

`log` åŒ…ã€‚è¾“å‡ºåˆ° stderr

```go
package main

import (
	"fmt"
	"log"
	"os"
)

func main() {
	// åŸºæœ¬æ—¥å¿—è¾“å‡º
	log.Println("è¿™æ˜¯ä¸€æ¡æ™®é€šæ—¥å¿—")

	// å¸¦å‰ç¼€çš„æ—¥å¿—
	log.SetPrefix("INFO: ")
	log.Println("è¿™æ˜¯ä¸€æ¡å¸¦å‰ç¼€çš„æ—¥å¿—")

	// è¾“å‡ºåˆ°æ–‡ä»¶
	file, err := os.OpenFile("app.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatal("æ— æ³•æ‰“å¼€æ—¥å¿—æ–‡ä»¶:", err)
	}
	defer file.Close()
	log.SetOutput(file)
	log.Println("è¿™æ¡æ—¥å¿—ä¼šå†™å…¥æ–‡ä»¶") // ä¸ä¼šå†™åˆ°æ§åˆ¶å°
	// è¾“å‡ºå½¢å¦‚ INFO: 2025/10/02 18:25:04 è¿™æ¡æ—¥å¿—ä¼šå†™å…¥æ–‡ä»¶
    // ä¸Šé¢çš„è¾“å‡ºç±»ä¼¼ï¼Œæ ¼å¼å’Œè¿™ä¸ªä¸€æ ·

	// è‡´å‘½é”™è¯¯æ—¥å¿—ï¼ˆä¼šè°ƒç”¨os.Exit(1)ï¼‰
	if false {
		log.Fatal("è‡´å‘½é”™è¯¯")
		fmt.Println("è¿™æ¡ä¸ä¼šè¢«æ‰§è¡Œ")
	}

	// å¸¦å †æ ˆä¿¡æ¯çš„é”™è¯¯æ—¥å¿—ï¼ˆä¼šè°ƒç”¨panicï¼‰
	if false {
		log.Panic("ææ…Œé”™è¯¯")
		fmt.Println("è¿™æ¡ä¸ä¼šè¢«æ‰§è¡Œ")
	}
}
```



#### æ–‡ä»¶å¤„ç†

##### è·¯å¾„

åŒ… `path/filepath`ã€‚

`filepath.Dir`æ˜¯ Go è¯­è¨€æ ‡å‡†åº“ `path/filepath`åŒ…ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºè¿”å›è·¯å¾„å­—ç¬¦ä¸²ä¸­çš„ç›®å½•éƒ¨åˆ†

```go
fmt.Println(filepath.Dir("abc.txt"))          // "."
fmt.Println(filepath.Dir("gg/abc.txt"))       // "gg"
fmt.Println(filepath.Dir("/var/usr/abc.txt")) // "/var/usr"
```

æœç´¢ï¼š

```go
pattern := fmt.Sprintf("mr-*-%d", y)
files, err := filepath.Glob(pattern)
```



##### ç§»åŠ¨

ç§»åŠ¨/é‡å‘½åã€‚åªèƒ½åœ¨åŒä¸€ä¸ªç£ç›˜å†…æ“ä½œã€‚ä¿è¯æ˜¯åŸå­çš„ã€‚

```go
err := os.Rename("a.txt", "D:/a.txt") // å‰ªè´´æ–‡ä»¶
if err != nil {
    fmt.Println("Error", err)
    return
}
```

##### å¤åˆ¶

> ä¸€ç§æ‰‹å†™é€»è¾‘æ˜¯ï¼Œè¯»æ–‡ä»¶ï¼Œç„¶åæ–°å»ºæ–‡ä»¶å†™ï¼Œè¾¾åˆ°å¤åˆ¶çš„æ•ˆæœã€‚å¦ä¸€ç§é€»è¾‘æ˜¯æ–‡ä»¶æµã€‚å½“ç„¶éƒ½ä¸å¦‚è°ƒåº“ï¼š

```go
src, err := os.Open("lgo-022.go")
if err != nil {
    fmt.Println("Error", err)
    return
}
defer src.Close()

dst, err := os.Create("D:/a.txt") // æ–°å»ºæ–‡ä»¶
if err != nil {
    fmt.Println("Error", err)
    return
}
defer dst.Close()

len, err := io.Copy(dst, src)
if err != nil {
    fmt.Println("Error", err)
    return
}
fmt.Println("Copy", len, "bytes")
```

##### åˆ é™¤

`err := os.Remove(path)`ï¼Œä¹Ÿå¯ä»¥åšå‰ªè´´çš„äº‹ã€‚ä¹Ÿå¯ä»¥åˆ é™¤ï¼ˆç©ºï¼‰ç›®å½•ã€‚

åˆ é™¤ç›®å½• `os.RemoveAll`

```go
err = os.RemoveAll("abc")
if err != nil {
    fmt.Println("Error", err)
    return
}
```

##### è½ç›˜

os.file çš„æ–¹æ³•ï¼Œä½¿ç”¨ `Sync()` æ–¹æ³•ï¼Œç¡®ä¿ä»ç³»ç»Ÿå†…å­˜ç¼“å†²åŒºå†™å…¥ç£ç›˜ï¼Œå¦‚è§¦å‘ç³»ç»Ÿè°ƒç”¨ fsyncã€‚

#### ç›®å½•å¤„ç†

##### æ–°å»ºç›®å½•

å•å±‚å’Œå¤šå±‚ï¼š

```go
var err error
err = os.Remove("abc/") // æˆ– abc ä¹Ÿè¡Œ
if err != nil {
    fmt.Println("Error", err)
    return
}
err = os.Mkdir("abc", 0666) // æˆ– ./abc ./abc/ abc/
if err != nil {
    fmt.Println("Error", err)
    return
}
err = os.MkdirAll("abc/def/ghi", 0666)
if err != nil {
    fmt.Println("Error", err)
    return
}
```

### æ•°æ®ç»“æ„

#### slices

##### min/max

> å†…ç½®å‡½æ•° min, max ä¸èƒ½æ‹¿æ¥ç®—æ•°ç»„ï¼Œ`nums...` ä¹Ÿä¸è¡Œã€‚

```go
mn := slices.Min(nums)
mx := slices.Max(nums)
```

##### éå†

[backward](https://blog.csdn.net/bigwhite20xx/article/details/139346846) [0x3f](https://leetcode.cn/problems/solving-questions-with-brainpower/solutions/1213919/dao-xu-dp-by-endlesscheng-2qkc/?envType=daily-question&envId=2025-04-01) é€†å‘éå†ï¼š

```go
func mostPoints(questions [][]int) int64 {
    // ...
    for i, q := range slices.Backward(questions) { // ...
```

##### sort

```go
bs := []byte(strconv.Itoa(x))
slices.Sort(bs)
```

Go 1.21+ ä¸­å¼•å…¥çš„ä¸€ä¸ªæ³›å‹å‡½æ•°ï¼Œå¯¹ä»»ä½•å¯æ¯”è¾ƒçš„åˆ‡ç‰‡ç±»å‹ï¼ˆåŒ…æ‹¬ `int`ã€`float64`ã€`string` ç­‰ï¼‰è¿›è¡Œæ’åºã€‚

ç»“æ„ä½“æ’åº 

```go
slices.SortFunc(nums, func(a, b int) int { return b - a })
```

æ˜¯å¦å·²ç»æ’åºï¼š`sort.IntsAreSorted(arr)`

##### Reverse

ç¿»è½¬ã€‚`slices.Reverse(a)`

##### Compact

å¾—åˆ°æ–°æ•°ç»„ï¼Œä¹Ÿä¼šä¿®æ”¹åŸæ•°ç»„(ä½†åŸæ•°ç»„é•¿åº¦ä¸å˜ï¼Œåé¢çš„é¡¹ä¸ç¡®å®šæ˜¯åŸæ•°ç»„çš„é¡¹ï¼Œå¯èƒ½æ˜¯0)

```go
slices.Compact(nums)
```

##### ç›¸ç­‰

é•¿åº¦å’Œæ¯ä¸ªå…ƒç´ éƒ½ç›¸ç­‰

```go
reflect.DeepEqual(slice1, slice2) // true
```

#### sort

##### æ’åº

sort åŒ…å¯ä»¥å¯¹åˆ‡ç‰‡(ä½†ä¸èƒ½æ•°ç»„)æ’åº [æ–‡æ¡£](https://golang.org/src/sort)

```go
import (
	"fmt"
	"sort"
)
func h3() {
	a := []int{1, 4, 3, 7, 5, 8, 1}
	sort.Ints(a)
	fmt.Println(a)
}
```

å…¶ä»–ç±»å‹ï¼Œå¦‚ `sort.Float64s`, `sort.Strings`ã€‚

é€†åºæ’åºï¼š

```go
s := []string{"ABC", "abc", "0123", "ad"}
sort.Sort(sort.Reverse(sort.StringSlice(s)))
fmt.Println(s)
```

è‡ªå®šä¹‰æ’åºï¼Œå¦‚æŒ‰å¦ä¸€ä¸ªæ•°ç»„çš„å¤§å°æ’åºä¸‹æ ‡ 1

```go
func maxSubsequence(nums []int, k int) []int {
	n := len(nums)
	a := make([]int, n)
	for i := 0; i < n; i++ {
		a[i] = i
	}
	sort.Slice(a, func(i, j int) bool {
		return nums[a[i]] > nums[a[j]]
	})
    // ...
}
//ä¹Ÿå¯ä»¥å†™æˆï¼š
slices.SortFunc(idx, func(i, j int) int { return nums[j] - nums[i] })
```

å¦ä¸€ç§åŸºäºæ¥å£çš„è‡ªå®šä¹‰æ’åºï¼Œéœ€è¦å®ç°ä¸‰ä¸ªå‡½æ•°ï¼š[å‚è€ƒ](http://nil.csail.mit.edu/6.5840/2025/labs/lab-mr.html)

```go
type ByKey []mr.KeyValue // æŸç»“æ„ä½“
func (a ByKey) Len() int           { return len(a) }
func (a ByKey) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByKey) Less(i, j int) bool { return a[i].Key < a[j].Key }
```

##### äºŒåˆ†æŸ¥æ‰¾

å¦‚è¡¨ç°åŒ C++ lower_bound (upper æ”¹æˆ `>` å³å¯)

```go
i := sort.Search(n, func(i int) bool { return nums[i] >= k })
```

> ä¾‹å¦‚ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ª trueï¼Œå³è¾“å‡º 58ï¼š
>
> ```go
> func main() {
> 	x := sort.Search(100, func(x int) bool {
> 		return x >= 58
> 	})
> 	fmt.Println(x)
> }
> ```

ç®€åŒ–ï¼š

```go
i := sort.SearchInts(nums, k)
```

#### string

##### unicode

æ˜¯å¦æ˜¯æ•°å­—ï¼Œè½¬å°å†™ï¼Œæ˜¯å¦æ˜¯å­—æ¯

```go
func isValid(word string) bool {
    if len(word) < 3 {
        return false
    }
    hasVowel := false
    hasConsonant := false
    for _, c := range word {
        if unicode.IsLetter(c) {
            ch := unicode.ToLower(c)
            if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {
                hasVowel = true
            } else {
                hasConsonant = true
            }
        } else if !unicode.IsDigit(c) {
            return false
        }
    }
    return hasVowel && hasConsonant
}
```



### å®¹å™¨

#### heap

é»˜è®¤å°æ ¹å †ï¼Œè¦æ‰‹å†™ä¸€å †ä¸œè¥¿ã€‚ä¹Ÿå¯ä»¥ç”¨ç¬¬ä¸‰æ–¹åº“ã€‚

```go
package main

import (
	"container/heap"
	"fmt"
)

// å®šä¹‰å †å…ƒç´ ç±»å‹
type IntHeap []int

// å®ç°heap.Interfaceæ¥å£çš„æ–¹æ³•
func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] < h[j] } // æœ€å°å †
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}

func main() {
	var n, k int
	fmt.Scan(&n, &k)
	a := make([]int, n+1)
	for i := 1; i <= n; i++ {
		fmt.Scan(&a[i])
	}

	// åˆå§‹åŒ–å †
	h := &IntHeap{}
	heap.Init(h)

	for i := n; i >= 1; i-- {
		if i%k == 0 && h.Len() > 0 {
			heap.Pop(h)
		}
		heap.Push(h, -a[i]) // ä½¿ç”¨è´Ÿæ•°å®ç°æœ€å¤§å †æ•ˆæœ
	}

	var ans int64
	for h.Len() > 0 {
		v := heap.Pop(h).(int)
		ans += int64(-v)
	}
	fmt.Println(ans)
}
```

å¦‚ç½‘æ ¼å›¾ Dijkstra (åŠ›æ‰£3341)

```go
func minTimeToReach(moveTime [][]int) int {
	n, m := len(moveTime), len(moveTime[0])
	d := make([][]int, n)
	v := make([][]bool, n)
	for i := range d {
		d[i] = make([]int, m)
		v[i] = make([]bool, m)
		for j := range d[i] {
			d[i][j] = math.MaxInt32
		}
	}

	dirs := [][]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}
	d[0][0] = 0
	q := &PriorityQueue{}
	heap.Push(q, State{0, 0, 0})

	for q.Len() > 0 {
		s := heap.Pop(q).(State)
		if v[s.x][s.y] {
			continue
		}
		v[s.x][s.y] = true
		for _, dir := range dirs {
			nx, ny := s.x + dir[0], s.y + dir[1]
			if nx < 0 || nx >= n || ny < 0 || ny >= m {
				continue
			}
			dist := max(d[s.x][s.y], moveTime[nx][ny]) + 1
			if d[nx][ny] > dist {
				d[nx][ny] = dist
				heap.Push(q, State{nx, ny, dist})
			}
		}
	}

	return d[n - 1][m - 1]
}

type State struct {
	x, y, dis int
}

type PriorityQueue []State

func (pq PriorityQueue) Len() int           { 
    return len(pq) 
}

func (pq PriorityQueue) Less(i, j int) bool { 
    return pq[i].dis < pq[j].dis 
}

func (pq PriorityQueue) Swap(i, j int) { 
    pq[i], pq[j] = pq[j], pq[i] 
}

func (pq *PriorityQueue) Push(x interface{}) { 
    *pq = append(*pq, x.(State)) 
}

func (pq *PriorityQueue) Pop() interface{} {
	old := *pq
	n := len(old)
	x := old[n - 1]
	*pq = old[:n - 1]
	return x
}
```

#### åç¼€æ•°ç»„

å¦‚åŠ›æ‰£ 3403ï¼Œå–å­—å…¸åºæœ€å¤§çš„åç¼€çš„é•¿ä¸º n-k+1 çš„å‰ç¼€

```go
package main

import (
	"index/suffixarray"
	"unsafe"
)

func answerString(s string, k int) string {
	if k == 1 {
		return s
	}
	sa := (*struct {
		_  []byte
		sa []int32
	})(unsafe.Pointer(suffixarray.New([]byte(s)))).sa
	n := len(s)
	i := int(sa[n-1])
	return s[i:min(i+n-k+1, n)]
}
```

### æ•°å­¦

#### math

##### å¸¸é‡

`math.MinInt` ç­‰ã€‚

##### å‡½æ•°

```go
func Abs(x float64) float64 // å¯¹äºæ•´æ•°ç±»å‹ï¼ŒGo è¯­è¨€æ²¡æœ‰å†…ç½®çš„ç»å¯¹å€¼å‡½æ•°
func Pow(i, p float64) float64
sin, cos := math.Sincos(2 * math.Pi)
math.Hypot(a, b) // æ±‚ç›´è§’ä¸‰è§’å½¢æ–œè¾¹é•¿
```

##### ä½è¿ç®—

```go
package main
import (
	"fmt"
	"math/bits"
)
func main() {
	x := uint(0b11010101)         // äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œåè¿›åˆ¶ä¸º 213
	fmt.Printf("Number: %b\n", x) // å¿…é¡»è¦uint
	fmt.Printf("Number of set bits: %d\n", bits.OnesCount(x)) // 5

	// å¯¹äºä¸åŒå¤§å°çš„æ•´æ•°æœ‰å¯¹åº”çš„å‡½æ•°
	var y uint64 = 0xFFFFFFFFFFFFFFFF
	fmt.Printf("OnesCount64(%064b) = %d\n", y, bits.OnesCount64(y)) // 64
}
```

```go
var x uint32 = 0b1000 // 28, 3
fmt.Printf("Leading zeros: %d\n", bits.LeadingZeros32(x))
fmt.Printf("Trailing zeros: %d\n", bits.TrailingZeros32(x))
var y uint64 = 0b1000 // 60, 3
fmt.Printf("Leading zeros: %d\n", bits.LeadingZeros64(y))
fmt.Printf("Trailing zeros: %d\n", bits.TrailingZeros64(y))
```

```go
var x uint = 1023 // 10
fmt.Printf("Len of %d: %d bits\n", x, bits.Len(x))
var y uint64 = 1 << 63 // 64
fmt.Printf("Len of %d: %d bits\n", y, bits.Len64(y))
```

##### å¤§æ•´æ•°

- `NewInt` åˆ›å»ºå¤§æ•´æ•°
- `Lsh` å®ç°å·¦ç§»ä½æ“ä½œ
- `Or` å®ç°æŒ‰ä½æˆ–æ“ä½œ
- `Bit` æ£€æŸ¥ç‰¹å®šä½çš„å€¼

```go
import "math/big"
// ... 
f := big.NewInt(1)
p := new(big.Int)
for _, x := range nums { // nums []int
    f.Or(f, p.Lsh(f, uint(x)))
}
return f.Bit(s) == 1 // s int
```

##### éšæœº

```go
package main
import (
	"fmt"
	"math/rand"
	"time"
)
func main() {
	// è®¾ç½®éšæœºç§å­ï¼ˆç¡®ä¿æ¯æ¬¡è¿è¡Œç»“æœä¸åŒï¼‰
	rand.Seed(time.Now().UnixNano())
	// ç”Ÿæˆ [0, 100) çš„éšæœºæ•´æ•°
	n := rand.Intn(100)
	fmt.Println(n)
}
```

æˆ–è€… `import crand "crypto/rand"`

#### hash

FNV(Fowler-Noll-Vo)å“ˆå¸Œç®—æ³•ï¼Œå…·ä½“æ˜¯FNV-1aå˜ç§ï¼š

- è¿™æ˜¯ä¸€ç§éåŠ å¯†å‹å“ˆå¸Œå‡½æ•°ï¼Œé€Ÿåº¦å¿«ï¼Œé€‚åˆå“ˆå¸Œè¡¨ç­‰ç”¨é€”
- `fnv.New32a()`åˆ›å»ºäº†ä¸€ä¸ª32ä½çš„FNV-1aå“ˆå¸Œå¯¹è±¡

```go
import "hash/fnv"
func ihash(key string) int {
	h := fnv.New32a()
	h.Write([]byte(key))
	return int(h.Sum32() & 0x7fffffff)
}
```

ç®—æ³•è¿‡ç¨‹ï¼šåœ¨åˆå§‹å€¼åŸºç¡€ä¸Šï¼Œå¾ªç¯æ‰§è¡Œï¼šå¼‚æˆ–æ¯ä¸ªå­—èŠ‚ã€ä¹˜ä¸Šå¸¸è´¨æ•°ã€‚

### è¯­æ³•å¢å¼º

#### plugin

åŠ¨æ€åŠ è½½å’Œä½¿ç”¨ç¼–è¯‘å¥½çš„ Go æ’ä»¶ã€‚è¿™ä¸ªåŠŸèƒ½ä» Go 1.8 ç‰ˆæœ¬å¼€å§‹å¼•å…¥

##### æ’ä»¶

æ’ä»¶ï¼šä¸€ä¸ªç¼–è¯‘ä¸º `.so` æ–‡ä»¶ï¼ˆåœ¨ Unix ç³»ç»Ÿä¸Šï¼‰çš„ Go åŒ… [å‚è€ƒ](http://nil.csail.mit.edu/6.5840/2025/labs/lab-mr.html)ï¼Œç¼–è¯‘æ’ä»¶ï¼š

```sh
go build -buildmode=plugin ../mrapps/wc.go
```

> `.so` æ–‡ä»¶ä¼šæ¯”è¾ƒå¤§ï¼Œå¯èƒ½æœ€åŸºç¡€çš„ä»£ç å°±å‡  MB äº†ã€‚

æ’ä»¶ä»£ç éœ€è¦æ»¡è¶³ä»¥ä¸‹è¦æ±‚ï¼š

- å¿…é¡»æ˜¯ `main` åŒ…
- éœ€è¦å¯¼å‡ºï¼ˆå¤§å†™å¼€å¤´ï¼‰ä½ æƒ³è¦åœ¨ä¸»ç¨‹åºä¸­ä½¿ç”¨çš„ç¬¦å·ï¼ˆå˜é‡ã€å‡½æ•°ç­‰ï¼‰

##### åŠ è½½

```go
// testplugin.go
package main

import "fmt"

var V int = 580

func F() {
    fmt.Printf("Hello from plugin! V=%d\n", V)
}
```

```go
package main

import (
	"fmt"
	"plugin"
)

func main() {
	p, err := plugin.Open("testplugin.so")
	if err != nil {
		panic(err)
	}
	v, err := p.Lookup("V")
	if err != nil {
		panic(err)
	}
	f, err := p.Lookup("F")
	if err != nil {
		panic(err)
	}
	fmt.Println(*v.(*int))
	f.(func())()
	// æ›´å¸¸ç”¨ï¼šå…ˆè½¬å†ç”¨
	// val := v.(*int)
	// fmt.Println(*val)
	// fv := f.(func())
	// fv()
}
```



#### cmp

##### compare

`cmp.Compare`æ¯”è¾ƒä¸¤ä¸ªæœ‰åºç±»å‹çš„å€¼ `x`å’Œ `y`ï¼Œå¹¶è¿”å›ï¼š

- å¦‚æœ `x < y`ï¼Œè¿”å› -1
- å¦‚æœ `x == y`ï¼Œè¿”å› 0
- å¦‚æœ `x > y`ï¼Œè¿”å› +1

```go
fmt.Println(cmp.Compare(1, 2))    // -1
```

##### or

1.22 ç‰ˆæœ¬

```go
fmt.Println(cmp.Or("", "default", "backup")) // è¾“å‡º: "default"
```

å¸¸ç”¨ï¼šå½“éœ€è¦ä»å¤šä¸ªå€™é€‰å€¼ä¸­é€‰æ‹©ç¬¬ä¸€ä¸ªæœ‰æ•ˆå€¼æ—¶ï¼ˆå¦‚é…ç½®ä¼˜å…ˆçº§ï¼‰

ç»“æ„ä½“æ’åºæ¡ä»¶åˆ¤æ–­ï¼š

```go
return cmp.Or(a.price-b.price, a.shop-b.shop)
```

#### testing

å‚è§ `åŸºæœ¬æ¦‚å¿µ/ä½¿ç”¨/æµ‹è¯•`ã€‚

##### Testå‡½æ•°

æ”¯æŒè¾“å‡ºï¼Œå¦‚å•å…ƒæµ‹è¯•ï¼š

```go
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    expected := 5
    if result != expected {
        t.Errorf("Add(2, 3) = %d; want %d", result, expected)
    }
}
```

åªæµ‹è¯•å« `Reliable` å‡½æ•°åçš„å‡½æ•°

```sh
go test -v -run Reliable
```

##### Exampleå‡½æ•°

éªŒè¯è¾“å‡ºæ˜¯å¦åˆç†ï¼Œä¸åˆç†å°±æŠ¥é”™ï¼Œå¿…é¡»è¦æœ‰ output æ‰ä¼šæ‰§è¡Œï¼Œå¦åˆ™ä¸æ‰§è¡Œ

```go
func ExamplePrint() {
	// å¦‚æœoutputä¸æ˜¯é‚£æ ·ï¼Œå°±ä¼šæŠ¥é”™
	fmt.Println("Learning Go testing")
	// Output: Learning Go testing
}

func ExamplePrint2() {
	fmt.Println("Will not call this function")
}

func ExampleMultiLine() { // å¦‚æœæœ‰è¾“å‡ºç©ºè¡Œä¹Ÿè¦å£°æ˜
    fmt.Println("Line 1")
    fmt.Println("Line 2")
    // Output:
    // Line 1
    // Line 2
}
```

æ— åºåŒ¹é…ï¼Œæ–¹ä¾¿ map

```go
func ExampleUnordered() {
    for _, v := range []int{1, 2, 3} {
        fmt.Println(v)
    }
    // Unordered output:
    // 2
    // 1
    // 3
}
```

æ­¤å¤–ï¼ŒExample å¼€å¤´çš„ä¹Ÿå¯ç”¨äºæ–‡æ¡£ç”Ÿæˆã€‚

##### testing.Tå‚æ•°

è¡¨æ ¼é©±åŠ¨æµ‹è¯•ï¼ˆTable-Driven Testsï¼‰ ï¼ŒæŠŠå¤šä¸ªæµ‹è¯•ç”¨ä¾‹ç»„ç»‡æˆä¸€ä¸ªè¡¨æ ¼

```go
func TestAddTableDriven(t *testing.T) {
    // å®šä¹‰ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹çš„ç»“æ„ä½“æ•°ç»„
    tests := []struct {
        name     string // æµ‹è¯•ç”¨ä¾‹çš„åç§°ï¼ˆç”¨äºæ ‡è¯†ï¼‰
        a, b     int    // è¾“å…¥å‚æ•°
        expected int    // æœŸæœ›çš„è¾“å‡º
    }{
        {"add positives", 2, 3, 5},  // æµ‹è¯•ç”¨ä¾‹1ï¼šæ­£æ•°ç›¸åŠ 
        {"add zeros", 0, 0, 0},      // æµ‹è¯•ç”¨ä¾‹2ï¼šé›¶ç›¸åŠ 
        {"add negatives", -1, -1, -2}, // æµ‹è¯•ç”¨ä¾‹3ï¼šè´Ÿæ•°ç›¸åŠ 
    }

    // éå†æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹
    for _, tt := range tests {
        // ä½¿ç”¨ t.Run è¿è¡Œå­æµ‹è¯•ï¼Œå¹¶æ˜¾ç¤ºæµ‹è¯•ç”¨ä¾‹åç§°
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b) // è°ƒç”¨è¢«æµ‹å‡½æ•°
            if result != tt.expected {
                // å¦‚æœç»“æœä¸ç¬¦åˆé¢„æœŸï¼ŒæŠ¥é”™
                t.Errorf("Add(%d, %d) = %d; want %d", tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

æ”¯æŒåŸºå‡†æµ‹è¯•ã€‚

### æ—¶é—´

#### time

##### Now

Time å¯¹è±¡ã€‚å–å½“å‰æ—¶é—´

```go
now := time.Now()
fmt.Println(now)
// 2025-03-12 18:29:48.5373521 +0800 CST m=+0.000000001
year := now.Year()
month := now.Month()
day := now.Day()
hour := now.Hour()
minute := now.Minute()
second := now.Second()
fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)
```

> ```go
> // 24 å°æ—¶åˆ¶
> fmt.Println(now.Format("2006-01-02 15:04:05"))
> // 12 å°æ—¶åˆ¶
> fmt.Println(now.Format("2006-01-02 03:04:05"))
> fmt.Println(now.Format("2006/01/02 15:04"))
> fmt.Println(now.Format("15:04 2006/01/02"))
> fmt.Println(now.Format("2006/01/02"))
> ```
>
> è¾“å‡ºçš„æ˜¯ now çš„æ—¶é—´ï¼Œä½†æ˜¯æŒ‰ format çš„æ ¼å¼

##### æ„é€ 

åŸºäºæ—¶é—´æˆ³æˆ–å­—ç¬¦ä¸²æ„é€ 

æ—¶é—´æˆ³æ˜¯è‡ª 1970 å¹´ 1 æœˆ 1 æ—¥ï¼ˆ08:00:00GMTï¼‰ è‡³å½“å‰æ—¶é—´çš„æ€»æ¯«ç§’æ•°ã€‚ å®ƒä¹Ÿè¢«ç§°ä¸º Unix æ—¶é—´æˆ³ï¼ˆUnixTimestampï¼‰ ã€‚

åŸºäºæ—¶é—´æˆ³å¯ä»¥æ„é€ ä¸Šé¢çš„ Time å¯¹è±¡ã€‚

Time è½¬æ—¶é—´æˆ³ï¼š

```go
timestamp1 := now.Unix() //æ—¶é—´æˆ³
timestamp2 := now.UnixNano() //çº³ç§’æ—¶é—´æˆ³
fmt.Printf("current timestamp1:%v\n", timestamp1)
fmt.Printf("current timestamp2:%v\n", timestamp2)
// 1741775621 1741775621568192500
```

æ—¶é—´æˆ³è½¬ Timeï¼š

```go
var timestamp int64 = 1587880013
timeObj := time.Unix(timestamp, 0) //å°†æ—¶é—´æˆ³è½¬ä¸ºæ—¶é—´æ ¼å¼
year := timeObj.Year() //å¹´
// ... åŒä¸Šé¢
fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)
```

å­—ç¬¦ä¸²è½¬ Time è½¬æ—¶é—´æˆ³ï¼š

```go
t := "2019-01-08 13:50:30"            //æ—¶é—´å­—ç¬¦ä¸²
timeTemplate := "2006-01-02 15:04:05" //å¸¸è§„ç±»å‹
stamp, _ := time.ParseInLocation(timeTemplate, t, time.Local)
fmt.Println(stamp.Unix())
```

##### æ—¶é—´é—´éš”

time.Duration æ˜¯ time åŒ…å®šä¹‰çš„ä¸€ä¸ªç±»å‹(æœ¬è´¨ä¸Šæ˜¯int64ï¼ŒåŸºæœ¬å•ä½æ˜¯çº³ç§’)ï¼Œ å®ƒä»£è¡¨ä¸¤ä¸ªæ—¶é—´ç‚¹ä¹‹é—´ç»è¿‡çš„æ—¶é—´ï¼Œ ä»¥çº³ç§’ä¸ºå•ä½ã€‚ time.Duration è¡¨ç¤ºä¸€æ®µæ—¶é—´é—´éš”ï¼Œ å¯è¡¨ç¤ºçš„æœ€é•¿æ—¶é—´æ®µå¤§çº¦ 290 å¹´  

time åŒ…ä¸­å®šä¹‰çš„æ—¶é—´é—´éš”ç±»å‹çš„å¸¸é‡å¦‚ä¸‹  

```go
const (
    Nanosecond Duration = 1
    Microsecond = 1000 * Nanosecond
    Millisecond = 1000 * Microsecond
    Second = 1000 * Millisecond
    Minute = 60 * Second
    Hour = 60 * Minute
)
```

##### è¿ç®—

åŸºäºæ—¶é—´é—´éš”ï¼Œè¿ç®—åŠ å‡å’Œæ¯”è¾ƒã€‚æ–¹æ³•æœ‰ï¼š

- Add åšæ—¶é—´åŠ å‡

- Sub æ±‚ä¸¤ä¸ªæ—¶é—´çš„é—´éš”

  `time.Since(x)` æ±‚ä» `x` æ—¶é—´åˆ°å½“å‰æ—¶é—´çš„é—´éš”

- Equal åˆ¤æ–­æ—¶é—´æ˜¯å¦ç›¸ç­‰

  Before, After åˆ¤æ–­æ˜¯å¦åœ¨å‚æ•°æ—¶é—´ä¹‹å‰/å

```go
now := time.Now()
later := now.Add(time.Hour)
fmt.Println(later)
dur := later.Sub(now)
fmt.Println(dur)         // 1h0m0s
fmt.Println(dur.Hours()) // 1
fmt.Println(now.Sub(later))
fmt.Println(now.Equal(later.Add(now.Sub(later))))
fmt.Println(now.Before(later), later.After(now)) // all true
```

##### å®šæ—¶å™¨

æ¯ä¸€ç§’æ‰§è¡Œä¸€æ¬¡ï¼š

```go
ticker := time.NewTicker(time.Second)
n := 0
for i := range ticker.C { // for range ticker.C {
    fmt.Println(i)
    // i æ˜¯ Time, è¾“å‡ºå½“å‰æ—¶é—´ (ä¸æ–­ä¸¥æ ¼+1s)
    n++
    if n > 5 {
        ticker.Stop()
        break
    }
}
```

##### sleep

```go
fmt.Println("abc")
time.Sleep(time.Second)
// time.Sleep(2*time.Second)
fmt.Println("abc again 1 sec later")
```

##### è®¡æ—¶å™¨

```go
start := time.Now()
var x int64 = 580
for i := 0; i < 1e8; i++ {
    x += int64(i)
}
fmt.Println(x)
fmt.Println(time.Since(start)) // 13.3413ms
fmt.Println(time.Since(start).Microseconds()) // 13341
```

### æ–‡æœ¬å¤„ç†

#### regexp

`regexp` åŒ…ã€‚æ­£åˆ™è¡¨è¾¾å¼ï¼ŒåŒ¹é…ä¸€ä¸ªæˆ–æ‰€æœ‰ï¼Œæ£€æŸ¥æ˜¯å¦åŒ¹é…ã€è¿”å›å­ä¸²ã€ä¸‹æ ‡ã€‚

```go
re := regexp.MustCompile("[LR]+")
str := re.FindString(s)
```

#### json

JSON(JavaScript Object Notation) æ˜¯ä¸€ç§è½»é‡çº§çš„æ•°æ®äº¤æ¢æ ¼å¼ã€‚ æ˜“äºäººé˜…è¯»å’Œç¼–å†™ã€‚ åŒæ—¶ä¹Ÿæ˜“äºæœºå™¨è§£æå’Œç”Ÿæˆã€‚ RESTfull Api æ¥å£ä¸­è¿”å›çš„æ•°æ®éƒ½æ˜¯ json æ•°æ®  

åºåˆ—åŒ–å’Œååºåˆ—åŒ–ä¸»è¦é€šè¿‡"encoding/json"åŒ…

##### åºåˆ—åŒ–

```go
package main
import (
	"encoding/json"
	"fmt"
)
type Student struct {
	ID     int
	Gender string
	name   string // ç§æœ‰
	Sno    string
}
func main() {
	{
		s1 := Student{1, "ç”·", "å¼ ä¸‰", "480"}
		var s, _ = json.Marshal(s1) // s:[]byte
		fmt.Println(s, string(s))
        // [123 34 73 68 34 58 49 44 34 71 101 110 100 101 114 34 58 34 231 148 183 34 44 34 83 110 111 34 58 34 52 56 48 34 125] {"ID":1,"Gender":"ç”·","Sno":"480"}
	}
}
```

ç¬¬äºŒä¸ªè¿”å›å€¼æ˜¯é”™è¯¯ä¿¡æ¯ï¼Œå¯ä»¥ `if err != nil` åˆ¤æ–­å¤±è´¥ã€‚

å¯¹åµŒå¥—ç»“æ„ä½“ã€æ•°ç»„ç­‰åŒç†ã€‚

> ç©ºåˆ‡ç‰‡å¾—åˆ° [], nil åˆ‡ç‰‡å¾—åˆ° nullã€‚

##### ååºåˆ—åŒ–

æ¥ä¸Šä¾‹(Student)ã€‚

```go
var s2 Student
err := json.Unmarshal(s, &s2)
if err != nil {
    fmt.Println(err)
}
fmt.Println(s2) // {1 ç”·  480}
```

##### Tag

å¯ä»¥ç”¨æ ‡ç­¾ï¼Œ`json:"xxx"`ï¼Œä¿®æ”¹ json é‡Œå¯¹è¯¥å­—æ®µçš„å‘½åï¼›`xxx,omitempty` 

```go
type Node struct {
	PointX int `json:"x"`
	PointY int `json:"y,omitempty"`
}
// ...
p := []Node{Node{13, 31}, Node{3, 0}, Node{0, 1}}
for i := 0; i < len(p); i++ {
    s, _ := json.Marshal(p[i])
    fmt.Println(string(s))
    p2 := Node{}
    json.Unmarshal(s, &p2)
    fmt.Println(p2) // åªä¼šèµ‹å€¼jsonä¸­æœ‰çš„å­—æ®µï¼Œå…¶ä»–ä¿æŒåŸæœ¬çš„å€¼
}
```

#### gob

è¿›è¡Œç¼–ç å’Œè§£ç ï¼Œå®ƒæ˜¯ Go çš„å†…ç½®åŒ…ä¹‹ä¸€ï¼Œå¯ä»¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–ä»»æ„çš„ Go æ•°æ®ç±»å‹ï¼Œæ¯”æ‰‹å·¥æ“ä½œè¦ç®€å•å¾—å¤š

### ç½‘ç»œ

#### rpc

æœåŠ¡ç«¯

```go
package main

import (
	"errors"
	"log"
	"net"
	"net/http"
	"net/rpc"
)

// å®šä¹‰æœåŠ¡ç»“æ„ä½“
type Arith struct{}

// å®šä¹‰æœåŠ¡æ–¹æ³•çš„å‚æ•°ç»“æ„
type Args struct {
    A, B int // ä¸€å®šè¦å…¬æœ‰(å¤§å†™)
    // å¦‚æœä¸æƒ³è¦ï¼Œå°±ä¼ ç©ºç»“æ„ä½“ï¼Œå³æ²¡æˆå‘˜å±æ€§ï¼Œä½¿ç”¨ï¼š&EmptyReply{}
}

// å®šä¹‰æœåŠ¡æ–¹æ³•çš„è¿”å›ç»“æ„
type Quotient struct {
	Quo, Rem int
}

// ä¸è¦å‚æ•°æˆ–è¿”å›å€¼å°± _ struct{}
// ä¹˜æ³•æ–¹æ³•
func (t *Arith) Multiply(args *Args, reply *int) error {
	*reply = args.A * args.B
	return nil
}

// é™¤æ³•æ–¹æ³•
func (t *Arith) Divide(args *Args, quo *Quotient) error {
	if args.B == 0 {
		return errors.New("divide by zero")
	}
	quo.Quo = args.A / args.B
	quo.Rem = args.A % args.B
	return nil
}

func main() {
	// æ³¨å†ŒæœåŠ¡
	arith := new(Arith)
	rpc.Register(arith)
	rpc.HandleHTTP()

	// å¯åŠ¨æœåŠ¡
	l, err := net.Listen("tcp", ":1234")
	if err != nil {
		log.Fatal("listen error:", err)
	}

	log.Println("Server started on port 1234")
	http.Serve(l, nil)
}
```

å®¢æˆ·ç«¯ï¼š

```go
package main

import (
	"fmt"
	"log"
	"net/rpc"
)

// ä¸æœåŠ¡ç«¯ç›¸åŒçš„å‚æ•°å’Œè¿”å›ç»“æ„
type Args struct {
	A, B int
}

type Quotient struct {
	Quo, Rem int
}

func main() {
	// è¿æ¥RPCæœåŠ¡
	client, err := rpc.DialHTTP("tcp", "localhost:1234")
	if err != nil {
		log.Fatal("dialing:", err)
	}

	// åŒæ­¥è°ƒç”¨ä¹˜æ³•
	args := &Args{7, 8}
	var reply int
	err = client.Call("Arith.Multiply", args, &reply)
	if err != nil {
		log.Fatal("arith error:", err)
	}
	fmt.Printf("Arith: %d*%d=%d\n", args.A, args.B, reply)

	// åŒæ­¥è°ƒç”¨é™¤æ³•
	args = &Args{15, 4}
	var quot Quotient // å¿…é¡»ä¿æŒå…¨éƒ¨æˆå‘˜å±æ€§éƒ½æ˜¯åˆå§‹å€¼
	err = client.Call("Arith.Divide", args, &quot)
	if err != nil {
		log.Fatal("arith error:", err)
	}
	fmt.Printf("Arith: %d/%d=%d remainder %d\n", args.A, args.B, quot.Quo, quot.Rem)

	// å¼‚æ­¥è°ƒç”¨ä¹˜æ³•
	args = &Args{9, 5}
	multiplyCall := client.Go("Arith.Multiply", args, &reply, nil)
	<-multiplyCall.Done // ç­‰å¾…è°ƒç”¨å®Œæˆ
	fmt.Printf("Async Arith: %d*%d=%d\n", args.A, args.B, reply)
}
```

æ‰§è¡Œï¼šä¸¤ä¸ªçª—å£åˆ†åˆ«

```sh
go run rpcserver.go
go run rpcclient.go
```

> å¦ä¸€ä¸ªä¾‹å­ï¼Œæœ¬æœº Unix é€šä¿¡ä½¿ç”¨ sockï¼Œå‚è§ [mit6.824](http://nil.csail.mit.edu/6.5840/2025/labs/lab-mr.html)ï¼Œæ”¹ä¸ºï¼š
>
> ```go
> net.Listen / DialHTTP("unix", sockname)
> ```

ç©ºçš„å¦‚ï¼šå‚è§æˆ‘çš„ mit6.824 å®ç°ã€‚

```go
func (c *Coordinator) Allocate(_ *struct{}, reply *AllocatedTask) error {
// æˆ–
type Empty struct{} // ç„¶åç”¨ _ *Empty
```



### åå°„

##### åŸºæœ¬æ¦‚å¿µ

> åå°„æ˜¯æŒ‡åœ¨ç¨‹åºè¿è¡ŒæœŸé—´å¯¹ç¨‹åºæœ¬èº«è¿›è¡Œè®¿é—®å’Œä¿®æ”¹çš„èƒ½åŠ›ã€‚ æ­£å¸¸æƒ…å†µç¨‹åºåœ¨ç¼–è¯‘æ—¶ï¼Œ å˜é‡è¢«è½¬æ¢ä¸ºå†…å­˜åœ°å€ï¼Œ å˜é‡åä¸ä¼šè¢«ç¼–è¯‘å™¨å†™å…¥åˆ°å¯æ‰§è¡Œéƒ¨åˆ†ã€‚ åœ¨è¿è¡Œç¨‹åºæ—¶ï¼Œ ç¨‹åºæ— æ³•è·å–è‡ªèº«çš„ä¿¡æ¯ã€‚ æ”¯æŒåå°„çš„è¯­è¨€å¯ä»¥åœ¨ç¨‹åºç¼–è¯‘æœŸå°†å˜é‡çš„åå°„ä¿¡æ¯ï¼Œ å¦‚å­—æ®µåç§°ã€ ç±»å‹ä¿¡æ¯ã€ç»“æ„ä½“ä¿¡æ¯ç­‰æ•´åˆåˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œ å¹¶ç»™ç¨‹åºæä¾›æ¥å£è®¿é—®åå°„ä¿¡æ¯ï¼Œ è¿™æ ·å°±å¯ä»¥åœ¨ç¨‹åºè¿è¡ŒæœŸè·å–ç±»å‹çš„åå°„ä¿¡æ¯ï¼Œ å¹¶ä¸”æœ‰èƒ½åŠ›ä¿®æ”¹å®ƒä»¬  
>

> ORM:å¯¹è±¡å…³ç³»æ˜ å°„ï¼ˆ Object Relational Mappingï¼Œ ç®€ç§° ORMï¼‰ æ˜¯é€šè¿‡ä½¿ç”¨æè¿°å¯¹è±¡å’Œæ•°æ®åº“ä¹‹é—´æ˜ å°„çš„å…ƒæ•°æ®ï¼Œ å°†é¢å‘å¯¹è±¡è¯­è¨€ç¨‹åºä¸­çš„å¯¹è±¡è‡ªåŠ¨æŒä¹…åŒ–åˆ°å…³ç³»æ•°æ®åº“ä¸­ã€‚

Golang æ”¯æŒçš„åå°„ï¼š

1. åå°„å¯ä»¥åœ¨ç¨‹åºè¿è¡ŒæœŸé—´åŠ¨æ€çš„è·å–å˜é‡çš„å„ç§ä¿¡æ¯ï¼Œ æ¯”å¦‚å˜é‡çš„ç±»å‹ ç±»åˆ«
2. å¦‚æœæ˜¯ç»“æ„ä½“ï¼Œ é€šè¿‡åå°„è¿˜å¯ä»¥è·å–ç»“æ„ä½“æœ¬èº«çš„ä¿¡æ¯ï¼Œ æ¯”å¦‚ç»“æ„ä½“çš„å­—æ®µã€ ç»“æ„ä½“çš„æ–¹æ³•ã€ ç»“æ„ä½“çš„ tag
3. é€šè¿‡åå°„ï¼Œ å¯ä»¥ä¿®æ”¹å˜é‡çš„å€¼ï¼Œ å¯ä»¥è°ƒç”¨å…³è”çš„æ–¹æ³•

Go å˜é‡åˆ†ä¸ºç±»å‹ä¿¡æ¯ï¼š é¢„å…ˆå®šä¹‰å¥½çš„å…ƒä¿¡æ¯ã€å€¼ä¿¡æ¯ï¼šç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­å¯åŠ¨æ€å˜åŒ–çš„ã€‚

åœ¨ GoLang çš„åå°„æœºåˆ¶ä¸­ï¼Œ ä»»ä½•æ¥å£å€¼éƒ½ç”±æ˜¯ä¸€ä¸ªå…·ä½“ç±»å‹å’Œå…·ä½“ç±»å‹çš„å€¼ä¸¤éƒ¨åˆ†ç»„æˆçš„ã€‚

åœ¨ GoLang ä¸­ï¼Œ åå°„çš„ç›¸å…³åŠŸèƒ½ç”±å†…ç½®çš„ reflect åŒ…æä¾›ï¼Œ ä»»æ„æ¥å£å€¼åœ¨åå°„ä¸­éƒ½å¯ä»¥ç†è§£ä¸ºç”± reflect.Type å’Œ reflect.Value ä¸¤éƒ¨åˆ†ç»„æˆ ï¼Œ å¹¶ä¸” reflect åŒ… æä¾›äº† reflect.TypeOf å’Œreflect.ValueOf ä¸¤ä¸ªé‡è¦å‡½æ•°æ¥è·å–ä»»æ„å¯¹è±¡çš„ Value å’Œ Type

åœ¨åå°„ä¸­å…³äºç±»å‹è¿˜åˆ’åˆ†ä¸ºä¸¤ç§ï¼š ç±»å‹ï¼ˆTypeï¼‰ å’Œç§ç±»ï¼ˆ Kindï¼‰ ã€‚ å› ä¸ºåœ¨ Go è¯­è¨€ä¸­æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ type å…³é”®å­—æ„é€ å¾ˆå¤šè‡ªå®šä¹‰ç±»å‹ï¼Œ è€Œç§ç±»ï¼ˆKindï¼‰ å°±æ˜¯æŒ‡åº•å±‚çš„ç±»å‹ï¼Œ ä½†åœ¨åå°„ä¸­ï¼Œå½“éœ€è¦åŒºåˆ†æŒ‡é’ˆã€ ç»“æ„ä½“ç­‰å¤§å“ç§çš„ç±»å‹æ—¶ï¼Œ å°±ä¼šç”¨åˆ°ç§ç±»ï¼ˆKindï¼‰ ã€‚ ä¸¾ä¸ªä¾‹å­ï¼Œ æˆ‘ä»¬å®šä¹‰äº†ä¸¤ä¸ªæŒ‡é’ˆç±»å‹å’Œä¸¤ä¸ªç»“æ„ä½“ç±»å‹ï¼Œ é€šè¿‡åå°„æŸ¥çœ‹å®ƒä»¬çš„ç±»å‹å’Œç§ç±»ã€‚  

> åå°„ä¸åº”è¯¥è¢«æ»¥ç”¨ï¼ŒåŸå› æœ‰ä»¥ä¸‹ä¸¤ä¸ªã€‚
>
> 1. åŸºäºåå°„çš„ä»£ç æ˜¯æå…¶è„†å¼±çš„ï¼Œ åå°„ä¸­çš„ç±»å‹é”™è¯¯ä¼šåœ¨çœŸæ­£è¿è¡Œçš„æ—¶å€™æ‰ä¼šå¼•å‘ panic é‚£å¾ˆå¯èƒ½æ˜¯åœ¨ä»£ç å†™å®Œçš„å¾ˆé•¿æ—¶é—´ä¹‹åã€‚
>
> 2. å¤§é‡ä½¿ç”¨åå°„çš„ä»£ç é€šå¸¸éš¾ä»¥ç†è§£
>
> å³å®‰å…¨æ€§ä¸è¶³ï¼Œæ€§èƒ½å·®ã€‚

##### TypeOf

åˆ†åˆ«è¾“å‡º name, kind

```go
package main

import (
	"fmt"
	"reflect"
)

func testReflect(x interface{}) {
	t := reflect.TypeOf(x)
	fmt.Println(t, t.Name(), t.Kind())
}
func main() {
	var x1 float32 = 12.5
	testReflect(x1)  // float32 float32 float32
	testReflect(100) // int int int
	var a *float32   // æ— è®ºæŒ‡å‘ä¸å¦ï¼Œè¾“å‡ºä¸€æ ·
	testReflect(a)   // *float32   ptr
	type myint int64 //è‡ªå®šä¹‰ç±»å‹
	var b myint
	testReflect(b) // main.myint myint int64
	// mainæ˜¯åŒ…çš„æ„æ€ï¼Œæ”¾å‡½æ•°å¤–ä¹Ÿæ˜¯main.myint
	var c rune     // åˆ«å
	testReflect(c) // int32 int32 int32
	type person struct {
		name string
		age  int
	}
	var d = person{"lr580", 580}
	testReflect(d) // main.person person struct
	var f = []int{99, 82, 44, 353}
	testReflect(f) // []int  slice
}
```

```go
type Kind uint
const (
    Invalid Kind = iota // éæ³•ç±»å‹
    Bool // å¸ƒå°”å‹
    Int // æœ‰ç¬¦å·æ•´å‹
    Int8 // æœ‰ç¬¦å· 8 ä½æ•´å‹
    Int16 // æœ‰ç¬¦å· 16 ä½æ•´å‹
    Int32 // æœ‰ç¬¦å· 32 ä½æ•´å‹
    Int64 // æœ‰ç¬¦å· 64 ä½æ•´å‹
    Uint // æ— ç¬¦å·æ•´å‹
    Uint8 // æ— ç¬¦å· 8 ä½æ•´å‹
    Uint16 // æ— ç¬¦å· 16 ä½æ•´å‹
    Uint32 // æ— ç¬¦å· 32 ä½æ•´å‹
    Uint64 // æ— ç¬¦å· 64 ä½æ•´å‹
    Uintptr // æŒ‡é’ˆ
    Float32 // å•ç²¾åº¦æµ®ç‚¹æ•°
    Float64 // åŒç²¾åº¦æµ®ç‚¹æ•°
    Complex64 // 64 ä½å¤æ•°ç±»å‹
    Complex128 // 128 ä½å¤æ•°ç±»å‹
    Array // æ•°ç»„
    Chan // é€šé“
    Func // å‡½æ•°
    Interface // æ¥å£
    Map // æ˜ å°„
    Ptr // æŒ‡é’ˆ
    Slice // åˆ‡ç‰‡
    String // å­—ç¬¦ä¸²
    Struct // ç»“æ„ä½“
    UnsafePointer // åº•å±‚æŒ‡é’ˆ
)
```

##### ValueOf

reflect.Value ä¸åŸå§‹å€¼ä¹‹é—´å¯ä»¥äº’ç›¸è½¬æ¢ï¼Œå¦‚ï¼š

```go
var a int64 = 100
v := reflect.ValueOf(a)
var av = v.Int() + 58 //int64
fmt.Println(v, av)    // 100, 158
fmt.Printf("%T\n", v) // reflect.Value
```

åŒç†æœ‰ `v.Float()` æ–¹æ³•ï¼Œå¯¹æµ®ç‚¹ç±»å‹ã€‚

switch åˆ¤æ–­ç±»å‹ (å¯ä»¥æ‹¿æ¥åˆ¤æ–­çš„ï¼Œè§ä¸Šæ–‡ Kind const)

```go
var a int64 = 100
k := reflect.ValueOf(a).Kind()
switch k {
case reflect.Int64:
    fmt.Println("int64")
// ...
default:
    fmt.Println("other")
}
```

##### Elem()

éœ€è¦æ³¨æ„å‡½æ•°å‚æ•°ä¼ é€’çš„æ˜¯å€¼æ‹·è´ï¼Œ å¿…é¡»ä¼ é€’å˜é‡åœ°å€æ‰èƒ½ä¿®æ”¹å˜é‡å€¼ã€‚ è€Œåå°„ä¸­ä½¿ç”¨ä¸“æœ‰çš„ Elem()æ–¹æ³•æ¥è·å–æŒ‡é’ˆå¯¹åº”çš„å€¼  

```go
var a int64 = 100
ad := &a // *int64
v = reflect.ValueOf(ad)
fmt.Println(v)  // 0xc0001060a8
v2 := v.Elem()  // å–åœ°å€å…ƒç´ å€¼
fmt.Println(v2) // 100
if v2.Kind() == reflect.Int64 {
    v2.SetInt(580) // åœ¨è¿™é‡Œå¯ä»¥ä¸åˆ¤æ–­ if
}
fmt.Println(a, v2) // 580 580
```

##### ç»“æ„ä½“

1. `Field(int)`  æ ¹æ®ç´¢å¼•ï¼Œ è¿”å›ç´¢å¼•å¯¹åº”çš„ç»“æ„ä½“å­—æ®µ
2. `NumField()` å‡ ä¸ªå­æ®µ
3. `FieldByName(string)` æ ¹æ®ç»™å®šå­—ç¬¦ä¸²è¿”å›å­—ç¬¦ä¸²å¯¹åº”çš„ç»“æ„ä½“å­—æ®µ
4. `FieldByNameFunc(match func(string) bool) (StructField,bool)` æ ¹æ®ä¼ å…¥çš„åŒ¹é…å‡½æ•°åŒ¹é…éœ€è¦çš„å­—æ®µ
5. `NumMethod() Int` è¿”å›è¯¥ç±»å‹çš„æ–¹æ³•é›†ä¸­æ–¹æ³•çš„æ•°ç›®
6. `Method(int)` è¿”å›è¯¥ç±»å‹æ–¹æ³•é›†ä¸­çš„ç¬¬ i ä¸ªæ–¹æ³•
7. `MethodByName(string)(Method, bool)` æ ¹æ®æ–¹æ³•åè¿”å›è¯¥ç±»å‹æ–¹æ³•é›†ä¸­çš„æ–¹æ³•

å­æ®µç»“æ„ä½“æœ‰çš„æˆå‘˜ï¼š[src](http://golang.org/ref/spec#Uniqueness_of_identifiers)

> ```go
> type StructField struct {
>     Name string // Name æ˜¯å­—æ®µçš„åå­—
>     PkgPath string //PkgPath æ˜¯éå¯¼å‡ºå­—æ®µçš„åŒ…è·¯å¾„ï¼Œ å¯¹å¯¼å‡ºå­—æ®µè¯¥å­—æ®µä¸º""
>     Type Type // å­—æ®µçš„ç±»å‹
>     Tag StructTag // å­—æ®µçš„æ ‡ç­¾
>     Offset uintptr // å­—æ®µåœ¨ç»“æ„ä½“ä¸­çš„å­—èŠ‚åç§»é‡
>     Index []int // ç”¨äº Type.FieldByIndex æ—¶çš„ç´¢å¼•åˆ‡ç‰‡
>     Anonymous bool // æ˜¯å¦åŒ¿åå­—æ®µ
> }
> ```

å¦‚ï¼šæŸ¥è¯¢ã€ä½¿ç”¨

```go
package main

import (
	"fmt"
	"reflect"
)

// studentç»“æ„ä½“
type Student struct {
	Name  string `json:"name1" form:"username"`
	Age   int    `json:"age"`
	Score int    `json:"score"`
}

func (s Student) GetInfo() string {
	var str = fmt.Sprintf("å§“å:%v å¹´é¾„:%v æˆç»©:%v", s.Name, s.Age, s.Score)
	return str
}

func (s *Student) SetInfo(name string, age int, score int) {
	s.Name = name
	s.Age = age
	s.Score = score
}

func (s Student) Print() {
	fmt.Println("è¿™æ˜¯ä¸€ä¸ªæ‰“å°æ–¹æ³•...")
}

// æ‰“å°å­—æ®µ
func PrintStructField(s interface{}) {

	//åˆ¤æ–­å‚æ•°æ˜¯ä¸æ˜¯ç»“æ„ä½“ç±»å‹
	t := reflect.TypeOf(s)
	v := reflect.ValueOf(s)
	if t.Kind() != reflect.Struct && t.Elem().Kind() != reflect.Struct {
		fmt.Println("ä¼ å…¥çš„å‚æ•°ä¸æ˜¯ä¸€ä¸ªç»“æ„ä½“")
		return
	}

	//1ã€é€šè¿‡ç±»å‹å˜é‡é‡Œé¢çš„Fieldå¯ä»¥è·å–ç»“æ„ä½“çš„å­—æ®µ
	field0 := t.Field(0)
	fmt.Printf("%#v \n", field0)      //reflect.StructField{Name:"Name", PkgPath:"", Type:(*reflect.rtype)(0x4adf20), Tag:"json:\"name\"", Offset:0x0, Index:[]int{0}, Anonymous:false}
	fmt.Println("å­—æ®µåç§°ï¼š", field0.Name) // Name (æŒ‰å®šä¹‰é¡ºåº)
	fmt.Println("å­—æ®µç±»å‹ï¼š", field0.Type)
	fmt.Println("å­—æ®µTagï¼š", field0.Tag.Get("json")) //name1
	fmt.Println("å­—æ®µTagï¼š", field0.Tag.Get("form"))
	//2ã€é€šè¿‡ç±»å‹å˜é‡é‡Œé¢çš„FieldByNameå¯ä»¥è·å–ç»“æ„ä½“çš„å­—æ®µ
	fmt.Println("----------------------")
	field1, ok := t.FieldByName("Age")
	if ok {
		fmt.Println("å­—æ®µåç§°ï¼š", field1.Name)
		fmt.Println("å­—æ®µç±»å‹ï¼š", field1.Type)
		fmt.Println("å­—æ®µTagï¼š", field1.Tag.Get("json"))
	}

	//3ã€é€šè¿‡ç±»å‹å˜é‡é‡Œé¢çš„NumFieldè·å–åˆ°è¯¥ç»“æ„ä½“æœ‰å‡ ä¸ªå­—æ®µ

	var fieldCount = t.NumField()
	fmt.Println("ç»“æ„ä½“æœ‰", fieldCount, "ä¸ªå±æ€§")

	//4ã€é€šè¿‡å€¼å˜é‡è·å–ç»“æ„ä½“å±æ€§å¯¹åº”çš„å€¼

	fmt.Println(v.FieldByName("Name"))
	fmt.Println(v.FieldByName("Age"))
	fmt.Println("----------------------")
	for i := 0; i < fieldCount; i++ {
		fmt.Printf("å±æ€§åç§°:%v å±æ€§å€¼:%v å±æ€§ç±»å‹:%v å±æ€§Tag:%v\n", t.Field(i).Name, v.Field(i), t.Field(i).Type, t.Field(i).Tag.Get("json"))
	}

}

// æ‰“å°æ‰§è¡Œæ–¹æ³•
func PrintStructFn(s interface{}) {

	t := reflect.TypeOf(s)
	v := reflect.ValueOf(s)
	if t.Kind() != reflect.Struct && t.Elem().Kind() != reflect.Struct {
		fmt.Println("ä¼ å…¥çš„å‚æ•°ä¸æ˜¯ä¸€ä¸ªç»“æ„ä½“")
		return
	}
	//1ã€é€šè¿‡ç±»å‹å˜é‡é‡Œé¢çš„Methodå¯ä»¥è·å–ç»“æ„ä½“çš„æ–¹æ³•
	method0 := t.Method(0)    //å’Œç»“æ„ä½“æ–¹æ³•çš„é¡ºåºæ²¡æœ‰å…³ç³»ï¼Œå’Œç»“æ„ä½“æ–¹æ³•çš„ASCIIæœ‰å…³ç³» // æŒ‰å­—å…¸åºæ’åº
	fmt.Println(method0.Name) //GetInfo
	fmt.Println(method0.Type) //func(*main.Student) string

	fmt.Println("--------------------------")
	//2ã€é€šè¿‡ç±»å‹å˜é‡è·å–è¿™ä¸ªç»“æ„ä½“æœ‰å¤šå°‘ä¸ªæ–¹æ³•

	method1, ok := t.MethodByName("Print")
	if ok {
		fmt.Println(method1.Name) //Print
		fmt.Println(method1.Type) //func(*main.Student)
	}
	fmt.Println("--------------------------")
	//3ã€é€šè¿‡ã€Šå€¼å˜é‡ã€‹æ‰§è¡Œæ–¹æ³• ï¼ˆæ³¨æ„éœ€è¦ä½¿ç”¨å€¼å˜é‡ï¼Œå¹¶ä¸”è¦æ³¨æ„å‚æ•°ï¼‰ v.Method(0).Call(nil) æˆ–è€…v.MethodByName("Print").Call(nil)
	// v.Method(1).Call(nil)
	v.MethodByName("Print").Call(nil) // ä¼šè°ƒç”¨, call ä¼ å…¥å‚æ•°è°ƒç”¨
	// å¾—åˆ°è¿”å›å€¼ info1
	info1 := v.MethodByName("GetInfo").Call(nil)
	fmt.Println(info1) //é•¿ä¸º1çš„æ•°ç»„ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯è¿”å›å€¼
	//4ã€æ‰§è¡Œæ–¹æ³•ä¼ å…¥å‚æ•° ï¼ˆæ³¨æ„éœ€è¦ä½¿ç”¨ã€Šå€¼å˜é‡ã€‹ï¼Œå¹¶ä¸”è¦æ³¨æ„å‚æ•°,æ¥æ”¶çš„å‚æ•°æ˜¯[]reflect.Valueçš„åˆ‡ç‰‡ï¼‰

	var params []reflect.Value
	params = append(params, reflect.ValueOf("æå››"))
	params = append(params, reflect.ValueOf(23))
	params = append(params, reflect.ValueOf(99))
	v.MethodByName("SetInfo").Call(params) //æ‰§è¡Œæ–¹æ³•ä¼ å…¥å‚æ•°

	info2 := v.MethodByName("GetInfo").Call(nil)
	fmt.Println(info2)

	// 5ã€è·å–æ–¹æ³•æ•°é‡

	fmt.Println("æ–¹æ³•æ•°é‡:", t.NumMethod())

}

func main() {
	stu1 := Student{
		Name:  "å°æ˜",
		Age:   15,
		Score: 98,
	}
	PrintStructField(stu1)
	PrintStructFn(&stu1)

	fmt.Printf("%#v\n", stu1) // main.Student{Name:"æå››", Age:23, Score:99}
}
```

å¦‚ï¼šä¿®æ”¹

```go
package main

import (
	"fmt"
	"reflect"
)

// studentç»“æ„ä½“
type Student struct {
	Name  string `json:"name"`
	Age   int    `json:"age"`
	Score int    `json:"score"`
}

// åå°„ä¿®æ”¹ç»“æ„ä½“å±æ€§
func reflectChangeStruct(s interface{}) {
	t := reflect.TypeOf(s)
	v := reflect.ValueOf(s)

	if t.Kind() != reflect.Ptr {
		fmt.Println("ä¼ å…¥çš„ä¸æ˜¯ç»“æ„ä½“æŒ‡é’ˆç±»å‹")
		return
	} else if t.Elem().Kind() != reflect.Struct {

		fmt.Println("ä¼ å…¥çš„ä¸æ˜¯ç»“æ„ä½“æŒ‡é’ˆç±»å‹")
		return
	}
	//ä¿®æ”¹ç»“æ„ä½“å±æ€§çš„å€¼
	name := v.Elem().FieldByName("Name")
	name.SetString("å°æ")

	age := v.Elem().FieldByName("Age")
	age.SetInt(22)

}
func main() {
	stu1 := Student{
		Name:  "å°æ˜",
		Age:   15,
		Score: 98,
	}
	reflectChangeStruct(&stu1)

	fmt.Printf("%#v\n", stu1) //main.Student{Name:"å°æ", Age:22, Score:98}
}
```



## ç¬¬ä¸‰æ–¹åŒ…

### æ•°æ®ç»“æ„

#### redblacktree

ä»¥ [è¿™ä¸ª](https://pkg.go.dev/github.com/emirpasic/gods@v1.18.1#section-readme) ä¸ºä¾‹

```sh
go get github.com/emirpasic/gods/trees/redblacktree
```

##### æ–°å»º

éæ³›å‹

```go
// prio2task *redblacktree.Tree
prio2task := redblacktree.NewWithIntComparator()
```

æ³›å‹

```go
t := redblacktree.New[int, struct{}]()
```

###### åµŒå¥—

ä¸¤ä¸ªçº¢é»‘æ ‘ç»„æˆæ•°ç»„ï¼Œé”® onlyï¼Œå€¼ any (å³ï¼Œå¯¹åº” C++ set)

```go
indices := [2]*redblacktree.Tree[int, struct{}]{
    redblacktree.New[int, struct{}](),
    redblacktree.New[int, struct{}](),
}
```

åµŒå¥— map

```go
type NumberContainers struct {
	indexToNumber   map[int]int
	numberToIndices map[int]*redblacktree.Tree[int, struct{}]
}

func Constructor() NumberContainers {
	return NumberContainers{map[int]int{}, map[int]*redblacktree.Tree[int, struct{}]{}}
}
```



##### ä½¿ç”¨

æ’å…¥ (ä¸Šæ–‡æ–°å»ºçš„ indices ä¸ºä¾‹) Put

```go
indices[i%2].Put(i, struct{}{})
```

éå† (æœ‰é™æ¬¡ä¸ºä¾‹)

```go
for i, it := 0, t.Iterator(); i < 5 && it.Next(); i++ {
    pr := it.Key() // ä¹Ÿå¯ä»¥å– it.Value()ï¼›éƒ½å¾—åˆ° Interafce{}
}
```

æŸ¥æ‰¾ 

- Ceiling è¿”å›ç¬¬ä¸€ä¸ªå¤§äºç­‰äº key çš„èŠ‚ç‚¹ï¼ŒæŸ¥æ—  nil
- Floor ç¬¬ä¸€ä¸ªå°äºç­‰äº key çš„ï¼ŒæŸ¥æ—  nil
- Get æŸ¥è¯¢æ°å¥½ç­‰äº key çš„ï¼ŒæŸ¥æ—  nil
- Left / Right æŸ¥è¯¢æœ€å¤§/æœ€å°å€¼ï¼Œè¿”å› node* æŒ‡é’ˆï¼Œå…¶ `.Key` æ˜¯é”®ï¼Œ`.Value` æ˜¯å€¼

æŸ¥è¯¢+åˆ é™¤ï¼šRemove (å¿…é¡»å­˜åœ¨ï¼Œå¦åˆ™ panic)

æ³¨æ„åˆ é™¤æ“ä½œä¼šä¿®æ”¹æŸ¥æ‰¾å‡ºæ¥çš„èŠ‚ç‚¹ï¼Œè¯·ä¿è¯åˆ é™¤åä¸å†ä½¿ç”¨èŠ‚ç‚¹

```go
for node, _ := t.Ceiling(mn); node.Key <= mx; node, _ = t.Ceiling(mn) { // _ æ˜¯æ˜¯å¦æŸ¥è¯¢åˆ°
    j := node.Key // å– key
    t.Remove(j) // åˆ é™¤ï¼Œæ­¤æ—¶nodeæŒ‡å‘å…¶ä»–èŠ‚ç‚¹
}
```

æœ€å€¼æŸ¥è¯¢ï¼š(å‡è®¾æ˜¯ int64ï¼ŒåŠ›æ‰£3408)

```go
if node := t.Right(); node != nil {
    val := node.Key.(int64)
}
```

##### è‡ªå®šä¹‰æ¯”è¾ƒ

å»ºè®®ä½¿ç”¨ cmp.Or ç®€åŒ–ï¼Œå‚è§æ³›å‹ä¸‹æ–‡ã€‚

åŠ›æ‰£3408ï¼Œint64å®ç°ä¸¤int32åšå…³é”®å­—çš„æ’åº(å‡åºï¼Œç±»ä¼¼ C++ pair int int)

```go
func Int64Comparator(a, b interface{}) int {
	av, bv := a.(int64), b.(int64)
	if av < bv {
		return -1
	}
	if av > bv {
		return 1
	}
	return 0
}
prio2task := redblacktree.NewWith(Int64Comparator)
func toMapId(taskId, priority int) int64 {
	return int64(priority)<<32 | int64(taskId)
}
func fromMapId(id int64) (int, int) { // prio, task
	return int(id >> 32), int(id & 0xffffffff)
}
this.prio2task.Put(toMapId(taskId, priority), nil)
node := this.prio2task.Right()
_, taskId := fromMapId(node.Key.(int64))
```

int[]æ¯”è¾ƒï¼ŒåŠ›æ‰£1912

```go
func Compare(x, y interface{}) int {
	a, b := x.([]int), y.([]int)
	other := b
	minLen := len(a)
	if len(other) < minLen {
		minLen = len(other)
	}
	for i := 0; i < minLen; i++ {
		if a[i] != other[i] {
			return a[i] - other[i]
		}
	}
	return len(a) - len(other)
}
```

##### æ³›å‹

æ³›å‹å¯ä»¥ä¸ç”¨ interface{} åšæ¯”è¾ƒå‚æ•°ï¼Œè¿˜å¯ä»¥ä¸ç”¨ç±»å‹æ–­è¨€ï¼ŒåŠ›æ‰£1912

```go
type entry struct{ price, shop, movie int }
var rentedMovies *redblacktree.Tree[entry, struct{}]
rentedMovies := redblacktree.NewWith[entry, struct{}](func(a, b entry) int {
    return cmp.Or(a.price-b.price, a.shop-b.shop, a.movie-b.movie)
})
rentedMovies.Put(entry{price, shop, movie}, struct{}{})
for it := rentedMovies.Iterator(); len(ans) < 5 && it.Next(); {
    ans = append(ans, []int{it.Key().shop, it.Key().movie})
}
```

#### treeset

ä»¥å¢åˆ ã€æŸ¥è¯¢æœ€å°å€¼ä¸ºä¾‹ï¼š(åŠ›æ‰£2349)

```go
package main

import (
	"github.com/emirpasic/gods/sets/treeset"
	"github.com/emirpasic/gods/utils"
)

type NumberContainers struct {
	a map[int]int
	b map[int]*treeset.Set
}

func Constructor() NumberContainers {
	return NumberContainers{
		a: make(map[int]int),
		b: make(map[int]*treeset.Set),
	}
}

func (this *NumberContainers) check(number int) {
	if _, ok := this.b[number]; !ok {
		this.b[number] = treeset.NewWith(utils.IntComparator)
	}
}

func (this *NumberContainers) Change(index int, number int) {
	if this.a[index] > 0 {
		old := this.a[index]
		this.b[old].Remove(index)
	}
	this.a[index] = number
	this.check(number)
	this.b[number].Add(index)
}

func (this *NumberContainers) Find(number int) int {
	this.check(number)
	if this.b[number].Size() == 0 {
		return -1
	}
	it := this.b[number].Iterator()
	if it.Next() {
		return it.Value().(int)
	}
	return -1
}

```

å¿…é¡»ç”¨æŒ‡é’ˆï¼Œå¦åˆ™ï¼Œå–å‡ºä¹‹åæ˜¯å‰¯æœ¬ï¼Œè¿˜è¦èµ‹å€¼å›å»ï¼Œå¦‚ï¼š

```go
if oldNumber, exists := this.a[index]; exists {
    if set, ok := this.b[oldNumber]; ok {
        set.Remove(index) // æ“ä½œå‰¯æœ¬
        this.b[oldNumber] = set // å¿…é¡»é‡æ–°èµ‹å€¼ï¼
    }
}
```

#### priorityqueue

```go
package main

import (
	"fmt"

	"github.com/emirpasic/gods/queues/priorityqueue"
	"github.com/emirpasic/gods/utils"
)

func main() {
	var n, k int
	fmt.Scan(&n, &k)
	a := make([]int, n+1)
	for i := 1; i <= n; i++ {
		fmt.Scan(&a[i])
	}
	pq := priorityqueue.NewWith(utils.IntComparator)
	for i := n; i >= 1; i-- {
		if i%k == 0 && pq.Size() > 0 {
			pq.Dequeue()
		}
		pq.Enqueue(-a[i])
	}
	var ans int64
	for _, v := range pq.Values() {
		ans += int64(-v.(int))
	}
	fmt.Println(ans)
}
```



### æ•°å€¼

```sh
go get github.com/shopspring/decimal
```

å‚è€ƒå®˜ç½‘æ–‡æ¡£ï¼Œå¦‚ï¼š

```go
fee, _ := decimal.NewFromString(".035")
taxRate, _ := decimal.NewFromString(".08875")
fmt.Println(fee.Add(taxRate)) // 0.12375
```



> # æ¡†æ¶
>
> ## Gin
>
> [å®˜ç½‘](https://gin-gonic.com/zh-cn/)
>
> ### åŸºç¡€
>
> #### å®‰è£…ä½¿ç”¨
>
> ```go
> go get -u github.com/gin-gonic/gin
> ```
>

