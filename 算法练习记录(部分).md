算法笔记的子集。按平台分类。建议搜索。为了防止目录过长，暂时将考虑按时间或专题分一个子目录。

## 洛谷

#### 杂题

#####  p1327-数列排序

> 长不超过 $10^5$ 不重复数列 ，每次只允许交换任意一对数，求最少交换多少次使数列升序

解法一：贪心 快排 

原数组和快排后新数组一一对比，发现不同就把原数组当前位置和新数组数在原数组的位置交换。

证明：(题解区 [LuffyLuo](https://blog.csdn.net/yunxiaoqinghe/article/details/113153795?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%9C%80%E5%B0%91%E4%BB%BB%E6%84%8F%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E8%AF%81%E6%98%8E%E7%94%A8%E7%BD%AE%E6%8D%A2&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-.pc_search_download_positive&spm=1018.2226.3001.4187))

对一个错位数，它要回到原位，它跟原位连有向边；然后对原位本来的数继续为错位数同上递推……最后可以画出带环图(正位是自环)。每个环交换次数为环长 $-1$ 。

因此，本题解法二可以用求环数的图论解法(DFS即可)来解。



##### p4051 字符加密

> 对一个长 $n$ 的字符串排成一圈，将其从第 $i$ 项开始取 $n$ 个字符组成共 $n$ 个长 $n$ 的字符串，将它们排序，然后输出它们的最后一个字符 $n\le 10^5$

不能直接取后缀数组。由于 `bnabn` 有 `bn<bnabn` ，而题意 `bnbna>bnabn` ，所以矛盾。可以按题意破圈为二倍长，然后取 `sa[i]` 在原长里的 $n$ 项。扩充后多余的部分不影响原题意的字典序排序，因为在跑到多余部分前，已经可以唯一区分开顺序。

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
#define mn 1000010
char s[mn];
ll n, sa[mn], rk[mn], oldrk[mn << 1], id[mn], px[mn], cnt[mn], n0;
bool cmp(ll x, ll y, ll w)
{
    return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];
}
ll m = 300, i, p, w; //ASCII范围<300为计数排序值域,p是新值域
signed main()
{
    scanf("%s", s + 1), n0 = strlen(s + 1), n = n0 * 2;
    for (ll i = 1; i <= n0; ++i)
    {
        s[i + n0] = s[i];
    }
    for (ll i = 1; i <= n; ++i)
    { //暂时以第一关键字为排序值，有很多同名并列
        ++cnt[rk[i] = s[i]];
    }
    for (ll i = 1; i <= m; ++i)
    {
        cnt[i] += cnt[i - 1];
    }
    for (ll i = n; i >= 1; --i)
    {
        sa[cnt[rk[i]]--] = i;
    }
    for (w = 1;; w <<= 1, m = p)
    {
        for (p = 0, i = n; i > n - w; --i)
        { //第二关键字排序；无穷小区域
            id[++p] = i;
        }
        for (ll i = 1; i <= n; ++i)
        {
            if (sa[i] > w)
            {
                id[++p] = sa[i] - w;
            }
        }
        memset(cnt, 0, sizeof cnt);
        for (ll i = 1; i <= n; ++i) //第一关键字排序
        {
            ++cnt[px[i] = rk[id[i]]]; //px是常数优化
        }
        for (ll i = 1; i <= m; ++i)
        {
            cnt[i] += cnt[i - 1];
        }
        for (ll i = n; i >= 1; --i)
        {
            sa[cnt[px[i]]--] = id[i];
        }
        memcpy(oldrk, rk, sizeof rk);
        for (p = 0, i = 1; i <= n; ++i) //重名并列
        {
            rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
        }
        if (p == n)
        {
            for (ll i = 1; i <= n; ++i)
            {
                sa[rk[i]] = i;
            }
            break;
        }
    }
    for (ll i = 1; i <= n; ++i)
    {
        if (sa[i] <= n0)
        {
            printf("%c", s[sa[i] + n0 - 1]);
        }
    }
    return 0;
}
```



##### p3629-巡逻

> 边长均 $1$ ，从根节点出发遍历每一条边然后回到根节点，现在可以加 $k(1\le k\le2)$ 条边，求加了边后遍历每一条边总路程最少为多少

树的直径好题。不加边总路程恒为 $2(n-1)$ 。$k=1$ 时直接在直径两边加边，可以使得直径少走一次，但多走了加的边，节省了 $d-1$ 的路程。

若 $k=2$ ，可以在原本基础上再找直径，已经是本来直径的边权改为 $-1$ (如果有环重合，那么重合部分还是要走两次)，跑 $DP$ 找直径，同理操作，又节省了 $d_2-1$ 的路程。

详细参考题解区 [Wow_Goodjob](https://www.luogu.com.cn/problem/solution/P3629)

代码如下：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 100010
ll n, k;
struct edge
{
    ll to, nx, w;
} e[mn << 1];
ll hd[mn], cnt, mx, id, dbf, daf, bg, ed, fr[mn], dis[mn];
bool fid;
map<ll, bool> m;
void adde(ll &u, ll &v)
{
    e[++cnt] = {v, hd[u], 1};
    hd[u] = cnt;
}
void dfs(ll u, ll fa, ll w)
{
    if (w >= mx)
    {
        mx = w, id = u;
    }
    for (ll i = hd[u]; i; i = e[i].nx)
    {
        if (e[i].to != fa)
        {
            dfs(e[i].to, u, w + e[i].w);
        }
    }
}

void dfs2(ll u, ll fa, ll t) //找直径上的全部点，形成链表
{
    if (fid)
    {
        return;
    }
    for (ll i = hd[u]; i; i = e[i].nx)
    {
        ll v = e[i].to;
        if (fid)
        {
            return;
        }
        if (v == fa)
        {
            continue;
        }
        if (v == t)
        {
            fr[u] = v, fid = true;
            return;
        }
        fr[u] = v;
        dfs2(v, u, t);
        if (fid)
        {
            return;
        }
    }
}

void dfs3(ll u, ll fa) //求带负权的树的直径的方法
{
    for (ll i = hd[u]; i; i = e[i].nx)
    {
        ll v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs3(v, u);
        daf = max(daf, dis[u] + dis[v] + e[i].w);
        dis[u] = max(dis[u], dis[v] + e[i].w);
    }
}

signed main()
{
    sc(n), sc(k);
    for (ll i = 1, u, v; i < n; ++i)
    {
        sc(u), sc(v), adde(u, v), adde(v, u);
    }
    dfs(1, 0, 0);
    bg = id, mx = 0;
    dfs(bg, 0, 0);
    ed = id, dbf = mx;
    if (k == 1)
    {
        printf("%lld", 2 * (n - 1) - dbf + 1); //原是2(n-1),优化掉了(直径-1)
        return 0;
    }
    dfs2(bg, 0, ed);
    m[ed] = 1, m[bg] = 1;
    for (ll i = bg; i != ed; i = fr[i])
    {
        m[i] = 1;
    }
    for (ll u = 1; u <= n; ++u)
    {
        if (m.count(u) == 1)
        {
            for (ll i = hd[u]; i; i = e[i].nx)
            {
                if (m.count(e[i].to) == 1)
                {
                    e[i].w = -1; //有重叠，还要再走回去，取消节省
                }
            }
        }
    }
    dfs3(1, 0);
    printf("%d", 2 * n - dbf - daf); //即2(n-1)-(dbf-1)-(daf-1)
    return 0;
}
```



##### p5666-树的重心

> 若删掉某节点后，所得所有子树大小(节点数)均不超过原树大小 $\lfloor\dfrac n2\rfloor$ ，那么该节点是树的重心。树的重心只可能有 $1$ 或 $2$ 个。依次删掉树的每一个单边得两子树，求两子树的重心编号和(每次可能有 $2\sim 4$ 个重心)之和。 $1\le t\le 5,1\le n\le3\times10^5$

树上倍增法。题解区 [soar_ing](https://www.luogu.com.cn/problem/solution/P5666)

重要结论：对于一个点,若 $x$ 不是重心,重心要么在重儿子子树里,要么在父亲节点上

先 DFS 求重儿子和次重儿子(删边后新的重儿子只可能是重、次重、父、自己四种，不可能是其他)

然后 DFS ，模拟删边，用树上倍增法，二分找到树的一个重心，然后求出可能的另一个重心(显然是相邻的，所以找父、重子即可)。每次对两个子树都这么做。

细节是注意回溯。

代码如下：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 300010
#define ml 18
struct node
{
    ll to, nx;
} e[mn << 1];
ll n, t, sn[mn], s[mn], pr[mn], sn2[mn], p[mn][ml], sn3[mn], f[mn], hd[mn], cnt, s2[mn], ans;
void adde(ll &u, ll &v)
{
    e[++cnt] = {v, hd[u]};
    hd[u] = cnt;
}
void dfs(ll u, ll fa)
{
    s[u] = 1, pr[u] = fa; //前向为pr
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs(v, u);
        s[u] += s[v];        //节点数：判定轻重的依据
        if (s[v] > s[sn[u]]) //sn重儿子，sn2轻儿子
        {
            sn2[u] = sn[u], sn[u] = v;
        }
        else if (s[v] > s[sn2[u]])
        {
            sn2[u] = v;
        }
    }
    p[u][0] = sn[u]; //树上k级儿子
    for (ll i = 1; i < ml; ++i)
    {
        p[u][i] = p[p[u][i - 1]][i - 1];
    }
}
ll judge(ll x, ll sum) //树所有点数为sum
{
    //对于一个点,若x不是重心,重心要么在重儿子子树里,要么在父亲节点上
    return x * (max(s2[sn3[x]], sum - s2[x]) <= sum / 2);
}
void dfs2(ll u, ll fa)
{
    for (ll i = hd[u], v, b; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        s2[u] = s[1] - s[v]; //除这条边的子树外的节点数(按题删边)
        f[v] = f[u] = 0;     //前向
        //对于一个点u,若u不是重心,重心要么在重儿子子树里,要么在父亲节点上
        if (sn[u] == v) //找剪掉重儿子之后的重儿子
        {
            sn3[u] = sn2[u];
        }
        else
        {
            sn3[u] = sn[u];
        }
        if (s2[fa] > s2[sn3[u]])
        {
            sn3[u] = fa;
        }
        p[u][0] = sn3[u]; //树上k级重儿子
        for (ll j = 1; j < ml; ++j)
        {
            p[u][j] = p[p[u][j - 1]][j - 1];
        }

        //删边后的一棵子树
        b = u;
        //跳到重心为止
        for (ll j = ml - 1; j >= 0; --j)
        {
            if (s2[u] - s2[p[b][j]] <= s2[u] / 2)
            {
                b = p[b][j];
            }
        }
        //这个位置，它的父亲或它的重儿子之一可能是重心
        ans += judge(sn3[b], s2[u]) + judge(b, s2[u]) + judge(f[b], s2[u]);

        //另一个子树
        b = v;
        for (ll j = ml - 1; j >= 0; --j)
        {
            if (s2[v] - s2[p[b][j]] <= s2[v] / 2)
            {
                b = p[b][j];
            }
        }
        ans += judge(sn3[b], s2[v]) + judge(b, s2[v]) + judge(f[b], s2[v]);
        f[u] = v;
        dfs2(v, u);
    }
    //回溯
    sn3[u] = p[u][0] = sn[u], f[u] = pr[u];
    for (ll j = 1; j < ml; ++j)
    {
        p[u][j] = p[p[u][j - 1]][j - 1];
    }
    s2[u] = s[u];
}
signed main()
{
    sc(t);
    while (t--)
    {
        memset(hd, 0, sizeof hd), cnt = ans = 0;
        memset(sn, 0, sizeof sn);
        memset(pr, 0, sizeof pr);
        memset(f, 0, sizeof f);
        sc(n);
        for (ll i = 1, u, v; i < n; ++i)
        {
            sc(u), sc(v), adde(u, v), adde(v, u);
        }
        dfs(1, 0);
        memcpy(s2, s, sizeof s2);    //s2是s的副本
        memcpy(sn3, sn, sizeof sn3); //sn3->s
        memcpy(f, pr, sizeof f);     //f->pr
        dfs2(1, 0);
        printf("%lld\n", ans);
    }
    return 0;
}
```



##### p1081-开车旅行

> $A,B$ 轮流开车前行，城市间距离为海拔差绝对值，海拔互异；$A$ 每次前进到次小距离值(同距离就海拔低的)， $B$ 每次前进到最小值，当不可行或总路程大于 $x$ 时停止。给定 $x_0$ ，求从哪个城市出发 $A$ 路程和与 $B$ 路程和比值最小；然后解决 $m$ 个询问，从 $s$ 出发给定 $x$ ，求 $A,B$ 各自走的路程。

用 `multiset` +二分模拟平衡树，倒序插点，可以用较快的复杂度(内部原理是红黑树)找到最小和次小。

设 `i` 是行驶了 $2^i$ 天， `j` 是从城市 $j$ 出发， $k$ 是谁开车($0A,1B$) ，设三个三维 DP：

- `f` 是最终到达的城市
- `ca` 是 $A$ 行驶的总路程
- `cb` 是 $B$ 行驶的总路程

设不存在的城市是 $0$ ，无限开大整数，初始值显而易见

转移方程是前半部分 $i-1$ ，后半部分先用 `f` 将 `j` 位移到前半部分结束，再 `i-1`

$i=1$ 时，转移方程的 $k$ 两半部分不一样，否则都一样，由 $2^{i-1}$ 奇偶可知

计算距离用倍增法从大到小不断地跳即可。注意除了满足 `x` 外还需要满足 `f` 存在

代码如下：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define ml 19
#define mn 100010
struct city
{
    ll i, h;
    bool operator<(const city &x) const { return h < x.h; }
} bg, ga, gb, nei[5];
bool cmp(const city &x, const city &y)
{
    return abs(x.h - bg.h) < abs(y.h - bg.h);
}
ll n, m, x0, ansi, as, bs, h[mn], big = 1e18, s, x;
ll f[ml][mn][2], ca[ml][mn][2], cb[ml][mn][2];
db ans = big, no;
multiset<city> q;
void ro(ll s, ll x)
{
    as = bs = 0;
    for (ll i = ml - 1, p = s; i >= 0; --i)
    {
        if (f[i][p][0] && as + bs + ca[i][p][0] + cb[i][p][0] <= x)
        {
            as += ca[i][p][0], bs += cb[i][p][0];
            p = f[i][p][0];
        }
    }
}
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        sc(h[i]);
    }
    sc(x0), sc(m);

    h[0] = big, h[n + 1] = -big;
    q.insert({0, big}), q.insert({0, big});
    q.insert({n + 1, -big}), q.insert({n + 1, -big});
    for (ll i = n; i; --i)
    {
        bg = {i, h[i]};
        q.insert(bg);
        auto p = q.lower_bound(bg);
        --p, --p;
        for (ll j = 0, k = 0; j < 5; ++j, ++p)
        {
            if (j != 2)
            {
                nei[k++] = {p->i, p->h};
            }
        }
        sort(nei, nei + 4, cmp);
        gb = nei[0], ga = nei[1];
        // printf("<%lld %lld\n", ga.i, gb.i);
        f[0][i][0] = ga.i, f[0][i][1] = gb.i;
        ca[0][i][0] = abs(bg.h - ga.h);
        cb[0][i][1] = abs(bg.h - gb.h);
    }
    for (ll i = 1; i < ml; ++i)
    {
        for (ll j = 1; j <= n; ++j)
        {
            for (ll k = 0; k < 2; ++k)
            {
                if (i == 1)
                {
                    f[i][j][k] = f[0][f[0][j][k]][1 - k];
                    ca[i][j][k] = ca[0][j][k] + ca[0][f[0][j][k]][1 - k];
                    cb[i][j][k] = cb[0][j][k] + cb[0][f[0][j][k]][1 - k];
                }
                else
                {
                    f[i][j][k] = f[i - 1][f[i - 1][j][k]][k];
                    ca[i][j][k] = ca[i - 1][j][k] + ca[i - 1][f[i - 1][j][k]][k];
                    cb[i][j][k] = cb[i - 1][j][k] + cb[i - 1][f[i - 1][j][k]][k];
                }
            }
        }
    }

    for (ll i = 1; i <= n; ++i)
    {
        ro(i, x0);
        no = 1.0 * as / bs;
        if (ans > no || (ans == no && h[ansi] < h[i]))
        {
            ans = no, ansi = i;
        }
    }
    printf("%lld\n", ansi);

    while (m--)
    {
        sc(s), sc(x), ro(s, x);
        printf("%lld %lld\n", as, bs);
    }
    return 0;
}
```



##### p4550-收集邮票

> 有 $n$ 种邮票，每次购买等概率获得随机一张，第 $k$ 次购买价格为 $k$ ，求得到全部种类所需花费期望。

设 $f_i$ 表示已经取到 $i$ 张邮票，需取完剩下邮票的期望次数

初始值为 $f_n=0$ ，递推式为：
$$
f_i=\dfrac inf_i+\left(1-\dfrac in\right)f_{i+1}+1
$$
移项：
$$
f_i=f_{i+1}\dfrac n{n-i}
$$
设 $f_i$ 表示已经取到 $i$ 张邮票，需取完剩下邮票的期望价格

初始值为 $g_n=0$ ，递推式为：
$$
g_i=\dfrac in(g_i+f_i+1)+\left(1-\dfrac in\right)(g_{i+1}+f_{i+1}+1)
$$
移项：
$$
g_i=\dfrac i{n-i}f_i+g_{i+1}+f_{i+1}+\dfrac n{n-i}
$$
参见题解：[league](https://www.luogu.com.cn/problem/solution/P4550)

```c++
#define mn 10010
ll n;
db f[mn], g[mn];
signed main()
{
    sc(n);
    for (ll i = n - 1; i >= 0; --i)
    {
        f[i] = f[i + 1] + (1. * n) / (1. * (n - i));
        g[i] = (1. * i) / (1. * (n - i)) * (f[i] + 1) + g[i + 1] + f[i + 1] + 1;
    }
    printf("%.2lf", g[0]);
    return 0;
}
```



##### p1502-窗口的星星

> 有 $n$ 个星星，星星坐标为 $x,y$，亮度为 $l$，有不计边框的窗口 $w,h$  ，求窗口能显示的最大总亮度 $1\le t\le10,1\le n\le10^4$

将星星拓展为 $w,h$ 矩形，其权为 $l$ ，转化为用扫描线找平面坐标，使得矩形覆盖权最大

上板子即可。要注意不少细节。

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 100010
ll t, n, w, h, c[mn], cnt, ans;
struct seg
{
    ll l, r, h, v;
    bool operator<(const seg &x) const
    {
        return (h != x.h) ? h < x.h : v > x.v;
    }
} s[mn << 2];
struct segtr
{
    ll l, r, mx, cnt;
} tr[mn << 2];
#define lfs p << 1
#define rfs p << 1 | 1
#define mkcf ll cf = (lf + rf) >> 1
void build(ll p, ll lf, ll rf)
{
    tr[p].l = lf, tr[p].r = rf;
    if (lf == rf)
    {
        return;
    }
    mkcf;
    build(lfs, lf, cf);
    build(rfs, cf + 1, rf);
}
void pushdf(ll p)
{
    tr[lfs].mx += tr[p].cnt; //区间最值
    tr[rfs].mx += tr[p].cnt;
    tr[lfs].cnt += tr[p].cnt; //懒标记
    tr[rfs].cnt += tr[p].cnt;
    tr[p].cnt = 0;
}
void update(ll p, ll &lc, ll &rc, ll &d)
{
    ll lf = tr[p].l, rf = tr[p].r;
    if (lc <= lf && rf <= rc)
    {
        tr[p].mx += d;
        tr[p].cnt += d;
        return;
    }
    pushdf(p);
    mkcf;
    if (lc <= cf)
    {
        update(lfs, lc, rc, d);
    }
    if (rc > cf)
    {
        update(rfs, lc, rc, d);
    }
    tr[p].mx = max(tr[lfs].mx, tr[rfs].mx);
}
signed main()
{
    sc(t);
    while (t--)
    {
        sc(n), sc(w), sc(h);
        memset(s, 0, sizeof s);
        memset(tr, 0, sizeof tr);
        for (ll i = 1, x, y, l; i <= n; ++i)
        {
            sc(x), sc(y), sc(l);
            c[(i << 1) - 1] = y; //显然坐标是2i-1和2i，而不是2^i
            c[i << 1] = y + h - 1;
            s[(i << 1) - 1] = {y, y + h - 1, x, l};
            s[i << 1] = {y, y + h - 1, x + w - 1, -l};
        }
        n <<= 1;
        sort(c + 1, c + 1 + n);
        sort(s + 1, s + 1 + n);
        cnt = unique(c + 1, c + 1 + n) - c - 1;
        for (ll i = 1, p1, p2; i <= n; ++i) //离散化后的新坐标值是p1,p2
        {
            p1 = lower_bound(c + 1, c + 1 + cnt, s[i].l) - c;
            p2 = lower_bound(c + 1, c + 1 + cnt, s[i].r) - c;
            s[i].l = p1, s[i].r = p2; //这个新坐标区间是线段树所维护的区间
        }
        build(1, 1, cnt);
        ans = 0;
        for (ll i = 1; i <= n; ++i)
        {
            update(1, s[i].l, s[i].r, s[i].v);
            ans = max(ans, tr[1].mx);
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```



##### p4198-楼房重建

> 初始 $n$ 栋楼房，高度为 $0$ ，有 $m$ 次修改，每次将 $x$ 处楼房高度改为 $y$ (即线段 $x'=x,0\le y'\le y$)。问改完之后从 $(0,0)$ 能看到多少楼房 (刚好挡住也看不到)。
>
> $1\le n,m\le10^5$

题解 [Nemlit](https://www.luogu.com.cn/problem/solution/P4198) 作最高点和 $(0,0)$ 连线，易知能看到的充要条件是它前面所有楼房斜率小于它。所以问题转化为斜率问题。

设线段树维护信息：只有所维护区间的全部楼房，能够看到多少栋楼房为 `ans` ，区间斜率最值为 `mx` 。 每次单点修改 $(x,y)$ ，显然 $[1,x-1]$ 的区间都不会被修改。对剩余部分区间，作区间更改，设更改区间 $[l,r]$ ，其前面最大斜率为 $mxv=mx([1,l-1])$ ，拆为区间 $[l,c]$ , $[c+1,r]$ ，若左区间最值小于 $mxv$ ，那么左区间全部被挡住，且左区间不影响右区间，用 $mxv$ 继续更新处理右区间。若最值大于 $mxv$ ，那么 $mxv$ 不影响右区间，而是左区间影响右区间。所以右区间答案可以直接输出为从 $l$ 看 $[c+1,r]$ ，即 $ans[l,r]-ans[l,c]$ ，注意不是 $ans[c+1,r]$ ，因为代表从 $c+1$ 看。然后对左区间递归处理。

如果这个过程不懂，可以自己动手操作一下，很快可以明白原理。

由于找到修改点需要 $\Omicron(\log n)$ ，这些 $\Omicron(\log n)$ 个线段树点都需要做区间更改，每次更改都用到了上述的二分，所以时间复杂度是 $\Omicron(m\log^2n)$ ，可以过题。

参考代码：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 100010
#define big 0x7fffffff
ll n, m, ans[mn << 2], x, y;
db mx[mn << 2];
#define lfs p << 1
#define rfs p << 1 | 1
#define mkcf ll cf = (lf + rf) >> 1
ll query(ll p, ll lf, ll rf, db mxv)
{ //查询比mxv斜率大的楼房数
    if (mx[p] <= mxv)
    { //区间最大斜率比查询mxv要小，不影响答案
        return 0;
    }
    if (lf == rf)
    {
        return mx[p] > mxv;
    }
    mkcf;
    if (mx[lfs] <= mxv)
    { //左区间全部被mxv挡住了，只看右
        return query(rfs, cf + 1, rf, mxv);
    } //否则，mx[lfs]>mxv
    return query(lfs, lf, cf, mxv) + ans[p] - ans[lfs];
    //ans[p]-ans[lfs]意思是从p看，统计右区间能看到多少
    //这是因为mxv影响不及mx[lfs]，所以右区间的影响不变
    //但左区间变了，所以继续递归处理
}
void update(ll p, ll lf, ll rf, ll k, db v)
{ //将楼房k的斜率修改为v
    if (lf == k && lf == rf)
    {
        ans[p] = 1, mx[p] = v;
        return;
    }
    mkcf;
    if (k <= cf)
    {
        update(lfs, lf, cf, k, v);
    }
    else
    {
        update(rfs, cf + 1, rf, k, v);
    }
    mx[p] = max(mx[lfs], mx[rfs]);
    ans[p] = ans[lfs] + query(rfs, cf + 1, rf, mx[lfs]);
    //该区间的答案是左区间的答案加上右区间的斜率大于左区间最大值的所有楼房
    //ans[lfs]答案不受更改影响；rfs有影响，所以改变了
}
signed main()
{
    sc(n), sc(m);
    while (m--)
    {
        sc(x), sc(y);
        update(1, 1, n, x, 1.0 * y / x);
        printf("%lld\n", ans[1]);
    }
    return 0;
}
```



##### p1196-银河英雄传说

> 有 $30000$ 战舰，每次 `M i j` 将 $i$ 所在编队连在 $j$ 所在编队尾部成链。每次 `C i j` 查询 $i,j$ 链之间有多少个战舰。若 $i,j$ 不同编队输出 `-1` 。 $t\le 5\times10^5$

题解 [假装思考](https://www.luogu.com.cn/problem/solution/P1196) ，设前缀和 `cnt` 为离队首的距离，则所求为 $|cnt_i-cnt_j|+1-2$ 

每次合并并查集时， `fa[find(i)]=find(j)` ，在这之前，更新 $cnt_x$ ，距离增加 $num_y$ ，即舰队数。且 $num_y$ 增加 $num_x$ ，并且清零 $num_x$ (否则反复合并会出锅)。`find` 用递归式，每次 `find` 时更新 $cnt_x=cnt_{fa_x}$ ，注意在更新 $fa$ 之前做，不然等于我赋值我自己。

参考代码：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 30010
ll t, fa[mn], cnt[mn], num[mn], i, j;
char cmd[10];
ll find(ll x)
{
    if (x == fa[x])
    {
        return x;
    }
    ll res = find(fa[x]);
    cnt[x] += cnt[fa[x]];
    return fa[x] = res;
}
signed main()
{
    for (ll i = 1; i <= 30000; ++i)
    {
        fa[i] = i, num[i] = 1;
    }
    sc(t);
    while (t--)
    {
        scanf("%s%lld%lld", cmd, &i, &j);
        ll x = find(i), y = find(j);
        if (cmd[0] == 'M')
        {
            cnt[x] += num[y];
            fa[x] = y;
            num[y] += num[x];
            num[x] = 0;
        }
        else if (cmd[0] == 'C')
        {
            if (x != y)
            {
                printf("-1\n");
            }
            else
            {
                printf("%lld\n", abs(cnt[i] - cnt[j]) - 1);
            }
        }
    }
    return 0;
}
```



##### p1341-无序字母对

> $n$ 个区分大小写无序字母对，构造一个 $n+1$ 个字母的字符串使得每个字母对都出现，或输出 `No Solution`

无向图欧拉路径板子题

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 130
ll m, du[mn], vis[mn][mn], s = 'z', t = 'z', fa[mn], ucon;
vector<ll> e[mn], odd;
stack<ll> ans;
char c[10];
void dfs(ll u)
{
    for (ll i = 0, v; i < (ll)e[u].size(); ++i)
    {
        v = e[u][i];
        if (vis[u][v])
        {
            continue;
        }
        vis[u][v] = vis[v][u] = true;
        dfs(v);
    }
    ans.push(u);
}
ll findf(ll x)
{
    while (x != fa[x])
    {
        x = fa[x] = fa[fa[x]];
    }
    return x;
}
signed main()
{
    scanf("%lld", &m);
    for (ll i = 'A'; i <= (ll)'z'; ++i)
    {
        fa[i] = i;
    }
    for (ll i = 0, u, v; i < m; ++i)
    {
        scanf("%s", c);
        u = c[0], v = c[1], ++du[u], ++du[v];
        e[u].emplace_back(v), e[v].emplace_back(u);
        s = min(s, min(u, v));
        fa[findf(u)] = findf(v);
    }
    for (ll i = 'A'; i <= (ll)'z'; ++i)
    {
        ucon += (du[i] > 0) * (fa[i] == i);
        // printf("%c %lld %lld\n", (char)i, du[i], ucon);
        if (du[i] & 1)
        {
            odd.emplace_back(i);
            t = min(t, i);
        }
        sort(e[i].begin(), e[i].end());
    }
    if (!(odd.size() == 0 || (odd.size() == 2)) || ucon > 1)
    {
        printf("No Solution");
        return 0;
    }
    if (odd.size())
    {
        s = t;
    }
    dfs(s);
    while (!ans.empty())
    {
        printf("%c", (char)ans.top());
        ans.pop();
    }
    return 0;
}
/*6 ab bc ca AB BC CA*/
```



##### p2731-骑马修栅栏

> 给定无向图边数 $m$ ，点在 $[1,500]$ 编号，必然有解且联通，输出字典序最小欧拉路

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 512
ll m, s = 1, g[mn][mn], du[mn], n;
stack<ll> ans;
void dfs(ll u)
{
    for (ll v = 1; v <= n; ++v)
    {
        if (g[u][v] > 0)
        {
            --g[u][v], --g[v][u];
            dfs(v);
        }
    }
    ans.push(u);
}
signed main()
{
    scanf("%lld", &m);
    for (ll i = 0, u, v; i < m; ++i)
    {
        scanf("%lld%lld", &u, &v);
        ++du[u], ++du[v], ++g[u][v], ++g[v][u];
        n = max(n, max(u, v));
    }
    for (ll i = 1; i <= n; ++i)
    {
        if (du[i] & 1)
        {
            s = i;
            break;
        }
    }
    dfs(s);
    while (!ans.empty())
    {
        printf("%lld\n", ans.top());
        ans.pop();
    }
    return 0;
}
```



##### p2493-消耗战

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 500010
#define mm 10000
#define big 0x3ffffffffffffffa
#define mlg 20
struct edge
{
    ll to, nx, w;
} e[mn << 1], e2[mn << 1];
ll hd[mn], hd2[mn], cnt, cnt2, n, q, k;
void adde(const ll &u, const ll &v, const ll &w, ll *hd, ll &cnt, edge *e)
{
    e[++cnt] = {v, hd[u], w};
    hd[u] = cnt;
}
ll dfn[mn], dep[mn], fa[mn][mlg], mi[mn], m[mn], lst[mn];
bool vis[mn];
ll num, top, dfscnt, stk[mn];

void dfs1(ll u)
{
    ll k = 0;
    for (; fa[u][k]; ++k)
    {
        fa[u][k + 1] = fa[fa[u][k]][k];
    }
    m[u] = k;
    dfn[u] = ++dfscnt;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (!dfn[v])
        {
            dep[v] = dep[u] + 1;
            mi[v] = min(mi[u], e[i].w);
            fa[v][0] = u;
            dfs1(v);
        }
    }
}

ll lca(ll x, ll y)
{
    if (dep[x] < dep[y])
    {
        swap(x, y);
    }
    for (ll i = m[x]; i >= 0; --i)
    {
        if (dep[fa[x][i]] >= dep[y])
        {
            x = fa[x][i];
        }
    }
    if (x == y)
    {
        return x;
    }
    for (ll i = m[x]; i >= 0; --i)
    {
        if (fa[x][i] != fa[y][i])
        {
            x = fa[x][i], y = fa[y][i];
        }
    }
    return fa[x][0];
}

ll dfs2(ll u) //dp
{
    ll sum = 0;
    for (ll i = hd2[u], v; i; i = e2[i].nx)
    {
        v = e2[i].to;
        sum += dfs2(v);
    }
    ll res = vis[u] ? mi[u] : min(mi[u], sum); //vis[u] hd.d af
    hd2[u] = 0, vis[u] = false;                //clear
    return res;
}

#define sc(x) scanf("%lld", &x)
signed main()
{
    sc(n);
    for (ll i = 1, u, v, w; i < n; ++i)
    {
        sc(u), sc(v), sc(w);
        adde(u, v, w, hd, cnt, e), adde(v, u, w, hd, cnt, e);
    }
    mi[1] = big;
    dfs1(1);
    for (sc(q); q; --q)
    {
        sc(k);
        for (ll i = 1; i <= k; ++i)
        {
            sc(lst[i]), vis[lst[i]] = true;
        }
        sort(lst + 1, lst + 1 + k, [](const ll &x, const ll &y)
             { return dfn[x] < dfn[y]; });
        stk[top = 1] = lst[1];
        for (ll i = 2; i <= k; ++i)
        {
            ll now = lst[i], lc = lca(now, stk[top]);
            while (true)
            {
                if (dep[lc] >= dep[stk[top - 1]])
                {
                    if (lc != stk[top])
                    {
                        adde(lc, stk[top], 0, hd2, cnt2, e2);
                        if (lc != stk[top - 1])
                        {
                            stk[top] = lc;
                        }
                        else
                        {
                            --top;
                        }
                    }
                    break;
                }
                else
                {
                    adde(stk[top - 1], stk[top], 0, hd2, cnt2, e2);
                    --top;
                }
            }
            stk[++top] = now;
        }
        while (--top)
        {
            adde(stk[top], stk[top + 1], 0, hd2, cnt2, e2);
        }
        printf("%lld\n", dfs2(stk[1])), cnt2 = 0;
    }
    return 0;
}
```



##### p2634-聪聪可可

> 有 $n(n\le 2\times10^4)$ 点的树，任选两点为端点，求有多大概率选到路径长度是 $3$ 的倍数。

解法一：树上 DP

记 $dp[i][j]$ 表示以 $i$ 为根的子树里距离 $i$ 模 $3$ 余 $j$ 的点的个数。

因为自己到自己是 $0$ ，所以初始值是 $dp[i][0]=1$ 。

每次 DFS 更新，设当前遍历直接儿子为 $s$ ，边权为 $w$ ，令答案增加如下值：
$$
2\times dp[i][j]\times dp[s][3-j-w]
$$
$2$ 是一个有序对对应两个无序对。 $j\equiv3-j-w(\bmod 3)$ 是加起来为 $0$ 

计算结束后，进行更新，将当前儿子的点加到父亲上：
$$
dp[i][j+w]=dp[s][j]
$$
特别地，不是 $2\times dp[i][j]\times(3-j-w\equiv 0)$ ，因为如果这样的话，就不能够计算出子树之间的路径。 只有 $dp[s][3-j-w]$ 才是当前已遍历部分跟未遍历部分的路径 DP 。

注意两个 for 要分开。特别注意最后额外加上 $n$ ，因为所有点到自己也需要积累贡献，注意该贡献在 DP 时没有计算入内。

代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 20010
#define sc(x) scanf("%lld", &x)
struct edge
{
    ll to, nx, w;
} e[mn << 1];
ll hd[mn], cnt, dp[mn][3], n, fz, fm, c;
void adde(ll u, ll v, ll w)
{
    e[++cnt] = {v, hd[u], w};
    hd[u] = cnt;
}
void dfs(ll u, ll fa)
{
    dp[u][0] = 1;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs(v, u);
        for (ll j = 0; j < 3; ++j)
        {
            fz += 2 * dp[v][j] * dp[u][(6 - j - e[i].w % 3) % 3];
        }
        for (ll j = 0; j < 3; ++j)
        {
            dp[u][(j + e[i].w) % 3] += dp[v][j];
        }
    }
}
signed main()
{
    sc(n);
    for (ll i = 1, u, v, w; i < n; ++i)
    {
        sc(u), sc(v), sc(w);
        adde(u, v, w), adde(v, u, w);
    }
    dfs(1, 0);
    fz += n, fm = n * n, c = __gcd(fz, fm), fz /= c, fm /= c;
    printf("%lld/%lld", fz, fm);
    return 0;
}
```



解法二：点分治

树上路径要么经过根，要么不经过。求出所有子树的答案，再求出经过根的所有路径即得答案。

1. 以重心为根统计经过重心的所有路径的贡献

   统计贡献的方法为：DFS，桶记录距离模 $3$ 余 $i$ 的点有多少个

   所有距离余 $1$ 和余 $2$ 的点可以组成余 $0$ ，无序，即 $2xy$；

   所有距离余 $0$ 的点之间也可以组成余 $0$ ，具体为：自己跟自己、两两之间，即自己和包括自己的所有点，即 $x^2$ 

2. 删掉重心，剩下的各个子树同上操作

特别地，发现有一个事实：假设 $x$ 是原重心， $y$ 是新子树重心，在计算 $x$ 的时候发现有若干余 $0$ 点，会被重复计数…具体没搞懂。总之就是会重复。以后再细想，我没想明白想了非常久。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 20010
struct edge
{
    ll to, nx, w;
} e[mn << 1];
ll t, n, hd[mn], cnt, siz[mn], w[mn], bin[4], m, dp[mn], root, dis[mn];
ll fz, fm, c;
bool vis[mn];
void adde(ll u, ll v, ll w)
{
    e[++cnt] = {v, hd[u], w};
    hd[u] = cnt;
}
void fi_root(ll u, ll fa)
{
    siz[u] = 1, dp[u] = 0;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || vis[v])
        {
            continue;
        }
        fi_root(v, u);
        siz[u] += siz[v];
        dp[u] = max(dp[u], siz[v]);
    }
    dp[u] = max(dp[u], m - siz[u]);
    if (dp[u] < dp[root])
    {
        root = u;
    }
}
void dfs(ll u, ll fa)
{
    ++bin[dis[u]];
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || vis[v])
        {
            continue;
        }
        dis[v] = (dis[u] + e[i].w) % 3;
        dfs(v, u);
    }
}
ll cal(ll u, ll v) //以u为根的剩余子树的贡献(v=0)
{
    memset(bin, 0, sizeof bin), dis[u] = v;
    dfs(u, 0);
    return bin[1] * bin[2] * 2 + bin[0] * bin[0]; //模3余0
    //经由u的路径，一端是x一端是y,满足距离x=1,y=2或x=y=0
}
void solve(ll u)
{
    fz += cal(u, 0), vis[u] = true; //删除点u
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (vis[v])
        {
            continue;
        }
        fz -= cal(v, e[i].w);
        root = 0, m = siz[v];
        fi_root(v, 0);
        solve(root);
    }
}
#define sc(x) scanf("%lld", &x)
signed main()
{
    sc(n);
    for (ll i = 1, ui, vi, wi; i < n; ++i)
    {
        sc(ui), sc(vi), sc(wi), adde(ui, vi, wi % 3), adde(vi, ui, wi % 3);
    }
    m = dp[0] = n;
    fi_root(1, 0);
    solve(root);
    fm = n * n, c = __gcd(fz, fm), fz /= c, fm /= c;
    printf("%lld/%lld", fz, fm);
    return 0;
}
```





##### p1364-医院设置

> 有二叉树，节点数为 $n(n\le 100)$

解法一：树上 DP 题 / 树的重心模板题

先预处理节点数。由于有点权，可以认为等于若干个重合点，所以初始 size 是点权。然后一次 DFS 求出 size 数组和 $dp[1]$ 代表以 $1$ 为根的距离和。

状态转移方程为：
$$
dp[v]=dp[u]+(size[1]-size[v])-size[v]
$$
这是因为子树上节点都少走一步，其他节点都多走一步。答案是 DP 内最小值。

参考代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 105
#define sc(x) scanf("%lld", &x)
struct edge
{
    ll to, nx;
} e[mn << 1];
ll hd[mn], cnt, siz[mn], w[mn], dp[mn], n, ans = 0x7fffffff;
void adde(ll u, ll v)
{
    e[++cnt] = {v, hd[u]};
    hd[u] = cnt;
}
void dfs1(ll u, ll fa, ll d)
{
    siz[u] = w[u];
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs1(v, u, d + 1);
        siz[u] += siz[v];
    }
    dp[1] += d * w[u];
}
void dfs2(ll u, ll fa)
{
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dp[v] = dp[u] + (siz[1] - siz[v]) - siz[v];
        dfs2(v, u);
    }
    ans = min(ans, dp[u]);
}
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1, x, y; i <= n; ++i)
    {
        sc(w[i]), sc(x), sc(y);
        if (x)
        {
            adde(i, x), adde(x, i);
        }
        if (y)
        {
            adde(i, y), adde(y, i);
        }
    }
    dfs1(1, 0, 0);
    dfs2(1, 0);
    printf("%lld", ans);
    return 0;
}
```



解法二：也可以跑 Floyd 求解。然后暴力遍历每个点验证即可。略。



##### p1521-求逆序对

设 $dp[i][j]$ 表示全排列 $1\to i$ 内，逆序数模 $10^4$ 余 $j$ 的方案数

初始值为 $dp[0\sim 2][0]=dp[2][1]=1$ 

递推时，可以把 $i+1$ 插入到原方案的 $i+1$ 个位置里。其中显然尾部不贡献新的逆序对，头部贡献 $i$ 个。进一步地，由于 $i+1$ 大于任意 $[1,i]$ ，所以可以发现有多少个新的贡献，取决于它后面还有多少个值。显然插入到第 $h$ 个位置贡献 $i-h$ 个值

时间复杂度 $O(n^2k)$

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
ll n, k, dp[105][10005];
signed main()
{
    sc(n), sc(k), dp[0][0] = dp[1][0] = dp[2][0] = dp[2][1] = 1;
    for (ll i = 3; i <= n; ++i)
    {
        for (ll j = 0; j <= k; ++j)
        {
            for (ll h = 0; h <= i - 1 && j - h >= 0; ++h)
            {
                dp[i][j] = (dp[i][j] + dp[i - 1][j - h]) % 10000;
            }
        }
    }
    printf("%lld", dp[n][k]);
    return 0;
}
```





#### 网络流24题

##### p2761-软件补丁问题

> 有 $n$ 个 bugs ， $m$ 个补丁，补丁能启用当且仅当满足特定的若干个 bugs 存在 (+)，若干个 bugs 不存在 (-) ，能修复若干个 bugs (-) ，带来若干个 bugs (+)，耗费时间 $t$ ，一开始有 $n$ 个全部 bugs ，求修复完全部 bugs 最小用时。若修不好，输出 `-1` $1\le n\le20,1\le m\le100$

参考题解 [FCBM71](https://www.luogu.com.cn/problem/solution/P2761)

这道题类似于完全图，有 $2^n$ 个点，确定好连边状态之后暴力跑最短路即可。点编号为状态数位压缩值，满足存在条件即当前状态按位与为目标状态，满足不存在条件即按位与为 $0$ ，带来即按位或，修复即按位或然后按位异或。然后随便跑一个最短路即可(如SPFA,dijkstra)，

由于边太多，会MLE，所以不存边，每次直接判断即可。代码如下：

 ```C++
 #include <bits/stdc++.h>
 #define re
 using namespace std;
 typedef long long ll;
 #define il inline
 typedef double db;
 il ll read()
 {
     re char p = 0;
     re ll r = 0, o = 0;
     for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
         ;
     for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
         ;
     return o ? (~r) + 1 : r;
 }
 #define sc(x) x = read()
 #define me 105
 #define mn (1 << 20) + 10
 struct pack
 {
     ll b1, b2, f1, f2, t;
 } a[me];
 struct node
 {
     ll v, i;
     bool operator<(const node &x) const { return v > x.v; }
 };
 ll d[mn], vis[mn], no, n, m;
 priority_queue<node> q;
 char b[me], f[me];
 void dijkstra()
 {
     d[no] = 0, q.push({0, no});
     while (!q.empty())
     {
         ll u = q.top().i;
         q.pop();
         if (vis[u])
         {
             continue;
         }
         vis[u] = true;
         for (ll i = 1; i <= m; ++i)
         {
             if ((u & a[i].b1) == a[i].b1 && (u & a[i].b2) == 0)
             {
                 ll v = ((u | a[i].f1) ^ a[i].f1) | a[i].f2;
                 if (d[v] > d[u] + a[i].t)
                 {
                     d[v] = d[u] + a[i].t;
                     q.push({d[v], v});
                 }
             }
         }
     }
 }
 signed main()
 {
     sc(n), sc(m), no = (1 << n) - 1;
     memset(d, 0x3f, sizeof d);
     for (ll i = 1; i <= m; ++i)
     {
         scanf("%lld%s%s", &a[i].t, b, f);
         for (ll j = 0; j < n; ++j)
         {
             if (b[j] == '+')
             {
                 a[i].b1 |= (1 << j);
             }
             else if (b[j] == '-')
             {
                 a[i].b2 |= (1 << j);
             }
             if (f[j] == '-')
             {
                 a[i].f1 |= (1 << j);
             }
             else if (f[j] == '+')
             {
                 a[i].f2 |= (1 << j);
             }
         }
     }
     dijkstra();
     if (d[0] == d[mn - 1])
     {
         printf("0");
     }
     else
     {
         printf("%lld", d[0]);
     }
     return 0;
 }
 ```



##### p2756-飞行员配对方案问题

> 求二分图最大匹配的边数和匹配情况，左右点数为n,m，边数为e。

解法一：二分图匈牙利算法

复杂度 $\Omicron(ne+m)$

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 105
vector<ll> e[mn];
ll m, n, ui, vi, t, mch[mn], vis[mn], r;
bool dfs(ll u, ll st)
{
    if (vis[u] == st)
    {
        return false;
    }
    vis[u] = st;
    for (auto &v : e[u])
    {
        if (!mch[v] || dfs(mch[v], st))
        {
            mch[v] = u;
            return true;
        }
    }
    return false;
}
signed main()
{
    sc(m), sc(n);
    while (true)
    {
        sc(ui), sc(vi);
        if (ui == -1 && vi == -1)
        {
            break;
        }
        e[ui].emplace_back(vi);
    }
    for (ll i = 1; i <= m; ++i)
    {
        if (dfs(i, i))
        {
            ++r;
        }
    }
    printf("%lld\n", r);
    for (ll i = m + 1; i <= n; ++i)
    {
        if (mch[i])
        {
            printf("%lld %lld\n", mch[i], i);
        }
    }
    return 0;
}
```

解法二：dinic算法

复杂度 $\Omicron(e\sqrt n)$

源点、汇点、题目边都建权为 $1$ 的边，跑最大流即可。输出最大流和残量网络里剩余流量为 $0$ 的边(不含源点汇点)。

代码如下：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define big 0x7fffffff
#define me 10010
#define mn 110
struct edge
{
    ll to, w, nx;
} e[me];
ll n, m, s, t, hd[mn], cnt = 1, h[mn], ans1[mn], ans2[mn], u, v, res, c0;
void adde(ll &u, ll &v, ll w = 1)
{
    e[++cnt] = {v, w, hd[u]};
    hd[u] = cnt;
    e[++cnt] = {u, 0LL, hd[v]};
    hd[v] = cnt;
}
bool bfs()
{
    queue<ll> q;
    q.push(s);
    memset(h, -1, sizeof h);
    h[s] = 0;
    while (!q.empty())
    {
        ll u = q.front();
        q.pop();
        for (ll i = hd[u], v; i; i = e[i].nx)
        {
            v = e[i].to;
            if (h[v] == -1 && e[i].w)
            {
                h[v] = h[u] + 1;
                q.push(v);
            }
        }
    }
    return h[t] != -1;
}
ll dfs(ll u, ll f)
{
    if (u == t)
    {
        return f;
    }
    ll w, used = 0;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (h[v] == h[u] + 1 && e[i].w)
        {
            w = dfs(v, min(f - used, e[i].w));
            e[i].w -= w, e[i ^ 1].w += w;
            used += w;
            if (used == f)
            {
                return f;
            }
        }
    }
    if (!used)
    {
        h[u] = -1;
    }
    return used;
}
signed main()
{
    sc(m), sc(n), s = 0, t = n + 1;
    while (true)
    {
        sc(u), sc(v);
        if (u == -1 && v == -1)
        {
            break;
        }
        adde(u, v);
    }
    c0 = cnt;
    for (ll i = 1; i <= m; ++i)
    {
        adde(s, i);
    }
    for (ll i = m + 1; i <= n; ++i)
    {
        adde(i, t);
    }
    while (bfs())
    {
        res += dfs(s, big);
    }
    printf("%lld\n", res);
    for (ll i = 2; i <= c0; i += 2)
    {
        if (e[i ^ 1].w != 0)
        {
            printf("%lld %lld\n", e[i ^ 1].to, e[i].to);
        }
    }
    return 0;
}
```



##### p4016-负载平衡问题

> $n$ 个仓库成环，每个仓库现存货量为 $a$ ，求最少搬运量，使 $n$ 仓库存货量相同 $1\le n\le100$

解法一： $DP$ + 中位数性质



解法二：最小费用最大流    EK 算法 / dinic 算法

以 $a-\overline{a}$ 为点权建边(注意平均数下取整)，对点权大于 $0$ 的点跟源点连流量为无限，费用为 $1$ 的边，小于 $0$ 的跟汇点连流量为无限，费用为 $1$ 的边。环内连流量为点权，费用为 $0$ 的边。跑最小费用最大流，得到答案。

代码如下：

```c++

```





##### p4011-孤岛营救问题

> 有 $n\times m$ 网格，从 $(1,1)$ 开始，要到达 $(n,m)$ ，在 $p$ 个两格边沿有墙或门，墙为 $0$ ，门为 $g$ 。在 $s$ 个格有钥匙 $g$ 。当且仅当有钥匙才能开门，且不会消耗钥匙。求到达终点需要最小步数，若无解输出 `-1` 。 $1\le n,m,p\le10,k < 150,s\le 14$

是一个非常普通的分层图 BFS。设当前状态为所有已拥有钥匙的数位压缩。如果到某个位置的该状态没走过就走。门能否打开的判定是当前状态按位或门的状态是否是门的状态本身，是的话可以通过，不然不能通过。

时间复杂度为 $\Omicron(nm2^p)$ ，可以过题。代码如下：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 12
#define ms 16
ll n, m, p, k, ax, ay, bx, by, g, s;
ll key[mn][mn][ms], keyn[mn][mn];
ll door[mn][mn][mn][mn]; //door[ax][ay][bx][by]
ll dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};
struct node
{
    ll x, y, k;
    bool operator<(const node &p) const
    {
        return x * 10000LL + y * 100 + k < p.x * 10000LL + p.y * 100 + p.k;
    }
};
struct node2
{
    ll x, y, k, s;
};
set<node> vis;
ll getk(ll x, ll y)
{
    ll r = 0;
    for (ll i = 1, ie = keyn[x][y]; i <= ie; ++i)
    {
        r |= key[x][y][i];
    }
    return r;
}
ll bfs()
{
    queue<node2> q;
    q.push({1, 1, 0, 0});
    while (!q.empty())
    {
        node2 t = q.front();
        q.pop();
        if (vis.find({t.x, t.y, t.k}) != vis.end())
        {
            continue;
        }

        vis.insert({t.x, t.y, t.k});
        if (t.x == n && t.y == m)
        {
            return t.s;
        }
        for (ll i = 0; i < 4; ++i)
        {
            ll ax = t.x + dx[i], ay = t.y + dy[i];
            ll adr = door[t.x][t.y][ax][ay];
            if (ax <= 0 || ay <= 0 || ax > n || ay > m || adr == -1)
            {
                continue;
            }
            ll ak = getk(ax, ay) | t.k;
            if (vis.find({ax, ay, ak}) != vis.end())
            {
                continue;
            }
            if (adr > 0 && (ak & adr) != adr)
            {
                continue;
            }
            q.push({ax, ay, ak, t.s + 1});
        }
    }
    return -1;
}
signed main()
{
    sc(n), sc(m), sc(p), sc(k);
    for (ll i = 1; i <= k; ++i)
    {
        sc(ax), sc(ay), sc(bx), sc(by), sc(g);
        if (g)
        {
            door[ax][ay][bx][by] = 1 << g;
            door[bx][by][ax][ay] = 1 << g;
        }
        else
        {
            door[ax][ay][bx][by] = -1;
            door[bx][by][ax][ay] = -1;
        }
    }
    sc(s);
    for (ll i = 1; i <= s; ++i)
    {
        sc(ax), sc(ay), sc(g);
        key[ax][ay][++keyn[ax][ay]] = 1 << g;
    }
    printf("%lld", bfs());
    return 0;
}
```





#### THUPC 2021 初赛/正赛

##### p7140 区间矩阵乘法

前缀和题目，估计难度不超过绿题，可能是黄题 具体看题解 [Cirno\_9](https://www.luogu.com.cn/problem/solution/P7140)

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef unsigned int ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 200010
ll n, m, p1, p2, d, a[mn], sk[450][mn], s[mn], ans; //450=2e5**.5
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        sc(a[i]);
        s[i] = s[i - 1] + a[i];
    }
    for (ll i = 1, ie = sqrt(n); i <= ie; ++i) //d枚举
    {
        for (ll j = 1; j <= i; ++j)
        {
            sk[i][j] = a[j];
        }
        for (ll j = i + 1; j <= n; ++j)
        {
            sk[i][j] = sk[i][j - i] + a[j];
        }
    }
    sc(m);
    while (m--)
    {
        sc(d), sc(p1), sc(p2), ans = 0;
        for (ll j = 0; j < d; ++j)
        {
            ans += (sk[d][p1 + (d - 1) * d + j] - sk[d][p1 + j] + a[p1 + j]) * (s[p2 + d * (j + 1) - 1] - s[p2 + d * j - 1]);
        }
        printf("%u\n", ans);
    }
    return 0;
}
```



## HDU

##### hdu-6287 口算练习

> CCPC18女生赛真题

唯一分解定理+二分。设vector数组,`vector[x]`:质数`x`出现`a_i`的`i`，不去重，重复则占多个位。对`d`的每个因子`i`，对`vector[i]`二分找区间$[l,r]$，若区间长度大于因子幂，则符合条件，不大于则条件不符合。

时间复杂度$\Omicron(tn\log n)$。空间复杂度为$\Omicron(n\log n)$。

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 100010
ll t, n, m, a[mn], l, r, d;
vector<ll> p[mn];
void upd(ll &v, const ll pi, const ll &pv)
{
    p[pi].emplace_back(pv);
    v /= pi;
}
bool chk(const ll &i, const ll &req)
{
    auto hs = upper_bound(p[i].begin(), p[i].end(), r) - lower_bound(p[i].begin(), p[i].end(), l);
    return hs >= req;
}
signed main()
{
    sc(t);
    while (t--)
    {
        sc(n), sc(m);
        for (ll i = 0; i <= 100000; ++i)
        {
            p[i].clear();
        }
        for (ll i = 1; i <= n; ++i)
        {
            sc(a[i]);
            for (ll j = 2; j * j <= a[i]; ++j)
            {
                while (a[i] % j == 0)
                {
                    // upd(a[i], j, i);
                    p[j].emplace_back(i);
                    a[i] /= j;
                }
            }
            if (a[i] > 1)
            {
                // upd(a[i], a[i], i);
                p[a[i]].emplace_back(i);
            }
        }
        while (m--)
        {
            sc(l), sc(r), sc(d);
            bool suc = true;
            for (ll i = 2, req; i * i <= d; ++i)
            {
                req = 0;
                if (d % i == 0)
                {
                    while (d % i == 0)
                    {
                        d /= i, ++req;
                    }
                    auto hs = upper_bound(p[i].begin(), p[i].end(), r) - lower_bound(p[i].begin(), p[i].end(), l);
                    if (hs < req)
                    {
                        suc = 0;
                        break;
                    }
                }
            }
            if (d > 1)
            {
                auto hs = upper_bound(p[d].begin(), p[d].end(), r) - lower_bound(p[d].begin(), p[d].end(), l);
                if (hs < 1)
                {
                    suc = 0;
                }
            }
            printf(suc ? "Yes\n" : "No\n");
        }
    }
    return 0;
}
```



##### hdu-1003 Max Sum

> 求最大连续子序列和及其边界 $1\le n\le10^5$

个人代码：(试了很多次)

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 100010
ll t, n, s[mn], v, lf, rf, ans, mins, minlf, maxv, maxi;
signed main()
{
    sc(t);
    for (ll h = 1; h <= t; ++h)
    {
        sc(n);
        mins = rf = ans = minlf = 0, maxv = -9999;
        for (ll i = 1; i <= n; ++i)
        {
            sc(v);
            s[i] = s[i - 1] + v; //s[i]是区间[1,i]和
            if (v > maxv)        //全负特判
            {
                maxv = v;
                maxi = i;
            }
            if (s[i] < mins)
            {
                mins = s[i]; //mins已知1为左端的最小区间和
                minlf = i;   //mins区间为[1,minlf]
            }
            //[1,i] 减去 [1,minlf] 是 [minlf+1,i]
            if (s[i] - mins > ans)
            {
                ans = s[i] - mins;
                lf = minlf + 1;
                rf = i;
            }
        }
        if (maxv <= 0)
        {
            ans = maxv, lf = rf = maxi;
        }
        if (h > 1)//乐，竟然会PE
        {
            printf("\n");
        }
        printf("Case %lld:\n%lld %lld %lld\n", h, ans, lf, rf);
    }
    return 0;
}
```

更优解法：[这里](https://blog.csdn.net/weixin_40894017/article/details/79134244)

```c++
#include<bits/stdc++.h>
using namespace std;//由于本题从前往后更新，所以不用另开数组
int dp[100005];//dp[i]记录的是以dp[i]为结尾的最大值；
int main()
{
	int n;cin>>n;
	for(int kk=1;kk<=n;kk++){
		int t;cin>>t;
		memset(dp,0,sizeof(dp));
		for(int i=1;i<=t;i++)
		{
			scanf("%d",&dp[i]);
		}
		int l=1,r=1;//记录区间
		int temp=1;//记录起点
		int MAx=dp[1];
		for(int i=2;i<=t;i++)
		{
            if(dp[i-1]>=0)//dp[i-1]大于0，则对dp[i]有贡献
            {
                dp[i]=dp[i-1]+dp[i];
            }else{temp=i;}
            if(dp[i]>MAx)
            {
            	MAx=dp[i];
            	l=temp;
         	    r=i;
            }
		}
		if(kk>=2){printf("\n");}
		printf("Case %d:\n",kk);
		printf("%d %d %d\n",MAx,l,r);
	}
}
```



## CCF

> 补题链接：http://118.190.20.162/home.page

### 标签

#### 23CCF

1. 数组推导

   签到 思维

2. 非零段划分

   签到 思维

3. 脉冲神经网络

   大模拟 图论

4. 收集卡牌

   状压DP / 记忆化搜索

5. 箱根山岳险天下

   LCT



#### 22CCF

1. 灰度直方图

   签到 计数(排序)

2. 领域均值

   签到 滑动窗口

3. DHCP服务器

   大模拟

4. 校门外的树

   DP 因数筛

5. 疫苗运输

   Dijkstra最短路 exgcd解二元方程



### 题目

#### 23CCF

##### 数组推导

从补题时自己的水平来看，自然是签到题就是了。

一开始WA了一发，以为非固定值要放第一个元素，后来猛然一想放 0 不就好了。这样例坑了我一把

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 110
ll n, b[mn], mi, mx, miv;
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", &b[i]);
    }
    miv = mi = mx = b[1];
    for (ll i = 2; i <= n; ++i)
    {
        if (b[i] == b[i - 1])
        {
            mi += 0;
        }
        else
        {
            mi += b[i];
        }
        mx += b[i];
    }
    printf("%lld\n%lld \n", mx, mi);
    return 0;
}
```



##### 非零段划分

一开始题目没读完就想着是不是二分答案(二分p)，然后写到一半猛然想到好像不满足单调性啊；然后想着是不是链表+并查集。然后刚把并查集板子敲完，然后发现好像找段并没有这么简单。(属于是被自己出题出魔怔了，刚好蓝桥热身自己出过一道二分+并查集+链表的题目)

然后思索了几分钟，发现好像直接枚举然后删就可以了。删的时候会 $-1$ ，两边有的话各 $+1$ 。就这么简单。不管连不连续都是这样的。

所以一发过了

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 500010
ll a[mn], n, fa[mn], ans, now;
vector<ll> bin[10010];
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
    }
    for (ll i = 1, cnt = 0; i <= n + 1; ++i)
    {
        bin[a[i]].emplace_back(i);
        if (a[i])
        {
            ++cnt;
        }
        else
        {
            now += (cnt != 0);
            cnt = 0;
        }
    }
    ans = now;
    for (ll v = 1; v <= 10000; ++v)
    {
        for (auto i : bin[v])
        {
            --now;
            a[i] = 0;
            now += (a[i - 1] != 0) + (a[i + 1] != 0);
        }
        ans = max(ans, now);
    }
    printf("%lld", ans);
    return 0;
}
```



##### 脉冲神经网络

花了很久才读懂题目。读懂之后就可以上大模拟了。逐秒模拟即可。完全理解题意之后感觉也题意不是特别复杂……虽然光是把输入读懂就花了不少时间。一开始写好显然就炸了，然后debug了一会发现竟然是输入炸了，读多个同神经元的时候的内层循环条件有问题。

然后喜提66分RE，发现看少了一个0大概，然后喜提66分TLE。然后进行了多次常数优化，均以失败告终。包括把前向星改了，结构体拆了很多，之类的。一开始没有冲量二维的，而是按vector来记录每一次脉冲事件的，然后喜提TLE+MLE。然后就觉得是不行了。考虑到 $T$ 的范围，想到了可以压缩数组压二维事件。

后来看了题解，发现可以压缩二维冲量。但是我把自己的代码调整到跟题解几乎一样了，还是不能过题。不过据别人说这题卡常也确实很阴间。所以放弃继续往下深思或重写一次了。目前的思路就算是正确的了。

不过显然复杂度都到 $10^8$ 了，这常数拿头来压。挂一个最后的 $66$ 分TLE代码吧

```c++
#include <bits/stdc++.h>
using namespace std;
#define re register
#define il inline
typedef int ll;
typedef double db;
#define big 1e9
ll n, s, p, t;
#define mn 1005
db v[mn], u[mn], a[mn], b[mn], c[mn], d[mn], dt, ik[mn][mn];
ll r[mn * 2], num[mn];
struct edge
{
    ll to;
    db w;
    ll d;
};
vector<edge> g[mn * 2];

static unsigned long nex = 1;
/* RAND_MAX assumed to be 32767 */
int myrand(void)
{
    nex = nex * 1103515245 + 12345;
    return ((unsigned)(nex / 65536) % 32768);
}

void f()
{
    for (re ll i = 1; i <= t; ++i)
    {
        for (re ll j = n, je = 0, nownx; je < p; ++je, ++j)
        {
            nownx = myrand();
            if (r[j] > nownx)
            {
                for (ll h = 0, he = g[j].size(); h < he; ++h)
                {
                    edge &e = g[j][h];
                    ik[(i + e.d) % mn][e.to] += e.w;
                }
            }
        }
        for (re ll j = 0; j < n; ++j)
        {
            db pv = v[j], pu = u[j];
            v[j] = pv + dt * ((0.04 * pv + 5) * pv + 140 - pu) + ik[i % mn][j];
            u[j] = pu + dt * a[j] * (b[j] * pv - pu);
            if (v[j] >= 30)
            {
                v[j] = c[j];
                u[j] += d[j];
                ++num[j];
                for (ll h = 0, he = g[j].size(); h < he; ++h)
                {
                    edge &e = g[j][h];
                    ik[(i + e.d) % mn][e.to] += e.w;
                }
            }
            ik[i % mn][j] = 0;
        }
    }
    db mi = big, mx = -big;
    ll nmi = big, nmx = -big;
    for (re ll i = 0; i < n; ++i)
    {
        mi = min(mi, v[i]);
        mx = max(mx, v[i]);
        nmi = min(nmi, num[i]);
        nmx = max(nmx, num[i]);
    }
    printf("%.3lf %.3lf\n%d %d", mi, mx, nmi, nmx);
}

db vi, ui, ai, bi, ci, di, wi;
ll ri;
signed main()
{
    scanf("%d%d%d%d%lf", &n, &s, &p, &t, &dt);
    for (ll rn = 0, i = 0; rn < n;)
    {
        scanf("%d%lf%lf%lf%lf%lf%lf", &ri, &vi, &ui, &ai, &bi, &ci, &di);
        for (ll j = 0; j < ri; ++j, ++i)
        {
            v[i] = vi, u[i] = ui, a[i] = ai, b[i] = bi, c[i] = ci, d[i] = di;
        }
        rn += ri;
    }
    for (ll i = n, j = 0; j < p; ++j, ++i)
    {
        scanf("%d", &r[i]);
    }
    for (ll i = 0, si, ti, di; i < s; ++i)
    {
        scanf("%d%d%lf%d", &si, &ti, &wi, &di);
        g[si].push_back({ti, wi, di});
    }
    f();
    return 0;
}
```



##### 收集卡牌

爆搜很容易想。花了一小时推导 $p$ 相等的情况，觉得是 DP，方程也推得差不多了，但是最后发现实现不出来，即概率阻断后怎么防止不干扰，怎么都没搞对。我设的是 $dp[i][j]$ 代表当前抽了 $i$ 个不同邮票，有 $j-1$ 个硬币(防止 $0$ 的越界)的概率。初始值是 $dp[1][1]=1$ 。递推是用记忆化搜索来，方程不是特别难。然后答案累积的时候把概率叠上步骤。

一开始用小 $k$ 递推。发现是可以倒道来，即 $i=n$ 有 $k$ 个，往下有 $n-1$ 有更高的 $k$ 个……以此类推，到 $n=1$ 时只有一个，因为阻断了。然后阻断就设 $dp$ 值为 $0$ 。然后写完代码了一交一个零蛋。重新思考发现 $k$ 大了好像完全不同了，阻断的情况太复杂了，根本推不出来。

全错代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define mn 105
db dp[mn][mn], p[mn];
ll n, k, sa = 1;
bool vis[mn][mn];

db dfs(ll x, ll y)
{
    if (vis[x][y] || x == 0 || y == 0)
    {
        return dp[x][y];
    }
    vis[x][y] = true;
    dp[x][y] = dfs(x, y - 1) * x * p[1] + dfs(x - 1, y) * (n - x + 1) * p[1];
    return dp[x][y];
}

void fs()
{
    dp[1][1] = 1;
    vis[1][1] = true;
    db ans = 0;
    for (ll x = n, y = 1; x >= 2; --x)
    {
        for (ll j = 0; j < k; ++j, ++y)
        {
            ans += dfs(x, y) * (x + y - 1);
            printf("%lld %lld %lf\n", x, y, dp[x][y]);
            dp[x][y] = 0;
        }
    }
    ans += dfs(1, k * (n - 1) + 1) * (k * (n - 1) + 1);
    printf("%lld %lld %lf\n", 1LL, k * (n - 1) + 1, dp[1][k * (n - 1) + 1]);
    printf("%.12lf\n", ans);
}

signed main()
{
    scanf("%lld%lld", &n, &k);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lf", p + i);
    }
    for (ll i = 2; i <= n; ++i)
    {
        if (p[i] != p[i - 1])
        {
            sa = 0;
        }
    }
    if (sa)
    {
        fs();
    }
    return 0;
}
```

然后写了一个爆搜代码，骗了20分跑人了：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long double db;
#define mn 105
db p[mn];
ll n, k;
ll cnt[mn];
db dfs(ll suc, ll fai, db pos)
{
    db ans = 0;
    if (suc + fai / k >= n)
    {
        return (suc + fai) * pos;
    }
    for (ll i = 1; i <= n; ++i)
    {
        db nwpos = pos * p[i];
        ll nwsuc = suc, nwfai = fai;
        if (cnt[i])
        {
            nwfai++;
        }
        else
        {
            nwsuc++;
        }
        ++cnt[i];
        ans += dfs(nwsuc, nwfai, nwpos);
        --cnt[i];
    }
    return ans;
}
signed main()
{
    scanf("%d%d", &n, &k);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%Lf", p + i);
    }
    printf("%.10Lf", dfs(0, 0, 1.0));
    return 0;
}
```

然后看题解，可以用状压记忆化搜索，设状态代表当前有多少有的邮票，第二维状态是当前的硬币数，然后暴力记忆化搜索即可，整体思路不难：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define mn 17
#define mk 6
db p[mn], dp[1 << mn][mn * mk];
ll n, k;
bool vis[1 << mn][mn * mk];
db dfs(ll state, ll coins, ll ngot)
{ //当前状态还要额外用多少期望才能得到结果
    if (vis[state][coins])
    {
        return dp[state][coins];
    }
    if (state == (1 << n) - 1 || coins / k >= ngot)
    { //结束态无需额外花费
        return 0;
    }
    db res = 0;
    for (ll i = 0; i < n; ++i)
    {
        ll si = (state >> i) & 1;
        if (!si) //未得到第i张牌
        {        //那么以p[i]概率得到这张牌，花费1
            db nw = dfs(state | (1 << i), coins, ngot - 1);
            res += (nw + 1) * p[i];
        }
        else //得到了，硬币+1
        {
            db nw = dfs(state, coins + 1, ngot);
            res += (nw + 1) * p[i];
        }
    }
    vis[state][coins] = true;
    dp[state][coins] = res;
    return res;
}
signed main()
{
    scanf("%lld%lld", &n, &k);
    for (ll i = 0; i < n; ++i)
    {
        scanf("%lf", p + i);
    }
    printf("%.10lf", dfs(0, 0, n));
    return 0;
}
```



##### 箱根山岳险天下

本来想骗点分的，然后发现在强制在线下我完全区分不开数据点，而且维护乘法+取模还要比大小这个操作我真不会。所以到头来我连一个点都没办法入手。遗憾0分离场，代码都没交，就试了一下`pb_ds`能不能用，发现可以。

标解是LCT。没学过，以后补。见[这里](https://blog.csdn.net/qq_51557417/article/details/120927426?spm=1001.2014.3001.5506)



#### 22CCF

##### 灰度直方图

究极签到题不解释，一发过

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, m, l, a, bin[300];
signed main()
{
    scanf("%lld%lld%lld", &n, &m, &l);
    for (ll i = 0; i < n; ++i)
    {
        for (ll j = 0; j < m; ++j)
        {
            scanf("%lld", &a);
            ++bin[a];
        }
    }
    for (ll i = 0; i < l; ++i)
    {
        printf("%lld ", bin[i]);
    }
    return 0;
}
```



##### 邻域均值

一开始我读错题目了，然后以为区域是菱形的，写了个比较复杂的滑窗，样例显然没过；然后输出了一下发现最初值就是个正方形区域啊……反正思路就是每行初始跑一次，之后每次往右滑，删一行加一行。复杂度是 $\Omicron(nr^2+n^2r)$ 

代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 606
ll n, l, r, t, a[mn][mn], ans, cnt, sums;
inline bool nin(const ll &x, const ll &y, const ll &i, const ll &j)
{
    return x < 0 || y < 0 || x >= n || y >= n || abs(x - i) > r || abs(y - j) > r;
}
inline void acc()
{
    ans += (1.0 * sums / cnt) <= t;
}
signed main()
{
    scanf("%lld%lld%lld%lld", &n, &l, &r, &t);
    for (ll i = 0; i < n; ++i)
    {
        for (ll j = 0; j < n; ++j)
        {
            scanf("%lld", &a[i][j]);
        }
    }
    for (ll i = 0; i < n; ++i)
    {
        cnt = 0, sums = 0;
        for (ll dx = -r, j = 0; dx <= r; ++dx)
        {
            for (ll dy = -r; dy <= r; ++dy)
            {
                ll x = i + dx, y = j + dy;
                if (nin(x, y, i, j))
                {
                    continue;
                }
                ++cnt;
                sums += a[x][y];
            }
        }
        acc();
        for (ll j = 1; j < n; ++j)
        {
            for (ll x = i - r, y1 = j - r - 1, y2 = j + r; x <= i + r; ++x)
            {
                if (!nin(x, y1, i, j - 1))
                {
                    --cnt, sums -= a[x][y1];
                }
                if (!nin(x, y2, i, j))
                {
                    ++cnt, sums += a[x][y2];
                }
            }
            acc();
        }
    }
    printf("%lld", ans);
    return 0;
}
```



##### DHCP服务器

天知道我写了多久……读懂题目花了很久，然后调各种bugs改了很久，比如时间调整运算有误，各种重复和去重运算有误，过期被延期取消我还是让它过期之类的，反正就是到处出错。因为我一开始读错题目了以为是 $10^5$ 个点，所以全部找最小值之类的遍历查询操作全部被我用 $set$ 来写了，然后自然开了一大堆 $set$ ，然后究竟重复与否，计次什么的反正就是一堆问题。然后写了个巨长的代码，样例终于是能过了，然后一交一个WA60分。时间倒是只有几十ms。然后改了点什么，好像是修了点bugs，然后再交一个66分，之后一直卡在66分没有再进展了，最终代码巨长无比，是这样的：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define il inline
#define mn 100010
ll n, tdef, tmax, tmin, num, gi;
string h;
struct baowen
{
    string from, to, type;
    ll ip, expire, t;
} bw[mn];

#define sunalloc 1
#define swaitalloc 2
#define soccupy 3
#define sexpire 4
struct pool
{
    ll state, owner, expire;
} p[mn];

struct task
{
    ll ty, i, t, state; //ty0报文,1过期
    bool operator<(const task &r) const
    {
        return t != r.t ? t > r.t : ty < r.ty;
    }
};
set<ll> uid[mn * 2];
string iton[mn * 2];
map<string, ll> ntoi;
ll ntois;
il void addname(string &name)
{
    if (!ntoi[name])
    {
        ntoi[name] = ++ntois;
        iton[ntois] = name;
    }
}

set<ll> munalloc, mexpire;
priority_queue<task> q;

void adjust_expiretime(ll &bwexpire, ll ot)
{
    if (!bwexpire)
    {
        bwexpire = ot + tdef;
    }
    else if (bwexpire - ot < tmin)
    {
        bwexpire = ot + tmin;
    }
    else if (bwexpire - ot > tmax)
    {
        bwexpire = ot + tmax;
    }
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> num >> tdef >> tmax >> tmin >> h >> n;
    for (ll g = 0; g < n; ++g)
    {
        cin >> bw[g].t >> bw[g].from >> bw[g].to >> bw[g].type >> bw[g].ip >> bw[g].expire;
        addname(bw[g].from), addname(bw[g].to);
        q.push({0, g, bw[g].t, 0});
    }
    gi = n;

    for (ll i = 1; i <= num; ++i)
    {
        munalloc.insert(i);
    }

    while (!q.empty())
    {
        task qi = q.top();
        q.pop();
        ll oi = qi.i;
        ll ot = qi.t;
        if (qi.ty == 0)
        {
            --gi;
            string &ty = bw[oi].type;
            string &to = bw[oi].to;
            bool ndeal = false;
            if (!(to == h || to == "*") && ty != "REQ")
            {
                ndeal = true;
            }
            if (!(ty == "DIS" || ty == "REQ"))
            {
                ndeal = true;
            }
            if ((to == "*" && ty != "DIS") || (to == h && ty == "DIS"))
            {
                ndeal = true;
            }
            string &from = bw[oi].from;
            ll fromid = ntoi[from];

            if (!ndeal)
            {
                if (ty == "DIS")
                {
                    ll seleid = 0;
                    if (uid[fromid].size())
                    {
                        seleid = *uid[fromid].begin();
                    }
                    else if (munalloc.size())
                    {
                        seleid = *munalloc.begin();
                        // munalloc.erase(seleid);
                    }
                    else if (mexpire.size())
                    {
                        seleid = *mexpire.begin();
                        // mexpire.erase(seleid);
                    }
                    else
                    {
                        ndeal = true;
                    }

                    if (!ndeal)
                    {
                        p[seleid].state = swaitalloc;
                        p[seleid].owner = fromid;
                        uid[fromid].insert(seleid);
                        ll bwexpire = bw[oi].expire;
                        adjust_expiretime(bwexpire, ot);
                        p[seleid].expire = bwexpire;

                        // mexpire.erase(seleid);
                        munalloc.erase(seleid);
                        cout << h << ' ' << from << " OFR " << seleid << ' ' << bwexpire << "\n";
                        q.push({1, seleid, bwexpire, swaitalloc});
                    }
                }
                else if (ty == "REQ")
                {
                    if (to != h)
                    {
                        stack<ll> derase;
                        for (ll i : uid[fromid])
                        {
                            if (p[i].state == swaitalloc && p[i].owner == fromid)
                            {
                                p[i].state = sunalloc;
                                p[i].owner = 0;
                                p[i].expire = 0;
                                munalloc.insert(i);
                                derase.push(i);
                            }
                        }
                        while (derase.size())
                        {
                            uid[fromid].erase(derase.top());
                            derase.pop();
                        }
                    }
                    else
                    {
                        ll bwip = bw[oi].ip;
                        ll seleid = bw[oi].ip;
                        if (bwip < 1 || bwip > n || p[seleid].owner != fromid)
                        {
                            cout << h << ' ' << from << " NAK " << bw[oi].ip << " 0\n";
                        }
                        else
                        {
                            uid[fromid].insert(seleid);
                            p[seleid].state = soccupy;
                            p[seleid].owner = fromid;
                            ll bwexpire = bw[oi].expire;
                            adjust_expiretime(bwexpire, ot);
                            p[seleid].expire = bwexpire;

                            mexpire.erase(seleid);
                            munalloc.erase(seleid);
                            cout << h << ' ' << from << " ACK " << seleid << ' ' << bwexpire << "\n";
                            q.push({1, seleid, bwexpire, soccupy});
                        }
                    }
                }
            }
            if (!gi)
            {
                break;
            }
        }
        else
        {
            if (qi.state != p[oi].state || p[oi].expire > ot)
            {
                continue;
            }
            if (p[oi].state == swaitalloc)
            {
                p[oi].state = sunalloc;
                munalloc.insert(oi);
            }
            else if (p[oi].state == soccupy)
            {
                p[oi].state = sexpire;
                mexpire.insert(oi);
            }
            if (p[oi].owner)
            {
                uid[p[oi].owner].erase(oi);
            }
        }
    }
    return 0;
}
```

然后看题解，猛然发现这 $10^4$ 的复杂度，什么找最小直接遍历就行了，时间也不需要穿插的，每次报文前暴力更新一次就好了，然后重写了一次，debug了一会儿，出了一个满分补题代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 10010
struct pool
{
    ll state, owner, expire;
} p[mn];
map<string, ll> ntoi;
string iton[mn * 2], h, from, to, req = "REQ", dis = "DIS", ty;
ll ntois, n, tc, tdef, tmax, tmin;
ll t, fromid, id, expire;
#define sunalloc 0
#define swaitalloc 2
#define soccupy 3
#define sexpire 4
void addname(string &v)
{
    if (!ntoi[v])
    {
        ntoi[v] = ++ntois;
        iton[ntois] = v;
    }
}
ll fixdate(ll v)
{
    if (!v)
    {
        return tdef + t;
    }
    if (v - t < tmin)
    {
        return tmin + t;
    }
    if (v - t > tmax)
    {
        return tmax + t;
    }
    return v;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> n >> tdef >> tmax >> tmin >> h >> tc;
    while (tc--)
    {
        cin >> t >> from >> to >> ty >> id >> expire;
        addname(from), addname(to);
        fromid = ntoi[from];
        if (!(to == h || to == "*") && ty != req)
        {
            continue;
        }
        if (!(ty == req || ty == dis))
        {
            continue;
        }
        if ((to == "*" && ty != dis) || (to == h && ty == dis))
        {
            continue;
        }
        for (ll i = 1; i <= n; ++i)
        {
            if (p[i].expire && p[i].expire <= t)
            {
                if (p[i].state == swaitalloc)
                {
                    p[i].state = sunalloc;
                    p[i].expire = p[i].owner = 0;
                }
                else if (p[i].state == soccupy)
                {
                    p[i].state = sexpire;
                    p[i].expire = 0;
                }
            }
        }
        if (ty == dis)
        {
            ll seleid = 0;
            for (ll i = 1; i <= n; ++i)
            {
                if (p[i].owner == fromid)
                {
                    seleid = i;
                    break;
                }
            }
            if (!seleid)
            {
                for (ll i = 1; i <= n; ++i)
                {
                    if (p[i].state == sunalloc)
                    {
                        seleid = i;
                        break;
                    }
                }
            }
            if (!seleid)
            {
                for (ll i = 1; i <= n; ++i)
                {
                    if (p[i].state == sexpire)
                    {
                        seleid = i;
                        break;
                    }
                }
            }
            if (!seleid)
            {
                continue;
            }
            p[seleid].state = swaitalloc;
            p[seleid].owner = fromid;
            expire = fixdate(expire);
            p[seleid].expire = expire;
            cout << h << ' ' << from << " OFR " << seleid << ' ' << expire << '\n';
        }
        else if (ty == req)
        {
            if (to != h)
            {
                for (ll i = 1; i <= n; ++i)
                {
                    if (p[i].owner == fromid && p[i].state == swaitalloc)
                    {
                        p[i].state = sunalloc;
                        p[i].owner = p[i].expire = 0;
                    }
                }
                continue;
            }
            if (id > n || id < 1 || p[id].owner != fromid)
            {
                cout << h << ' ' << from << " NAK " << id << " 0\n";
                continue;
            }
            p[id].state = soccupy;
            expire = fixdate(expire);
            p[id].expire = expire;
            cout << h << ' ' << from << " ACK " << id << ' ' << expire << "\n";
        }
    }
    return 0;
}
```



##### 校门外的树

这道题就……耗费了久了。尝试了很久。

发现了一个猜想结论，即不可能出现子段加起来刚好等于父段的情况，如果是的话一定会被障碍物卡住。

我设的区间 DP，是 $dp[i][j]$ 一开始表示两树 $[i,j]$ 为边界的答案是多少我以为直接子段累乘即可，即：
$$
dp[i][j]=\sum_{k=i+1}^{j-1}dp[i][k]\times dp[k][j]+cnt[i][j]
$$
然后按区间长度顺序遍历即可。区间 DP 板子。内层计算时枚举因数作为公差，然后枚举每个区间内障碍，判断离左边界的差是否能被整除，能的话就是挡住了。这个做法时间复杂度是 $\Omicron(n^3\sqrt a)$ 。

然后一交一个 WA，得了10分。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 1010
ll n, a[mn], dp[mn][mn], mod = 1e9 + 7;
bool check(ll p, ll i, ll j)
{
    for (ll k = i + 1; k < j; ++k)
    {
        if ((a[k] - a[i]) % p == 0)
        {
            return false;
        }
    }
    // printf("- %lld %lld %lld\n", i, j, p);
    return true;
}
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
    }
    for (ll d = 1; d < n; ++d)
    {
        for (ll i = 1, j = i + d; j <= n; ++i, ++j)
        {
            ll v = a[j] - a[i], cnt = 0;
            // printf("<%lld %lld %lld\n", i, j, v);
            for (ll p = 1; p * p <= v; ++p)
            {
                if (v % p == 0)
                {
                    cnt += check(p, i, j);
                    cnt += v / p != p && v / p != v && check(v / p, i, j);
                }
            }
            for (ll k = i + 1; k < j; ++k)
            {
                dp[i][j] = (dp[i][j] + dp[i][k] * dp[k][j]) % mod;
            }
            dp[i][j] = (dp[i][j] + cnt) % mod;
            // printf("%lld %lld %lld %lld\n", i, j, cnt, dp[i][j]);
        }
    }
    printf("%lld", dp[1][n]);
    return 0;
}
```

然后思考可能是累乘重复了。想了很久，然后重新推导定义 $dp[i][j]$ 代表单独自己的第一个条件下成立的个数。然后用爆搜推导另一个答案 $ans[i]$ 代表长为 $i$ 的头这么多的答案是多少。爆搜即对于当前 $i$ ，前面的已经算好了，然后当前可以走 $j$ 区间长，走的时候加上区间 $dp$ 值即这个区间单独的计数，乘上选了它之后剩下的子问题。 一交一个意料之中的TLE：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 1010
ll n, a[mn], dp[mn][mn], mod = 1e9 + 7, me[mn];
bool vis[mn];
bool check(ll p, ll i, ll j)
{
    for (ll k = i + 1; k < j; ++k)
    {
        if ((a[k] - a[i]) % p == 0)
        {
            return false;
        }
    }
    return true;
}
ll dfs(ll now)
{
    if (vis[now])
    {
        return me[now];
    }
    if (now == n)
    {
        return 1;
    }
    ll nw = 0;
    for (ll step = 1; now + step <= n; ++step)
    {
        nw = (nw + dp[now][now + step] * dfs(now + step) % mod) % mod;
    }
    me[now] = nw;
    vis[now] = true;
    return nw;
}
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
    }
    for (ll d = 1; d < n; ++d)
    {
        for (ll i = 1, j = i + d; j <= n; ++i, ++j)
        {
            ll v = a[j] - a[i], cnt = 0;
            for (ll p = 1; p * p <= v; ++p)
            {
                if (v % p == 0)
                {
                    cnt += check(p, i, j);
                    cnt += v / p != p && v / p != v && check(v / p, i, j);
                }
            }
            dp[i][j] = cnt;
        }
    }
    printf("%lld", dfs(1));
    return 0;
}
```

然后思索了一会儿，发现这个东西往下的 DFS 就是一样的子问题(之前以为是不一样的)，那为什么不可以记忆化呢？然后改了改，得到 WA 50分。

测试了一下第三个样例，发现真正用时间的是 DP。然后发现质数可以预处理，然后优化成了 DP 部分的复杂度(你优化了个屁)是 $\Omicron(a\sqrt a+n^3\sqrt a)$。然后又不知道怎么地改了改喜提 TLE 60分：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 1010
ll n, a[mn], dp[mn][mn], mod = 1e9 + 7, me[mn], mxa;
bool vis[mn];
bool check(ll p, ll i, ll j)
{
    for (ll k = i + 1; k < j; ++k)
    {
        if ((a[k] - a[i]) % p == 0)
        {
            return false;
        }
    }
    return true;
}
ll dfs(ll now)
{
    if (vis[now])
    {
        return me[now];
    }
    if (now == n)
    {
        return 1;
    }
    ll nw = 0;
    for (ll step = 1; now + step <= n; ++step)
    {
        nw = (nw + dp[now][now + step] * dfs(now + step)) % mod;
    }
    me[now] = nw;
    vis[now] = true;
    return nw;
}
vector<ll> f[100010];
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
        mxa = max(mxa, a[i]);
    }
    for (ll i = 2; i <= mxa; ++i)
    {
        for (ll j = 1; j * j <= i; ++j)
        {
            if (i % j == 0)
            {
                f[i].emplace_back(j);
                if (i / j != j && i / j != i)
                {
                    f[i].emplace_back(i / j);
                }
            }
        }
    }
    for (ll d = 1; d < n; ++d)
    {
        for (ll i = 1, j = i + d; j <= n; ++i, ++j)
        {
            ll v = a[j] - a[i], cnt = 0;
            for (ll k = 0, ke = f[v].size(); k < ke; ++k)
            {
                cnt += check(f[v][k], i, j);
            }
            dp[i][j] = cnt;
        }
    }
    // printf("done\n");
    printf("%lld", dfs(1));
    return 0;
}
```

然后又改了改，想了很久，想把枚举的也砍了，于是对每个枚举，判断其因子数，即取 gcd 然后看因子数，对其因子和自己，全部在桶里标记失败。最后只积累没有标记失败的因数。但是复杂度其实没怎么变，而且还加一个 gcd 是对数的，可能还会更差……但是不大好说，因子数肯定是小了，但是次数又变多了……所以还是 TLE60分：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 1010
#define mp 100010
ll n, a[mn], dp[mn][mn], mod = 1e9 + 7, me[mn], mxa;
ll fre[mp];
bool vis[mn];
bool check(ll p, ll i, ll j)
{
    for (ll k = i + 1; k < j; ++k)
    {
        if ((a[k] - a[i]) % p == 0)
        {
            return false;
        }
    }
    return true;
}
ll dfs(ll now)
{
    if (vis[now])
    {
        return me[now];
    }
    if (now == n)
    {
        return 1;
    }
    ll nw = 0;
    for (ll step = 1; now + step <= n; ++step)
    {
        nw = (nw + dp[now][now + step] * dfs(now + step)) % mod;
    }
    me[now] = nw;
    vis[now] = true;
    return nw;
}
vector<ll> f[mp];
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
        mxa = max(mxa, a[i]);
    }
    for (ll i = 2; i <= mxa; ++i)
    {
        for (ll j = 1; j * j <= i; ++j)
        {
            if (i % j == 0)
            {
                f[i].emplace_back(j);
                if (i / j != j && i / j != i)
                {
                    f[i].emplace_back(i / j);
                }
            }
        }
    }
    for (ll d = 1; d < n; ++d)
    {
        for (ll i = 1, j = i + d; j <= n; ++i, ++j)
        {
            ll v = a[j] - a[i], cnt = 0;
            for (ll k = 0, ke = f[v].size(); k < ke; ++k)
            {
                fre[f[v][k]] = 1;
            }
            for (ll k = i + 1; k < j; ++k)
            {
                ll gcd = __gcd(a[k] - a[i], v);
                for (ll g = 0, ge = f[gcd].size(); g < ge; ++g)
                {
                    fre[f[gcd][g]]--;
                }
                fre[gcd]--;
            }
            for (ll k = 0, ke = f[v].size(); k < ke; ++k)
            {
                cnt += fre[f[v][k]] > 0;
            }
            dp[i][j] = cnt;
        }
    }
    printf("%lld", dfs(1));
    return 0;
}
```

然后终于妥协了，看了题解……妙啊。解法思路是：

先用筛法预处理因数，根据调和级数，可知预处理复杂度是 $\Omicron(a\log a)$ 。

设 $dp[i]$ 代表当前区间答案，那么有初始值 $dp[1]=1$ ，递推方程：
$$
dp[i]=\sum_{j=1}^{i-1}dp[j]\times cnt[j][i]
$$
这个可以理解，但是我自己做的时候没想出来。

然后关键是 $cnt$ 的计算。对右边界 $i$ ，倒序枚举 $j$ 。第一个 $j$ 所有因数都可以。到下一个的时候，上一个的所有因数都会在上一个的左边界作为障碍，所以这些因数都不可以。那么对下一个的因数，用 $set$ 维护曾经因数，如果不在就计数且放进曾经因数，在就忽略。注意区间长本身也要，因为刚好第一棵树就碰到了左边界，而这是因素筛和计数没有枚举到的。

时间复杂度为 $\Omicron(a\log a+n^2\log a\log n)$ 。

代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 1010
#define ma 100010
ll n, mod = 1e9 + 7, a[mn], dp[mn];
vector<ll> v[ma];
set<ll> s;
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
    }
    for (ll i = 1; i <= a[n] / 2; ++i)
    {
        for (ll j = 2 * i; j <= a[n]; j += i)
        {
            v[j].emplace_back(i);
        }
    }
    dp[1] = 1;
    for (ll i = 2; i <= n; ++i)
    {
        s.clear();
        for (ll j = i - 1; j >= 1; --j)
        {
            ll d = a[i] - a[j], cnt = 0;
            s.insert(d);
            for (ll k = 0; k < (ll)v[d].size(); ++k)
            {
                ll vi = v[d][k];
                if (s.find(vi) == s.end())
                {
                    ++cnt;
                    s.insert(vi);
                }
            }
            dp[i] = (dp[i] + cnt * dp[j]) % mod;
        }
    }
    printf("%lld", dp[n]);
    return 0;
}
```



##### 疫苗运输

发现可以骗分，于是只考虑不相交的情况打了个暴力。一开始因为细节问题WA了只有5分。然后改了之后竟然有35分，大赚一笔。代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 505
#define big 0x7ffffffa
ll n, m, no[mn][mn], arr[mn][mn], num[mn], dar[mn][mn], ans[mn];
vector<ll> its[mn];
signed main()
{
    scanf("%lld%lld", &n, &m);
    for (ll i = 1; i <= n; ++i)
    {
        ans[i] = big;
    }
    for (ll i = 1; i <= m; ++i)
    {
        scanf("%lld", num + i);
        ll ever = 0;
        for (ll j = 1; j <= num[i]; ++j)
        {
            scanf("%lld%lld", &no[i][j], &dar[i][j]);
            its[no[i][j]].emplace_back(i);
            arr[i][j + 1] = arr[i][j] + dar[i][j];
            ever = no[i][j] == 1 ? j : ever;
        }
        arr[i][1] = arr[i][num[i] + 1];
        for (ll j = 1; j < ever; ++j)
        {
            arr[i][j + 1] = arr[i][j] + dar[i][j];
        }
    }
    if (its[1].size())
    {
        for (ll j = 0, je = its[1].size(); j < je; ++j)
        {
            for (ll k = 1, ke = num[its[1][j]]; k <= ke; ++k)
            {
                ll u = no[its[1][j]][k];
                ans[u] = min(ans[u], arr[its[1][j]][k]);
            }
        }
    }
    for (ll i = 2; i <= n; ++i)
    {
        if (ans[i] != big)
        {
            printf("%lld\n", ans[i]);
        }
        else
        {
            printf("inf\n");
        }
    }
    return 0;
}
```

标解看懂了，最短路还好，关键是求方程用exgcd，没想到。不过就算都知道，实现起来也很不简单。

最后题解见：[这里](https://blog.csdn.net/qq_45734984/article/details/119650624?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.essearch_pc_relevant)



# POJ

[链接](http://poj.org/)

##### 1655-Balancing Act

> 给定 $t(\le 20)$ 询问，每次节点为 $n(n\le2\times10^4)$ 的树，求最小编号重心及其最大子树节点数
>
> POJ 炸了，不知道代码对不对

直接跑板子。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 20010
struct edge
{
    ll to, nx;
} e[mn << 1];
ll t, n, hd[mn], cnt, cf, cfv, siz[mn], w[mn];
void adde(ll u, ll v)
{
    e[++cnt] = {v, hd[u]};
    hd[u] = cnt;
}
#define sc(x) scanf("%lld", &x)
void dfs(ll u, ll fa)
{
    siz[u] = 1, w[u] = 0;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs(v, u);
        siz[u] += siz[v];
        w[u] = max(w[u], siz[v]);
    }
    w[u] = max(w[u], n - siz[u]);
    if (w[u] <= n / 2 && u < cf)
    {
        cf = u, cfv = w[u];
    }
}
signed main()
{
    for (sc(t); t; --t)
    {
        sc(n), cnt = 0, memset(hd, 0, sizeof hd), cf = n + 1;
        for (ll i = 1, u, v; i < n; ++i)
        {
            sc(u), sc(v), adde(u, v), adde(v, u);
        }
        dfs(1, 0);
        printf("%lld %lld\n", cf, cfv);
    }
    return 0;
}
```

