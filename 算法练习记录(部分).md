算法笔记的一部分。按平台分类。建议在目录搜索( Typora 下鼠标在大纲除上滚轮即可看到)。为了防止目录过长，暂时将考虑按时间或专题分一个子目录。不会记录所有做过的题，只会记录比较有意义的题，曾经做过已会或太简单或太难或太怪的题都不收录。

## 洛谷

`https://www.luogu.com.cn/problem/` 加上题号就是题目URL

#### 未分类

#####  p1327-数列排序

> 长不超过 $10^5$ 不重复数列 ，每次只允许交换任意一对数，求最少交换多少次使数列升序

解法一：贪心 快排 

原数组和快排后新数组一一对比，发现不同就把原数组当前位置和新数组数在原数组的位置交换。

证明：(题解区 [LuffyLuo](https://blog.csdn.net/yunxiaoqinghe/article/details/113153795?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%9C%80%E5%B0%91%E4%BB%BB%E6%84%8F%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E8%AF%81%E6%98%8E%E7%94%A8%E7%BD%AE%E6%8D%A2&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-.pc_search_download_positive&spm=1018.2226.3001.4187))

对一个错位数，它要回到原位，它跟原位连有向边；然后对原位本来的数继续为错位数同上递推……最后可以画出带环图(正位是自环)。每个环交换次数为环长 $-1$ 。

因此，本题解法二可以用求环数的图论解法(DFS即可)来解。



##### p4051 字符加密

> 对一个长 $n$ 的字符串排成一圈，将其从第 $i$ 项开始取 $n$ 个字符组成共 $n$ 个长 $n$ 的字符串，将它们排序，然后输出它们的最后一个字符 $n\le 10^5$

不能直接取后缀数组。由于 `bnabn` 有 `bn<bnabn` ，而题意 `bnbna>bnabn` ，所以矛盾。可以按题意破圈为二倍长，然后取 `sa[i]` 在原长里的 $n$ 项。扩充后多余的部分不影响原题意的字典序排序，因为在跑到多余部分前，已经可以唯一区分开顺序。

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
#define mn 1000010
char s[mn];
ll n, sa[mn], rk[mn], oldrk[mn << 1], id[mn], px[mn], cnt[mn], n0;
bool cmp(ll x, ll y, ll w)
{
    return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];
}
ll m = 300, i, p, w; //ASCII范围<300为计数排序值域,p是新值域
signed main()
{
    scanf("%s", s + 1), n0 = strlen(s + 1), n = n0 * 2;
    for (ll i = 1; i <= n0; ++i)
    {
        s[i + n0] = s[i];
    }
    for (ll i = 1; i <= n; ++i)
    { //暂时以第一关键字为排序值，有很多同名并列
        ++cnt[rk[i] = s[i]];
    }
    for (ll i = 1; i <= m; ++i)
    {
        cnt[i] += cnt[i - 1];
    }
    for (ll i = n; i >= 1; --i)
    {
        sa[cnt[rk[i]]--] = i;
    }
    for (w = 1;; w <<= 1, m = p)
    {
        for (p = 0, i = n; i > n - w; --i)
        { //第二关键字排序；无穷小区域
            id[++p] = i;
        }
        for (ll i = 1; i <= n; ++i)
        {
            if (sa[i] > w)
            {
                id[++p] = sa[i] - w;
            }
        }
        memset(cnt, 0, sizeof cnt);
        for (ll i = 1; i <= n; ++i) //第一关键字排序
        {
            ++cnt[px[i] = rk[id[i]]]; //px是常数优化
        }
        for (ll i = 1; i <= m; ++i)
        {
            cnt[i] += cnt[i - 1];
        }
        for (ll i = n; i >= 1; --i)
        {
            sa[cnt[px[i]]--] = id[i];
        }
        memcpy(oldrk, rk, sizeof rk);
        for (p = 0, i = 1; i <= n; ++i) //重名并列
        {
            rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
        }
        if (p == n)
        {
            for (ll i = 1; i <= n; ++i)
            {
                sa[rk[i]] = i;
            }
            break;
        }
    }
    for (ll i = 1; i <= n; ++i)
    {
        if (sa[i] <= n0)
        {
            printf("%c", s[sa[i] + n0 - 1]);
        }
    }
    return 0;
}
```



##### p3629-巡逻

> 边长均 $1$ ，从根节点出发遍历每一条边然后回到根节点，现在可以加 $k(1\le k\le2)$ 条边，求加了边后遍历每一条边总路程最少为多少

树的直径好题。不加边总路程恒为 $2(n-1)$ 。$k=1$ 时直接在直径两边加边，可以使得直径少走一次，但多走了加的边，节省了 $d-1$ 的路程。

若 $k=2$ ，可以在原本基础上再找直径，已经是本来直径的边权改为 $-1$ (如果有环重合，那么重合部分还是要走两次)，跑 $DP$ 找直径，同理操作，又节省了 $d_2-1$ 的路程。

详细参考题解区 [Wow_Goodjob](https://www.luogu.com.cn/problem/solution/P3629)

代码如下：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 100010
ll n, k;
struct edge
{
    ll to, nx, w;
} e[mn << 1];
ll hd[mn], cnt, mx, id, dbf, daf, bg, ed, fr[mn], dis[mn];
bool fid;
map<ll, bool> m;
void adde(ll &u, ll &v)
{
    e[++cnt] = {v, hd[u], 1};
    hd[u] = cnt;
}
void dfs(ll u, ll fa, ll w)
{
    if (w >= mx)
    {
        mx = w, id = u;
    }
    for (ll i = hd[u]; i; i = e[i].nx)
    {
        if (e[i].to != fa)
        {
            dfs(e[i].to, u, w + e[i].w);
        }
    }
}

void dfs2(ll u, ll fa, ll t) //找直径上的全部点，形成链表
{
    if (fid)
    {
        return;
    }
    for (ll i = hd[u]; i; i = e[i].nx)
    {
        ll v = e[i].to;
        if (fid)
        {
            return;
        }
        if (v == fa)
        {
            continue;
        }
        if (v == t)
        {
            fr[u] = v, fid = true;
            return;
        }
        fr[u] = v;
        dfs2(v, u, t);
        if (fid)
        {
            return;
        }
    }
}

void dfs3(ll u, ll fa) //求带负权的树的直径的方法
{
    for (ll i = hd[u]; i; i = e[i].nx)
    {
        ll v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs3(v, u);
        daf = max(daf, dis[u] + dis[v] + e[i].w);
        dis[u] = max(dis[u], dis[v] + e[i].w);
    }
}

signed main()
{
    sc(n), sc(k);
    for (ll i = 1, u, v; i < n; ++i)
    {
        sc(u), sc(v), adde(u, v), adde(v, u);
    }
    dfs(1, 0, 0);
    bg = id, mx = 0;
    dfs(bg, 0, 0);
    ed = id, dbf = mx;
    if (k == 1)
    {
        printf("%lld", 2 * (n - 1) - dbf + 1); //原是2(n-1),优化掉了(直径-1)
        return 0;
    }
    dfs2(bg, 0, ed);
    m[ed] = 1, m[bg] = 1;
    for (ll i = bg; i != ed; i = fr[i])
    {
        m[i] = 1;
    }
    for (ll u = 1; u <= n; ++u)
    {
        if (m.count(u) == 1)
        {
            for (ll i = hd[u]; i; i = e[i].nx)
            {
                if (m.count(e[i].to) == 1)
                {
                    e[i].w = -1; //有重叠，还要再走回去，取消节省
                }
            }
        }
    }
    dfs3(1, 0);
    printf("%d", 2 * n - dbf - daf); //即2(n-1)-(dbf-1)-(daf-1)
    return 0;
}
```



##### p5666-树的重心

> 若删掉某节点后，所得所有子树大小(节点数)均不超过原树大小 $\lfloor\dfrac n2\rfloor$ ，那么该节点是树的重心。树的重心只可能有 $1$ 或 $2$ 个。依次删掉树的每一个单边得两子树，求两子树的重心编号和(每次可能有 $2\sim 4$ 个重心)之和。 $1\le t\le 5,1\le n\le3\times10^5$

树上倍增法。题解区 [soar_ing](https://www.luogu.com.cn/problem/solution/P5666)

重要结论：对于一个点,若 $x$ 不是重心,重心要么在重儿子子树里,要么在父亲节点上

先 DFS 求重儿子和次重儿子(删边后新的重儿子只可能是重、次重、父、自己四种，不可能是其他)

然后 DFS ，模拟删边，用树上倍增法，二分找到树的一个重心，然后求出可能的另一个重心(显然是相邻的，所以找父、重子即可)。每次对两个子树都这么做。

细节是注意回溯。

代码如下：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 300010
#define ml 18
struct node
{
    ll to, nx;
} e[mn << 1];
ll n, t, sn[mn], s[mn], pr[mn], sn2[mn], p[mn][ml], sn3[mn], f[mn], hd[mn], cnt, s2[mn], ans;
void adde(ll &u, ll &v)
{
    e[++cnt] = {v, hd[u]};
    hd[u] = cnt;
}
void dfs(ll u, ll fa)
{
    s[u] = 1, pr[u] = fa; //前向为pr
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs(v, u);
        s[u] += s[v];        //节点数：判定轻重的依据
        if (s[v] > s[sn[u]]) //sn重儿子，sn2轻儿子
        {
            sn2[u] = sn[u], sn[u] = v;
        }
        else if (s[v] > s[sn2[u]])
        {
            sn2[u] = v;
        }
    }
    p[u][0] = sn[u]; //树上k级儿子
    for (ll i = 1; i < ml; ++i)
    {
        p[u][i] = p[p[u][i - 1]][i - 1];
    }
}
ll judge(ll x, ll sum) //树所有点数为sum
{
    //对于一个点,若x不是重心,重心要么在重儿子子树里,要么在父亲节点上
    return x * (max(s2[sn3[x]], sum - s2[x]) <= sum / 2);
}
void dfs2(ll u, ll fa)
{
    for (ll i = hd[u], v, b; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        s2[u] = s[1] - s[v]; //除这条边的子树外的节点数(按题删边)
        f[v] = f[u] = 0;     //前向
        //对于一个点u,若u不是重心,重心要么在重儿子子树里,要么在父亲节点上
        if (sn[u] == v) //找剪掉重儿子之后的重儿子
        {
            sn3[u] = sn2[u];
        }
        else
        {
            sn3[u] = sn[u];
        }
        if (s2[fa] > s2[sn3[u]])
        {
            sn3[u] = fa;
        }
        p[u][0] = sn3[u]; //树上k级重儿子
        for (ll j = 1; j < ml; ++j)
        {
            p[u][j] = p[p[u][j - 1]][j - 1];
        }

        //删边后的一棵子树
        b = u;
        //跳到重心为止
        for (ll j = ml - 1; j >= 0; --j)
        {
            if (s2[u] - s2[p[b][j]] <= s2[u] / 2)
            {
                b = p[b][j];
            }
        }
        //这个位置，它的父亲或它的重儿子之一可能是重心
        ans += judge(sn3[b], s2[u]) + judge(b, s2[u]) + judge(f[b], s2[u]);

        //另一个子树
        b = v;
        for (ll j = ml - 1; j >= 0; --j)
        {
            if (s2[v] - s2[p[b][j]] <= s2[v] / 2)
            {
                b = p[b][j];
            }
        }
        ans += judge(sn3[b], s2[v]) + judge(b, s2[v]) + judge(f[b], s2[v]);
        f[u] = v;
        dfs2(v, u);
    }
    //回溯
    sn3[u] = p[u][0] = sn[u], f[u] = pr[u];
    for (ll j = 1; j < ml; ++j)
    {
        p[u][j] = p[p[u][j - 1]][j - 1];
    }
    s2[u] = s[u];
}
signed main()
{
    sc(t);
    while (t--)
    {
        memset(hd, 0, sizeof hd), cnt = ans = 0;
        memset(sn, 0, sizeof sn);
        memset(pr, 0, sizeof pr);
        memset(f, 0, sizeof f);
        sc(n);
        for (ll i = 1, u, v; i < n; ++i)
        {
            sc(u), sc(v), adde(u, v), adde(v, u);
        }
        dfs(1, 0);
        memcpy(s2, s, sizeof s2);    //s2是s的副本
        memcpy(sn3, sn, sizeof sn3); //sn3->s
        memcpy(f, pr, sizeof f);     //f->pr
        dfs2(1, 0);
        printf("%lld\n", ans);
    }
    return 0;
}
```



##### p1081-开车旅行

> $A,B$ 轮流开车前行，城市间距离为海拔差绝对值，海拔互异；$A$ 每次前进到次小距离值(同距离就海拔低的)， $B$ 每次前进到最小值，当不可行或总路程大于 $x$ 时停止。给定 $x_0$ ，求从哪个城市出发 $A$ 路程和与 $B$ 路程和比值最小；然后解决 $m$ 个询问，从 $s$ 出发给定 $x$ ，求 $A,B$ 各自走的路程。

用 `multiset` +二分模拟平衡树，倒序插点，可以用较快的复杂度(内部原理是红黑树)找到最小和次小。

设 `i` 是行驶了 $2^i$ 天， `j` 是从城市 $j$ 出发， $k$ 是谁开车($0A,1B$) ，设三个三维 DP：

- `f` 是最终到达的城市
- `ca` 是 $A$ 行驶的总路程
- `cb` 是 $B$ 行驶的总路程

设不存在的城市是 $0$ ，无限开大整数，初始值显而易见

转移方程是前半部分 $i-1$ ，后半部分先用 `f` 将 `j` 位移到前半部分结束，再 `i-1`

$i=1$ 时，转移方程的 $k$ 两半部分不一样，否则都一样，由 $2^{i-1}$ 奇偶可知

计算距离用倍增法从大到小不断地跳即可。注意除了满足 `x` 外还需要满足 `f` 存在

代码如下：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define ml 19
#define mn 100010
struct city
{
    ll i, h;
    bool operator<(const city &x) const { return h < x.h; }
} bg, ga, gb, nei[5];
bool cmp(const city &x, const city &y)
{
    return abs(x.h - bg.h) < abs(y.h - bg.h);
}
ll n, m, x0, ansi, as, bs, h[mn], big = 1e18, s, x;
ll f[ml][mn][2], ca[ml][mn][2], cb[ml][mn][2];
db ans = big, no;
multiset<city> q;
void ro(ll s, ll x)
{
    as = bs = 0;
    for (ll i = ml - 1, p = s; i >= 0; --i)
    {
        if (f[i][p][0] && as + bs + ca[i][p][0] + cb[i][p][0] <= x)
        {
            as += ca[i][p][0], bs += cb[i][p][0];
            p = f[i][p][0];
        }
    }
}
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        sc(h[i]);
    }
    sc(x0), sc(m);

    h[0] = big, h[n + 1] = -big;
    q.insert({0, big}), q.insert({0, big});
    q.insert({n + 1, -big}), q.insert({n + 1, -big});
    for (ll i = n; i; --i)
    {
        bg = {i, h[i]};
        q.insert(bg);
        auto p = q.lower_bound(bg);
        --p, --p;
        for (ll j = 0, k = 0; j < 5; ++j, ++p)
        {
            if (j != 2)
            {
                nei[k++] = {p->i, p->h};
            }
        }
        sort(nei, nei + 4, cmp);
        gb = nei[0], ga = nei[1];
        // printf("<%lld %lld\n", ga.i, gb.i);
        f[0][i][0] = ga.i, f[0][i][1] = gb.i;
        ca[0][i][0] = abs(bg.h - ga.h);
        cb[0][i][1] = abs(bg.h - gb.h);
    }
    for (ll i = 1; i < ml; ++i)
    {
        for (ll j = 1; j <= n; ++j)
        {
            for (ll k = 0; k < 2; ++k)
            {
                if (i == 1)
                {
                    f[i][j][k] = f[0][f[0][j][k]][1 - k];
                    ca[i][j][k] = ca[0][j][k] + ca[0][f[0][j][k]][1 - k];
                    cb[i][j][k] = cb[0][j][k] + cb[0][f[0][j][k]][1 - k];
                }
                else
                {
                    f[i][j][k] = f[i - 1][f[i - 1][j][k]][k];
                    ca[i][j][k] = ca[i - 1][j][k] + ca[i - 1][f[i - 1][j][k]][k];
                    cb[i][j][k] = cb[i - 1][j][k] + cb[i - 1][f[i - 1][j][k]][k];
                }
            }
        }
    }

    for (ll i = 1; i <= n; ++i)
    {
        ro(i, x0);
        no = 1.0 * as / bs;
        if (ans > no || (ans == no && h[ansi] < h[i]))
        {
            ans = no, ansi = i;
        }
    }
    printf("%lld\n", ansi);

    while (m--)
    {
        sc(s), sc(x), ro(s, x);
        printf("%lld %lld\n", as, bs);
    }
    return 0;
}
```



##### p4550-收集邮票

> 有 $n$ 种邮票，每次购买等概率获得随机一张，第 $k$ 次购买价格为 $k$ ，求得到全部种类所需花费期望。

设 $f_i$ 表示已经取到 $i$ 张邮票，需取完剩下邮票的期望次数

初始值为 $f_n=0$ ，递推式为：
$$
f_i=\dfrac inf_i+\left(1-\dfrac in\right)f_{i+1}+1
$$
移项：
$$
f_i=f_{i+1}\dfrac n{n-i}
$$
设 $f_i$ 表示已经取到 $i$ 张邮票，需取完剩下邮票的期望价格

初始值为 $g_n=0$ ，递推式为：
$$
g_i=\dfrac in(g_i+f_i+1)+\left(1-\dfrac in\right)(g_{i+1}+f_{i+1}+1)
$$
移项：
$$
g_i=\dfrac i{n-i}f_i+g_{i+1}+f_{i+1}+\dfrac n{n-i}
$$
参见题解：[league](https://www.luogu.com.cn/problem/solution/P4550)

```c++
#define mn 10010
ll n;
db f[mn], g[mn];
signed main()
{
    sc(n);
    for (ll i = n - 1; i >= 0; --i)
    {
        f[i] = f[i + 1] + (1. * n) / (1. * (n - i));
        g[i] = (1. * i) / (1. * (n - i)) * (f[i] + 1) + g[i + 1] + f[i + 1] + 1;
    }
    printf("%.2lf", g[0]);
    return 0;
}
```



##### p1502-窗口的星星

> 有 $n$ 个星星，星星坐标为 $x,y$，亮度为 $l$，有不计边框的窗口 $w,h$  ，求窗口能显示的最大总亮度 $1\le t\le10,1\le n\le10^4$

将星星拓展为 $w,h$ 矩形，其权为 $l$ ，转化为用扫描线找平面坐标，使得矩形覆盖权最大

上板子即可。要注意不少细节。

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 100010
ll t, n, w, h, c[mn], cnt, ans;
struct seg
{
    ll l, r, h, v;
    bool operator<(const seg &x) const
    {
        return (h != x.h) ? h < x.h : v > x.v;
    }
} s[mn << 2];
struct segtr
{
    ll l, r, mx, cnt;
} tr[mn << 2];
#define lfs p << 1
#define rfs p << 1 | 1
#define mkcf ll cf = (lf + rf) >> 1
void build(ll p, ll lf, ll rf)
{
    tr[p].l = lf, tr[p].r = rf;
    if (lf == rf)
    {
        return;
    }
    mkcf;
    build(lfs, lf, cf);
    build(rfs, cf + 1, rf);
}
void pushdf(ll p)
{
    tr[lfs].mx += tr[p].cnt; //区间最值
    tr[rfs].mx += tr[p].cnt;
    tr[lfs].cnt += tr[p].cnt; //懒标记
    tr[rfs].cnt += tr[p].cnt;
    tr[p].cnt = 0;
}
void update(ll p, ll &lc, ll &rc, ll &d)
{
    ll lf = tr[p].l, rf = tr[p].r;
    if (lc <= lf && rf <= rc)
    {
        tr[p].mx += d;
        tr[p].cnt += d;
        return;
    }
    pushdf(p);
    mkcf;
    if (lc <= cf)
    {
        update(lfs, lc, rc, d);
    }
    if (rc > cf)
    {
        update(rfs, lc, rc, d);
    }
    tr[p].mx = max(tr[lfs].mx, tr[rfs].mx);
}
signed main()
{
    sc(t);
    while (t--)
    {
        sc(n), sc(w), sc(h);
        memset(s, 0, sizeof s);
        memset(tr, 0, sizeof tr);
        for (ll i = 1, x, y, l; i <= n; ++i)
        {
            sc(x), sc(y), sc(l);
            c[(i << 1) - 1] = y; //显然坐标是2i-1和2i，而不是2^i
            c[i << 1] = y + h - 1;
            s[(i << 1) - 1] = {y, y + h - 1, x, l};
            s[i << 1] = {y, y + h - 1, x + w - 1, -l};
        }
        n <<= 1;
        sort(c + 1, c + 1 + n);
        sort(s + 1, s + 1 + n);
        cnt = unique(c + 1, c + 1 + n) - c - 1;
        for (ll i = 1, p1, p2; i <= n; ++i) //离散化后的新坐标值是p1,p2
        {
            p1 = lower_bound(c + 1, c + 1 + cnt, s[i].l) - c;
            p2 = lower_bound(c + 1, c + 1 + cnt, s[i].r) - c;
            s[i].l = p1, s[i].r = p2; //这个新坐标区间是线段树所维护的区间
        }
        build(1, 1, cnt);
        ans = 0;
        for (ll i = 1; i <= n; ++i)
        {
            update(1, s[i].l, s[i].r, s[i].v);
            ans = max(ans, tr[1].mx);
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```



##### p4198-楼房重建

> 初始 $n$ 栋楼房，高度为 $0$ ，有 $m$ 次修改，每次将 $x$ 处楼房高度改为 $y$ (即线段 $x'=x,0\le y'\le y$)。问改完之后从 $(0,0)$ 能看到多少楼房 (刚好挡住也看不到)。
>
> $1\le n,m\le10^5$

题解 [Nemlit](https://www.luogu.com.cn/problem/solution/P4198) 作最高点和 $(0,0)$ 连线，易知能看到的充要条件是它前面所有楼房斜率小于它。所以问题转化为斜率问题。

设线段树维护信息：只有所维护区间的全部楼房，能够看到多少栋楼房为 `ans` ，区间斜率最值为 `mx` 。 每次单点修改 $(x,y)$ ，显然 $[1,x-1]$ 的区间都不会被修改。对剩余部分区间，作区间更改，设更改区间 $[l,r]$ ，其前面最大斜率为 $mxv=mx([1,l-1])$ ，拆为区间 $[l,c]$ , $[c+1,r]$ ，若左区间最值小于 $mxv$ ，那么左区间全部被挡住，且左区间不影响右区间，用 $mxv$ 继续更新处理右区间。若最值大于 $mxv$ ，那么 $mxv$ 不影响右区间，而是左区间影响右区间。所以右区间答案可以直接输出为从 $l$ 看 $[c+1,r]$ ，即 $ans[l,r]-ans[l,c]$ ，注意不是 $ans[c+1,r]$ ，因为代表从 $c+1$ 看。然后对左区间递归处理。

如果这个过程不懂，可以自己动手操作一下，很快可以明白原理。

由于找到修改点需要 $\Omicron(\log n)$ ，这些 $\Omicron(\log n)$ 个线段树点都需要做区间更改，每次更改都用到了上述的二分，所以时间复杂度是 $\Omicron(m\log^2n)$ ，可以过题。

参考代码：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 100010
#define big 0x7fffffff
ll n, m, ans[mn << 2], x, y;
db mx[mn << 2];
#define lfs p << 1
#define rfs p << 1 | 1
#define mkcf ll cf = (lf + rf) >> 1
ll query(ll p, ll lf, ll rf, db mxv)
{ //查询比mxv斜率大的楼房数
    if (mx[p] <= mxv)
    { //区间最大斜率比查询mxv要小，不影响答案
        return 0;
    }
    if (lf == rf)
    {
        return mx[p] > mxv;
    }
    mkcf;
    if (mx[lfs] <= mxv)
    { //左区间全部被mxv挡住了，只看右
        return query(rfs, cf + 1, rf, mxv);
    } //否则，mx[lfs]>mxv
    return query(lfs, lf, cf, mxv) + ans[p] - ans[lfs];
    //ans[p]-ans[lfs]意思是从p看，统计右区间能看到多少
    //这是因为mxv影响不及mx[lfs]，所以右区间的影响不变
    //但左区间变了，所以继续递归处理
}
void update(ll p, ll lf, ll rf, ll k, db v)
{ //将楼房k的斜率修改为v
    if (lf == k && lf == rf)
    {
        ans[p] = 1, mx[p] = v;
        return;
    }
    mkcf;
    if (k <= cf)
    {
        update(lfs, lf, cf, k, v);
    }
    else
    {
        update(rfs, cf + 1, rf, k, v);
    }
    mx[p] = max(mx[lfs], mx[rfs]);
    ans[p] = ans[lfs] + query(rfs, cf + 1, rf, mx[lfs]);
    //该区间的答案是左区间的答案加上右区间的斜率大于左区间最大值的所有楼房
    //ans[lfs]答案不受更改影响；rfs有影响，所以改变了
}
signed main()
{
    sc(n), sc(m);
    while (m--)
    {
        sc(x), sc(y);
        update(1, 1, n, x, 1.0 * y / x);
        printf("%lld\n", ans[1]);
    }
    return 0;
}
```



##### p1196-银河英雄传说

> 有 $30000$ 战舰，每次 `M i j` 将 $i$ 所在编队连在 $j$ 所在编队尾部成链。每次 `C i j` 查询 $i,j$ 链之间有多少个战舰。若 $i,j$ 不同编队输出 `-1` 。 $t\le 5\times10^5$

题解 [假装思考](https://www.luogu.com.cn/problem/solution/P1196) ，设前缀和 `cnt` 为离队首的距离，则所求为 $|cnt_i-cnt_j|+1-2$ 

每次合并并查集时， `fa[find(i)]=find(j)` ，在这之前，更新 $cnt_x$ ，距离增加 $num_y$ ，即舰队数。且 $num_y$ 增加 $num_x$ ，并且清零 $num_x$ (否则反复合并会出锅)。`find` 用递归式，每次 `find` 时更新 $cnt_x=cnt_{fa_x}$ ，注意在更新 $fa$ 之前做，不然等于我赋值我自己。

参考代码：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 30010
ll t, fa[mn], cnt[mn], num[mn], i, j;
char cmd[10];
ll find(ll x)
{
    if (x == fa[x])
    {
        return x;
    }
    ll res = find(fa[x]);
    cnt[x] += cnt[fa[x]];
    return fa[x] = res;
}
signed main()
{
    for (ll i = 1; i <= 30000; ++i)
    {
        fa[i] = i, num[i] = 1;
    }
    sc(t);
    while (t--)
    {
        scanf("%s%lld%lld", cmd, &i, &j);
        ll x = find(i), y = find(j);
        if (cmd[0] == 'M')
        {
            cnt[x] += num[y];
            fa[x] = y;
            num[y] += num[x];
            num[x] = 0;
        }
        else if (cmd[0] == 'C')
        {
            if (x != y)
            {
                printf("-1\n");
            }
            else
            {
                printf("%lld\n", abs(cnt[i] - cnt[j]) - 1);
            }
        }
    }
    return 0;
}
```



##### p1341-无序字母对

> $n$ 个区分大小写无序字母对，构造一个 $n+1$ 个字母的字符串使得每个字母对都出现，或输出 `No Solution`

无向图欧拉路径板子题

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 130
ll m, du[mn], vis[mn][mn], s = 'z', t = 'z', fa[mn], ucon;
vector<ll> e[mn], odd;
stack<ll> ans;
char c[10];
void dfs(ll u)
{
    for (ll i = 0, v; i < (ll)e[u].size(); ++i)
    {
        v = e[u][i];
        if (vis[u][v])
        {
            continue;
        }
        vis[u][v] = vis[v][u] = true;
        dfs(v);
    }
    ans.push(u);
}
ll findf(ll x)
{
    while (x != fa[x])
    {
        x = fa[x] = fa[fa[x]];
    }
    return x;
}
signed main()
{
    scanf("%lld", &m);
    for (ll i = 'A'; i <= (ll)'z'; ++i)
    {
        fa[i] = i;
    }
    for (ll i = 0, u, v; i < m; ++i)
    {
        scanf("%s", c);
        u = c[0], v = c[1], ++du[u], ++du[v];
        e[u].emplace_back(v), e[v].emplace_back(u);
        s = min(s, min(u, v));
        fa[findf(u)] = findf(v);
    }
    for (ll i = 'A'; i <= (ll)'z'; ++i)
    {
        ucon += (du[i] > 0) * (fa[i] == i);
        // printf("%c %lld %lld\n", (char)i, du[i], ucon);
        if (du[i] & 1)
        {
            odd.emplace_back(i);
            t = min(t, i);
        }
        sort(e[i].begin(), e[i].end());
    }
    if (!(odd.size() == 0 || (odd.size() == 2)) || ucon > 1)
    {
        printf("No Solution");
        return 0;
    }
    if (odd.size())
    {
        s = t;
    }
    dfs(s);
    while (!ans.empty())
    {
        printf("%c", (char)ans.top());
        ans.pop();
    }
    return 0;
}
/*6 ab bc ca AB BC CA*/
```



##### p2731-骑马修栅栏

> 给定无向图边数 $m$ ，点在 $[1,500]$ 编号，必然有解且联通，输出字典序最小欧拉路

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 512
ll m, s = 1, g[mn][mn], du[mn], n;
stack<ll> ans;
void dfs(ll u)
{
    for (ll v = 1; v <= n; ++v)
    {
        if (g[u][v] > 0)
        {
            --g[u][v], --g[v][u];
            dfs(v);
        }
    }
    ans.push(u);
}
signed main()
{
    scanf("%lld", &m);
    for (ll i = 0, u, v; i < m; ++i)
    {
        scanf("%lld%lld", &u, &v);
        ++du[u], ++du[v], ++g[u][v], ++g[v][u];
        n = max(n, max(u, v));
    }
    for (ll i = 1; i <= n; ++i)
    {
        if (du[i] & 1)
        {
            s = i;
            break;
        }
    }
    dfs(s);
    while (!ans.empty())
    {
        printf("%lld\n", ans.top());
        ans.pop();
    }
    return 0;
}
```



##### p2495-消耗战

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 500010
#define mm 10000
#define big 0x3ffffffffffffffa
#define mlg 20
struct edge
{
    ll to, nx, w;
} e[mn << 1], e2[mn << 1];
ll hd[mn], hd2[mn], cnt, cnt2, n, q, k;
void adde(const ll &u, const ll &v, const ll &w, ll *hd, ll &cnt, edge *e)
{
    e[++cnt] = {v, hd[u], w};
    hd[u] = cnt;
}
ll dfn[mn], dep[mn], fa[mn][mlg], mi[mn], m[mn], lst[mn];
bool vis[mn];
ll num, top, dfscnt, stk[mn];

void dfs1(ll u)
{
    ll k = 0;
    for (; fa[u][k]; ++k)
    {
        fa[u][k + 1] = fa[fa[u][k]][k];
    }
    m[u] = k;
    dfn[u] = ++dfscnt;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (!dfn[v])
        {
            dep[v] = dep[u] + 1;
            mi[v] = min(mi[u], e[i].w);
            fa[v][0] = u;
            dfs1(v);
        }
    }
}

ll lca(ll x, ll y)
{
    if (dep[x] < dep[y])
    {
        swap(x, y);
    }
    for (ll i = m[x]; i >= 0; --i)
    {
        if (dep[fa[x][i]] >= dep[y])
        {
            x = fa[x][i];
        }
    }
    if (x == y)
    {
        return x;
    }
    for (ll i = m[x]; i >= 0; --i)
    {
        if (fa[x][i] != fa[y][i])
        {
            x = fa[x][i], y = fa[y][i];
        }
    }
    return fa[x][0];
}

ll dfs2(ll u) //dp
{
    ll sum = 0;
    for (ll i = hd2[u], v; i; i = e2[i].nx)
    {
        v = e2[i].to;
        sum += dfs2(v);
    }
    ll res = vis[u] ? mi[u] : min(mi[u], sum); //vis[u] hd.d af
    hd2[u] = 0, vis[u] = false;                //clear
    return res;
}

#define sc(x) scanf("%lld", &x)
signed main()
{
    sc(n);
    for (ll i = 1, u, v, w; i < n; ++i)
    {
        sc(u), sc(v), sc(w);
        adde(u, v, w, hd, cnt, e), adde(v, u, w, hd, cnt, e);
    }
    mi[1] = big;
    dfs1(1);
    for (sc(q); q; --q)
    {
        sc(k);
        for (ll i = 1; i <= k; ++i)
        {
            sc(lst[i]), vis[lst[i]] = true;
        }
        sort(lst + 1, lst + 1 + k, [](const ll &x, const ll &y)
             { return dfn[x] < dfn[y]; });
        stk[top = 1] = lst[1];
        for (ll i = 2; i <= k; ++i)
        {
            ll now = lst[i], lc = lca(now, stk[top]);
            while (true)
            {
                if (dep[lc] >= dep[stk[top - 1]])
                {
                    if (lc != stk[top])
                    {
                        adde(lc, stk[top], 0, hd2, cnt2, e2);
                        if (lc != stk[top - 1])
                        {
                            stk[top] = lc;
                        }
                        else
                        {
                            --top;
                        }
                    }
                    break;
                }
                else
                {
                    adde(stk[top - 1], stk[top], 0, hd2, cnt2, e2);
                    --top;
                }
            }
            stk[++top] = now;
        }
        while (--top)
        {
            adde(stk[top], stk[top + 1], 0, hd2, cnt2, e2);
        }
        printf("%lld\n", dfs2(stk[1])), cnt2 = 0;
    }
    return 0;
}
```



##### p2634-聪聪可可

> 有 $n(n\le 2\times10^4)$ 点的树，任选两点为端点，求有多大概率选到路径长度是 $3$ 的倍数。

解法一：树上 DP

记 $dp[i][j]$ 表示以 $i$ 为根的子树里距离 $i$ 模 $3$ 余 $j$ 的点的个数。

因为自己到自己是 $0$ ，所以初始值是 $dp[i][0]=1$ 。

每次 DFS 更新，设当前遍历直接儿子为 $s$ ，边权为 $w$ ，令答案增加如下值：
$$
2\times dp[i][j]\times dp[s][3-j-w]
$$
$2$ 是一个有序对对应两个无序对。 $j\equiv3-j-w(\bmod 3)$ 是加起来为 $0$ 

计算结束后，进行更新，将当前儿子的点加到父亲上：
$$
dp[i][j+w]=dp[s][j]
$$
特别地，不是 $2\times dp[i][j]\times(3-j-w\equiv 0)$ ，因为如果这样的话，就不能够计算出子树之间的路径。 只有 $dp[s][3-j-w]$ 才是当前已遍历部分跟未遍历部分的路径 DP 。

注意两个 for 要分开。特别注意最后额外加上 $n$ ，因为所有点到自己也需要积累贡献，注意该贡献在 DP 时没有计算入内。

代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 20010
#define sc(x) scanf("%lld", &x)
struct edge
{
    ll to, nx, w;
} e[mn << 1];
ll hd[mn], cnt, dp[mn][3], n, fz, fm, c;
void adde(ll u, ll v, ll w)
{
    e[++cnt] = {v, hd[u], w};
    hd[u] = cnt;
}
void dfs(ll u, ll fa)
{
    dp[u][0] = 1;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs(v, u);
        for (ll j = 0; j < 3; ++j)
        {
            fz += 2 * dp[v][j] * dp[u][(6 - j - e[i].w % 3) % 3];
        }
        for (ll j = 0; j < 3; ++j)
        {
            dp[u][(j + e[i].w) % 3] += dp[v][j];
        }
    }
}
signed main()
{
    sc(n);
    for (ll i = 1, u, v, w; i < n; ++i)
    {
        sc(u), sc(v), sc(w);
        adde(u, v, w), adde(v, u, w);
    }
    dfs(1, 0);
    fz += n, fm = n * n, c = __gcd(fz, fm), fz /= c, fm /= c;
    printf("%lld/%lld", fz, fm);
    return 0;
}
```



解法二：点分治

树上路径要么经过根，要么不经过。求出所有子树的答案，再求出经过根的所有路径即得答案。

1. 以重心为根统计经过重心的所有路径的贡献

   统计贡献的方法为：DFS，桶记录距离模 $3$ 余 $i$ 的点有多少个

   所有距离余 $1$ 和余 $2$ 的点可以组成余 $0$ ，无序，即 $2xy$；

   所有距离余 $0$ 的点之间也可以组成余 $0$ ，具体为：自己跟自己、两两之间，即自己和包括自己的所有点，即 $x^2$ 

2. 删掉重心，剩下的各个子树同上操作

特别地，发现有一个事实：假设 $x$ 是原重心， $y$ 是新子树重心，在计算 $x$ 的时候发现有若干余 $0$ 点，会被重复计数…具体没搞懂。总之就是会重复。以后再细想，我没想明白想了非常久。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 20010
struct edge
{
    ll to, nx, w;
} e[mn << 1];
ll t, n, hd[mn], cnt, siz[mn], w[mn], bin[4], m, dp[mn], root, dis[mn];
ll fz, fm, c;
bool vis[mn];
void adde(ll u, ll v, ll w)
{
    e[++cnt] = {v, hd[u], w};
    hd[u] = cnt;
}
void fi_root(ll u, ll fa)
{
    siz[u] = 1, dp[u] = 0;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || vis[v])
        {
            continue;
        }
        fi_root(v, u);
        siz[u] += siz[v];
        dp[u] = max(dp[u], siz[v]);
    }
    dp[u] = max(dp[u], m - siz[u]);
    if (dp[u] < dp[root])
    {
        root = u;
    }
}
void dfs(ll u, ll fa)
{
    ++bin[dis[u]];
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || vis[v])
        {
            continue;
        }
        dis[v] = (dis[u] + e[i].w) % 3;
        dfs(v, u);
    }
}
ll cal(ll u, ll v) //以u为根的剩余子树的贡献(v=0)
{
    memset(bin, 0, sizeof bin), dis[u] = v;
    dfs(u, 0);
    return bin[1] * bin[2] * 2 + bin[0] * bin[0]; //模3余0
    //经由u的路径，一端是x一端是y,满足距离x=1,y=2或x=y=0
}
void solve(ll u)
{
    fz += cal(u, 0), vis[u] = true; //删除点u
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (vis[v])
        {
            continue;
        }
        fz -= cal(v, e[i].w);
        root = 0, m = siz[v];
        fi_root(v, 0);
        solve(root);
    }
}
#define sc(x) scanf("%lld", &x)
signed main()
{
    sc(n);
    for (ll i = 1, ui, vi, wi; i < n; ++i)
    {
        sc(ui), sc(vi), sc(wi), adde(ui, vi, wi % 3), adde(vi, ui, wi % 3);
    }
    m = dp[0] = n;
    fi_root(1, 0);
    solve(root);
    fm = n * n, c = __gcd(fz, fm), fz /= c, fm /= c;
    printf("%lld/%lld", fz, fm);
    return 0;
}
```





##### p1364-医院设置

> 有二叉树，节点数为 $n(n\le 100)$ ，输入每个节点的点权和左右儿子 ($0$ 代表空)，求最小距离和

解法一：树上 DP 题 / 树的重心模板题

先预处理节点数。由于有点权，可以认为等于若干个重合点，所以初始 size 是点权。然后一次 DFS 求出 size 数组和 $dp[1]$ 代表以 $1$ 为根的距离和。

状态转移方程为：
$$
dp[v]=dp[u]+(size[1]-size[v])-size[v]
$$
这是因为子树上节点都少走一步，其他节点都多走一步。答案是 DP 内最小值。

参考代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 105
#define sc(x) scanf("%lld", &x)
struct edge
{
    ll to, nx;
} e[mn << 1];
ll hd[mn], cnt, siz[mn], w[mn], dp[mn], n, ans = 0x7fffffff;
void adde(ll u, ll v)
{
    e[++cnt] = {v, hd[u]};
    hd[u] = cnt;
}
void dfs1(ll u, ll fa, ll d)
{
    siz[u] = w[u];
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs1(v, u, d + 1);
        siz[u] += siz[v];
    }
    dp[1] += d * w[u];
}
void dfs2(ll u, ll fa)
{
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dp[v] = dp[u] + (siz[1] - siz[v]) - siz[v];
        dfs2(v, u);
    }
    ans = min(ans, dp[u]);
}
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1, x, y; i <= n; ++i)
    {
        sc(w[i]), sc(x), sc(y);
        if (x)
        {
            adde(i, x), adde(x, i);
        }
        if (y)
        {
            adde(i, y), adde(y, i);
        }
    }
    dfs1(1, 0, 0);
    dfs2(1, 0);
    printf("%lld", ans);
    return 0;
}
```



解法二：也可以跑 Floyd 求解。然后暴力遍历每个点验证即可。略。



##### p1521-求逆序对

> 求 $n$ 的全排列中逆序数为 $k$ 的方案数模 $10^4$ 后的结果

设 $dp[i][j]$ 表示全排列 $1\to i$ 内，逆序数模 $10^4$ 余 $j$ 的方案数

初始值为 $dp[0\sim 2][0]=dp[2][1]=1$ 

递推时，可以把 $i+1$ 插入到原方案的 $i+1$ 个位置里。其中显然尾部不贡献新的逆序对，头部贡献 $i$ 个。进一步地，由于 $i+1$ 大于任意 $[1,i]$ ，所以可以发现有多少个新的贡献，取决于它后面还有多少个值。显然插入到第 $h$ 个位置贡献 $i-h$ 个值

时间复杂度 $O(n^2k)$

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
ll n, k, dp[105][10005];
signed main()
{
    sc(n), sc(k), dp[0][0] = dp[1][0] = dp[2][0] = dp[2][1] = 1;
    for (ll i = 3; i <= n; ++i)
    {
        for (ll j = 0; j <= k; ++j)
        {
            for (ll h = 0; h <= i - 1 && j - h >= 0; ++h)
            {
                dp[i][j] = (dp[i][j] + dp[i - 1][j - h]) % 10000;
            }
        }
    }
    printf("%lld", dp[n][k]);
    return 0;
}
```



##### p5514-永夜的报应

> 将 $n$ 个自然数分成若干组，求组内异或和后各组和的最小值

由于 $x\oplus y\le x+y$ ，这意味着把两个数合在一起一定会比拆开更优；推广开来的结论就是直接全部合在一组即可

```c++
sc(n);
for (ll i = 1; i <= n; ++i) sc(a), x ^= a;
printf("%lld", x);
```



##### U41492-树上数颜色

> $n(n\le 10^5)$ 个节点的树，每个节点有不同的颜色( $10^5$ 种)，问每个节点为根的子树中，所有节点有多少种不同的颜色；$m(m\le 10^5)$ 次询问，每次问一棵子树 

树上启发式合并模板，有两种写的方法。

不需要用 set 来维护异色，只需要用桶计数即可。

写法一 (带 DFN 序子树，效率更优)：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define sc(x) scanf("%lld", &x)
#define mn 100010
ll n, m, cnt, dfn[mn], big[mn], siz[mn], tot, c[mn], ecnt, hd[mn];
ll lf[mn], rf[mn], s[mn], ans[mn], x;
struct edge
{
    ll to, nx;
} e[mn * 2];
void adde(ll u, ll v)
{
    e[++ecnt] = {v, hd[u]};
    hd[u] = ecnt;
}
void dfs1(ll u, ll fa)
{
    lf[u] = ++cnt, dfn[cnt] = u, siz[u] = 1;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[big[u]] < siz[v])
        {
            big[u] = v;
        }
    }
    rf[u] = cnt;
}
void add(ll u)
{
    tot += (s[c[u]]++ == 0);
}
void remove(ll u)
{
    tot -= (--s[c[u]] == 0);
}
void dfs2(ll u, ll fa, bool save)
{
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v != fa && v != big[u])
        {
            dfs2(v, u, false);
        }
    }
    if (big[u])
    {
        dfs2(big[u], u, true);
    }
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v != fa && v != big[u])
        {
            for (ll j = lf[v]; j <= rf[v]; ++j)
            {
                add(dfn[j]);
            }
        }
    }
    add(u);
    ans[u] = tot;
    if (!save)
    {
        for (ll j = lf[u]; j <= rf[u]; ++j)
        {
            remove(dfn[j]);
        }
    }
}
signed main()
{
    sc(n);
    for (ll i = 1, u, v; i < n; ++i)
    {
        sc(u), sc(v), adde(u, v), adde(v, u);
    }
    for (ll i = 1; i <= n; ++i)
    {
        sc(c[i]);
    }
    dfs1(1, 0), dfs2(1, 0, false);
    for (sc(m); m; --m)
    {
        sc(x);
        printf("%lld\n", ans[x]);
    }
    return 0;
}
```

写法二：不带 DFN 序，更多的递归

```c++
#include <cstdio>
#include <cstring>
#define maxn 100010

int n,m,col[maxn];
struct edge{int y,next;};
edge e[maxn*2];
int first[maxn];
void buildroad(int x,int y)
{
	static int len=0;
	e[++len]=(edge){y,first[x]};
	first[x]=len;
}
int size[maxn],mson[maxn];
void dfs1(int x,int fa)//求重儿子
{
	size[x]=1;
	for(int i=first[x];i;i=e[i].next)
	{
		int y=e[i].y;
		if(y==fa)continue;
		dfs1(y,x);
		if(size[y]>size[mson[x]])mson[x]=y;
		size[x]+=size[y];
	}
}
int tong[maxn],ans[maxn],now_ans=0;
void go(int x,int fa,int type)
{
	tong[col[x]]+=type;
	if(type==1&&tong[col[x]]==1)now_ans++;
	if(type==-1&&tong[col[x]]==0)now_ans--;
	for(int i=first[x];i;i=e[i].next)
	if(e[i].y!=fa)go(e[i].y,x,type);
}
void dfs2(int x,int fa,bool del)
//求解，del表示求完x的子树的答案后需不需要清空x的子树的信息
{
	for(int i=first[x];i;i=e[i].next)//先统计轻儿子的答案
	if(e[i].y!=fa&&e[i].y!=mson[x])dfs2(e[i].y,x,true);
	if(mson[x]!=0)dfs2(mson[x],x,false);//最后统计重儿子的答案
	
	tong[col[x]]++;if(tong[col[x]]==1)now_ans++;//统计自己以及轻子树的信息
	for(int i=first[x];i;i=e[i].next)
	if(e[i].y!=fa&&e[i].y!=mson[x])go(e[i].y,x,1);
	ans[x]=now_ans;//得到自己的答案
	
	if(del)go(x,fa,-1);//假如要删掉自己的信息，就暴力地删掉
}

int main()
{
	scanf("%d",&n);
	for(int i=1,x,y;i<n;i++)
	scanf("%d %d",&x,&y),buildroad(x,y),buildroad(y,x);
	for(int i=1;i<=n;i++)
	scanf("%d",&col[i]);
	dfs1(1,0);
	dfs2(1,0,false);
	scanf("%d",&m);
	for(int i=1,x;i<=m;i++)
	scanf("%d",&x),printf("%d\n",ans[x]);
}

```



##### CF600E-Lomsat gelral

> $1$ 为根的 $n(\le10^5)$ 点的树，节点有颜色；若子树里某种颜色出现次数最多，称其为主导颜色；一个子树可能有多个主导颜色；求每个子树的主导颜色的颜色编号和。颜色编号满足 $\le n$ 

只需要改写合并函数即可。记录最大频次是哪个频次，如果当前累增的桶积累值大于最值，那么清零当前答案，然后改成当前出现的颜色编号；如果等于，那么累加当前答案；否则什么也不做，这样可以保证合并函数是 $O(1)$ 的

根据树上启发式合并的过程，每次删除的时候一定是全部删完的，所以删除的时候直接清零初始化即可，置零最大频次和答案。

写法一：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define sc(x) scanf("%lld", &x)
#define mn 100010
ll n, cnt, dfn[mn], big[mn], siz[mn], tot, c[mn], ecnt, hd[mn];
ll lf[mn], rf[mn], s[mn], ans[mn], mx;
struct edge
{
    ll to, nx;
} e[mn * 2];
void adde(ll u, ll v)
{
    e[++ecnt] = {v, hd[u]};
    hd[u] = ecnt;
}
void dfs1(ll u, ll fa)
{
    lf[u] = ++cnt, dfn[cnt] = u, siz[u] = 1;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[big[u]] < siz[v])
        {
            big[u] = v;
        }
    }
    rf[u] = cnt;
}
void modify(ll u, ll isadd = 1)
{
    s[c[u]] += isadd;
    ll no = s[c[u]];
    // printf("- %lld %lld %lld %lld %lld\n", u, no, mx, tot, isadd);
    if (isadd == 1)
    {
        if (no > mx)
        {
            mx = no, tot = c[u];
        }
        else if (no == mx)
        {
            tot += c[u];
        }
    }
}
void dfs2(ll u, ll fa, bool save)
{
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v != fa && v != big[u])
        {
            dfs2(v, u, false);
        }
    }
    if (big[u])
    {
        dfs2(big[u], u, true);
    }
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v != fa && v != big[u])
        {
            for (ll j = lf[v]; j <= rf[v]; ++j)
            {
                modify(dfn[j]);
            }
        }
    }
    modify(u);
    ans[u] = tot;
    // printf("<%lld %lld\n", u, ans[u]);
    if (!save)
    {
        for (ll j = lf[u]; j <= rf[u]; ++j)
        {
            modify(dfn[j], -1);
        }
        mx = tot = 0;
    }
}
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        sc(c[i]);
    }
    for (ll i = 1, u, v; i < n; ++i)
    {
        sc(u), sc(v), adde(u, v), adde(v, u);
    }
    dfs1(1, 0), dfs2(1, 0, false);
    for (ll i = 1; i <= n; ++i)
    {
        printf("%lld ", ans[i]);
    }
    return 0;
}
```

写法二：

```c++
#include <cstdio>
#include <cstring>
#define maxn 100010

int n,col[maxn];
struct edge{int y,next;};
edge e[maxn*2];
int first[maxn];
void buildroad(int x,int y)
{
	static int len=0;
	e[++len]=(edge){y,first[x]};
	first[x]=len;
}
int size[maxn],mson[maxn];
void dfs_getmson(int x,int fa)
{
	size[x]=1;
	for(int i=first[x];i;i=e[i].next)
	{
		int y=e[i].y;
		if(y==fa)continue;
		dfs_getmson(y,x);
		if(size[y]>size[mson[x]])mson[x]=y;
		size[x]+=size[y];
	}
}
long long ans[maxn],now_ans=0;
int tong[maxn],max_col=0;
void go(int x,int fa,int type)
{
	tong[col[x]]+=type;
	if(type==1)
	{
		if(tong[col[x]]>max_col)max_col=tong[col[x]],now_ans=col[x];
		else if(tong[col[x]]==max_col)now_ans+=col[x];
	}
	for(int i=first[x];i;i=e[i].next)
	if(e[i].y!=fa)go(e[i].y,x,type);
}
void dfs_getans(int x,int fa,bool del)
{
	for(int i=first[x];i;i=e[i].next)
	if(e[i].y!=fa&&e[i].y!=mson[x])dfs_getans(e[i].y,x,true);
	
	if(mson[x]!=0)dfs_getans(mson[x],x,false);
	for(int i=first[x];i;i=e[i].next)
	if(e[i].y!=fa&&e[i].y!=mson[x])go(e[i].y,x,1);
	
	tong[col[x]]++;
	if(tong[col[x]]>max_col)max_col=tong[col[x]],now_ans=col[x];
	else if(tong[col[x]]==max_col)now_ans+=col[x];
	
	ans[x]=now_ans;if(del)go(x,fa,-1),max_col=0,now_ans=0;
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&col[i]);
	for(int i=1,x,y;i<n;i++)
	scanf("%d %d",&x,&y),buildroad(x,y),buildroad(y,x);
	dfs_getmson(1,0);
	dfs_getans(1,0,false);
	for(int i=1;i<=n;i++)
	printf("%lld ",ans[i]);
}

```



##### p3806-[模板]点分治1

无注释版个人代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 10010
#define mm 105
#define mb 10000010
struct edge
{
    ll to, nx, w;
} e[mn << 2];
ll hd[mn], ecnt;
void adde(ll &u, ll &v, ll &w)
{
    e[++ecnt] = {v, hd[u], w};
    hd[u] = ecnt;
}
bool died[mn], bin[mb], suc[mm];
ll n, m, q[mn];
ll p, sz[mn], n2, smx[mn];
void dfs(ll u, ll fa)
{
    sz[u] = 1, smx[u] = 0;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        dfs(v, u);
        sz[u] += sz[v];
        smx[u] = max(smx[u], sz[v]);
    }
    smx[u] = max(smx[u], n2 - smx[u]);
    if (smx[u] < smx[p])
    {
        p = u;
    }
}
ll ds[mn], dcnt, d[mn];
void dfs2(ll u, ll fa)
{
    ds[++dcnt] = d[u];
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        d[v] = d[u] + e[i].w;
        dfs2(v, u);
    }
}
stack<ll> qd;
void dfz(ll u, ll fa)
{
    bin[0] = true;
    qd.push(0);
    died[u] = true;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        d[v] = e[i].w;
        dfs2(v, u);
        for (ll j = 1; j <= dcnt; ++j)
        {
            for (ll k = 1; k <= m; ++k)
            {
                if (q[k] >= ds[j])
                {
                    suc[k] |= bin[q[k] - ds[j]];
                }
            }
        }
        for (ll j = 1; j <= dcnt; ++j)
        {
            if (ds[j] < mb)
            {
                bin[ds[j]] = true;
                qd.push(ds[j]);
            }
        }
        dcnt = 0;
    }
    while (!qd.empty())
    {
        bin[qd.top()] = false;
        qd.pop();
    }
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        n2 = sz[v], p = 0;
        dfs(v, u), dfs(p, 0);
        dfz(p, u);
    }
}
signed main()
{
    sc(n), sc(m), n2 = n, smx[0] = 0x7fffffff;
    for (ll i = 1, u, v, w; i < n; ++i)
    {
        sc(u), sc(v), sc(w), adde(u, v, w), adde(v, u, w);
    }
    for (ll i = 1; i <= m; ++i)
    {
        sc(q[i]);
    }
    dfs(1, 0), dfs(p, 0);
    dfz(p, 0);
    for (ll i = 1; i <= m; ++i)
    {
        printf(suc[i] ? "AYE\n" : "NAY\n");
    }
    return 0;
}
```

OI-wiki 代码集注：

```c++
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int maxn = 20010;
const int inf = 2e9;
int n, m, a, b, c, q[maxn], rt, siz[maxn], maxx[maxn], dist[maxn];
int cur, h[maxn], nxt[maxn], p[maxn], w[maxn];
bool tf[10000010], ret[maxn], vis[maxn];

void add_edge(int x, int y, int z)
{ // 建图
    cur++;
    nxt[cur] = h[x];
    h[x] = cur;
    p[cur] = y;
    w[cur] = z;
}

int sum;

void calcsiz(int x, int fa)
{ // 这里是两个计算答案的
    siz[x] = 1;
    maxx[x] = 0;
    for (int j = h[x]; j; j = nxt[j])
        if (p[j] != fa && !vis[p[j]])
        {
            calcsiz(p[j], x);
            maxx[x] = max(maxx[x], siz[p[j]]);
            siz[x] += siz[p[j]];
        }
    maxx[x] = max(maxx[x], sum - siz[x]);
    if (maxx[x] < maxx[rt])
        rt = x;
}

int dd[maxn], cnt;

void calcdist(int x, int fa)
{
    dd[++cnt] = dist[x]; //记录各点的距离
    for (int j = h[x]; j; j = nxt[j])
        if (p[j] != fa && !vis[p[j]])
            dist[p[j]] = dist[x] + w[j], calcdist(p[j], x);
    //根为起点，到p[j]的距离
}

queue<int> tag;

void dfz(int x, int fa)
{ // 点分治具体
    tf[0] = true;
    tag.push(0);   // 0距离恒已有
    vis[x] = true; //这个点被点分支过；树上把该点永久删除
    for (int j = h[x]; j; j = nxt[j])
        if (p[j] != fa && !vis[p[j]])
        {
            dist[p[j]] = w[j]; //根为起点，到点p[j]的距离是w[j]
            calcdist(p[j], x); //求根为起点到各点的距离

            for (int k = 1; k <= cnt; k++)   //对每个已知距离
                for (int i = 1; i <= m; i++) //对每一个询问
                    if (q[i] >= dd[k])       //询问的距离比这个距离大
                        ret[i] |= tf[q[i] - dd[k]];
            //如果已有q[i]-dd[k]这段距离，可以两链相加，求出答案

            for (int k = 1; k <= cnt; k++) //现在记录tf
                if (dd[k] < 10000010)
                    tag.push(dd[k]), tf[dd[k]] = true;
            cnt = 0; //当前子树已知距离清零
        }
    //到此为止，以x为根的子树里所有经过x的链都统计完毕

    //删掉已知的全部tf
    while (!tag.empty())
        tf[tag.front()] = false, tag.pop(); // 底下递归处理
    for (int j = h[x]; j; j = nxt[j])
        if (p[j] != fa && !vis[p[j]])
        {
            sum = siz[p[j]]; //现在只看这一个子树
            rt = 0;
            maxx[rt] = inf;
            calcsiz(p[j], x); //找子树重心
            calcsiz(rt, -1);  //计算子树siz
            dfz(rt, x);       //点分治
        }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i < n; i++)
        scanf("%d%d%d", &a, &b, &c), add_edge(a, b, c), add_edge(b, a, c);
    for (int i = 1; i <= m; i++)
        scanf("%d", q + i);
    rt = 0;
    maxx[rt] = inf;
    sum = n;
    calcsiz(1, -1);  //求重心
    calcsiz(rt, -1); //以重心为根求siz (重心在这个过程不会改变)
    dfz(rt, -1);
    for (int i = 1; i <= m; i++)
        if (ret[i])
            printf("AYE\n");
        else
            printf("NAY\n");
    return 0;
}
```



##### p4178-Tree

点分治模板题，在原来基础上作出改变，改成单点修改和区间查询，即线段树模板即可。

常规动态树写法：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 40010
#define mt 160010 // mn<<2
#define tp 20010
struct edge
{
    ll to, nx, w;
} e[mn << 2];
ll hd[mn], ecnt;
void adde(ll &u, ll &v, ll &w)
{
    e[++ecnt] = {v, hd[u], w};
    hd[u] = ecnt;
}
bool died[mn];
ll n, q, ans;
ll p, sz[mn], n2, smx[mn];
void dfs(ll u, ll fa)
{
    sz[u] = 1, smx[u] = 0;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        dfs(v, u);
        sz[u] += sz[v];
        smx[u] = max(smx[u], sz[v]);
    }
    smx[u] = max(smx[u], n2 - smx[u]);
    if (smx[u] < smx[p])
    {
        p = u;
    }
}
ll ds[mn], dcnt, d[mn];
void dfs2(ll u, ll fa)
{
    ds[++dcnt] = d[u];
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        d[v] = d[u] + e[i].w;
        dfs2(v, u);
    }
}
stack<ll> qd;
#define lfs r << 1
#define rfs r << 1 | 1
#define mkcf ll cf = (lf + rf) >> 1
ll t[mt]; //一种动态的线段树，空时删点
void update(ll r, ll lf, ll rf, const ll &pos, const ll &dt)
{
    if (lf == rf)
    {
        t[r] += dt;
        return;
    }
    mkcf;
    if (pos <= cf)
    {
        update(lfs, lf, cf, pos, dt);
    }
    else
    {
        update(rfs, cf + 1, rf, pos, dt);
    }
    t[r] = t[lfs] + t[rfs];
}
void cls()
{
    while (!qd.empty()) //清空线段树，因为加减守恒，绝对清得空
    {
        update(1, 1, tp, qd.top(), -1);
        qd.pop();
    }
}
ll query(ll r, ll lf, ll rf, const ll &lc, const ll &rc)
{
    if (lf >= lc && rf <= rc)
    {
        return t[r];
    }
    if (rf < lc || lf > rc)
    {
        return 0;
    }
    mkcf;
    return query(lfs, lf, cf, lc, rc) + query(rfs, cf + 1, rf, lc, rc);
}

void dfz(ll u, ll fa)
{
    update(1, 1, tp, 1, 1); //线段树l,r从1开始，所以偏移+1
    //这是因为有0时cf=(lf+rf)>>1会挂掉
    qd.push(1);
    died[u] = true;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        d[v] = e[i].w;
        dfs2(v, u);
        for (ll j = 1; j <= dcnt; ++j)
        {
            if (q >= ds[j]) //现在还缺(0,q]-ds[j]
            {
                ans += query(1, 1, tp, 1 + max(0LL, 1 - ds[j]), 1 + max(0LL, q - ds[j])); //有的都加起来
            }
        }
        for (ll j = 1; j <= dcnt; ++j) //加上新有的
        {
            update(1, 1, tp, ds[j] + 1, 1);
            qd.push(ds[j] + 1);
        }
        dcnt = 0;
    }
    cls();
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        n2 = sz[v], p = 0;
        dfs(v, u), dfs(p, 0);
        dfz(p, u);
    }
}
signed main()
{
    sc(n), n2 = n, smx[0] = 0x7fffffff;
    for (ll i = 1, u, v, w; i < n; ++i)
    {
        sc(u), sc(v), sc(w), adde(u, v, w), adde(v, u, w);
    }
    sc(q);
    dfs(1, 0), dfs(p, 0);
    dfz(p, 0);
    printf("%lld", ans);
    return 0;
}
```

动态线段树写法：(事实上效率和内存占用几乎跟上面的常规线段树写法一样)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 40010
#define mt 160010 // mn<<2
#define tp 20010
struct edge
{
    ll to, nx, w;
} e[mn << 2];
ll hd[mn], ecnt;
void adde(ll &u, ll &v, ll &w)
{
    e[++ecnt] = {v, hd[u], w};
    hd[u] = ecnt;
}
bool died[mn];
ll n, q, ans;
ll p, sz[mn], n2, smx[mn];
void dfs(ll u, ll fa)
{
    sz[u] = 1, smx[u] = 0;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        dfs(v, u);
        sz[u] += sz[v];
        smx[u] = max(smx[u], sz[v]);
    }
    smx[u] = max(smx[u], n2 - smx[u]);
    if (smx[u] < smx[p])
    {
        p = u;
    }
}
ll ds[mn], dcnt, d[mn];
void dfs2(ll u, ll fa)
{
    ds[++dcnt] = d[u];
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        d[v] = d[u] + e[i].w;
        dfs2(v, u);
    }
}
stack<ll> qd;
#define mkcf ll cf = (lf + rf) >> 1
ll ls[mt], rs[mt], t[mt], tcnt, tr; //一种动态的线段树，空时删点
void update(ll &r, ll lf, ll rf, const ll &pos, const ll &dt)
{
    if (!r) //动态加点
    {
        r = ++tcnt;
    }
    if (lf == rf)
    {
        t[r] += dt;
        if (t[r] == 0) //动态删点
        {
            r = 0;
        }
        return;
    }
    mkcf;
    if (pos <= cf)
    {
        update(ls[r], lf, cf, pos, dt);
    }
    else
    {
        update(rs[r], cf + 1, rf, pos, dt);
    }
    t[r] = t[ls[r]] + t[rs[r]];
    if (t[r] == 0)
    {
        r = 0;
    }
}
void cls()
{
    while (!qd.empty()) //清空线段树，因为加减守恒，绝对清得空
    {
        update(tr, 1, tp, qd.top(), -1);
        qd.pop();
    }
    tcnt = 0;
}
ll query(ll &r, ll lf, ll rf, const ll &lc, const ll &rc)
{
    if (!r)
    {
        return 0;
    }
    if (lf >= lc && rf <= rc)
    {
        return t[r];
    }
    if (rf < lc || lf > rc)
    {
        return 0;
    }
    mkcf;
    return query(ls[r], lf, cf, lc, rc) + query(rs[r], cf + 1, rf, lc, rc);
}

void dfz(ll u, ll fa)
{
    update(tr, 1, tp, 1, 1); //线段树l,r从1开始，所以偏移+1
    //这是因为有0时cf=(lf+rf)>>1会挂掉
    qd.push(1);
    died[u] = true;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        d[v] = e[i].w;
        dfs2(v, u);
        for (ll j = 1; j <= dcnt; ++j)
        {
            if (q >= ds[j]) //现在还缺(0,q]-ds[j]
            {
                ans += query(tr, 1, tp, 1 + max(0LL, 1 - ds[j]), 1 + max(0LL, q - ds[j])); //有的都加起来
            }
        }
        for (ll j = 1; j <= dcnt; ++j) //加上新有的
        {
            update(tr, 1, tp, ds[j] + 1, 1);
            qd.push(ds[j] + 1);
        }
        dcnt = 0;
    }
    cls();
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa || died[v])
        {
            continue;
        }
        n2 = sz[v], p = 0;
        dfs(v, u), dfs(p, 0);
        dfz(p, u);
    }
}
signed main()
{
    // freopen("a.out", "w", stdout);
    sc(n), n2 = n, smx[0] = 0x7fffffff;
    for (ll i = 1, u, v, w; i < n; ++i)
    {
        sc(u), sc(v), sc(w), adde(u, v, w), adde(v, u, w);
    }
    sc(q);
    dfs(1, 0), dfs(p, 0);
    dfz(p, 0);
    printf("%lld", ans);
    return 0;
}
```



##### P1276 校门外的树(增强版)

暴力即可，此处展示珂朵莉树代码：

```c++
#include <bits/stdc++.h>
#define re
#define repe(i, l, r) for (re int i = l; i <= r; ++i)
#define IT set<node>::iterator
using namespace std;
#define int long long
int n, m, x, y, c, res2;

struct node
{
    int l, r;
    mutable int v;
    node(int L, int R = -1, int V = 0) : l(L), r(R), v(V) {}
    bool operator<(const node &o) const
    {
        return l < o.l;
    }
};

set<node> s;

inline IT split(re int pos)
{
    IT it = s.lower_bound(node(pos));
    if (it != s.end() && it->l == pos)
        return it;
    --it;
    int L = it->l;
    int R = it->r;
    int V = it->v;
    s.erase(it);
    s.insert(node(L, pos - 1, V));
    return s.insert(node(pos, R, V)).first;
}

inline void assign_val(re int l, re int r, re int val = 0)
{
    IT itr = split(r + 1), itl = split(l);
    for (; itl != itr; ++itl)
        res2 += (itl->r - itl->l + 1) * (itl->v == 2);
    itr = split(r + 1), itl = split(l);
    s.erase(itl, itr);
    s.insert(node(l, r, val));
}

inline void assign_val2(re int l, re int r, re int val = 0)
{
    IT itr = split(r + 1), itl = split(l);
    for (; itl != itr; ++itl)
        if (itl->v == 0)
            itl->v = 2;
}

inline int query(re int l, re int r)
{
    int res = 0;
    IT itr = split(r + 1), itl = split(l);
    for (; itl != itr; ++itl)
        res += (itl->r - itl->l + 1) * (itl->v == 2);
    return res;
}

signed main()
{
    scanf("%lld%lld", &n, &m);
    s.insert(node(0, n, 1));
    // assign_val(0, 0, 0);
    repe(i, 1, m)
    {
        scanf("%lld%lld%lld", &c, &x, &y);
        if (c == 0)
        {
            assign_val(x, y);
        }
        else
        {
            assign_val2(x, y);
        }
    }
    printf("%lld\n%lld", query(0, n), res2);
    return 0;
}

```



##### p2782 友好城市

以一个岸为基准结构体排序，然后求另一个岸的最长单调上升子序列长度即可

这是因为，如果出现了不单调上升的话，就会形成 $<x_1,y_1>,<x_2,y_2>$ ，根据排序结果有 $x_1\le x_2$ ，而不升则 $y_2\ge y_2$ ，画图易知冲突。如果单调上升，同理一直不会交叉

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 200010
ll n, dp[mn], m;
struct node
{
    ll a, b;
    bool operator<(const node &x) const
    {
        return a < x.a;
    }
} p[mn];
signed main()
{
    sc(n);
    for (ll i = 1, x, y; i <= n; ++i)
    {
        sc(x), sc(y);
        p[i].a = x;
        p[i].b = y;
    }
    sort(p + 1, p + 1 + n);
    dp[++m] = p[1].b;
    for (ll i = 2; i <= n; ++i)
    {
        if (p[i].b > dp[m])
        {
            dp[++m] = p[i].b;
        }
        else if (p[i].b < dp[m])
        {
            *lower_bound(dp + 1, dp + 1 + m, p[i].b) = p[i].b;
        }
    }
    printf("%lld", m);
    return 0;
}
```



##### p4551 最长异或路径

> 给定 $n$ 点带权树，下标 $1$ 开始，求最大异或路径 ($n\le 10^5$ ，点权在 int 内)

路径异或可以划分为经过根节点的和不经过的。经过的可以以根为一端划分为两段。不经过的，可以虚补上相同的经过根的路径，即 $AB=AC+CB=AC+CP+PC+CB$ ，其中异或和 $CP,PC$ 抵消掉了。所以可以预处理每点到根的异或和得到一条路径，然后枚举每个这样的路径，对这些路径建01-trie，从高位开始贪心地找可以异或的位，相当于贪心地找到另一半路径。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef int ll;
#define sc(x) scanf("%d", &x)
#define mn 1000010
struct edge
{
    ll to, nx, w;
} e[mn << 1];
ll hd[mn], cnt, tot, n, u, v, w, sum[mn << 1], ans;
void adde(ll &u, ll &v, ll &w)
{
    e[++cnt] = {v, hd[u], w};
    hd[u] = cnt;
}
void dfs(ll u, ll fa)
{
    for (ll i = hd[u]; i; i = e[i].nx)
    {
        ll v = e[i].to, w = e[i].w;
        if (v != fa)
        {
            sum[v] = w ^ sum[u]; //子树边权前缀异或和
            dfs(v, u);
        }
    }
}
struct trie
{
    ll c[2];
} t[mn << 1];
void build(ll v, ll x)
{
    for (ll i = (1 << 30); i; i >>= 1)
    {
        bool b = v & i; //v&i暴毙 不用bool暴毙
        if (!t[x].c[b])
        {
            t[x].c[b] = ++tot;
        }
        x = t[x].c[b];
    }
}
ll query(ll v, ll x)
{
    ll res = 0;
    for (ll i = (1 << 30); i; i >>= 1)
    {
        bool b = v & i;
        if (t[x].c[!b])
        {
            res += i;
            x = t[x].c[!b];
        }
        else
        {
            x = t[x].c[b];
        }
    }
    return res;
}

signed main()
{
    sc(n);
    for (ll i = 1; i < n; ++i)
    {
        sc(u), sc(v), sc(w);
        adde(u, v, w), adde(v, u, w);
    }
    dfs(1, 0);
    for (ll i = 1; i <= n; ++i)
    {
        build(sum[i], 0);
    }
    for (ll i = 1; i <= n; ++i)
    {
        ans = max(ans, query(sum[i], 0));
    }
    printf("%d", ans);
    return 0;
}
```



##### SP4033 PHONELST - Phone List

> 给定n个长度不超过10的数字串，问其中是否存在两个数字串S，T，使得S是T的前缀。有多组数据，数据组数不超过40。n<=10000。
>
> 第一行，一个整数T，表示数据组数。
> 对于每组数据，第一行一个数n，接下去n行，输入n个数字串。
>
> 对于每组数据，若存在两个数字串S，T，使得S是T的前缀，则输出“NO”，否则输出“YES”。

字典树板子题，实现方法多样

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 100010
ll tc, n, t[mn][10], v[mn], cnt, p, m, suc;
char s[15];
void dfs(ll u)
{
    bool isLeaf = true;
    for (ll i = 0; i <= 9; ++i)
    {
        if (t[u][i] != 0)
        {
            isLeaf = false;
            dfs(t[u][i]);
        }
    }
    if (v[u] && !isLeaf)
    {
        suc = 1;
    }
}
signed main()
{
    for (sc(tc); tc--;)
    {
        sc(n);
        cnt = 1, suc = 0;
        memset(v, 0, sizeof v);
        memset(t, 0, sizeof t);
        for (ll i = 1; i <= n; ++i)
        {
            scanf("%s", s + 1);
            m = strlen(s + 1);
            p = 1;
            for (ll j = 1; j <= m; ++j)
            {
                ll si = s[j] - '0';
                if (t[p][si] == 0)
                {
                    t[p][si] = ++cnt;
                }
                p = t[p][si];
            }
            v[p] = 1;
        }
        dfs(1);
        if (!suc)
        {
            printf("YES\n");
        }
        else
        {
            printf("NO\n");
        }
    }
    return 0;
}
```



##### P7469 积木小赛

> 给定长为 $n(\le3000)$ 的小写字母字符串 $s,t$ ，从 $s$ 取非空子序列，从 $t$ 取非空子串，问子序列和子串有多少相同的

枚举 $t$ 子串的每一个左端点，然后延伸右端点，寻找 $s$ 是否有相同的子序列跟它匹配(类似 SCNUOJ [子序列](http://10.191.65.243:5000/p/1070)) ，这个过程找到有多少个 $t$ 子串与 $s$ 子序列相等，然后把 $t$ 子串存哈希判重，看看有多少个不同的 $t$ 子串，就是答案数。手写哈希能够实现 $O(n^2)$ 。

参考代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define mn 3010
ull a[mn * mn], p = 131, h;
char s[mn], t[mn];
ll n, cnt, k, ans, mm = mn * mn;
signed main()
{
    scanf("%lld%s%s", &n, s + 1, t + 1);
    for (ll i = 1; i <= n; ++i)
    {
        k = 1, h = 0;
        for (ll j = i; j <= n; ++j)
        {
            while (k <= n && s[k] != t[j])
            {
                ++k;
            }
            if (k > n)
            {
                break;
            }
            ++k;
            h = h * p + t[j]; //存在相同
            assert(h != 0);
            ll hi = h % mm;
            bool rep = (a[hi] == h);
            while (a[hi] != 0)
            {
                hi = (hi + 2333) % mm; //不能rand，不然判重会炸
                if (a[hi] == h)
                {
                    rep = true;
                    break;
                }
            }
            if (!rep)
            {
                a[hi] = h;
            }
        }
    }
    for (ll i = 0; i < mn * mn; ++i)
    {
        if (a[i] != 0)
        {
            ++ans;
        }
    }
    printf("%lld", ans);
    return 0;
}
```



##### p4423-最小三角形

跟平面最近点对差不多。要改几个地方：

- 把筛选条件换成坐标值绝对值差值小于最优解的一半。因为三角形最长边的边长不会超过周长的一半
- 暴力枚举时单层枚举改成双层暴力枚举

如果用了特判：跳过掉了 $n\le 3$ 的区间，而是特判这些区间的话，那么归并需要归一下，不然归并会炸，只能用快排。如果不特判，就可以归并。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define sc(x) scanf("%lld", &x)
#define mn 200010
ll n;
db ans = 1e21;
struct node
{
    ll x, y;
    bool operator<(const node &r) const { return x < r.x; }
} p[mn];
db dis(const node &a, const node &b)
{
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}
db tri(const node &a, const node &b, const node &c)
{
    return dis(a, b) + dis(b, c) + dis(c, a);
}
void solve(ll lc, ll rc)
{
    if (lc == rc)
    {
        return;
    }
    ll cc = (lc + rc) >> 1;
    ll cx = p[cc].x; //修改前的
    solve(lc, cc), solve(cc + 1, rc);
    inplace_merge(p + lc, p + cc + 1, p + rc + 1, [](const node &x, const node &y)
                  { return x.y < y.y; });
    vector<node> v;
    for (ll i = lc; i <= rc; ++i)
    {
        if (abs(cx - p[i].x) < ans / 2)
        {
            v.emplace_back(p[i]);
        }
    }
    for (auto lf = v.begin(), rf = lf; lf != v.end(); lf++)
    {
        while (rf != v.end() && abs(rf->y - lf->y) < ans / 2)
        {
            ++rf;
        }
        for (auto i = lf + 1; i != rf; ++i)
        {
            for (auto j = lf + 1; j != i; ++j)
            {
                ans = min(ans, tri(*lf, *i, *j));
            }
        }
    }
}
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        sc(p[i].x), sc(p[i].y);
    }
    sort(p + 1, p + 1 + n);
    solve(1, n);
    printf("%lf", ans);
    return 0;
}
```



##### p1742 最小圆覆盖

> 输入 $n(\le 10^5)$ ，输入 $n$ 个实数坐标点(绝对值 $\le10^4$ )，求覆盖这 $n$ 点的最小覆盖圆的半径和圆心坐标

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define mn 100010
#define cp const point &
ll n;
struct point
{
    db x = 0, y = 0;
    point(db a = 0, db b = 0) : x(a), y(b) {}
    point operator+(cp r) const { return point(x + r.x, y + r.y); }
    point operator-(cp r) const { return point(x - r.x, y - r.y); }
    point operator*(const db r) const { return point(x * r, y * r); }
    point operator/(const db r) const { return point(x / r, y / r); }
    db norm() const { return x * x + y * y; }
    point rotate() const { return point(y, -x); } //顺90
} p[mn], o;
db r2; // r*r
db cross(cp a, cp b) { return a.x * b.y - a.y * b.x; }
point intersect(cp p0, cp v0, cp p1, cp v1)
{
    return p0 + v0 * (cross(p1 - p0, v1) / cross(v0, v1));
}
void solve(cp a, cp b, cp c)
{
    o = intersect((a + b) / 2, (a - b).rotate(), (a + c) / 2, (a - c).rotate());
    r2 = (a - o).norm();
}
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lf%lf", &p[i].x, &p[i].y);
    }
    random_shuffle(p + 1, p + 1 + n);
    for (ll i = 1; i <= n; ++i)
    {
        if ((p[i] - o).norm() > r2)
        {
            o = p[i], r2 = 0;
            for (ll j = 1; j < i; ++j)
            {
                if ((p[j] - o).norm() > r2)
                {
                    o = (p[i] + p[j]) / 2, r2 = ((p[i] - p[j]) / 2).norm();
                    for (ll k = 1; k < j; ++k)
                    {
                        if ((p[k] - o).norm() > r2)
                        {
                            solve(p[i], p[j], p[k]);
                        }
                    }
                }
            }
        }
    }
    printf("%.12lf\n%.12lf %.12lf", sqrt(r2), o.x, o.y);
    return 0;
}
```



##### P2992 Triangle Counting G

[题目链接](https://www.luogu.com.cn/problem/P2992)

题目大意：已知 $n(1\le n\le10^5)$ 个点，坐标绝对值范围为 $\le10^5$ ，没有任何点在原点，任两点连向不经过原点。问这些点组成的三角形中，有多少个包含原点。

> 这其实是一道组合数学题。答案数 $=$ 三角形总数(即 $C_n^3$ ) $-$ 不经过原点的三角形。对于每个点与原点形成的直线 $OP_i$ ，极角是 `atan2(y, x)` ，我们发现该 $OP_i$ 左边的所有点两两组合，再与该点形成第三边，都必然不经过原点。且右边同理。根据题意可知，$P_i$  斜率大小各不同，所以 $OP_i$ 上没有任何其他点。
>
> 按极角排序后，在极角范围 $(P_i,\pi+P_i)$ 内的所有点都在同一侧，其余点在另一侧。考虑到极角大于 $\pi$ 的点 $P_i$ ，其 $\pi+P_i$ 会超过 $2\pi$ 的范围(类似于对 $2\pi$ 取模)，所以为了处理方便，可以把每个点复制多一个角度为 $2\pi +P_i$ 的点 (有点类似于化环为直线是思想)。对每个点，我们每次总是计算在 $(P_i,\pi+P_i)$ 一侧的点的数量 $m_i$ ，在另一侧的点可以不予理会 (必然会被其他点 $P_j$ 作 $OP_j$ 直线时考虑到)。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define sc(x) scanf("%lld", &x)
#define mn 100010
#define cp const point &
struct point
{
    ll x, y;
    db a;
    point(ll a = 0, ll b = 0) : x(a), y(b) {}
    bool operator<(cp r) const { return a < r.a; }
} p[mn * 2];
ll n, ans;
db pi = acos(-1);
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        sc(p[i].x), sc(p[i].y);
        p[i].a = atan2(p[i].y, p[i].x);
    }
    sort(p + 1, p + 1 + n);
    for (ll i = 1; i <= n; ++i)
    {
        p[i + n] = p[i], p[i + n].a += 2 * pi;
    }
    ans = n * (n - 1) * (n - 2) / 6; // C(n,3)
    for (ll i = 1, lf, rf = 0, m; i <= n; ++i)
    {
        lf = i + 1;
        while (rf + 1 <= 2 * n && p[lf - 1].a + pi > p[rf + 1].a)
        {
            ++rf;
        }
        m = rf - lf + 1;
        ans -= m * (m - 1) / 2; // C(m,2)
    }
    printf("%lld", ans);
    return 0;
}
```



##### P3476 TRO-Triangles

[题目链接](https://www.luogu.com.cn/problem/P3476)

题目翻译：给定 $n(3\le n\le3000)$ 个坐标值在 $[0,10^4]$ 的点，精确地求所有这些点形成的三角形的面积和

> 所求即：
> $$
> \dfrac12\sum_{i=1}^n\sum_{j=i+1}^n\sum_{k=j+1}^n|\vec{P_iP_j}\times\vec{P_iP_k}|
> $$
> 为了表达上的方便，以 $i$ 为坐标原点，变换后可得表达式为：
> $$
> \dfrac12\sum_{i=1}^n\sum_{j=i+1}^n\sum_{k=j+1}^n|\vec{OP_j}\times\vec{OP_k}|
> =
> \dfrac12\sum_{i=1}^n\sum_{j=i+1}^n\sum_{k=j+1}^n|x_jy_k-x_ky_j|
> $$
> 如果先按照 $x,y$ 为第一、第二关键字排序，然后枚举 $i$ ，那么必然满足 $P_j,P_k$ 都在直线 $x=x_i$ 的右方，也就是说剩下的点极角逆时针跨度不会超过 $\pi$ ，且不会在 $y\le y_i$ 这条射线上。因为要求没有精度误差，所以不能用 `atan2` ，只能用叉乘。 那么对剩下的点可以进行极角排序，使得排序后顺着 $j < k$ 枚举必然是逆时针方向的，那么差积大于 $0$ ，可以去掉绝对值。原式化简为：
> $$
> \dfrac12\sum_{i=1}^n\sum_{j=i+1}^n\sum_{k=j+1}^n(x_jy_k-x_ky_j)
> =
> \dfrac12\sum_{i=1}^n\sum_{j=i+1}^n(x_j\sum_{k=j+1}^ny_k-\sum_{k=j+1}^nx_ky_j)
> $$
> 这表明可以使用前缀和思想，去掉一层求和，当固定 $i,j$ 时，可以设后缀和 $s_x(k)=\sum_{i=k}^nx,s_y(k)=\sum_{i=k}^ny$ ，由此节省掉一层循环的时间。
>
> 因为都是整数运算，在除二之前不会出现小数。最后进行零精度的除二运算，可得整数 $\dfrac x2$ 的整数和小数点后数值依次为 $\lfloor\dfrac x2\rfloor,5(x\bmod 2)$  
>
> 那么只需要枚举 $i,j$ 两层循环，并且进行 $n$ 次极角排序即可，复杂度为 $O(n^2\log n)$ 。
>
> 考点：极角排序+组合数学+前缀和
>
> 参考代码：
>
> ```c++
> #include <bits/stdc++.h>
> using namespace std;
> typedef long long ll;
> #define sc(x) scanf("%lld", &x)
> #define mn 3010
> #define cp const point &
> struct point
> {
>     ll x, y;
>     point(ll a = 0, ll b = 0) : x(a), y(b) {}
>     point operator-(cp r) const { return point(x - r.x, y - r.y); }
> } p[mn], q[mn], p0;
> ll cross(cp a, cp b) { return a.x * b.y - a.y * b.x; }
> ll n, ans, sumx, sumy;
> signed main()
> {
>     sc(n);
>     for (ll i = 1; i <= n; ++i)
>     {
>         sc(p[i].x), sc(p[i].y);
>     }
>     sort(p + 1, p + 1 + n, [](cp a, cp b)
>          { return a.x != b.x ? a.x < b.x : a.y < b.y; });
>     for (ll i = 1; i <= n; ++i)
>     {
>         for (ll j = i + 1; j <= n; ++j)
>         {
>             q[j] = p[j] - p[i];
>         }
>         p0 = p[i], sumx = sumy = 0;
>         sort(q + 1 + i, q + 1 + n, [](cp a, cp b)
>              { return cross(a, b) > 0; });
>         for (ll j = n; j > i; --j)
>         {
>             ans += q[j].x * sumy - q[j].y * sumx;
>             sumx += q[j].x, sumy += q[j].y;
>         }
>     }
>     printf("%lld.%lld\n", ans / 2, ans % 2 * 5);
>     return 0;
> }
> ```



#### 网络流24题

##### p2761-软件补丁问题

> 有 $n$ 个 bugs ， $m$ 个补丁，补丁能启用当且仅当满足特定的若干个 bugs 存在 (+)，若干个 bugs 不存在 (-) ，能修复若干个 bugs (-) ，带来若干个 bugs (+)，耗费时间 $t$ ，一开始有 $n$ 个全部 bugs ，求修复完全部 bugs 最小用时。若修不好，输出 `-1` $1\le n\le20,1\le m\le100$

参考题解 [FCBM71](https://www.luogu.com.cn/problem/solution/P2761)

这道题类似于完全图，有 $2^n$ 个点，确定好连边状态之后暴力跑最短路即可。点编号为状态数位压缩值，满足存在条件即当前状态按位与为目标状态，满足不存在条件即按位与为 $0$ ，带来即按位或，修复即按位或然后按位异或。然后随便跑一个最短路即可(如SPFA,dijkstra)，

由于边太多，会MLE，所以不存边，每次直接判断即可。代码如下：

 ```C++
 #include <bits/stdc++.h>
 #define re
 using namespace std;
 typedef long long ll;
 #define il inline
 typedef double db;
 il ll read()
 {
     re char p = 0;
     re ll r = 0, o = 0;
     for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
         ;
     for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
         ;
     return o ? (~r) + 1 : r;
 }
 #define sc(x) x = read()
 #define me 105
 #define mn (1 << 20) + 10
 struct pack
 {
     ll b1, b2, f1, f2, t;
 } a[me];
 struct node
 {
     ll v, i;
     bool operator<(const node &x) const { return v > x.v; }
 };
 ll d[mn], vis[mn], no, n, m;
 priority_queue<node> q;
 char b[me], f[me];
 void dijkstra()
 {
     d[no] = 0, q.push({0, no});
     while (!q.empty())
     {
         ll u = q.top().i;
         q.pop();
         if (vis[u])
         {
             continue;
         }
         vis[u] = true;
         for (ll i = 1; i <= m; ++i)
         {
             if ((u & a[i].b1) == a[i].b1 && (u & a[i].b2) == 0)
             {
                 ll v = ((u | a[i].f1) ^ a[i].f1) | a[i].f2;
                 if (d[v] > d[u] + a[i].t)
                 {
                     d[v] = d[u] + a[i].t;
                     q.push({d[v], v});
                 }
             }
         }
     }
 }
 signed main()
 {
     sc(n), sc(m), no = (1 << n) - 1;
     memset(d, 0x3f, sizeof d);
     for (ll i = 1; i <= m; ++i)
     {
         scanf("%lld%s%s", &a[i].t, b, f);
         for (ll j = 0; j < n; ++j)
         {
             if (b[j] == '+')
             {
                 a[i].b1 |= (1 << j);
             }
             else if (b[j] == '-')
             {
                 a[i].b2 |= (1 << j);
             }
             if (f[j] == '-')
             {
                 a[i].f1 |= (1 << j);
             }
             else if (f[j] == '+')
             {
                 a[i].f2 |= (1 << j);
             }
         }
     }
     dijkstra();
     if (d[0] == d[mn - 1])
     {
         printf("0");
     }
     else
     {
         printf("%lld", d[0]);
     }
     return 0;
 }
 ```



##### p2756-飞行员配对方案问题

> 求二分图最大匹配的边数和匹配情况，左右点数为n,m，边数为e。

解法一：二分图匈牙利算法

复杂度 $\Omicron(ne+m)$

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 105
vector<ll> e[mn];
ll m, n, ui, vi, t, mch[mn], vis[mn], r;
bool dfs(ll u, ll st)
{
    if (vis[u] == st)
    {
        return false;
    }
    vis[u] = st;
    for (auto &v : e[u])
    {
        if (!mch[v] || dfs(mch[v], st))
        {
            mch[v] = u;
            return true;
        }
    }
    return false;
}
signed main()
{
    sc(m), sc(n);
    while (true)
    {
        sc(ui), sc(vi);
        if (ui == -1 && vi == -1)
        {
            break;
        }
        e[ui].emplace_back(vi);
    }
    for (ll i = 1; i <= m; ++i)
    {
        if (dfs(i, i))
        {
            ++r;
        }
    }
    printf("%lld\n", r);
    for (ll i = m + 1; i <= n; ++i)
    {
        if (mch[i])
        {
            printf("%lld %lld\n", mch[i], i);
        }
    }
    return 0;
}
```

解法二：dinic算法

复杂度 $\Omicron(e\sqrt n)$

源点、汇点、题目边都建权为 $1$ 的边，跑最大流即可。输出最大流和残量网络里剩余流量为 $0$ 的边(不含源点汇点)。

代码如下：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define big 0x7fffffff
#define me 10010
#define mn 110
struct edge
{
    ll to, w, nx;
} e[me];
ll n, m, s, t, hd[mn], cnt = 1, h[mn], ans1[mn], ans2[mn], u, v, res, c0;
void adde(ll &u, ll &v, ll w = 1)
{
    e[++cnt] = {v, w, hd[u]};
    hd[u] = cnt;
    e[++cnt] = {u, 0LL, hd[v]};
    hd[v] = cnt;
}
bool bfs()
{
    queue<ll> q;
    q.push(s);
    memset(h, -1, sizeof h);
    h[s] = 0;
    while (!q.empty())
    {
        ll u = q.front();
        q.pop();
        for (ll i = hd[u], v; i; i = e[i].nx)
        {
            v = e[i].to;
            if (h[v] == -1 && e[i].w)
            {
                h[v] = h[u] + 1;
                q.push(v);
            }
        }
    }
    return h[t] != -1;
}
ll dfs(ll u, ll f)
{
    if (u == t)
    {
        return f;
    }
    ll w, used = 0;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (h[v] == h[u] + 1 && e[i].w)
        {
            w = dfs(v, min(f - used, e[i].w));
            e[i].w -= w, e[i ^ 1].w += w;
            used += w;
            if (used == f)
            {
                return f;
            }
        }
    }
    if (!used)
    {
        h[u] = -1;
    }
    return used;
}
signed main()
{
    sc(m), sc(n), s = 0, t = n + 1;
    while (true)
    {
        sc(u), sc(v);
        if (u == -1 && v == -1)
        {
            break;
        }
        adde(u, v);
    }
    c0 = cnt;
    for (ll i = 1; i <= m; ++i)
    {
        adde(s, i);
    }
    for (ll i = m + 1; i <= n; ++i)
    {
        adde(i, t);
    }
    while (bfs())
    {
        res += dfs(s, big);
    }
    printf("%lld\n", res);
    for (ll i = 2; i <= c0; i += 2)
    {
        if (e[i ^ 1].w != 0)
        {
            printf("%lld %lld\n", e[i ^ 1].to, e[i].to);
        }
    }
    return 0;
}
```



##### p4016-负载平衡问题

> $n$ 个仓库成环，每个仓库现存货量为 $a$ ，求最少搬运量，使 $n$ 仓库存货量相同 $1\le n\le100$

解法一： $DP$ + 中位数性质



解法二：最小费用最大流    EK 算法 / dinic 算法

以 $a-\overline{a}$ 为点权建边(注意平均数下取整)，对点权大于 $0$ 的点跟源点连流量为无限，费用为 $1$ 的边，小于 $0$ 的跟汇点连流量为无限，费用为 $1$ 的边。环内连流量为点权，费用为 $0$ 的边。跑最小费用最大流，得到答案。

代码如下：

```c++

```





##### p4011-孤岛营救问题

> 有 $n\times m$ 网格，从 $(1,1)$ 开始，要到达 $(n,m)$ ，在 $p$ 个两格边沿有墙或门，墙为 $0$ ，门为 $g$ 。在 $s$ 个格有钥匙 $g$ 。当且仅当有钥匙才能开门，且不会消耗钥匙。求到达终点需要最小步数，若无解输出 `-1` 。 $1\le n,m,p\le10,k < 150,s\le 14$

是一个非常普通的分层图 BFS。设当前状态为所有已拥有钥匙的数位压缩。如果到某个位置的该状态没走过就走。门能否打开的判定是当前状态按位或门的状态是否是门的状态本身，是的话可以通过，不然不能通过。

时间复杂度为 $\Omicron(nm2^p)$ ，可以过题。代码如下：

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 12
#define ms 16
ll n, m, p, k, ax, ay, bx, by, g, s;
ll key[mn][mn][ms], keyn[mn][mn];
ll door[mn][mn][mn][mn]; //door[ax][ay][bx][by]
ll dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};
struct node
{
    ll x, y, k;
    bool operator<(const node &p) const
    {
        return x * 10000LL + y * 100 + k < p.x * 10000LL + p.y * 100 + p.k;
    }
};
struct node2
{
    ll x, y, k, s;
};
set<node> vis;
ll getk(ll x, ll y)
{
    ll r = 0;
    for (ll i = 1, ie = keyn[x][y]; i <= ie; ++i)
    {
        r |= key[x][y][i];
    }
    return r;
}
ll bfs()
{
    queue<node2> q;
    q.push({1, 1, 0, 0});
    while (!q.empty())
    {
        node2 t = q.front();
        q.pop();
        if (vis.find({t.x, t.y, t.k}) != vis.end())
        {
            continue;
        }

        vis.insert({t.x, t.y, t.k});
        if (t.x == n && t.y == m)
        {
            return t.s;
        }
        for (ll i = 0; i < 4; ++i)
        {
            ll ax = t.x + dx[i], ay = t.y + dy[i];
            ll adr = door[t.x][t.y][ax][ay];
            if (ax <= 0 || ay <= 0 || ax > n || ay > m || adr == -1)
            {
                continue;
            }
            ll ak = getk(ax, ay) | t.k;
            if (vis.find({ax, ay, ak}) != vis.end())
            {
                continue;
            }
            if (adr > 0 && (ak & adr) != adr)
            {
                continue;
            }
            q.push({ax, ay, ak, t.s + 1});
        }
    }
    return -1;
}
signed main()
{
    sc(n), sc(m), sc(p), sc(k);
    for (ll i = 1; i <= k; ++i)
    {
        sc(ax), sc(ay), sc(bx), sc(by), sc(g);
        if (g)
        {
            door[ax][ay][bx][by] = 1 << g;
            door[bx][by][ax][ay] = 1 << g;
        }
        else
        {
            door[ax][ay][bx][by] = -1;
            door[bx][by][ax][ay] = -1;
        }
    }
    sc(s);
    for (ll i = 1; i <= s; ++i)
    {
        sc(ax), sc(ay), sc(g);
        key[ax][ay][++keyn[ax][ay]] = 1 << g;
    }
    printf("%lld", bfs());
    return 0;
}
```





#### THUPC 2021 初赛/正赛

##### p7140 区间矩阵乘法

前缀和题目，估计难度不超过绿题，可能是黄题 具体看题解 [Cirno\_9](https://www.luogu.com.cn/problem/solution/P7140)

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef unsigned int ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 200010
ll n, m, p1, p2, d, a[mn], sk[450][mn], s[mn], ans; //450=2e5**.5
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        sc(a[i]);
        s[i] = s[i - 1] + a[i];
    }
    for (ll i = 1, ie = sqrt(n); i <= ie; ++i) //d枚举
    {
        for (ll j = 1; j <= i; ++j)
        {
            sk[i][j] = a[j];
        }
        for (ll j = i + 1; j <= n; ++j)
        {
            sk[i][j] = sk[i][j - i] + a[j];
        }
    }
    sc(m);
    while (m--)
    {
        sc(d), sc(p1), sc(p2), ans = 0;
        for (ll j = 0; j < d; ++j)
        {
            ans += (sk[d][p1 + (d - 1) * d + j] - sk[d][p1 + j] + a[p1 + j]) * (s[p2 + d * (j + 1) - 1] - s[p2 + d * j - 1]);
        }
        printf("%u\n", ans);
    }
    return 0;
}
```



#### 部分模板

##### P1020 导弹拦截

> 输入至多 $10^5$ 个数，求最长不下降序列的长度和可以划分为多少个最长不下降序列(不是不下降子串)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 100010
ll n, a[mn], dpnd[mn], dpu[mn], ans, x, nnd, nu;
signed main()
{
    while (EOF != scanf("%lld", &x))
    {
        if (x <= 0)
        {
            break;
        } // for test
        a[++n] = x;
    }
    dpnd[++nnd] = dpu[++nu] = a[1];
    for (ll i = 2; i <= n; ++i)
    {
        if (a[i] <= dpnd[nnd])
        {
            dpnd[++nnd] = a[i];
        }
        else
        {
            *upper_bound(dpnd + 1, dpnd + 1 + nnd, a[i], greater<ll>()) = a[i];
        }
        if (a[i] > dpu[nu])
        {
            dpu[++nu] = a[i];
        }
        else
        {
            *lower_bound(dpu + 1, dpu + 1 + nu, a[i]) = a[i];
        }
    }
    printf("%lld\n%lld", nnd, nu);
    return 0;
}
```



##### P2543 奇怪的字符串

> 给定 $n$ 给定两个长为 $n$ 的排列，求其最长公共子序列 $n\le10^5 $

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 10010
ll dp[2][mn], nx, ny; // dp[i][j]:LCS(x[1..i],LCS(y[1..y]))
char x[mn], y[mn];
signed main()
{
    scanf("%s%s", x + 1, y + 1);
    nx = strlen(x + 1), ny = strlen(y + 1);
    for (ll i = 1, now = 1, pre = 0; i <= nx; ++i, now ^= 1, pre ^= 1)
    {
        for (ll j = 1; j <= ny; ++j)
        {
            if (x[i] == y[j])
            {
                dp[now][j] = dp[pre][j - 1] + 1;
            }
            else
            {
                dp[now][j] = max(dp[pre][j], dp[now][j - 1]);
            }
        }
    }
    printf("%lld", dp[nx & 1][ny]);
    return 0;
}
```



##### P1439 最长公共子序列

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 100010
ll a[mn], b[mn], n, dp[mn], m, h[mn];
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        sc(a[i]);
        h[a[i]] = i;
    }
    for (ll i = 1; i <= n; ++i)
    {
        sc(b[i]);
        b[i] = h[b[i]];
    }
    dp[++m] = b[1];
    for (ll i = 2; i <= n; ++i)
    {
        if (b[i] > dp[m])
        {
            dp[++m] = b[i];
        }
        else
        {
            *lower_bound(dp + 1, dp + 1 + m, b[i]) = b[i];
        }
    }
    printf("%lld", m);
    return 0;
}
/*
5
3 2 4 5 1
1 4 2 3 5
=>
5 3 2 1 4 (ans2)
*/
```



##### P3808 AC自动机(简单版)

> 求有多少个模式串在主串出现过，输入模式串数 $n$ ，可能重复的模式串，主串。模式串数目、模式串长度、模式串长度和和主串长度不超过 $10^6$ ，只含小写字母

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 1000010
int tr[mn][26], cnt, e[mn], fail[mn];
ll n, ans;
char s[mn];
queue<int> q;
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%s", s + 1);
        int u = 0;
        for (int i = 1; s[i]; ++i)
        {
            int a = s[i] - 'a';
            if (!tr[u][a])
            {
                tr[u][a] = ++cnt;
            }
            u = tr[u][a];
        }
        ++e[u];
    }
    for (ll i = 0; i < 26; ++i)
    {
        if (tr[0][i])
        {
            q.push(tr[0][i]);
        }
    }
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int i = 0; i < 26; ++i)
        {
            if (tr[u][i])
            {
                fail[tr[u][i]] = tr[fail[u]][i];
                q.push(tr[u][i]);
            }
            else
            {
                tr[u][i] = tr[fail[u]][i];
            }
        }
    }
    scanf("%s", s + 1);
    int u = 0;
    for (int i = 1; s[i]; ++i)
    {
        int a = s[i] - 'a';
        u = tr[u][a];
        for (int j = u; j && e[j] != -1; j = fail[j])
        {
            ans += e[j], e[j] = -1;
        }
    }
    printf("%lld", ans);
    return 0;
}
```



##### p3796 AC自动机(加强版)

> 若干询问。输出出现次数最多的所有模式串。输入同上题。模式串不超过 $150$ 个，长度不超过 $70$ 。测试样例不超过 $50$ 组

```c++
#include <bits/stdc++.h>
using namespace std;
typedef int ll;
#define sc(x) scanf("%d", &x)
#define mn 152
#define ms 72
#define alp 26
#define mt ((mn) * (ms))
#define cls(x) memset(x, 0, sizeof x)
ll cnt, tr[mt][alp], fail[mt], idx[mt], v[mt], sum[mt], n, mx;
char s[mn][ms], t[1000010];
void insert(char *s, ll id)
{
    int u = 0;
    for (ll i = 1, a; s[i]; ++i)
    {
        a = s[i] - 'a';
        if (!tr[u][a])
        {
            tr[u][a] = ++cnt;
        }
        u = tr[u][a];
    }
    idx[u] = id;
}
void build()
{
    queue<ll> q;
    for (ll i = 0; i < alp; ++i)
    {
        if (tr[0][i])
        {
            q.push(tr[0][i]);
        }
    }
    while (!q.empty())
    {
        ll u = q.front();
        q.pop();
        for (ll i = 0; i < alp; ++i)
        {
            if (tr[u][i])
            {
                fail[tr[u][i]] = tr[fail[u]][i];
                q.push(tr[u][i]);
            }
            else
            {
                tr[u][i] = tr[fail[u]][i];
            }
        }
    }
}
void query()
{
    ll u = 0;
    for (ll i = 1, a; t[i]; ++i)
    {
        a = t[i] - 'a';
        u = tr[u][a];
        for (ll j = u; j; j = fail[j])
        {
            ++v[j];
        }
    }
    for (ll i = 0; i <= cnt; ++i)
    {
        if (idx[i])
        {
            mx = max(mx, v[i]);
            sum[idx[i]] = v[i];
        }
    }
}
signed main()
{
    while (~sc(n))
    {
        if (n == 0)
        {
            break;
        }
        for (ll i = 1; i <= n; ++i)
        {
            scanf("%s", s[i] + 1);
            insert(s[i], i);
        }
        build();
        scanf("%s", t + 1);
        query();
        printf("%lld\n", mx);
        for (ll i = 1; i <= n; ++i)
        {
            if (mx == sum[i])
            {
                printf("%s\n", s[i] + 1);
            }
        }
        cls(fail), cls(tr), cls(v), cls(idx), cls(sum), cnt = mx = 0;
    }
    return 0;
}
```



##### p1183 多边形的面积

> 逆时针顺序给定 $n(\le 100)$ 整点，绝对值不超过 $200$ ，保证答案是整数，求多边形面积

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 105
ll n, x[mn], y[mn], s;
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        sc(x[i]), sc(y[i]);
    }
    x[n + 1] = x[1], y[n + 1] = y[1];
    for (ll i = 1; i <= n; ++i)
    {
        s += x[i] * y[i + 1] - x[i + 1] * y[i];
    }
    printf("%lld", s / 2);
    return 0;
}
```



##### p7883 平面最近点对

> 给定 $n$ 对点 (绝对值不超过 $10^7$) ，求最近点对的距离平方。$2\le n\le4\times10^5$

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 400010
ll n, ans = 1e18;
struct node
{
    ll x, y;
    bool operator<(const node &r) const { return x < r.x; }
} p[mn];
void solve(ll lc, ll rc)
{
    if (lc == rc)
    {
        return;
    }
    ll cc = (lc + rc) >> 1;
    ll cx = p[cc].x; //修改前的
    solve(lc, cc), solve(cc + 1, rc);
    inplace_merge(p + lc, p + cc + 1, p + rc + 1, [](const node &x, const node &y)
                  { return x.y < y.y; });
    vector<node> v;
    for (ll i = lc; i <= rc; ++i)
    {
        if ((cx - p[i].x) * (cx - p[i].x) <= ans)
        {
            v.emplace_back(p[i]);
        }
    }
    for (auto lf = v.begin(), rf = lf; lf != v.end(); lf++)
    {
        double sans = sqrt(ans);
        while (rf != v.end() && rf->y <= lf->y + sans)
        {
            ++rf;
        }
        for (auto i = lf + 1; i != rf; ++i)
        {
            ans = min(ans, (lf->x - i->x) * (lf->x - i->x) + (lf->y - i->y) * (lf->y - i->y));
        }
    }
}
signed main()
{
    sc(n);
    for (ll i = 1; i <= n; ++i)
    {
        sc(p[i].x), sc(p[i].y);
    }
    sort(p + 1, p + 1 + n);
    solve(1, n);
    printf("%lld", ans);
    return 0;
}
```



#### UVA

##### UVA10635 Prince and Princess

把 $b$ 里没在 $a$ 出现过的部分扔掉即可

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 100010
ll a[mn], b[mn], n, nb, nc, dp[mn], m, h[mn], k, t, x;
void solve()
{
    memset(h, 0, sizeof 0);
    nc = m = 0;
    sc(x), sc(n), sc(nb), ++n, ++nb;
    for (ll i = 1; i <= n; ++i)
    {
        sc(a[i]);
        h[a[i]] = i;
    }
    for (ll i = 1; i <= nb; ++i)
    {
        sc(b[i]);
        b[i] = h[b[i]];
        if (b[i] != 0 && b[i] <= n)
        {
            b[++nc] = b[i];
        }
    }
    dp[++m] = b[1];
    for (ll i = 2; i <= nc; ++i)
    {
        if (b[i] > dp[m])
        {
            dp[++m] = b[i];
        }
        else
        {
            *lower_bound(dp + 1, dp + 1 + m, b[i]) = b[i];
        }
    }
    printf("Case %lld: %lld", k, m);
    if (k <= t)
    {
        putchar('\n');
    }
}
signed main()
{
    sc(t);
    for (k = 1; k <= t; ++k)
    {
        solve();
    }
    return 0;
}
```



##### UVA1401 Remember the Word

> 给定字符串 $|S|\le3\times10^5$ ，然后给定 $s\le 4000$ 个长度不超过 $100$ 的小写互补重复单词，问有多少种由这些字符串拼接成 $S$ 的方案

先建立一棵字典树，标记每个单词结尾，设 $dp[i]$ 代表 $S[i..|S|]$ 能够有多少种方案，并初始化空串 $dp[|S|+1]=1$ 。然后倒序遍历 $S[i..|S|]$ ，以这个后缀走一次字典树，如果在 $S[j]$ 访问到了标记的结尾，那么说明 $S[i..j]+S[j+1..|S|]$ 能够拼接，前者是字典树里遍历到的，后者有 $dp[j+1]$ 种情况。那么就对 $S[i..|S|]$ 加上这么多种方案。

虽然这个遍历过程看似是 $O(|S|^2)$ 的，但是如果加上走到字典树空就跳出循环，那么在题给限制下，因为字典树是树深是 $100$ ，所以实际上内层循环最多走 $100$ 下，即实际复杂度为 $O(100|S|)$ 。

参考代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 4010
#define ms 400010
ll kase, dp[ms], ns, tr[ms][26], vis[ms], n, nt, cnt, p, mod = 20071027;
char s[ms], t[105];
signed main()
{
    while (EOF != scanf("%s", s + 1))
    {
        scanf("%lld", &n), ns = strlen(s + 1);
        memset(tr, 0, sizeof tr); // ns跟trie长度无关
        memset(vis, 0, sizeof vis);
        memset(dp, 0, sizeof dp);
        cnt = 1;
        while (n--)
        {
            scanf("%s", t + 1), nt = strlen(t + 1);
            p = 1;
            for (ll i = 1, si; i <= nt; ++i)
            {
                si = t[i] - 'a';
                if (tr[p][si] == 0)
                {
                    tr[p][si] = ++cnt;
                }
                p = tr[p][si];
            }
            vis[p] += 1; //互不相同，不可能叠加，值域[0,1]
            assert(vis[p] <= 1);
        }
        dp[ns + 1] = 1;
        for (ll i = ns; i; --i)
        {
            p = 1;
            for (ll j = i, si; j <= ns; ++j)
            {
                si = s[j] - 'a';
                if (tr[p][si] <= 1)
                {
                    break;
                }
                p = tr[p][si];
                if (vis[p])
                {
                    dp[i] = (dp[i] + dp[j + 1]) % mod;
                }
            }
        }
        printf("Case %lld: %lld\n", ++kase, dp[1]);
    }
    return 0;
}
```



#### 多解板子

在这里多用别的算法来做不是该算法的模板

##### P3374  [模板] 树状数组 1

###### zkw线段树

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 500010
ll t[mn << 2], n, N, m, c, x, y;
signed main()
{
    sc(n), sc(m);
    for (N = 1; N <= n + 1; N <<= 1)
        ;
    for (ll i = N + 1; i <= N + n; ++i)
    {
        sc(t[i]);
    }
    for (ll i = N - 1; i >= 1; --i)
    {
        t[i] = t[i << 1] + t[i << 1 | 1];
    }
    while (m--)
    {
        sc(c), sc(x), sc(y);
        if (c == 1)
        {
            for (ll i = x + N; i; i >>= 1)
            {
                t[i] += y;
            }
        }
        else
        {
            ll ans = 0;
            for (ll s = N + x - 1, r = N + y + 1; s ^ r ^ 1; s >>= 1, r >>= 1)
            {
                if (~s & 1)
                {
                    ans += t[s ^ 1];
                }
                if (r & 1)
                {
                    ans += t[r ^ 1];
                }
            }
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```



##### P3372 [模板] 线段树 1

###### 线段树

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 100010
ll t[mn << 2], laz[mn << 2], n, m, c, lc, rc, v, a[mn], ans;
#define lfs p << 1
#define rfs p << 1 | 1
#define mkcf ll cf = (lf + rf) >> 1
void build(ll p, ll lf, ll rf)
{
    if (lf == rf)
    {
        t[p] = a[lf];
        return;
    }
    mkcf;
    build(lfs, lf, cf);
    build(rfs, cf + 1, rf);
    t[p] = t[lfs] + t[rfs];
}
void pushdown(ll p, ll lf, ll rf)
{
    mkcf;
    t[lfs] += (cf - lf + 1) * laz[p];
    t[rfs] += (rf - cf) * laz[p];
    laz[lfs] += laz[p];
    laz[rfs] += laz[p];
    laz[p] = 0;
}
void update(ll p, ll lf, ll rf)
{
    if (lf >= lc && rf <= rc)
    {
        t[p] += v * (rf - lf + 1);
        laz[p] += v;
        return;
    }
    pushdown(p, lf, rf);
    mkcf;
    if (cf >= lc)
    {
        update(lfs, lf, cf);
    }
    if (cf < rc)
    {
        update(rfs, cf + 1, rf);
    }
    t[p] = t[lfs] + t[rfs];
}
void query(ll p, ll lf, ll rf)
{
    if (lf >= lc && rf <= rc)
    {
        ans += t[p];
        return;
    }
    pushdown(p, lf, rf);
    mkcf;
    if (cf >= lc)
    {
        query(lfs, lf, cf);
    }
    if (cf < rc)
    {
        query(rfs, cf + 1, rf);
    }
    t[p] = t[lfs] + t[rfs];
}
signed main()
{
    sc(n), sc(m);
    for (ll i = 1; i <= n; ++i)
    {
        sc(a[i]);
    }
    build(1, 1, n);
    while (m--)
    {
        sc(c), sc(lc), sc(rc);
        if (c == 1)
        {
            sc(v);
            update(1, 1, n);
        }
        else
        {
            ans = 0;
            query(1, 1, n);
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```



###### zkw 线段树

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 400010
#define sc(x) scanf("%lld", &x)
ll n, m, a[mn], dt, laz[mn], c, x, y, k;
signed main()
{
    sc(n), sc(m);
    for (dt = 1; dt <= n + 1; dt <<= 1)
        ;
    for (ll i = dt + 1; i <= dt + n; ++i)
    {
        sc(a[i]);
    }
    for (ll i = dt - 1; i >= 1; --i)
    {
        a[i] = a[i << 1] + a[i << 1 | 1];
    }
    while (m--)
    {
        sc(c), sc(x), sc(y);
        if (c == 1)
        {
            sc(k);
            ll lf = 0, rf = 0, layer = 1, s = dt + x - 1, t = dt + y + 1;
            for (; s ^ t ^ 1; s >>= 1, t >>= 1, layer <<= 1)
            {
                a[s] += k * lf, a[t] += k * rf;
                if (~s & 1)
                {
                    laz[s ^ 1] += k, a[s ^ 1] += k * layer, lf += layer;
                }
                if (t & 1)
                {
                    laz[t ^ 1] += k, a[t ^ 1] += k * layer, rf += layer;
                }
            }
            for (; s; s >>= 1, t >>= 1)
            {
                a[s] += k * lf, a[t] += k * rf;
            }
            // printf("%lld\n", a[1] + laz[1]);
        }
        else
        {
            ll lf = 0, rf = 0, layer = 1, s = dt + x - 1, t = dt + y + 1;
            ll ans = 0;
            for (; s ^ t ^ 1; s >>= 1, t >>= 1, layer <<= 1)
            {
                if (laz[s])
                {
                    ans += laz[s] * lf;
                }
                if (laz[t])
                {
                    ans += laz[t] * rf;
                }
                if (~s & 1)
                {
                    ans += a[s ^ 1], lf += layer;
                }
                if (t & 1)
                {
                    ans += a[t ^ 1], rf += layer;
                }
            }
            for (; s; s >>= 1, t >>= 1)
            {
                ans += laz[s] * lf + laz[t] * rf;
            }
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```





## HDU

#### 杂题

##### hdu-6287 口算练习

> CCPC18女生赛真题

唯一分解定理+二分。设vector数组,`vector[x]`:质数`x`出现`a_i`的`i`，不去重，重复则占多个位。对`d`的每个因子`i`，对`vector[i]`二分找区间$[l,r]$，若区间长度大于因子幂，则符合条件，不大于则条件不符合。

时间复杂度$\Omicron(tn\log n)$。空间复杂度为$\Omicron(n\log n)$。

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 100010
ll t, n, m, a[mn], l, r, d;
vector<ll> p[mn];
void upd(ll &v, const ll pi, const ll &pv)
{
    p[pi].emplace_back(pv);
    v /= pi;
}
bool chk(const ll &i, const ll &req)
{
    auto hs = upper_bound(p[i].begin(), p[i].end(), r) - lower_bound(p[i].begin(), p[i].end(), l);
    return hs >= req;
}
signed main()
{
    sc(t);
    while (t--)
    {
        sc(n), sc(m);
        for (ll i = 0; i <= 100000; ++i)
        {
            p[i].clear();
        }
        for (ll i = 1; i <= n; ++i)
        {
            sc(a[i]);
            for (ll j = 2; j * j <= a[i]; ++j)
            {
                while (a[i] % j == 0)
                {
                    // upd(a[i], j, i);
                    p[j].emplace_back(i);
                    a[i] /= j;
                }
            }
            if (a[i] > 1)
            {
                // upd(a[i], a[i], i);
                p[a[i]].emplace_back(i);
            }
        }
        while (m--)
        {
            sc(l), sc(r), sc(d);
            bool suc = true;
            for (ll i = 2, req; i * i <= d; ++i)
            {
                req = 0;
                if (d % i == 0)
                {
                    while (d % i == 0)
                    {
                        d /= i, ++req;
                    }
                    auto hs = upper_bound(p[i].begin(), p[i].end(), r) - lower_bound(p[i].begin(), p[i].end(), l);
                    if (hs < req)
                    {
                        suc = 0;
                        break;
                    }
                }
            }
            if (d > 1)
            {
                auto hs = upper_bound(p[d].begin(), p[d].end(), r) - lower_bound(p[d].begin(), p[d].end(), l);
                if (hs < 1)
                {
                    suc = 0;
                }
            }
            printf(suc ? "Yes\n" : "No\n");
        }
    }
    return 0;
}
```



##### hdu-1003 Max Sum

> 求最大连续子序列和及其边界 $1\le n\le10^5$

个人代码：(试了很多次)

```c++
#include <bits/stdc++.h>
#define re
using namespace std;
typedef long long ll;
#define il inline
typedef double db;
il ll read()
{
    re char p = 0;
    re ll r = 0, o = 0;
    for (; p < '0' || p > '9'; o |= p == '-', p = getchar())
        ;
    for (; p >= '0' && p <= '9'; r = (r << 1) + (r << 3) + (p ^ 48), p = getchar())
        ;
    return o ? (~r) + 1 : r;
}
#define sc(x) x = read()
#define mn 100010
ll t, n, s[mn], v, lf, rf, ans, mins, minlf, maxv, maxi;
signed main()
{
    sc(t);
    for (ll h = 1; h <= t; ++h)
    {
        sc(n);
        mins = rf = ans = minlf = 0, maxv = -9999;
        for (ll i = 1; i <= n; ++i)
        {
            sc(v);
            s[i] = s[i - 1] + v; //s[i]是区间[1,i]和
            if (v > maxv)        //全负特判
            {
                maxv = v;
                maxi = i;
            }
            if (s[i] < mins)
            {
                mins = s[i]; //mins已知1为左端的最小区间和
                minlf = i;   //mins区间为[1,minlf]
            }
            //[1,i] 减去 [1,minlf] 是 [minlf+1,i]
            if (s[i] - mins > ans)
            {
                ans = s[i] - mins;
                lf = minlf + 1;
                rf = i;
            }
        }
        if (maxv <= 0)
        {
            ans = maxv, lf = rf = maxi;
        }
        if (h > 1)//乐，竟然会PE
        {
            printf("\n");
        }
        printf("Case %lld:\n%lld %lld %lld\n", h, ans, lf, rf);
    }
    return 0;
}
```

更优解法：[这里](https://blog.csdn.net/weixin_40894017/article/details/79134244)

```c++
#include<bits/stdc++.h>
using namespace std;//由于本题从前往后更新，所以不用另开数组
int dp[100005];//dp[i]记录的是以dp[i]为结尾的最大值；
int main()
{
	int n;cin>>n;
	for(int kk=1;kk<=n;kk++){
		int t;cin>>t;
		memset(dp,0,sizeof(dp));
		for(int i=1;i<=t;i++)
		{
			scanf("%d",&dp[i]);
		}
		int l=1,r=1;//记录区间
		int temp=1;//记录起点
		int MAx=dp[1];
		for(int i=2;i<=t;i++)
		{
            if(dp[i-1]>=0)//dp[i-1]大于0，则对dp[i]有贡献
            {
                dp[i]=dp[i-1]+dp[i];
            }else{temp=i;}
            if(dp[i]>MAx)
            {
            	MAx=dp[i];
            	l=temp;
         	    r=i;
            }
		}
		if(kk>=2){printf("\n");}
		printf("Case %d:\n",kk);
		printf("%d %d %d\n",MAx,l,r);
	}
}
```



#### 模板

##### hdu5306 gorgeous sequence

因为hdu炸了，所以没在原网址补代码，自己造了一道同样的题，随机弱数据，在上面补对了(SCNUOJ 1703)，个人 AC 代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 400010
#define lfs p << 1
#define rfs p << 1 | 1
#define mkcf ll cf = (lf + rf) >> 1
#define neg -1
ll n, m, c, lc, rc, v, a[mn], s[mn], mx[mn], se[mn], cnt[mn], laz[mn], ans;
void pushup(ll p)
{
    s[p] = s[lfs] + s[rfs];
    if (mx[lfs] == mx[rfs])
    {
        mx[p] = mx[lfs];
        cnt[p] = cnt[lfs] + cnt[rfs];
        se[p] = max(se[lfs], se[rfs]);
    }
    else if (mx[lfs] > mx[rfs])
    {
        mx[p] = mx[lfs];
        cnt[p] = cnt[lfs];
        se[p] = max(se[lfs], mx[rfs]);
    }
    else if (mx[lfs] < mx[rfs])
    {
        mx[p] = mx[rfs];
        cnt[p] = cnt[rfs];
        se[p] = max(se[rfs], mx[lfs]);
    }
}
void build(ll p, ll lf, ll rf)
{
    laz[p] = -1;
    if (lf == rf)
    {
        s[p] = mx[p] = a[lf];
        cnt[p] = 1;
        se[p] = -1;
        return;
    }
    mkcf;
    build(lfs, lf, cf);
    build(rfs, cf + 1, rf);
    pushup(p);
}
void pushd(ll p, ll nw)
{
    if (mx[p] <= nw)
    {
        return;
    }
    s[p] += cnt[p] * (nw - mx[p]);
    mx[p] = laz[p] = nw;
}
void pushdown(ll p)
{
    if (laz[p] == -1)
    {
        return;
    }
    pushd(lfs, laz[p]);
    pushd(rfs, laz[p]);
    laz[p] = -1;
}
void update(ll p, ll lf, ll rf)
{
    if (mx[p] <= v)
    {
        return;
    }
    if (lf >= lc && rf <= rc && se[p] < v)
    {
        return pushd(p, v);
    }
    pushdown(p);
    mkcf;
    if (cf >= lc)
    {
        update(lfs, lf, cf);
    }
    if (cf < rc)
    {
        update(rfs, cf + 1, rf);
    }
    pushup(p);
}
void query_mx(ll p, ll lf, ll rf)
{
    if (lf >= lc && rf <= rc)
    {
        ans = max(ans, mx[p]);
        return;
    }
    pushdown(p);
    mkcf;
    if (cf >= lc)
    {
        query_mx(lfs, lf, cf);
    }
    if (cf < rc)
    {
        query_mx(rfs, cf + 1, rf);
    }
}
void query_sum(ll p, ll lf, ll rf)
{
    if (lf >= lc && rf <= rc)
    {
        ans += s[p];
        return;
    }
    pushdown(p);
    mkcf;
    if (cf >= lc)
    {
        query_sum(lfs, lf, cf);
    }
    if (cf < rc)
    {
        query_sum(rfs, cf + 1, rf);
    }
}
signed main()
{
    sc(n), sc(m);
    for (ll i = 1; i <= n; ++i)
    {
        sc(a[i]);
    }
    build(1, 1, n);
    while (m--)
    {
        sc(c), sc(lc), sc(rc);
        if (c == 0)
        {
            sc(v);
            update(1, 1, n);
        }
        else if (c == 1)
        {
            ans = -1;
            query_mx(1, 1, n);
            printf("%lld\n", ans);
        }
        else
        {
            ans = 0;
            query_sum(1, 1, n);
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```

附上题解：

```c++
#include <algorithm>
#include <cctype>
#include <cstdio>
using namespace std;
const int N = 1e6 + 6;

char nc() {
  static char buf[1000000], *p = buf, *q = buf;
  return p == q && (q = (p = buf) + fread(buf, 1, 1000000, stdin), p == q)
             ? EOF
             : *p++;
}

int rd() {
  int res = 0;
  char c = nc();
  while (!isdigit(c)) c = nc();
  while (isdigit(c)) res = res * 10 + c - '0', c = nc();
  return res;
}

int t, n, m;
int a[N];
int mx[N << 2], se[N << 2], cn[N << 2], tag[N << 2];
long long sum[N << 2];

inline void pushup(int u) {  // 向上更新标记
  const int ls = u << 1, rs = u << 1 | 1;
  sum[u] = sum[ls] + sum[rs];
  if (mx[ls] == mx[rs]) {
    mx[u] = mx[rs];
    se[u] = max(se[ls], se[rs]);
    cn[u] = cn[ls] + cn[rs];
  } else if (mx[ls] > mx[rs]) {
    mx[u] = mx[ls];
    se[u] = max(se[ls], mx[rs]);
    cn[u] = cn[ls];
  } else {
    mx[u] = mx[rs];
    se[u] = max(mx[ls], se[rs]);
    cn[u] = cn[rs];
  }
}

inline void pushtag(int u, int tg) {  // 单纯地打标记，不暴搜
  if (mx[u] <= tg) return;
  sum[u] += (1ll * tg - mx[u]) * cn[u];
  mx[u] = tag[u] = tg;
}

inline void pushdown(int u) {  // 下传标记
  if (tag[u] == -1) return;
  pushtag(u << 1, tag[u]), pushtag(u << 1 | 1, tag[u]);
  tag[u] = -1;
}

void build(int u = 1, int l = 1, int r = n) {  // 建树
  tag[u] = -1;
  if (l == r) {
    sum[u] = mx[u] = a[l], se[u] = -1, cn[u] = 1;
    return;
  }
  int mid = (l + r) >> 1;
  build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
  pushup(u);
}

void modify_min(int L, int R, int v, int u = 1, int l = 1, int r = n) {
  if (mx[u] <= v) return;
  if (L <= l && r <= R && se[u] < v) return pushtag(u, v);
  int mid = (l + r) >> 1;
  pushdown(u);
  if (L <= mid) modify_min(L, R, v, u << 1, l, mid);
  if (mid < R) modify_min(L, R, v, u << 1 | 1, mid + 1, r);
  pushup(u);
}

int query_max(int L, int R, int u = 1, int l = 1, int r = n) {  // 查询最值
  if (L <= l && r <= R) return mx[u];
  int mid = (l + r) >> 1, r1 = -1, r2 = -1;
  pushdown(u);
  if (L <= mid) r1 = query_max(L, R, u << 1, l, mid);
  if (mid < R) r2 = query_max(L, R, u << 1 | 1, mid + 1, r);
  return max(r1, r2);
}

long long query_sum(int L, int R, int u = 1, int l = 1, int r = n) {  // 数值
  if (L <= l && r <= R) return sum[u];
  int mid = (l + r) >> 1;
  long long res = 0;
  pushdown(u);
  if (L <= mid) res += query_sum(L, R, u << 1, l, mid);
  if (mid < R) res += query_sum(L, R, u << 1 | 1, mid + 1, r);
  return res;
}

void go() {  // 根据题意
  n = rd(), m = rd();
  for (int i = 1; i <= n; i++) a[i] = rd();
  build();
  for (int i = 1; i <= m; i++) {
    int op, x, y, z;
    op = rd(), x = rd(), y = rd();
    if (op == 0)
      z = rd(), modify_min(x, y, z);
    else if (op == 1)
      printf("%d\n", query_max(x, y));
    else
      printf("%lld\n", query_sum(x, y));
  }
}

signed main() {
  t = rd();
  while (t--) go();
  return 0;
}
```





## CCF

> 补题链接：http://118.190.20.162/home.page

### 标签

#### 23CCF

1. 数组推导

   签到 思维

2. 非零段划分

   签到 思维

3. 脉冲神经网络

   大模拟 图论

4. 收集卡牌

   状压DP / 记忆化搜索

5. 箱根山岳险天下

   LCT



#### 22CCF

1. 灰度直方图

   签到 计数(排序)

2. 领域均值

   签到 滑动窗口

3. DHCP服务器

   大模拟

4. 校门外的树

   DP 因数筛

5. 疫苗运输

   Dijkstra最短路 exgcd解二元方程



### 题目

#### 23CCF

##### 数组推导

从补题时自己的水平来看，自然是签到题就是了。

一开始WA了一发，以为非固定值要放第一个元素，后来猛然一想放 0 不就好了。这样例坑了我一把

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 110
ll n, b[mn], mi, mx, miv;
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", &b[i]);
    }
    miv = mi = mx = b[1];
    for (ll i = 2; i <= n; ++i)
    {
        if (b[i] == b[i - 1])
        {
            mi += 0;
        }
        else
        {
            mi += b[i];
        }
        mx += b[i];
    }
    printf("%lld\n%lld \n", mx, mi);
    return 0;
}
```



##### 非零段划分

一开始题目没读完就想着是不是二分答案(二分p)，然后写到一半猛然想到好像不满足单调性啊；然后想着是不是链表+并查集。然后刚把并查集板子敲完，然后发现好像找段并没有这么简单。(属于是被自己出题出魔怔了，刚好蓝桥热身自己出过一道二分+并查集+链表的题目)

然后思索了几分钟，发现好像直接枚举然后删就可以了。删的时候会 $-1$ ，两边有的话各 $+1$ 。就这么简单。不管连不连续都是这样的。

所以一发过了

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 500010
ll a[mn], n, fa[mn], ans, now;
vector<ll> bin[10010];
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
    }
    for (ll i = 1, cnt = 0; i <= n + 1; ++i)
    {
        bin[a[i]].emplace_back(i);
        if (a[i])
        {
            ++cnt;
        }
        else
        {
            now += (cnt != 0);
            cnt = 0;
        }
    }
    ans = now;
    for (ll v = 1; v <= 10000; ++v)
    {
        for (auto i : bin[v])
        {
            --now;
            a[i] = 0;
            now += (a[i - 1] != 0) + (a[i + 1] != 0);
        }
        ans = max(ans, now);
    }
    printf("%lld", ans);
    return 0;
}
```



##### 脉冲神经网络

花了很久才读懂题目。读懂之后就可以上大模拟了。逐秒模拟即可。完全理解题意之后感觉也题意不是特别复杂……虽然光是把输入读懂就花了不少时间。一开始写好显然就炸了，然后debug了一会发现竟然是输入炸了，读多个同神经元的时候的内层循环条件有问题。

然后喜提66分RE，发现看少了一个0大概，然后喜提66分TLE。然后进行了多次常数优化，均以失败告终。包括把前向星改了，结构体拆了很多，之类的。一开始没有冲量二维的，而是按vector来记录每一次脉冲事件的，然后喜提TLE+MLE。然后就觉得是不行了。考虑到 $T$ 的范围，想到了可以压缩数组压二维事件。

后来看了题解，发现可以压缩二维冲量。但是我把自己的代码调整到跟题解几乎一样了，还是不能过题。不过据别人说这题卡常也确实很阴间。所以放弃继续往下深思或重写一次了。目前的思路就算是正确的了。

不过显然复杂度都到 $10^8$ 了，这常数拿头来压。挂一个最后的 $66$ 分TLE代码吧

```c++
#include <bits/stdc++.h>
using namespace std;
#define re register
#define il inline
typedef int ll;
typedef double db;
#define big 1e9
ll n, s, p, t;
#define mn 1005
db v[mn], u[mn], a[mn], b[mn], c[mn], d[mn], dt, ik[mn][mn];
ll r[mn * 2], num[mn];
struct edge
{
    ll to;
    db w;
    ll d;
};
vector<edge> g[mn * 2];

static unsigned long nex = 1;
/* RAND_MAX assumed to be 32767 */
int myrand(void)
{
    nex = nex * 1103515245 + 12345;
    return ((unsigned)(nex / 65536) % 32768);
}

void f()
{
    for (re ll i = 1; i <= t; ++i)
    {
        for (re ll j = n, je = 0, nownx; je < p; ++je, ++j)
        {
            nownx = myrand();
            if (r[j] > nownx)
            {
                for (ll h = 0, he = g[j].size(); h < he; ++h)
                {
                    edge &e = g[j][h];
                    ik[(i + e.d) % mn][e.to] += e.w;
                }
            }
        }
        for (re ll j = 0; j < n; ++j)
        {
            db pv = v[j], pu = u[j];
            v[j] = pv + dt * ((0.04 * pv + 5) * pv + 140 - pu) + ik[i % mn][j];
            u[j] = pu + dt * a[j] * (b[j] * pv - pu);
            if (v[j] >= 30)
            {
                v[j] = c[j];
                u[j] += d[j];
                ++num[j];
                for (ll h = 0, he = g[j].size(); h < he; ++h)
                {
                    edge &e = g[j][h];
                    ik[(i + e.d) % mn][e.to] += e.w;
                }
            }
            ik[i % mn][j] = 0;
        }
    }
    db mi = big, mx = -big;
    ll nmi = big, nmx = -big;
    for (re ll i = 0; i < n; ++i)
    {
        mi = min(mi, v[i]);
        mx = max(mx, v[i]);
        nmi = min(nmi, num[i]);
        nmx = max(nmx, num[i]);
    }
    printf("%.3lf %.3lf\n%d %d", mi, mx, nmi, nmx);
}

db vi, ui, ai, bi, ci, di, wi;
ll ri;
signed main()
{
    scanf("%d%d%d%d%lf", &n, &s, &p, &t, &dt);
    for (ll rn = 0, i = 0; rn < n;)
    {
        scanf("%d%lf%lf%lf%lf%lf%lf", &ri, &vi, &ui, &ai, &bi, &ci, &di);
        for (ll j = 0; j < ri; ++j, ++i)
        {
            v[i] = vi, u[i] = ui, a[i] = ai, b[i] = bi, c[i] = ci, d[i] = di;
        }
        rn += ri;
    }
    for (ll i = n, j = 0; j < p; ++j, ++i)
    {
        scanf("%d", &r[i]);
    }
    for (ll i = 0, si, ti, di; i < s; ++i)
    {
        scanf("%d%d%lf%d", &si, &ti, &wi, &di);
        g[si].push_back({ti, wi, di});
    }
    f();
    return 0;
}
```



##### 收集卡牌

爆搜很容易想。花了一小时推导 $p$ 相等的情况，觉得是 DP，方程也推得差不多了，但是最后发现实现不出来，即概率阻断后怎么防止不干扰，怎么都没搞对。我设的是 $dp[i][j]$ 代表当前抽了 $i$ 个不同邮票，有 $j-1$ 个硬币(防止 $0$ 的越界)的概率。初始值是 $dp[1][1]=1$ 。递推是用记忆化搜索来，方程不是特别难。然后答案累积的时候把概率叠上步骤。

一开始用小 $k$ 递推。发现是可以倒道来，即 $i=n$ 有 $k$ 个，往下有 $n-1$ 有更高的 $k$ 个……以此类推，到 $n=1$ 时只有一个，因为阻断了。然后阻断就设 $dp$ 值为 $0$ 。然后写完代码了一交一个零蛋。重新思考发现 $k$ 大了好像完全不同了，阻断的情况太复杂了，根本推不出来。

全错代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define mn 105
db dp[mn][mn], p[mn];
ll n, k, sa = 1;
bool vis[mn][mn];

db dfs(ll x, ll y)
{
    if (vis[x][y] || x == 0 || y == 0)
    {
        return dp[x][y];
    }
    vis[x][y] = true;
    dp[x][y] = dfs(x, y - 1) * x * p[1] + dfs(x - 1, y) * (n - x + 1) * p[1];
    return dp[x][y];
}

void fs()
{
    dp[1][1] = 1;
    vis[1][1] = true;
    db ans = 0;
    for (ll x = n, y = 1; x >= 2; --x)
    {
        for (ll j = 0; j < k; ++j, ++y)
        {
            ans += dfs(x, y) * (x + y - 1);
            printf("%lld %lld %lf\n", x, y, dp[x][y]);
            dp[x][y] = 0;
        }
    }
    ans += dfs(1, k * (n - 1) + 1) * (k * (n - 1) + 1);
    printf("%lld %lld %lf\n", 1LL, k * (n - 1) + 1, dp[1][k * (n - 1) + 1]);
    printf("%.12lf\n", ans);
}

signed main()
{
    scanf("%lld%lld", &n, &k);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lf", p + i);
    }
    for (ll i = 2; i <= n; ++i)
    {
        if (p[i] != p[i - 1])
        {
            sa = 0;
        }
    }
    if (sa)
    {
        fs();
    }
    return 0;
}
```

然后写了一个爆搜代码，骗了20分跑人了：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long double db;
#define mn 105
db p[mn];
ll n, k;
ll cnt[mn];
db dfs(ll suc, ll fai, db pos)
{
    db ans = 0;
    if (suc + fai / k >= n)
    {
        return (suc + fai) * pos;
    }
    for (ll i = 1; i <= n; ++i)
    {
        db nwpos = pos * p[i];
        ll nwsuc = suc, nwfai = fai;
        if (cnt[i])
        {
            nwfai++;
        }
        else
        {
            nwsuc++;
        }
        ++cnt[i];
        ans += dfs(nwsuc, nwfai, nwpos);
        --cnt[i];
    }
    return ans;
}
signed main()
{
    scanf("%d%d", &n, &k);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%Lf", p + i);
    }
    printf("%.10Lf", dfs(0, 0, 1.0));
    return 0;
}
```

然后看题解，可以用状压记忆化搜索，设状态代表当前有多少有的邮票，第二维状态是当前的硬币数，然后暴力记忆化搜索即可，整体思路不难：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define mn 17
#define mk 6
db p[mn], dp[1 << mn][mn * mk];
ll n, k;
bool vis[1 << mn][mn * mk];
db dfs(ll state, ll coins, ll ngot)
{ //当前状态还要额外用多少期望才能得到结果
    if (vis[state][coins])
    {
        return dp[state][coins];
    }
    if (state == (1 << n) - 1 || coins / k >= ngot)
    { //结束态无需额外花费
        return 0;
    }
    db res = 0;
    for (ll i = 0; i < n; ++i)
    {
        ll si = (state >> i) & 1;
        if (!si) //未得到第i张牌
        {        //那么以p[i]概率得到这张牌，花费1
            db nw = dfs(state | (1 << i), coins, ngot - 1);
            res += (nw + 1) * p[i];
        }
        else //得到了，硬币+1
        {
            db nw = dfs(state, coins + 1, ngot);
            res += (nw + 1) * p[i];
        }
    }
    vis[state][coins] = true;
    dp[state][coins] = res;
    return res;
}
signed main()
{
    scanf("%lld%lld", &n, &k);
    for (ll i = 0; i < n; ++i)
    {
        scanf("%lf", p + i);
    }
    printf("%.10lf", dfs(0, 0, n));
    return 0;
}
```



##### 箱根山岳险天下

本来想骗点分的，然后发现在强制在线下我完全区分不开数据点，而且维护乘法+取模还要比大小这个操作我真不会。所以到头来我连一个点都没办法入手。遗憾0分离场，代码都没交，就试了一下`pb_ds`能不能用，发现可以。

标解是LCT。没学过，以后补。见[这里](https://blog.csdn.net/qq_51557417/article/details/120927426?spm=1001.2014.3001.5506)



#### 22CCF

##### 灰度直方图

究极签到题不解释，一发过

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, m, l, a, bin[300];
signed main()
{
    scanf("%lld%lld%lld", &n, &m, &l);
    for (ll i = 0; i < n; ++i)
    {
        for (ll j = 0; j < m; ++j)
        {
            scanf("%lld", &a);
            ++bin[a];
        }
    }
    for (ll i = 0; i < l; ++i)
    {
        printf("%lld ", bin[i]);
    }
    return 0;
}
```



##### 邻域均值

一开始我读错题目了，然后以为区域是菱形的，写了个比较复杂的滑窗，样例显然没过；然后输出了一下发现最初值就是个正方形区域啊……反正思路就是每行初始跑一次，之后每次往右滑，删一行加一行。复杂度是 $\Omicron(nr^2+n^2r)$ 

代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 606
ll n, l, r, t, a[mn][mn], ans, cnt, sums;
inline bool nin(const ll &x, const ll &y, const ll &i, const ll &j)
{
    return x < 0 || y < 0 || x >= n || y >= n || abs(x - i) > r || abs(y - j) > r;
}
inline void acc()
{
    ans += (1.0 * sums / cnt) <= t;
}
signed main()
{
    scanf("%lld%lld%lld%lld", &n, &l, &r, &t);
    for (ll i = 0; i < n; ++i)
    {
        for (ll j = 0; j < n; ++j)
        {
            scanf("%lld", &a[i][j]);
        }
    }
    for (ll i = 0; i < n; ++i)
    {
        cnt = 0, sums = 0;
        for (ll dx = -r, j = 0; dx <= r; ++dx)
        {
            for (ll dy = -r; dy <= r; ++dy)
            {
                ll x = i + dx, y = j + dy;
                if (nin(x, y, i, j))
                {
                    continue;
                }
                ++cnt;
                sums += a[x][y];
            }
        }
        acc();
        for (ll j = 1; j < n; ++j)
        {
            for (ll x = i - r, y1 = j - r - 1, y2 = j + r; x <= i + r; ++x)
            {
                if (!nin(x, y1, i, j - 1))
                {
                    --cnt, sums -= a[x][y1];
                }
                if (!nin(x, y2, i, j))
                {
                    ++cnt, sums += a[x][y2];
                }
            }
            acc();
        }
    }
    printf("%lld", ans);
    return 0;
}
```



##### DHCP服务器

天知道我写了多久……读懂题目花了很久，然后调各种bugs改了很久，比如时间调整运算有误，各种重复和去重运算有误，过期被延期取消我还是让它过期之类的，反正就是到处出错。因为我一开始读错题目了以为是 $10^5$ 个点，所以全部找最小值之类的遍历查询操作全部被我用 $set$ 来写了，然后自然开了一大堆 $set$ ，然后究竟重复与否，计次什么的反正就是一堆问题。然后写了个巨长的代码，样例终于是能过了，然后一交一个WA60分。时间倒是只有几十ms。然后改了点什么，好像是修了点bugs，然后再交一个66分，之后一直卡在66分没有再进展了，最终代码巨长无比，是这样的：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define il inline
#define mn 100010
ll n, tdef, tmax, tmin, num, gi;
string h;
struct baowen
{
    string from, to, type;
    ll ip, expire, t;
} bw[mn];

#define sunalloc 1
#define swaitalloc 2
#define soccupy 3
#define sexpire 4
struct pool
{
    ll state, owner, expire;
} p[mn];

struct task
{
    ll ty, i, t, state; //ty0报文,1过期
    bool operator<(const task &r) const
    {
        return t != r.t ? t > r.t : ty < r.ty;
    }
};
set<ll> uid[mn * 2];
string iton[mn * 2];
map<string, ll> ntoi;
ll ntois;
il void addname(string &name)
{
    if (!ntoi[name])
    {
        ntoi[name] = ++ntois;
        iton[ntois] = name;
    }
}

set<ll> munalloc, mexpire;
priority_queue<task> q;

void adjust_expiretime(ll &bwexpire, ll ot)
{
    if (!bwexpire)
    {
        bwexpire = ot + tdef;
    }
    else if (bwexpire - ot < tmin)
    {
        bwexpire = ot + tmin;
    }
    else if (bwexpire - ot > tmax)
    {
        bwexpire = ot + tmax;
    }
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> num >> tdef >> tmax >> tmin >> h >> n;
    for (ll g = 0; g < n; ++g)
    {
        cin >> bw[g].t >> bw[g].from >> bw[g].to >> bw[g].type >> bw[g].ip >> bw[g].expire;
        addname(bw[g].from), addname(bw[g].to);
        q.push({0, g, bw[g].t, 0});
    }
    gi = n;

    for (ll i = 1; i <= num; ++i)
    {
        munalloc.insert(i);
    }

    while (!q.empty())
    {
        task qi = q.top();
        q.pop();
        ll oi = qi.i;
        ll ot = qi.t;
        if (qi.ty == 0)
        {
            --gi;
            string &ty = bw[oi].type;
            string &to = bw[oi].to;
            bool ndeal = false;
            if (!(to == h || to == "*") && ty != "REQ")
            {
                ndeal = true;
            }
            if (!(ty == "DIS" || ty == "REQ"))
            {
                ndeal = true;
            }
            if ((to == "*" && ty != "DIS") || (to == h && ty == "DIS"))
            {
                ndeal = true;
            }
            string &from = bw[oi].from;
            ll fromid = ntoi[from];

            if (!ndeal)
            {
                if (ty == "DIS")
                {
                    ll seleid = 0;
                    if (uid[fromid].size())
                    {
                        seleid = *uid[fromid].begin();
                    }
                    else if (munalloc.size())
                    {
                        seleid = *munalloc.begin();
                        // munalloc.erase(seleid);
                    }
                    else if (mexpire.size())
                    {
                        seleid = *mexpire.begin();
                        // mexpire.erase(seleid);
                    }
                    else
                    {
                        ndeal = true;
                    }

                    if (!ndeal)
                    {
                        p[seleid].state = swaitalloc;
                        p[seleid].owner = fromid;
                        uid[fromid].insert(seleid);
                        ll bwexpire = bw[oi].expire;
                        adjust_expiretime(bwexpire, ot);
                        p[seleid].expire = bwexpire;

                        // mexpire.erase(seleid);
                        munalloc.erase(seleid);
                        cout << h << ' ' << from << " OFR " << seleid << ' ' << bwexpire << "\n";
                        q.push({1, seleid, bwexpire, swaitalloc});
                    }
                }
                else if (ty == "REQ")
                {
                    if (to != h)
                    {
                        stack<ll> derase;
                        for (ll i : uid[fromid])
                        {
                            if (p[i].state == swaitalloc && p[i].owner == fromid)
                            {
                                p[i].state = sunalloc;
                                p[i].owner = 0;
                                p[i].expire = 0;
                                munalloc.insert(i);
                                derase.push(i);
                            }
                        }
                        while (derase.size())
                        {
                            uid[fromid].erase(derase.top());
                            derase.pop();
                        }
                    }
                    else
                    {
                        ll bwip = bw[oi].ip;
                        ll seleid = bw[oi].ip;
                        if (bwip < 1 || bwip > n || p[seleid].owner != fromid)
                        {
                            cout << h << ' ' << from << " NAK " << bw[oi].ip << " 0\n";
                        }
                        else
                        {
                            uid[fromid].insert(seleid);
                            p[seleid].state = soccupy;
                            p[seleid].owner = fromid;
                            ll bwexpire = bw[oi].expire;
                            adjust_expiretime(bwexpire, ot);
                            p[seleid].expire = bwexpire;

                            mexpire.erase(seleid);
                            munalloc.erase(seleid);
                            cout << h << ' ' << from << " ACK " << seleid << ' ' << bwexpire << "\n";
                            q.push({1, seleid, bwexpire, soccupy});
                        }
                    }
                }
            }
            if (!gi)
            {
                break;
            }
        }
        else
        {
            if (qi.state != p[oi].state || p[oi].expire > ot)
            {
                continue;
            }
            if (p[oi].state == swaitalloc)
            {
                p[oi].state = sunalloc;
                munalloc.insert(oi);
            }
            else if (p[oi].state == soccupy)
            {
                p[oi].state = sexpire;
                mexpire.insert(oi);
            }
            if (p[oi].owner)
            {
                uid[p[oi].owner].erase(oi);
            }
        }
    }
    return 0;
}
```

然后看题解，猛然发现这 $10^4$ 的复杂度，什么找最小直接遍历就行了，时间也不需要穿插的，每次报文前暴力更新一次就好了，然后重写了一次，debug了一会儿，出了一个满分补题代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 10010
struct pool
{
    ll state, owner, expire;
} p[mn];
map<string, ll> ntoi;
string iton[mn * 2], h, from, to, req = "REQ", dis = "DIS", ty;
ll ntois, n, tc, tdef, tmax, tmin;
ll t, fromid, id, expire;
#define sunalloc 0
#define swaitalloc 2
#define soccupy 3
#define sexpire 4
void addname(string &v)
{
    if (!ntoi[v])
    {
        ntoi[v] = ++ntois;
        iton[ntois] = v;
    }
}
ll fixdate(ll v)
{
    if (!v)
    {
        return tdef + t;
    }
    if (v - t < tmin)
    {
        return tmin + t;
    }
    if (v - t > tmax)
    {
        return tmax + t;
    }
    return v;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> n >> tdef >> tmax >> tmin >> h >> tc;
    while (tc--)
    {
        cin >> t >> from >> to >> ty >> id >> expire;
        addname(from), addname(to);
        fromid = ntoi[from];
        if (!(to == h || to == "*") && ty != req)
        {
            continue;
        }
        if (!(ty == req || ty == dis))
        {
            continue;
        }
        if ((to == "*" && ty != dis) || (to == h && ty == dis))
        {
            continue;
        }
        for (ll i = 1; i <= n; ++i)
        {
            if (p[i].expire && p[i].expire <= t)
            {
                if (p[i].state == swaitalloc)
                {
                    p[i].state = sunalloc;
                    p[i].expire = p[i].owner = 0;
                }
                else if (p[i].state == soccupy)
                {
                    p[i].state = sexpire;
                    p[i].expire = 0;
                }
            }
        }
        if (ty == dis)
        {
            ll seleid = 0;
            for (ll i = 1; i <= n; ++i)
            {
                if (p[i].owner == fromid)
                {
                    seleid = i;
                    break;
                }
            }
            if (!seleid)
            {
                for (ll i = 1; i <= n; ++i)
                {
                    if (p[i].state == sunalloc)
                    {
                        seleid = i;
                        break;
                    }
                }
            }
            if (!seleid)
            {
                for (ll i = 1; i <= n; ++i)
                {
                    if (p[i].state == sexpire)
                    {
                        seleid = i;
                        break;
                    }
                }
            }
            if (!seleid)
            {
                continue;
            }
            p[seleid].state = swaitalloc;
            p[seleid].owner = fromid;
            expire = fixdate(expire);
            p[seleid].expire = expire;
            cout << h << ' ' << from << " OFR " << seleid << ' ' << expire << '\n';
        }
        else if (ty == req)
        {
            if (to != h)
            {
                for (ll i = 1; i <= n; ++i)
                {
                    if (p[i].owner == fromid && p[i].state == swaitalloc)
                    {
                        p[i].state = sunalloc;
                        p[i].owner = p[i].expire = 0;
                    }
                }
                continue;
            }
            if (id > n || id < 1 || p[id].owner != fromid)
            {
                cout << h << ' ' << from << " NAK " << id << " 0\n";
                continue;
            }
            p[id].state = soccupy;
            expire = fixdate(expire);
            p[id].expire = expire;
            cout << h << ' ' << from << " ACK " << id << ' ' << expire << "\n";
        }
    }
    return 0;
}
```



##### 校门外的树

这道题就……耗费了久了。尝试了很久。

发现了一个猜想结论，即不可能出现子段加起来刚好等于父段的情况，如果是的话一定会被障碍物卡住。

我设的区间 DP，是 $dp[i][j]$ 一开始表示两树 $[i,j]$ 为边界的答案是多少我以为直接子段累乘即可，即：
$$
dp[i][j]=\sum_{k=i+1}^{j-1}dp[i][k]\times dp[k][j]+cnt[i][j]
$$
然后按区间长度顺序遍历即可。区间 DP 板子。内层计算时枚举因数作为公差，然后枚举每个区间内障碍，判断离左边界的差是否能被整除，能的话就是挡住了。这个做法时间复杂度是 $\Omicron(n^3\sqrt a)$ 。

然后一交一个 WA，得了10分。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 1010
ll n, a[mn], dp[mn][mn], mod = 1e9 + 7;
bool check(ll p, ll i, ll j)
{
    for (ll k = i + 1; k < j; ++k)
    {
        if ((a[k] - a[i]) % p == 0)
        {
            return false;
        }
    }
    // printf("- %lld %lld %lld\n", i, j, p);
    return true;
}
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
    }
    for (ll d = 1; d < n; ++d)
    {
        for (ll i = 1, j = i + d; j <= n; ++i, ++j)
        {
            ll v = a[j] - a[i], cnt = 0;
            // printf("<%lld %lld %lld\n", i, j, v);
            for (ll p = 1; p * p <= v; ++p)
            {
                if (v % p == 0)
                {
                    cnt += check(p, i, j);
                    cnt += v / p != p && v / p != v && check(v / p, i, j);
                }
            }
            for (ll k = i + 1; k < j; ++k)
            {
                dp[i][j] = (dp[i][j] + dp[i][k] * dp[k][j]) % mod;
            }
            dp[i][j] = (dp[i][j] + cnt) % mod;
            // printf("%lld %lld %lld %lld\n", i, j, cnt, dp[i][j]);
        }
    }
    printf("%lld", dp[1][n]);
    return 0;
}
```

然后思考可能是累乘重复了。想了很久，然后重新推导定义 $dp[i][j]$ 代表单独自己的第一个条件下成立的个数。然后用爆搜推导另一个答案 $ans[i]$ 代表长为 $i$ 的头这么多的答案是多少。爆搜即对于当前 $i$ ，前面的已经算好了，然后当前可以走 $j$ 区间长，走的时候加上区间 $dp$ 值即这个区间单独的计数，乘上选了它之后剩下的子问题。 一交一个意料之中的TLE：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 1010
ll n, a[mn], dp[mn][mn], mod = 1e9 + 7, me[mn];
bool vis[mn];
bool check(ll p, ll i, ll j)
{
    for (ll k = i + 1; k < j; ++k)
    {
        if ((a[k] - a[i]) % p == 0)
        {
            return false;
        }
    }
    return true;
}
ll dfs(ll now)
{
    if (vis[now])
    {
        return me[now];
    }
    if (now == n)
    {
        return 1;
    }
    ll nw = 0;
    for (ll step = 1; now + step <= n; ++step)
    {
        nw = (nw + dp[now][now + step] * dfs(now + step) % mod) % mod;
    }
    me[now] = nw;
    vis[now] = true;
    return nw;
}
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
    }
    for (ll d = 1; d < n; ++d)
    {
        for (ll i = 1, j = i + d; j <= n; ++i, ++j)
        {
            ll v = a[j] - a[i], cnt = 0;
            for (ll p = 1; p * p <= v; ++p)
            {
                if (v % p == 0)
                {
                    cnt += check(p, i, j);
                    cnt += v / p != p && v / p != v && check(v / p, i, j);
                }
            }
            dp[i][j] = cnt;
        }
    }
    printf("%lld", dfs(1));
    return 0;
}
```

然后思索了一会儿，发现这个东西往下的 DFS 就是一样的子问题(之前以为是不一样的)，那为什么不可以记忆化呢？然后改了改，得到 WA 50分。

测试了一下第三个样例，发现真正用时间的是 DP。然后发现质数可以预处理，然后优化成了 DP 部分的复杂度(你优化了个屁)是 $\Omicron(a\sqrt a+n^3\sqrt a)$。然后又不知道怎么地改了改喜提 TLE 60分：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 1010
ll n, a[mn], dp[mn][mn], mod = 1e9 + 7, me[mn], mxa;
bool vis[mn];
bool check(ll p, ll i, ll j)
{
    for (ll k = i + 1; k < j; ++k)
    {
        if ((a[k] - a[i]) % p == 0)
        {
            return false;
        }
    }
    return true;
}
ll dfs(ll now)
{
    if (vis[now])
    {
        return me[now];
    }
    if (now == n)
    {
        return 1;
    }
    ll nw = 0;
    for (ll step = 1; now + step <= n; ++step)
    {
        nw = (nw + dp[now][now + step] * dfs(now + step)) % mod;
    }
    me[now] = nw;
    vis[now] = true;
    return nw;
}
vector<ll> f[100010];
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
        mxa = max(mxa, a[i]);
    }
    for (ll i = 2; i <= mxa; ++i)
    {
        for (ll j = 1; j * j <= i; ++j)
        {
            if (i % j == 0)
            {
                f[i].emplace_back(j);
                if (i / j != j && i / j != i)
                {
                    f[i].emplace_back(i / j);
                }
            }
        }
    }
    for (ll d = 1; d < n; ++d)
    {
        for (ll i = 1, j = i + d; j <= n; ++i, ++j)
        {
            ll v = a[j] - a[i], cnt = 0;
            for (ll k = 0, ke = f[v].size(); k < ke; ++k)
            {
                cnt += check(f[v][k], i, j);
            }
            dp[i][j] = cnt;
        }
    }
    // printf("done\n");
    printf("%lld", dfs(1));
    return 0;
}
```

然后又改了改，想了很久，想把枚举的也砍了，于是对每个枚举，判断其因子数，即取 gcd 然后看因子数，对其因子和自己，全部在桶里标记失败。最后只积累没有标记失败的因数。但是复杂度其实没怎么变，而且还加一个 gcd 是对数的，可能还会更差……但是不大好说，因子数肯定是小了，但是次数又变多了……所以还是 TLE60分：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 1010
#define mp 100010
ll n, a[mn], dp[mn][mn], mod = 1e9 + 7, me[mn], mxa;
ll fre[mp];
bool vis[mn];
bool check(ll p, ll i, ll j)
{
    for (ll k = i + 1; k < j; ++k)
    {
        if ((a[k] - a[i]) % p == 0)
        {
            return false;
        }
    }
    return true;
}
ll dfs(ll now)
{
    if (vis[now])
    {
        return me[now];
    }
    if (now == n)
    {
        return 1;
    }
    ll nw = 0;
    for (ll step = 1; now + step <= n; ++step)
    {
        nw = (nw + dp[now][now + step] * dfs(now + step)) % mod;
    }
    me[now] = nw;
    vis[now] = true;
    return nw;
}
vector<ll> f[mp];
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
        mxa = max(mxa, a[i]);
    }
    for (ll i = 2; i <= mxa; ++i)
    {
        for (ll j = 1; j * j <= i; ++j)
        {
            if (i % j == 0)
            {
                f[i].emplace_back(j);
                if (i / j != j && i / j != i)
                {
                    f[i].emplace_back(i / j);
                }
            }
        }
    }
    for (ll d = 1; d < n; ++d)
    {
        for (ll i = 1, j = i + d; j <= n; ++i, ++j)
        {
            ll v = a[j] - a[i], cnt = 0;
            for (ll k = 0, ke = f[v].size(); k < ke; ++k)
            {
                fre[f[v][k]] = 1;
            }
            for (ll k = i + 1; k < j; ++k)
            {
                ll gcd = __gcd(a[k] - a[i], v);
                for (ll g = 0, ge = f[gcd].size(); g < ge; ++g)
                {
                    fre[f[gcd][g]]--;
                }
                fre[gcd]--;
            }
            for (ll k = 0, ke = f[v].size(); k < ke; ++k)
            {
                cnt += fre[f[v][k]] > 0;
            }
            dp[i][j] = cnt;
        }
    }
    printf("%lld", dfs(1));
    return 0;
}
```

然后终于妥协了，看了题解……妙啊。解法思路是：

先用筛法预处理因数，根据调和级数，可知预处理复杂度是 $\Omicron(a\log a)$ 。

设 $dp[i]$ 代表当前区间答案，那么有初始值 $dp[1]=1$ ，递推方程：
$$
dp[i]=\sum_{j=1}^{i-1}dp[j]\times cnt[j][i]
$$
这个可以理解，但是我自己做的时候没想出来。

然后关键是 $cnt$ 的计算。对右边界 $i$ ，倒序枚举 $j$ 。第一个 $j$ 所有因数都可以。到下一个的时候，上一个的所有因数都会在上一个的左边界作为障碍，所以这些因数都不可以。那么对下一个的因数，用 $set$ 维护曾经因数，如果不在就计数且放进曾经因数，在就忽略。注意区间长本身也要，因为刚好第一棵树就碰到了左边界，而这是因素筛和计数没有枚举到的。

时间复杂度为 $\Omicron(a\log a+n^2\log a\log n)$ 。

代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 1010
#define ma 100010
ll n, mod = 1e9 + 7, a[mn], dp[mn];
vector<ll> v[ma];
set<ll> s;
signed main()
{
    scanf("%lld", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%lld", a + i);
    }
    for (ll i = 1; i <= a[n] / 2; ++i)
    {
        for (ll j = 2 * i; j <= a[n]; j += i)
        {
            v[j].emplace_back(i);
        }
    }
    dp[1] = 1;
    for (ll i = 2; i <= n; ++i)
    {
        s.clear();
        for (ll j = i - 1; j >= 1; --j)
        {
            ll d = a[i] - a[j], cnt = 0;
            s.insert(d);
            for (ll k = 0; k < (ll)v[d].size(); ++k)
            {
                ll vi = v[d][k];
                if (s.find(vi) == s.end())
                {
                    ++cnt;
                    s.insert(vi);
                }
            }
            dp[i] = (dp[i] + cnt * dp[j]) % mod;
        }
    }
    printf("%lld", dp[n]);
    return 0;
}
```



##### 疫苗运输

发现可以骗分，于是只考虑不相交的情况打了个暴力。一开始因为细节问题WA了只有5分。然后改了之后竟然有35分，大赚一笔。代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 505
#define big 0x7ffffffa
ll n, m, no[mn][mn], arr[mn][mn], num[mn], dar[mn][mn], ans[mn];
vector<ll> its[mn];
signed main()
{
    scanf("%lld%lld", &n, &m);
    for (ll i = 1; i <= n; ++i)
    {
        ans[i] = big;
    }
    for (ll i = 1; i <= m; ++i)
    {
        scanf("%lld", num + i);
        ll ever = 0;
        for (ll j = 1; j <= num[i]; ++j)
        {
            scanf("%lld%lld", &no[i][j], &dar[i][j]);
            its[no[i][j]].emplace_back(i);
            arr[i][j + 1] = arr[i][j] + dar[i][j];
            ever = no[i][j] == 1 ? j : ever;
        }
        arr[i][1] = arr[i][num[i] + 1];
        for (ll j = 1; j < ever; ++j)
        {
            arr[i][j + 1] = arr[i][j] + dar[i][j];
        }
    }
    if (its[1].size())
    {
        for (ll j = 0, je = its[1].size(); j < je; ++j)
        {
            for (ll k = 1, ke = num[its[1][j]]; k <= ke; ++k)
            {
                ll u = no[its[1][j]][k];
                ans[u] = min(ans[u], arr[its[1][j]][k]);
            }
        }
    }
    for (ll i = 2; i <= n; ++i)
    {
        if (ans[i] != big)
        {
            printf("%lld\n", ans[i]);
        }
        else
        {
            printf("inf\n");
        }
    }
    return 0;
}
```

标解看懂了，最短路还好，关键是求方程用exgcd，没想到。不过就算都知道，实现起来也很不简单。

最后题解见：[这里](https://blog.csdn.net/qq_45734984/article/details/119650624?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.essearch_pc_relevant)



## POJ

[链接](http://poj.org/)

##### 1655-Balancing Act

> 给定 $t(\le 20)$ 询问，每次节点为 $n(n\le2\times10^4)$ 的树，求最小编号重心及其最大子树节点数
>
> POJ 炸了，不知道代码对不对

直接跑板子。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mn 20010
struct edge
{
    ll to, nx;
} e[mn << 1];
ll t, n, hd[mn], cnt, cf, cfv, siz[mn], w[mn];
void adde(ll u, ll v)
{
    e[++cnt] = {v, hd[u]};
    hd[u] = cnt;
}
#define sc(x) scanf("%lld", &x)
void dfs(ll u, ll fa)
{
    siz[u] = 1, w[u] = 0;
    for (ll i = hd[u], v; i; i = e[i].nx)
    {
        v = e[i].to;
        if (v == fa)
        {
            continue;
        }
        dfs(v, u);
        siz[u] += siz[v];
        w[u] = max(w[u], siz[v]);
    }
    w[u] = max(w[u], n - siz[u]);
    if (w[u] <= n / 2 && u < cf)
    {
        cf = u, cfv = w[u];
    }
}
signed main()
{
    for (sc(t); t; --t)
    {
        sc(n), cnt = 0, memset(hd, 0, sizeof hd), cf = n + 1;
        for (ll i = 1, u, v; i < n; ++i)
        {
            sc(u), sc(v), adde(u, v), adde(v, u);
        }
        dfs(1, 0);
        printf("%lld %lld\n", cf, cfv);
    }
    return 0;
}
```



##### 1265-Area

> 有多组测试，每组测试 $n(3\le n\le100)$ 个点，接下来输入若干坐标偏量，代表当前点离上一个点的坐标位移。求这个多边形的内部包含格点整点数、边上包含的格点整点数和多边形面积。

```c++
#include <cstdio>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define mn 200
ll t, n, x[mn], y[mn], s, edge, kase;
ll gcd(ll a, ll b)
{
    return b ? gcd(b, a % b) : a;
}
ll abs(ll x)
{
    return x < 0 ? -x : x;
}
signed main()
{
    for (sc(t); t--;)
    {
        sc(n);
        s = edge = 0;
        for (ll i = 1, dx, dy; i <= n; ++i)
        {
            sc(dx), sc(dy);
            x[i] = x[i - 1] + dx, y[i] = y[i - 1] + dy;
            edge += gcd(abs(dx), abs(dy));
        }
        x[n + 1] = x[1], y[n + 1] = y[1];
        for (ll i = 1, dx, dy; i <= n; ++i)
        {
            s += x[i] * y[i + 1] - x[i + 1] * y[i];
        }
        s = abs(s);
        printf("Scenario #%lld:\n%lld %lld %.1f\n\n", ++kase, (s - edge + 2) / 2, edge, s * 0.5f); // POJ卡魔幻精度
    }
    return 0;
}
```



##### 2007-Scrambled Polygon

> $\le50$ 个整数点组成凸多边形，坐标轴上只有原点且是第一个输入。求从原点开始逆时针遍历这些点

直接以原点极角排序即可。特别注意题目说了一个性质：凸多边形必不可能经过第二象限。

也可以按照下一题的做法(找最左下点，然后进行 $n$ 次极角排序)，也可以用 Garman 法求凸包。直接以原点即可，不需要找最左下角点。

原点极角排序：

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define cp const point &
struct point
{
    ll x, y;
    point(ll a = 0, ll b = 0) : x(a), y(b) {}
    point operator-(cp r) const { return point(x - r.x, y - r.y); }
    ll norm() const { return x * x + y * y; }
} p[55], p0;
ll cross(cp a, cp b) { return a.x * b.y - a.y * b.x; }
bool operator<(cp a, cp b)
{
    ll v = cross(a - p0, b - p0);
    return v > 0 || (v == 0 && (a - p0).norm() < (b - p0).norm());
}
ll n, b;
signed main()
{
    while (EOF != scanf("%lld%lld", &p0.x, &p0.y))
    {
        p[++n] = p0;
    }
    p0 = p[1];
    sort(p + 2, p + 1 + n);
    for (ll i = 1; i <= n; ++i)
    {
        printf("(%lld,%lld)\n", p[i].x, p[i].y);
    }
    return 0;
}
```

最左下多次极角排序：

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define cp const point &
struct point
{
    ll x, y;
    point(ll a = 0, ll b = 0) : x(a), y(b) {}
    point operator-(cp r) const { return point(x - r.x, y - r.y); }
    ll norm() const { return x * x + y * y; }
} p[55], p0;
ll cross(cp a, cp b) { return a.x * b.y - a.y * b.x; }
bool operator<(cp a, cp b)
{
    ll v = cross(a - p0, b - p0);
    return v > 0 || (v == 0 && (a - p0).norm() < (b - p0).norm());
}
ll t, n, b;
signed main()
{
    for (t = 1; t--;)
    {
        while (EOF != scanf("%lld%lld", &p0.x, &p0.y))
        {
            p[++n] = p0;
            if (p[n].y < p[1].y || (p[n].y == p[1].y && p[n].x < p[1].x))
            {
                swap(p[n], p[1]);
            }
        }
        for (ll i = 1; i <= n; ++i)
        {
            p0 = p[i];
            sort(p + 1 + i, p + 1 + n);
        }
        for (ll i = 1; i <= n; ++i)
        {
            if (p[i].x == 0 && p[i].y == 0)
            {
                b = i;
                break;
            }
        }
        for (ll i = 1, j = b; i <= n; ++i, j = j % n + 1)
        {
            printf("(%lld,%lld)\n", p[j].x, p[j].y);
        }
    }
    return 0;
}
```

凸包：

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef double db;
#define sc(x) scanf("%lld", &x)
#define mn 100010
#define cp const point &
ll n, ss, b;
struct point
{
    ll x, y;
    point(db a = 0, db b = 0) : x(a), y(b) {}
    point operator+(cp r) const { return point(x + r.x, y + r.y); }
    point operator-(cp r) const { return point(x - r.x, y - r.y); }
    db norm() const { return x * x + y * y; }
} p[mn], s[mn], p0;
db cross(cp a, cp b) { return a.x * b.y - a.y * b.x; }
bool operator<(cp a, cp b)
{
    db v = cross(a - p[1], b - p[1]);
    return v > 0 || (v == 0 && (a - p[1]).norm() < (b - p[1]).norm());
}
signed main()
{
    while (EOF != scanf("%lld%lld", &p0.x, &p0.y))
    {
        p[++n] = p0;
    }
    sort(p + 2, p + 1 + n);
    s[++ss] = p[1];
    for (ll i = 2; i <= n; ++i)
    {
        while (ss > 1 && cross(s[ss] - s[ss - 1], p[i] - s[ss]) <= 0)
        {
            --ss;
        }
        s[++ss] = p[i];
    }
    for (ll i = 1; i <= ss; ++i)
    {
        printf("(%lld,%lld)\n", p[i].x, p[i].y);
    }
    return 0;
}
```





##### 1696-Space Ant

> $\le10$ 组询问，给定 $n(\le 50)$ 个正整数点，只能选择任意点投影点 $(0,y_.)$ 开始走，然后不能往右，不能与已经走过的路线交叉，只能直走或左走，问最多经过多少个点，并给出一个方案

极角排序模板题。先找到最左下的点，然后每次走角度最小的点，一定可以走完全部的点。

如果以 $A$ 为原点，$B,C$ 对 $A$ 的极角大小 $B < C$ ，那么 $A$ 一定可以走到 $B,C$ ，而 $B$ 可以走到 $C$ 。既然可以选择 $A\to B\to C$ 和 $A\to C$ ，就应该选择前者。贪心。

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
#define sc(x) scanf("%lld", &x)
#define cp const point &
struct point
{
    ll x, y, i;
    point(ll a = 0, ll b = 0) : x(a), y(b) {}
    point operator-(cp r) const { return point(x - r.x, y - r.y); }
    ll norm() const { return x * x + y * y; }
} p[55], p0;
ll cross(cp a, cp b) { return a.x * b.y - a.y * b.x; }
bool operator<(cp a, cp b)
{
    ll v = cross(a - p0, b - p0);
    return v > 0 || (v == 0 && (a - p0).norm() < (b - p0).norm());
}
ll t, n;
signed main()
{
    for (sc(t); t--;)
    {
        sc(n);
        for (ll i = 1; i <= n; ++i)
        {
            sc(p[i].i), sc(p[i].x), sc(p[i].y);
            if (p[i].y < p[1].y || (p[i].y == p[1].y && p[i].x < p[1].x))
            {
                swap(p[i], p[1]);
            }
        }
        for (ll i = 1; i < n; ++i)
        {
            p0 = p[i];
            sort(p + 1 + i, p + 1 + n);
        }
        printf("%lld", n);
        for (ll i = 1; i <= n; ++i)
        {
            printf(" %lld", p[i].i);
        }
        printf("\n");
    }
    return 0;
}
```





## 牛客

#### 喜迎寒假

#####  F 小D的飞机跑道

正解线段树。附上珂朵莉树代码：

```c++
#include<bits/stdc++.h>
#define re
#define repe(i,l,r) for(re int i=l;i<=r;++i)
#define IT set<node>::iterator
using namespace std;

int n,m,x,y;

struct node{
    int l,r;
    mutable int v;
    node(int L,int R=-1,int V=0):l(L),r(R),v(V) {}
    bool operator <(const node &o)const{
        return l<o.l;
    }
};

set<node> s;

inline IT split(re int pos){
    IT it=s.lower_bound(node(pos));
    if(it!=s.end()&&it->l==pos)
      return it;
    --it;
    int L=it->l;
    int R=it->r;
    int V=it->v;
    s.erase(it);
    s.insert(node(L,pos-1,V));
    return s.insert(node(pos,R,V)).first;
}

inline void assign_val(re int l,re int r,re int val=0){
    IT itr=split(r+1),itl=split(l);
    s.erase(itl,itr);
    s.insert(node(l,r,val));
}

inline int query(re int l,re int r){
    int res=0;
    IT itr=split(r+1),itl=split(l);
    for(;itl!=itr;++itl)
      res+=(itl->r-itl->l+1)*(itl->v);
    return res;
}

signed main(){
    scanf("%d%d",&n,&m);
    s.insert(node(0,n,1));
    assign_val(0,0,0);
    repe(i,1,m){
        scanf("%d%d",&x,&y);
        assign_val(x,y,0);
    }
    printf("%d\n",query(0,n));
    return 0;
}

```



## XCPC

### ICPC

#### 2021银川

##### Browser Games

> 题意核心内容翻译：有 $n$ 个字符串，对每个 $i$ ，求最少的前缀数量，使得通过这些前缀只能找到前 $i$ 个字符串，不能找到剩余的字符串。保证字符串间互不为前缀。$(n\le 5\times 10^4,|S|\le50,S $ 小写字母和 `.` 和 `\` $)$ ，空间限制 $1024\ MB$

建树时可以先对每个节点加 $1$ ，那么点权代表从根节点到当前节点形成的前缀可以匹配到多少个字符串。初始时每个字符串都要求不能被匹配到，所以点权实质代表当前前缀不应匹配到的字符串有多少个。

然后顺次遍历 $i$ 个字符串，每次遍历时：对第 $i$ 个字符串的每个字符，在树上将其点权减一，代表第 $i$ 个字符串移除出不应匹配的字符串，如果减 一后点权为 $0$ ，代表当前前缀已经不能再匹配到任何不应匹配的字符串了，那么可以将当前前缀作为题目要求的 `confirmation prefix` ，答案加一。

特别注意的是，当前前缀 $p$ 加入后，以 $p$ 为前缀的所有本来被加入过的前缀都应该被删除，以达到“最少”的目的，因为它们已经冗余了。

以 `abc`,  `abd` , `abef` , `abeg` , `ba` 为例。 $i=1$ 时找到的当前前缀是 `abc` ，而 `i=2` 找到的是 `abd` ， `i=3` 时找到的是 `abef` ，但 `i=4` 时找的是 `a` ，这意味着前三个找到前缀都应该被删掉，因为 `a` 就能符合题意了，不需要多余的前缀。

为了实现这样的功能，我们可以在每次加入一个当前前缀 $p$ 时，把字典树上 $p$ 的所有前缀 (也就是 $p$ 的所有祖先)都额外标记一个数值 $dels$，代表它成为前缀时，要额外删掉之前已经存在的 `confirmation prefix` 的数目。然后每次新增一个当前前缀 $p$ 时，先加 $1$ 代表选中这个前缀加入答案，然后再删掉标记的数目 $dels$，代表删掉多少个已经存在的  `confirmation prefix` 。

这个额外标记的数值具体而言，就是当前前缀 $p$ 对答案的贡献值 $1-dels$ ，而并不是简单地标记加一。这是因为如果当前前缀 $p$ 加入后删掉了其子树上的全部前缀(即之前已经存在的 `confirmation prefix` )，那么这个删除对 $p$ 的所有祖先都是生效的，即对这些祖先的子树也删掉了。所以也要减去 $dels$ 。

时间复杂度是 $O(n|S|)$ ，空间复杂度是 $O(28n|S|)$ 

> 本题还有强化版本，限制空间为 $32\ MB$ ，见2021牛客多校第十场

参考代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef int ll;    // not long long
#define mn 2500010 // 5e4*50
ll n, dels[mn], t[mn][28], cnt = 1, w[mn], p, ns, si, stak[55], ans;
char s[50010][55];
ll f(char c)
{
    return c == '.' ? 26 : (c == '/' ? 27 : c - 'a');
}
signed main()
{
    scanf("%d", &n);
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%s", s[i] + 1);
        p = 1;
        ns = strlen(s[i] + 1);
        for (ll j = 1; j <= ns; ++j)
        {
            si = f(s[i][j]);
            if (t[p][si] == 0)
            {
                t[p][si] = ++cnt;
            }
            p = t[p][si];
            ++w[p];
        }
    }
    for (ll i = 1; i <= n; ++i)
    {
        p = 1;
        ns = strlen(s[i] + 1);
        for (ll j = 1; j <= ns; ++j)
        {
            si = f(s[i][j]);
            p = t[p][si];
            if (--w[p] == 0)
            {
                ll dt = 1 - dels[p];
                ans += dt;
                for (ll k = 1; k < j; ++k)
                {
                    dels[stak[k]] += dt;
                }
                break;
            }
            stak[j] = p;
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

强化版解题思路：只存关键节点，即叶子节点的 LCA ，有点像虚树的思维，可以得知加上叶子节点最多有 $O(2n)$ 个点。这些多出来的非叶子节点就是叶子的 LCA 及 LCA 的 LCA 。

因为我们不可能先建出树(不能真的建树然后建虚树)，会 MLE ，所以可以用别的方法。可以用一种基数排序的思想，从第一个字符开始作关键字，进行排序。设当前以第 $d$ 个字符作关键字，排序后，可以 $O(n)$ 比较每个字符串第 $d$ 个字符是否一样，如果第 $d$ 位存在不重复的字符(即所有字符串只有一个字符串第 $d$ 位取这个字符)，一个长为 $d$ 的前缀可以作为增加的节点，并把它作为叶子节点(而不是这个字符串作叶子节点)。否则，就是存在重复的，设有 $m$ 个第 $d$ 位为同一个值的字符串，说明当前一定可以继续划分。那么所有第 $d$ 位是该字符的字符串全部合在一个非叶子节点里，然后找到下一个使得这些选中字符串存在差异的第 $d'$ 位，以这些选中的字符串为整体，长为 $d'$ 的前缀(长为 $[d,d'] $ 的都符合题意)作为一个新节点，其能匹配到 $m$ 的字符串，并以第 $d'$ 位为关键字，继续向下递归，执行上述过程。本质上就是分治的思维。(具体实现参见代码)

最坏情况下需要走 $|S|$ 层，每层不断二分范围是最坏情况，如果用快排实现基数排序的内层排序，那么一次排序复杂度为 $O(n\log n)$ ，可以把 $\log n$ 看成是常数 $c\approx 16$ (事实上除了第一层递归，后面的层远不会这么大)，那么可以套用主定理： $T(n)=2T(\dfrac n2)+cn$ ，所以最坏复杂度为 $O(n\log n)$ 。事实上本题下面的过题代码用时在 SCNUOJ 的数据快了十倍，在牛客的过题情况如下 [所示](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=51220261&returnHomeType=1&uid=955759784)

参考代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef int ll;
#define mn 100010
#define mt 200010
#define ms 102 //注意这道题|S|=100
ll n, cnt, id[mt], fa[mt], w[mt], dp[mt], ans;
char s[mn][ms];
void build(ll lf, ll rf, ll dep, ll rot)
{
    sort(id + lf, id + rf + 1, [&](ll x, ll y)
         { return s[x][dep] < s[y][dep]; }); //[&]的&支持外部变量
    for (ll l = lf, r = lf; r <= rf;)
    {
        if (r == rf || s[id[r]][dep] != s[id[r + 1]][dep])
        {
            if (l == r)
            {
                fa[id[r]] = rot;
                w[id[r]] = 1;
                ++l, ++r;
                continue;
            }
            ll skip = 1;
            while (true)
            {
                bool allsame = true;
                for (ll i = l; i < r; ++i)
                {
                    if (s[id[i]][dep + skip] != s[id[i + 1]][dep + skip])
                    {
                        allsame = false;
                        break;
                    }
                }
                if (allsame)
                {
                    ++skip;
                }
                if (!allsame)
                {
                    ++cnt;
                    fa[cnt] = rot;
                    w[cnt] = r - l + 1;
                    build(l, r, dep + skip, cnt);
                    l = r + 1;
                    break;
                }
            }
        }
        ++r;
    }
}
signed main()
{
    scanf("%d", &n), cnt = n;
    for (ll i = 1; i <= n; ++i)
    {
        scanf("%s", s[i] + 1);
        id[i] = i;
    }
    build(1, n, 1, 0);
    for (ll i = 1; i <= n; ++i)
    {
        ll no = i, p = -1;
        while (no)
        {
            if (--w[no] == 0)
            {
                p = no;
                ans -= dp[no];
            }
            no = fa[no];
        }
        assert(p != -1);
        ++dp[fa[p]];
        ++ans;
        printf("%d\n", ans);
    }
    return 0;
}
```

